// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension ForecastQueryService {

    public struct DataPoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Timestamp", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]

        /// The timestamp of the specific forecast.
        public let timestamp: String?
        /// The forecast value.
        public let value: Double?

        public init(timestamp: String? = nil, value: Double? = nil) {
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case value = "Value"
        }
    }

    public struct Forecast: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Predictions", required: false, type: .map)
        ]

        /// The forecast. The string of the string to array map is one of the following values:   mean   p10   p50   p90  
        public let predictions: [String: [DataPoint]]?

        public init(predictions: [String: [DataPoint]]? = nil) {
            self.predictions = predictions
        }

        private enum CodingKeys: String, CodingKey {
            case predictions = "Predictions"
        }
    }

    public struct QueryForecastRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndDate", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: true, type: .map), 
            AWSShapeMember(label: "ForecastArn", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StartDate", required: false, type: .string)
        ]

        /// The end date for the forecast. Specify the date using this format: yyyy-MM-dd'T'HH:mm:ss'Z' (ISO 8601 format). For example, "1970-01-01T00:00:00Z." 
        public let endDate: String?
        /// The filtering criteria to apply when retrieving the forecast. For example:   To get a forecast for a specific item specify the following:  {"item_id" : "client_1"}      To get a forecast for a specific item sold in a specific location, specify the following:  {"item_id" : "client_1", "location" : "ny"}      To get a forecast for all blue items sold in a specific location, specify the following:  { "location" : "ny", "color":"blue"}    To get the full forecast, use the operation.
        public let filters: [String: String]
        /// The Amazon Resource Name (ARN) of the forecast to query.
        public let forecastArn: String
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?
        /// The start date for the forecast. Specify the date using this format: yyyy-MM-dd'T'HH:mm:ss'Z' (ISO 8601 format) For example, "1970-01-01T00:00:00Z."
        public let startDate: String?

        public init(endDate: String? = nil, filters: [String: String], forecastArn: String, nextToken: String? = nil, startDate: String? = nil) {
            self.endDate = endDate
            self.filters = filters
            self.forecastArn = forecastArn
            self.nextToken = nextToken
            self.startDate = startDate
        }

        public func validate(name: String) throws {
            try validate(self.endDate, name:"endDate", parent: name, max: 20)
            try validate(self.endDate, name:"endDate", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
            try self.filters.forEach {
                try validate($0.key, name:"filters.key", parent: name, max: 256)
                try validate($0.key, name:"filters.key", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
                try validate($0.value, name:"filters[\"\($0.key)\"]", parent: name, max: 256)
            }
            try validate(self.forecastArn, name:"forecastArn", parent: name, max: 256)
            try validate(self.forecastArn, name:"forecastArn", parent: name, pattern: "arn:([a-z\\d-]+):forecast:.*:.*:.+")
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.startDate, name:"startDate", parent: name, max: 20)
            try validate(self.startDate, name:"startDate", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case filters = "Filters"
            case forecastArn = "ForecastArn"
            case nextToken = "NextToken"
            case startDate = "StartDate"
        }
    }

    public struct QueryForecastResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Forecast", required: false, type: .structure)
        ]

        /// The forecast.
        public let forecast: Forecast?

        public init(forecast: Forecast? = nil) {
            self.forecast = forecast
        }

        private enum CodingKeys: String, CodingKey {
            case forecast = "Forecast"
        }
    }
}
