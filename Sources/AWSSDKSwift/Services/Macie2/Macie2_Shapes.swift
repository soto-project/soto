//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore
import Foundation

extension Macie2 {
    //MARK: Enums

    public enum AdminStatus: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disablingInProgress = "DISABLING_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum Currency: String, CustomStringConvertible, Codable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable {
        case sunday = "SUNDAY"
        case monday = "MONDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        case thursday = "THURSDAY"
        case friday = "FRIDAY"
        case saturday = "SATURDAY"
        public var description: String { return self.rawValue }
    }

    public enum EffectivePermission: String, CustomStringConvertible, Codable {
        case `public` = "PUBLIC"
        case notPublic = "NOT_PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case aes256 = "AES256"
        case awsKms = "aws:kms"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable {
        case clienterror = "ClientError"
        case internalerror = "InternalError"
        public var description: String { return self.rawValue }
    }

    public enum FindingActionType: String, CustomStringConvertible, Codable {
        case awsApiCall = "AWS_API_CALL"
        public var description: String { return self.rawValue }
    }

    public enum FindingCategory: String, CustomStringConvertible, Codable {
        case classification = "CLASSIFICATION"
        case policy = "POLICY"
        public var description: String { return self.rawValue }
    }

    public enum FindingPublishingFrequency: String, CustomStringConvertible, Codable {
        case fifteenMinutes = "FIFTEEN_MINUTES"
        case oneHour = "ONE_HOUR"
        case sixHours = "SIX_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatisticsSortAttributeName: String, CustomStringConvertible, Codable {
        case groupkey = "groupKey"
        case count = "count"
        public var description: String { return self.rawValue }
    }

    public enum FindingType: String, CustomStringConvertible, Codable {
        case sensitivedataS3ObjectMultiple = "SensitiveData:S3Object/Multiple"
        case sensitivedataS3ObjectFinancial = "SensitiveData:S3Object/Financial"
        case sensitivedataS3ObjectPersonal = "SensitiveData:S3Object/Personal"
        case sensitivedataS3ObjectCredentials = "SensitiveData:S3Object/Credentials"
        case sensitivedataS3ObjectCustomidentifier = "SensitiveData:S3Object/CustomIdentifier"
        case policyIamuserS3Bucketpublic = "Policy:IAMUser/S3BucketPublic"
        case policyIamuserS3Bucketsharedexternally = "Policy:IAMUser/S3BucketSharedExternally"
        case policyIamuserS3Bucketreplicatedexternally = "Policy:IAMUser/S3BucketReplicatedExternally"
        case policyIamuserS3Bucketencryptiondisabled = "Policy:IAMUser/S3BucketEncryptionDisabled"
        case policyIamuserS3Blockpublicaccessdisabled = "Policy:IAMUser/S3BlockPublicAccessDisabled"
        public var description: String { return self.rawValue }
    }

    public enum FindingsFilterAction: String, CustomStringConvertible, Codable {
        case archive = "ARCHIVE"
        case noop = "NOOP"
        public var description: String { return self.rawValue }
    }

    public enum GroupBy: String, CustomStringConvertible, Codable {
        case resourcesaffectedS3BucketName = "resourcesAffected.s3Bucket.name"
        case `type` = "type"
        case classificationdetailsJobid = "classificationDetails.jobId"
        case severityDescription = "severity.description"
        public var description: String { return self.rawValue }
    }

    public enum JobComparator: String, CustomStringConvertible, Codable {
        case eq = "EQ"
        case gt = "GT"
        case gte = "GTE"
        case lt = "LT"
        case lte = "LTE"
        case ne = "NE"
        case contains = "CONTAINS"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case running = "RUNNING"
        case paused = "PAUSED"
        case cancelled = "CANCELLED"
        case complete = "COMPLETE"
        case idle = "IDLE"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable {
        case oneTime = "ONE_TIME"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum ListJobsFilterKey: String, CustomStringConvertible, Codable {
        case jobtype = "jobType"
        case jobstatus = "jobStatus"
        case createdat = "createdAt"
        case name = "name"
        public var description: String { return self.rawValue }
    }

    public enum ListJobsSortAttributeName: String, CustomStringConvertible, Codable {
        case createdat = "createdAt"
        case jobstatus = "jobStatus"
        case name = "name"
        case jobtype = "jobType"
        public var description: String { return self.rawValue }
    }

    public enum MacieStatus: String, CustomStringConvertible, Codable {
        case paused = "PAUSED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum RelationshipStatus: String, CustomStringConvertible, Codable {
        case enabled = "Enabled"
        case paused = "Paused"
        case invited = "Invited"
        case created = "Created"
        case removed = "Removed"
        case resigned = "Resigned"
        case emailverificationinprogress = "EmailVerificationInProgress"
        case emailverificationfailed = "EmailVerificationFailed"
        public var description: String { return self.rawValue }
    }

    public enum ScopeFilterKey: String, CustomStringConvertible, Codable {
        case bucketCreationDate = "BUCKET_CREATION_DATE"
        case objectExtension = "OBJECT_EXTENSION"
        case objectLastModifiedDate = "OBJECT_LAST_MODIFIED_DATE"
        case objectSize = "OBJECT_SIZE"
        case tag = "TAG"
        public var description: String { return self.rawValue }
    }

    public enum SensitiveDataItemCategory: String, CustomStringConvertible, Codable {
        case financialInformation = "FINANCIAL_INFORMATION"
        case personalInformation = "PERSONAL_INFORMATION"
        case credentials = "CREDENTIALS"
        case customIdentifier = "CUSTOM_IDENTIFIER"
        public var description: String { return self.rawValue }
    }

    public enum SeverityDescription: String, CustomStringConvertible, Codable {
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        public var description: String { return self.rawValue }
    }

    public enum SharedAccess: String, CustomStringConvertible, Codable {
        case external = "EXTERNAL"
        case `internal` = "INTERNAL"
        case notShared = "NOT_SHARED"
        public var description: String { return self.rawValue }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable {
        case standard = "STANDARD"
        case reducedRedundancy = "REDUCED_REDUNDANCY"
        case standardIa = "STANDARD_IA"
        case intelligentTiering = "INTELLIGENT_TIERING"
        case deepArchive = "DEEP_ARCHIVE"
        case onezoneIa = "ONEZONE_IA"
        case glacier = "GLACIER"
        public var description: String { return self.rawValue }
    }

    public enum TagTarget: String, CustomStringConvertible, Codable {
        case s3Object = "S3_OBJECT"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable {
        case terabytes = "TERABYTES"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticsFilterKey: String, CustomStringConvertible, Codable {
        case accountid = "accountId"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticsSortKey: String, CustomStringConvertible, Codable {
        case accountid = "accountId"
        case total = "total"
        public var description: String { return self.rawValue }
    }

    public enum UsageType: String, CustomStringConvertible, Codable {
        case dataInventoryEvaluation = "DATA_INVENTORY_EVALUATION"
        case sensitiveDataDiscovery = "SENSITIVE_DATA_DISCOVERY"
        public var description: String { return self.rawValue }
    }

    public enum UserIdentityType: String, CustomStringConvertible, Codable {
        case assumedrole = "AssumedRole"
        case iamuser = "IAMUser"
        case federateduser = "FederatedUser"
        case root = "Root"
        case awsaccount = "AWSAccount"
        case awsservice = "AWSService"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AcceptInvitationRequest: AWSEncodableShape {

        public let invitationId: String
        public let masterAccount: String

        public init(invitationId: String, masterAccount: String) {
            self.invitationId = invitationId
            self.masterAccount = masterAccount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "invitationId"
            case masterAccount = "masterAccount"
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct AccessControlList: AWSDecodableShape {

        public let allowsPublicReadAccess: Bool?
        public let allowsPublicWriteAccess: Bool?

        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess = "allowsPublicReadAccess"
            case allowsPublicWriteAccess = "allowsPublicWriteAccess"
        }
    }

    public struct AccountDetail: AWSEncodableShape {

        public let accountId: String
        public let email: String

        public init(accountId: String, email: String) {
            self.accountId = accountId
            self.email = email
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case email = "email"
        }
    }

    public struct AccountLevelPermissions: AWSDecodableShape {

        public let blockPublicAccess: BlockPublicAccess?

        public init(blockPublicAccess: BlockPublicAccess? = nil) {
            self.blockPublicAccess = blockPublicAccess
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAccess = "blockPublicAccess"
        }
    }

    public struct AdminAccount: AWSDecodableShape {

        public let accountId: String?
        public let status: AdminStatus?

        public init(accountId: String? = nil, status: AdminStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case status = "status"
        }
    }

    public struct ApiCallDetails: AWSDecodableShape {

        public let api: String?
        public let apiServiceName: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var firstSeen: TimeStamp?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var lastSeen: TimeStamp?

        public init(api: String? = nil, apiServiceName: String? = nil, firstSeen: TimeStamp? = nil, lastSeen: TimeStamp? = nil) {
            self.api = api
            self.apiServiceName = apiServiceName
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
        }

        private enum CodingKeys: String, CodingKey {
            case api = "api"
            case apiServiceName = "apiServiceName"
            case firstSeen = "firstSeen"
            case lastSeen = "lastSeen"
        }
    }

    public struct ArchiveFindingsRequest: AWSEncodableShape {

        public let findingIds: [String]

        public init(findingIds: [String]) {
            self.findingIds = findingIds
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
        }
    }

    public struct ArchiveFindingsResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct AssumedRole: AWSDecodableShape {

        public let accessKeyId: String?
        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let sessionContext: SessionContext?

        public init(accessKeyId: String? = nil, accountId: String? = nil, arn: String? = nil, principalId: String? = nil, sessionContext: SessionContext? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.sessionContext = sessionContext
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case accountId = "accountId"
            case arn = "arn"
            case principalId = "principalId"
            case sessionContext = "sessionContext"
        }
    }

    public struct AwsAccount: AWSDecodableShape {

        public let accountId: String?
        public let principalId: String?

        public init(accountId: String? = nil, principalId: String? = nil) {
            self.accountId = accountId
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case principalId = "principalId"
        }
    }

    public struct AwsService: AWSDecodableShape {

        public let invokedBy: String?

        public init(invokedBy: String? = nil) {
            self.invokedBy = invokedBy
        }

        private enum CodingKeys: String, CodingKey {
            case invokedBy = "invokedBy"
        }
    }

    public struct BatchGetCustomDataIdentifierSummary: AWSDecodableShape {

        public let arn: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let deleted: Bool?
        public let description: String?
        public let id: String?
        public let name: String?

        public init(arn: String? = nil, createdAt: TimeStamp? = nil, deleted: Bool? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deleted = deleted
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deleted = "deleted"
            case description = "description"
            case id = "id"
            case name = "name"
        }
    }

    public struct BatchGetCustomDataIdentifiersRequest: AWSEncodableShape {

        public let ids: [String]?

        public init(ids: [String]? = nil) {
            self.ids = ids
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
        }
    }

    public struct BatchGetCustomDataIdentifiersResponse: AWSDecodableShape {

        public let customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]?
        public let notFoundIdentifierIds: [String]?

        public init(customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]? = nil, notFoundIdentifierIds: [String]? = nil) {
            self.customDataIdentifiers = customDataIdentifiers
            self.notFoundIdentifierIds = notFoundIdentifierIds
        }

        private enum CodingKeys: String, CodingKey {
            case customDataIdentifiers = "customDataIdentifiers"
            case notFoundIdentifierIds = "notFoundIdentifierIds"
        }
    }

    public struct BlockPublicAccess: AWSDecodableShape {

        public let blockPublicAcls: Bool?
        public let blockPublicPolicy: Bool?
        public let ignorePublicAcls: Bool?
        public let restrictPublicBuckets: Bool?

        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls = "blockPublicAcls"
            case blockPublicPolicy = "blockPublicPolicy"
            case ignorePublicAcls = "ignorePublicAcls"
            case restrictPublicBuckets = "restrictPublicBuckets"
        }
    }

    public struct BucketCountByEffectivePermission: AWSDecodableShape {

        public let publiclyAccessible: Int64?
        public let publiclyReadable: Int64?
        public let publiclyWritable: Int64?

        public init(publiclyAccessible: Int64? = nil, publiclyReadable: Int64? = nil, publiclyWritable: Int64? = nil) {
            self.publiclyAccessible = publiclyAccessible
            self.publiclyReadable = publiclyReadable
            self.publiclyWritable = publiclyWritable
        }

        private enum CodingKeys: String, CodingKey {
            case publiclyAccessible = "publiclyAccessible"
            case publiclyReadable = "publiclyReadable"
            case publiclyWritable = "publiclyWritable"
        }
    }

    public struct BucketCountByEncryptionType: AWSDecodableShape {

        public let kmsManaged: Int64?
        public let s3Managed: Int64?
        public let unencrypted: Int64?

        public init(kmsManaged: Int64? = nil, s3Managed: Int64? = nil, unencrypted: Int64? = nil) {
            self.kmsManaged = kmsManaged
            self.s3Managed = s3Managed
            self.unencrypted = unencrypted
        }

        private enum CodingKeys: String, CodingKey {
            case kmsManaged = "kmsManaged"
            case s3Managed = "s3Managed"
            case unencrypted = "unencrypted"
        }
    }

    public struct BucketCountBySharedAccessType: AWSDecodableShape {

        public let external: Int64?
        public let `internal`: Int64?
        public let notShared: Int64?

        public init(external: Int64? = nil, internal: Int64? = nil, notShared: Int64? = nil) {
            self.external = external
            self.`internal` = `internal`
            self.notShared = notShared
        }

        private enum CodingKeys: String, CodingKey {
            case external = "external"
            case `internal` = "internal"
            case notShared = "notShared"
        }
    }

    public struct BucketCriteriaAdditionalProperties: AWSEncodableShape {

        public let eq: [String]?
        public let gt: Int64?
        public let gte: Int64?
        public let lt: Int64?
        public let lte: Int64?
        public let neq: [String]?
        public let prefix: String?

        public init(eq: [String]? = nil, gt: Int64? = nil, gte: Int64? = nil, lt: Int64? = nil, lte: Int64? = nil, neq: [String]? = nil, prefix: String? = nil) {
            self.eq = eq
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "eq"
            case gt = "gt"
            case gte = "gte"
            case lt = "lt"
            case lte = "lte"
            case neq = "neq"
            case prefix = "prefix"
        }
    }

    public struct BucketLevelPermissions: AWSDecodableShape {

        public let accessControlList: AccessControlList?
        public let blockPublicAccess: BlockPublicAccess?
        public let bucketPolicy: BucketPolicy?

        public init(accessControlList: AccessControlList? = nil, blockPublicAccess: BlockPublicAccess? = nil, bucketPolicy: BucketPolicy? = nil) {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "accessControlList"
            case blockPublicAccess = "blockPublicAccess"
            case bucketPolicy = "bucketPolicy"
        }
    }

    public struct BucketMetadata: AWSDecodableShape {

        public let accountId: String?
        public let bucketArn: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var bucketCreatedAt: TimeStamp?
        public let bucketName: String?
        public let classifiableObjectCount: Int64?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var lastUpdated: TimeStamp?
        public let objectCount: Int64?
        public let objectCountByEncryptionType: ObjectCountByEncryptionType?
        public let publicAccess: BucketPublicAccess?
        public let region: String?
        public let replicationDetails: ReplicationDetails?
        public let sharedAccess: SharedAccess?
        public let sizeInBytes: Int64?
        public let sizeInBytesCompressed: Int64?
        public let tags: [KeyValuePair]?
        public let versioning: Bool?

        public init(accountId: String? = nil, bucketArn: String? = nil, bucketCreatedAt: TimeStamp? = nil, bucketName: String? = nil, classifiableObjectCount: Int64? = nil, lastUpdated: TimeStamp? = nil, objectCount: Int64? = nil, objectCountByEncryptionType: ObjectCountByEncryptionType? = nil, publicAccess: BucketPublicAccess? = nil, region: String? = nil, replicationDetails: ReplicationDetails? = nil, sharedAccess: SharedAccess? = nil, sizeInBytes: Int64? = nil, sizeInBytesCompressed: Int64? = nil, tags: [KeyValuePair]? = nil, versioning: Bool? = nil) {
            self.accountId = accountId
            self.bucketArn = bucketArn
            self.bucketCreatedAt = bucketCreatedAt
            self.bucketName = bucketName
            self.classifiableObjectCount = classifiableObjectCount
            self.lastUpdated = lastUpdated
            self.objectCount = objectCount
            self.objectCountByEncryptionType = objectCountByEncryptionType
            self.publicAccess = publicAccess
            self.region = region
            self.replicationDetails = replicationDetails
            self.sharedAccess = sharedAccess
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
            self.tags = tags
            self.versioning = versioning
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case bucketArn = "bucketArn"
            case bucketCreatedAt = "bucketCreatedAt"
            case bucketName = "bucketName"
            case classifiableObjectCount = "classifiableObjectCount"
            case lastUpdated = "lastUpdated"
            case objectCount = "objectCount"
            case objectCountByEncryptionType = "objectCountByEncryptionType"
            case publicAccess = "publicAccess"
            case region = "region"
            case replicationDetails = "replicationDetails"
            case sharedAccess = "sharedAccess"
            case sizeInBytes = "sizeInBytes"
            case sizeInBytesCompressed = "sizeInBytesCompressed"
            case tags = "tags"
            case versioning = "versioning"
        }
    }

    public struct BucketPermissionConfiguration: AWSDecodableShape {

        public let accountLevelPermissions: AccountLevelPermissions?
        public let bucketLevelPermissions: BucketLevelPermissions?

        public init(accountLevelPermissions: AccountLevelPermissions? = nil, bucketLevelPermissions: BucketLevelPermissions? = nil) {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }

        private enum CodingKeys: String, CodingKey {
            case accountLevelPermissions = "accountLevelPermissions"
            case bucketLevelPermissions = "bucketLevelPermissions"
        }
    }

    public struct BucketPolicy: AWSDecodableShape {

        public let allowsPublicReadAccess: Bool?
        public let allowsPublicWriteAccess: Bool?

        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess = "allowsPublicReadAccess"
            case allowsPublicWriteAccess = "allowsPublicWriteAccess"
        }
    }

    public struct BucketPublicAccess: AWSDecodableShape {

        public let effectivePermission: EffectivePermission?
        public let permissionConfiguration: BucketPermissionConfiguration?

        public init(effectivePermission: EffectivePermission? = nil, permissionConfiguration: BucketPermissionConfiguration? = nil) {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case effectivePermission = "effectivePermission"
            case permissionConfiguration = "permissionConfiguration"
        }
    }

    public struct BucketSortCriteria: AWSEncodableShape {

        public let attributeName: String?
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct ClassificationDetails: AWSDecodableShape {

        public let detailedResultsLocation: String?
        public let jobArn: String?
        public let jobId: String?
        public let result: ClassificationResult?

        public init(detailedResultsLocation: String? = nil, jobArn: String? = nil, jobId: String? = nil, result: ClassificationResult? = nil) {
            self.detailedResultsLocation = detailedResultsLocation
            self.jobArn = jobArn
            self.jobId = jobId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case detailedResultsLocation = "detailedResultsLocation"
            case jobArn = "jobArn"
            case jobId = "jobId"
            case result = "result"
        }
    }

    public struct ClassificationExportConfiguration: AWSEncodableShape & AWSDecodableShape {

        public let s3Destination: S3Destination?

        public init(s3Destination: S3Destination? = nil) {
            self.s3Destination = s3Destination
        }

        private enum CodingKeys: String, CodingKey {
            case s3Destination = "s3Destination"
        }
    }

    public struct ClassificationResult: AWSDecodableShape {

        public let customDataIdentifiers: CustomDataIdentifiers?
        public let mimeType: String?
        public let sensitiveData: [SensitiveDataItem]?
        public let sizeClassified: Int64?
        public let status: ClassificationResultStatus?

        public init(customDataIdentifiers: CustomDataIdentifiers? = nil, mimeType: String? = nil, sensitiveData: [SensitiveDataItem]? = nil, sizeClassified: Int64? = nil, status: ClassificationResultStatus? = nil) {
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case customDataIdentifiers = "customDataIdentifiers"
            case mimeType = "mimeType"
            case sensitiveData = "sensitiveData"
            case sizeClassified = "sizeClassified"
            case status = "status"
        }
    }

    public struct ClassificationResultStatus: AWSDecodableShape {

        public let code: String?
        public let reason: String?

        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case reason = "reason"
        }
    }

    public struct CreateClassificationJobRequest: AWSEncodableShape {

        public let clientToken: String
        public let customDataIdentifierIds: [String]?
        public let description: String?
        public let initialRun: Bool?
        public let jobType: JobType
        public let name: String
        public let s3JobDefinition: S3JobDefinition
        public let samplingPercentage: Int?
        public let scheduleFrequency: JobScheduleFrequency?
        public let tags: [String: String]?

        public init(clientToken: String = CreateClassificationJobRequest.idempotencyToken(), customDataIdentifierIds: [String]? = nil, description: String? = nil, initialRun: Bool? = nil, jobType: JobType, name: String, s3JobDefinition: S3JobDefinition, samplingPercentage: Int? = nil, scheduleFrequency: JobScheduleFrequency? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.customDataIdentifierIds = customDataIdentifierIds
            self.description = description
            self.initialRun = initialRun
            self.jobType = jobType
            self.name = name
            self.s3JobDefinition = s3JobDefinition
            self.samplingPercentage = samplingPercentage
            self.scheduleFrequency = scheduleFrequency
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customDataIdentifierIds = "customDataIdentifierIds"
            case description = "description"
            case initialRun = "initialRun"
            case jobType = "jobType"
            case name = "name"
            case s3JobDefinition = "s3JobDefinition"
            case samplingPercentage = "samplingPercentage"
            case scheduleFrequency = "scheduleFrequency"
            case tags = "tags"
        }
    }

    public struct CreateClassificationJobResponse: AWSDecodableShape {

        public let jobArn: String?
        public let jobId: String?

        public init(jobArn: String? = nil, jobId: String? = nil) {
            self.jobArn = jobArn
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
            case jobId = "jobId"
        }
    }

    public struct CreateCustomDataIdentifierRequest: AWSEncodableShape {

        public let clientToken: String?
        public let description: String?
        public let ignoreWords: [String]?
        public let keywords: [String]?
        public let maximumMatchDistance: Int?
        public let name: String?
        public let regex: String?
        public let tags: [String: String]?

        public init(clientToken: String? = CreateCustomDataIdentifierRequest.idempotencyToken(), description: String? = nil, ignoreWords: [String]? = nil, keywords: [String]? = nil, maximumMatchDistance: Int? = nil, name: String? = nil, regex: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ignoreWords = ignoreWords
            self.keywords = keywords
            self.maximumMatchDistance = maximumMatchDistance
            self.name = name
            self.regex = regex
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case ignoreWords = "ignoreWords"
            case keywords = "keywords"
            case maximumMatchDistance = "maximumMatchDistance"
            case name = "name"
            case regex = "regex"
            case tags = "tags"
        }
    }

    public struct CreateCustomDataIdentifierResponse: AWSDecodableShape {

        public let customDataIdentifierId: String?

        public init(customDataIdentifierId: String? = nil) {
            self.customDataIdentifierId = customDataIdentifierId
        }

        private enum CodingKeys: String, CodingKey {
            case customDataIdentifierId = "customDataIdentifierId"
        }
    }

    public struct CreateFindingsFilterRequest: AWSEncodableShape {

        public let action: FindingsFilterAction
        public let clientToken: String?
        public let description: String?
        public let findingCriteria: FindingCriteria
        public let name: String
        public let position: Int?
        public let tags: [String: String]?

        public init(action: FindingsFilterAction, clientToken: String? = CreateFindingsFilterRequest.idempotencyToken(), description: String? = nil, findingCriteria: FindingCriteria, name: String, position: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.findingCriteria = findingCriteria
            self.name = name
            self.position = position
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case name = "name"
            case position = "position"
            case tags = "tags"
        }
    }

    public struct CreateFindingsFilterResponse: AWSDecodableShape {

        public let arn: String?
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct CreateInvitationsRequest: AWSEncodableShape {

        public let accountIds: [String]
        public let disableEmailNotification: Bool?
        public let message: String?

        public init(accountIds: [String], disableEmailNotification: Bool? = nil, message: String? = nil) {
            self.accountIds = accountIds
            self.disableEmailNotification = disableEmailNotification
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case disableEmailNotification = "disableEmailNotification"
            case message = "message"
        }
    }

    public struct CreateInvitationsResponse: AWSDecodableShape {

        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct CreateMemberRequest: AWSEncodableShape {

        public let account: AccountDetail
        public let tags: [String: String]?

        public init(account: AccountDetail, tags: [String: String]? = nil) {
            self.account = account
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case account = "account"
            case tags = "tags"
        }
    }

    public struct CreateMemberResponse: AWSDecodableShape {

        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateSampleFindingsRequest: AWSEncodableShape {

        public let findingTypes: [FindingType]?

        public init(findingTypes: [FindingType]? = nil) {
            self.findingTypes = findingTypes
        }

        private enum CodingKeys: String, CodingKey {
            case findingTypes = "findingTypes"
        }
    }

    public struct CreateSampleFindingsResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct CriterionAdditionalProperties: AWSEncodableShape & AWSDecodableShape {

        public let eq: [String]?
        public let gt: Int64?
        public let gte: Int64?
        public let lt: Int64?
        public let lte: Int64?
        public let neq: [String]?

        public init(eq: [String]? = nil, gt: Int64? = nil, gte: Int64? = nil, lt: Int64? = nil, lte: Int64? = nil, neq: [String]? = nil) {
            self.eq = eq
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
            self.neq = neq
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "eq"
            case gt = "gt"
            case gte = "gte"
            case lt = "lt"
            case lte = "lte"
            case neq = "neq"
        }
    }

    public struct CustomDataIdentifierSummary: AWSDecodableShape {

        public let arn: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let description: String?
        public let id: String?
        public let name: String?

        public init(arn: String? = nil, createdAt: TimeStamp? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
        }
    }

    public struct CustomDataIdentifiers: AWSDecodableShape {

        public let detections: [CustomDetection]?
        public let totalCount: Int64?

        public init(detections: [CustomDetection]? = nil, totalCount: Int64? = nil) {
            self.detections = detections
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case detections = "detections"
            case totalCount = "totalCount"
        }
    }

    public struct CustomDetection: AWSDecodableShape {

        public let arn: String?
        public let count: Int64?
        public let name: String?

        public init(arn: String? = nil, count: Int64? = nil, name: String? = nil) {
            self.arn = arn
            self.count = count
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case count = "count"
            case name = "name"
        }
    }

    public struct DailySchedule: AWSEncodableShape & AWSDecodableShape {


        public init() {
        }

    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {

        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {

        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DefaultDetection: AWSDecodableShape {

        public let count: Int64?
        public let `type`: String?

        public init(count: Int64? = nil, type: String? = nil) {
            self.count = count
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case `type` = "type"
        }
    }

    public struct DeleteCustomDataIdentifierRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomDataIdentifierResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteFindingsFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFindingsFilterResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {

        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {

        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DeleteMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DescribeBucketsRequest: AWSEncodableShape {

        public let criteria: [String: BucketCriteriaAdditionalProperties]?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: BucketSortCriteria?

        public init(criteria: [String: BucketCriteriaAdditionalProperties]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: BucketSortCriteria? = nil) {
            self.criteria = criteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct DescribeBucketsResponse: AWSDecodableShape {

        public let buckets: [BucketMetadata]?
        public let nextToken: String?

        public init(buckets: [BucketMetadata]? = nil, nextToken: String? = nil) {
            self.buckets = buckets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case buckets = "buckets"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeClassificationJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClassificationJobResponse: AWSDecodableShape {

        public let clientToken: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let customDataIdentifierIds: [String]?
        public let description: String?
        public let initialRun: Bool?
        public let jobArn: String?
        public let jobId: String?
        public let jobStatus: JobStatus?
        public let jobType: JobType?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var lastRunTime: TimeStamp?
        public let name: String?
        public let s3JobDefinition: S3JobDefinition?
        public let samplingPercentage: Int?
        public let scheduleFrequency: JobScheduleFrequency?
        public let statistics: Statistics?
        public let tags: [String: String]?

        public init(clientToken: String? = DescribeClassificationJobResponse.idempotencyToken(), createdAt: TimeStamp? = nil, customDataIdentifierIds: [String]? = nil, description: String? = nil, initialRun: Bool? = nil, jobArn: String? = nil, jobId: String? = nil, jobStatus: JobStatus? = nil, jobType: JobType? = nil, lastRunTime: TimeStamp? = nil, name: String? = nil, s3JobDefinition: S3JobDefinition? = nil, samplingPercentage: Int? = nil, scheduleFrequency: JobScheduleFrequency? = nil, statistics: Statistics? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customDataIdentifierIds = customDataIdentifierIds
            self.description = description
            self.initialRun = initialRun
            self.jobArn = jobArn
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.jobType = jobType
            self.lastRunTime = lastRunTime
            self.name = name
            self.s3JobDefinition = s3JobDefinition
            self.samplingPercentage = samplingPercentage
            self.scheduleFrequency = scheduleFrequency
            self.statistics = statistics
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case createdAt = "createdAt"
            case customDataIdentifierIds = "customDataIdentifierIds"
            case description = "description"
            case initialRun = "initialRun"
            case jobArn = "jobArn"
            case jobId = "jobId"
            case jobStatus = "jobStatus"
            case jobType = "jobType"
            case lastRunTime = "lastRunTime"
            case name = "name"
            case s3JobDefinition = "s3JobDefinition"
            case samplingPercentage = "samplingPercentage"
            case scheduleFrequency = "scheduleFrequency"
            case statistics = "statistics"
            case tags = "tags"
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {

        public let autoEnable: Bool?
        public let maxAccountLimitReached: Bool?

        public init(autoEnable: Bool? = nil, maxAccountLimitReached: Bool? = nil) {
            self.autoEnable = autoEnable
            self.maxAccountLimitReached = maxAccountLimitReached
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
            case maxAccountLimitReached = "maxAccountLimitReached"
        }
    }

    public struct DisableMacieRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct DisableMacieResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DisableOrganizationAdminAccountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "adminAccountId", location: .querystring(locationName: "adminAccountId"))
        ]

        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisableOrganizationAdminAccountResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DisassociateMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMemberResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DomainDetails: AWSDecodableShape {

        public let domainName: String?

        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
        }
    }

    public struct EnableMacieRequest: AWSEncodableShape {

        public let clientToken: String?
        public let findingPublishingFrequency: FindingPublishingFrequency?
        public let status: MacieStatus?

        public init(clientToken: String? = EnableMacieRequest.idempotencyToken(), findingPublishingFrequency: FindingPublishingFrequency? = nil, status: MacieStatus? = nil) {
            self.clientToken = clientToken
            self.findingPublishingFrequency = findingPublishingFrequency
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case findingPublishingFrequency = "findingPublishingFrequency"
            case status = "status"
        }
    }

    public struct EnableMacieResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct EnableOrganizationAdminAccountRequest: AWSEncodableShape {

        public let adminAccountId: String
        public let clientToken: String?

        public init(adminAccountId: String, clientToken: String? = EnableOrganizationAdminAccountRequest.idempotencyToken()) {
            self.adminAccountId = adminAccountId
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "adminAccountId"
            case clientToken = "clientToken"
        }
    }

    public struct EnableOrganizationAdminAccountResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct FederatedUser: AWSDecodableShape {

        public let accessKeyId: String?
        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let sessionContext: SessionContext?

        public init(accessKeyId: String? = nil, accountId: String? = nil, arn: String? = nil, principalId: String? = nil, sessionContext: SessionContext? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.sessionContext = sessionContext
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case accountId = "accountId"
            case arn = "arn"
            case principalId = "principalId"
            case sessionContext = "sessionContext"
        }
    }

    public struct Finding: AWSDecodableShape {

        public let accountId: String?
        public let archived: Bool?
        public let category: FindingCategory?
        public let classificationDetails: ClassificationDetails?
        public let count: Int64?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let description: String?
        public let id: String?
        public let partition: String?
        public let policyDetails: PolicyDetails?
        public let region: String?
        public let resourcesAffected: ResourcesAffected?
        public let sample: Bool?
        public let schemaVersion: String?
        public let severity: Severity?
        public let title: String?
        public let `type`: FindingType?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var updatedAt: TimeStamp?

        public init(accountId: String? = nil, archived: Bool? = nil, category: FindingCategory? = nil, classificationDetails: ClassificationDetails? = nil, count: Int64? = nil, createdAt: TimeStamp? = nil, description: String? = nil, id: String? = nil, partition: String? = nil, policyDetails: PolicyDetails? = nil, region: String? = nil, resourcesAffected: ResourcesAffected? = nil, sample: Bool? = nil, schemaVersion: String? = nil, severity: Severity? = nil, title: String? = nil, type: FindingType? = nil, updatedAt: TimeStamp? = nil) {
            self.accountId = accountId
            self.archived = archived
            self.category = category
            self.classificationDetails = classificationDetails
            self.count = count
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.policyDetails = policyDetails
            self.region = region
            self.resourcesAffected = resourcesAffected
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.title = title
            self.`type` = `type`
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case archived = "archived"
            case category = "category"
            case classificationDetails = "classificationDetails"
            case count = "count"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case partition = "partition"
            case policyDetails = "policyDetails"
            case region = "region"
            case resourcesAffected = "resourcesAffected"
            case sample = "sample"
            case schemaVersion = "schemaVersion"
            case severity = "severity"
            case title = "title"
            case `type` = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct FindingAction: AWSDecodableShape {

        public let actionType: FindingActionType?
        public let apiCallDetails: ApiCallDetails?

        public init(actionType: FindingActionType? = nil, apiCallDetails: ApiCallDetails? = nil) {
            self.actionType = actionType
            self.apiCallDetails = apiCallDetails
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case apiCallDetails = "apiCallDetails"
        }
    }

    public struct FindingActor: AWSDecodableShape {

        public let domainDetails: DomainDetails?
        public let ipAddressDetails: IpAddressDetails?
        public let userIdentity: UserIdentity?

        public init(domainDetails: DomainDetails? = nil, ipAddressDetails: IpAddressDetails? = nil, userIdentity: UserIdentity? = nil) {
            self.domainDetails = domainDetails
            self.ipAddressDetails = ipAddressDetails
            self.userIdentity = userIdentity
        }

        private enum CodingKeys: String, CodingKey {
            case domainDetails = "domainDetails"
            case ipAddressDetails = "ipAddressDetails"
            case userIdentity = "userIdentity"
        }
    }

    public struct FindingCriteria: AWSEncodableShape & AWSDecodableShape {

        public let criterion: [String: CriterionAdditionalProperties]?

        public init(criterion: [String: CriterionAdditionalProperties]? = nil) {
            self.criterion = criterion
        }

        private enum CodingKeys: String, CodingKey {
            case criterion = "criterion"
        }
    }

    public struct FindingStatisticsSortCriteria: AWSEncodableShape {

        public let attributeName: FindingStatisticsSortAttributeName?
        public let orderBy: OrderBy?

        public init(attributeName: FindingStatisticsSortAttributeName? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct FindingsFilterListItem: AWSDecodableShape {

        public let arn: String?
        public let id: String?
        public let name: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetBucketStatisticsRequest: AWSEncodableShape {

        public let accountId: String?

        public init(accountId: String? = nil) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct GetBucketStatisticsResponse: AWSDecodableShape {

        public let bucketCount: Int64?
        public let bucketCountByEffectivePermission: BucketCountByEffectivePermission?
        public let bucketCountByEncryptionType: BucketCountByEncryptionType?
        public let bucketCountBySharedAccessType: BucketCountBySharedAccessType?
        public let classifiableObjectCount: Int64?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var lastUpdated: TimeStamp?
        public let objectCount: Int64?
        public let sizeInBytes: Int64?
        public let sizeInBytesCompressed: Int64?

        public init(bucketCount: Int64? = nil, bucketCountByEffectivePermission: BucketCountByEffectivePermission? = nil, bucketCountByEncryptionType: BucketCountByEncryptionType? = nil, bucketCountBySharedAccessType: BucketCountBySharedAccessType? = nil, classifiableObjectCount: Int64? = nil, lastUpdated: TimeStamp? = nil, objectCount: Int64? = nil, sizeInBytes: Int64? = nil, sizeInBytesCompressed: Int64? = nil) {
            self.bucketCount = bucketCount
            self.bucketCountByEffectivePermission = bucketCountByEffectivePermission
            self.bucketCountByEncryptionType = bucketCountByEncryptionType
            self.bucketCountBySharedAccessType = bucketCountBySharedAccessType
            self.classifiableObjectCount = classifiableObjectCount
            self.lastUpdated = lastUpdated
            self.objectCount = objectCount
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
        }

        private enum CodingKeys: String, CodingKey {
            case bucketCount = "bucketCount"
            case bucketCountByEffectivePermission = "bucketCountByEffectivePermission"
            case bucketCountByEncryptionType = "bucketCountByEncryptionType"
            case bucketCountBySharedAccessType = "bucketCountBySharedAccessType"
            case classifiableObjectCount = "classifiableObjectCount"
            case lastUpdated = "lastUpdated"
            case objectCount = "objectCount"
            case sizeInBytes = "sizeInBytes"
            case sizeInBytesCompressed = "sizeInBytesCompressed"
        }
    }

    public struct GetClassificationExportConfigurationRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetClassificationExportConfigurationResponse: AWSDecodableShape {

        public let configuration: ClassificationExportConfiguration?

        public init(configuration: ClassificationExportConfiguration? = nil) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct GetCustomDataIdentifierRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCustomDataIdentifierResponse: AWSDecodableShape {

        public let arn: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let deleted: Bool?
        public let description: String?
        public let id: String?
        public let ignoreWords: [String]?
        public let keywords: [String]?
        public let maximumMatchDistance: Int?
        public let name: String?
        public let regex: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: TimeStamp? = nil, deleted: Bool? = nil, description: String? = nil, id: String? = nil, ignoreWords: [String]? = nil, keywords: [String]? = nil, maximumMatchDistance: Int? = nil, name: String? = nil, regex: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deleted = deleted
            self.description = description
            self.id = id
            self.ignoreWords = ignoreWords
            self.keywords = keywords
            self.maximumMatchDistance = maximumMatchDistance
            self.name = name
            self.regex = regex
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deleted = "deleted"
            case description = "description"
            case id = "id"
            case ignoreWords = "ignoreWords"
            case keywords = "keywords"
            case maximumMatchDistance = "maximumMatchDistance"
            case name = "name"
            case regex = "regex"
            case tags = "tags"
        }
    }

    public struct GetFindingStatisticsRequest: AWSEncodableShape {

        public let findingCriteria: FindingCriteria?
        public let groupBy: GroupBy
        public let size: Int?
        public let sortCriteria: FindingStatisticsSortCriteria?

        public init(findingCriteria: FindingCriteria? = nil, groupBy: GroupBy, size: Int? = nil, sortCriteria: FindingStatisticsSortCriteria? = nil) {
            self.findingCriteria = findingCriteria
            self.groupBy = groupBy
            self.size = size
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria = "findingCriteria"
            case groupBy = "groupBy"
            case size = "size"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct GetFindingStatisticsResponse: AWSDecodableShape {

        public let countsByGroup: [GroupCount]?

        public init(countsByGroup: [GroupCount]? = nil) {
            self.countsByGroup = countsByGroup
        }

        private enum CodingKeys: String, CodingKey {
            case countsByGroup = "countsByGroup"
        }
    }

    public struct GetFindingsFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingsFilterResponse: AWSDecodableShape {

        public let action: FindingsFilterAction?
        public let arn: String?
        public let description: String?
        public let findingCriteria: FindingCriteria?
        public let id: String?
        public let name: String?
        public let position: Int?
        public let tags: [String: String]?

        public init(action: FindingsFilterAction? = nil, arn: String? = nil, description: String? = nil, findingCriteria: FindingCriteria? = nil, id: String? = nil, name: String? = nil, position: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.arn = arn
            self.description = description
            self.findingCriteria = findingCriteria
            self.id = id
            self.name = name
            self.position = position
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case id = "id"
            case name = "name"
            case position = "position"
            case tags = "tags"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {

        public let findingIds: [String]
        public let sortCriteria: SortCriteria?

        public init(findingIds: [String], sortCriteria: SortCriteria? = nil) {
            self.findingIds = findingIds
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {

        public let findings: [Finding]?

        public init(findings: [Finding]? = nil) {
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {

        public let invitationsCount: Int64?

        public init(invitationsCount: Int64? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "invitationsCount"
        }
    }

    public struct GetMacieSessionRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetMacieSessionResponse: AWSDecodableShape {

        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let findingPublishingFrequency: FindingPublishingFrequency?
        public let serviceRole: String?
        public let status: MacieStatus?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var updatedAt: TimeStamp?

        public init(createdAt: TimeStamp? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, serviceRole: String? = nil, status: MacieStatus? = nil, updatedAt: TimeStamp? = nil) {
            self.createdAt = createdAt
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case findingPublishingFrequency = "findingPublishingFrequency"
            case serviceRole = "serviceRole"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetMasterAccountResponse: AWSDecodableShape {

        public let master: Invitation?

        public init(master: Invitation? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "master"
        }
    }

    public struct GetMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemberResponse: AWSDecodableShape {

        public let accountId: String?
        public let arn: String?
        public let email: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var invitedAt: TimeStamp?
        public let masterAccountId: String?
        public let relationshipStatus: RelationshipStatus?
        public let tags: [String: String]?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var updatedAt: TimeStamp?

        public init(accountId: String? = nil, arn: String? = nil, email: String? = nil, invitedAt: TimeStamp? = nil, masterAccountId: String? = nil, relationshipStatus: RelationshipStatus? = nil, tags: [String: String]? = nil, updatedAt: TimeStamp? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.email = email
            self.invitedAt = invitedAt
            self.masterAccountId = masterAccountId
            self.relationshipStatus = relationshipStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case email = "email"
            case invitedAt = "invitedAt"
            case masterAccountId = "masterAccountId"
            case relationshipStatus = "relationshipStatus"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetUsageStatisticsRequest: AWSEncodableShape {

        public let filterBy: [UsageStatisticsFilter]?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortBy: UsageStatisticsSortBy?

        public init(filterBy: [UsageStatisticsFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: UsageStatisticsSortBy? = nil) {
            self.filterBy = filterBy
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        private enum CodingKeys: String, CodingKey {
            case filterBy = "filterBy"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct GetUsageStatisticsResponse: AWSDecodableShape {

        public let nextToken: String?
        public let records: [UsageRecord]?

        public init(nextToken: String? = nil, records: [UsageRecord]? = nil) {
            self.nextToken = nextToken
            self.records = records
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case records = "records"
        }
    }

    public struct GetUsageTotalsRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetUsageTotalsResponse: AWSDecodableShape {

        public let usageTotals: [UsageTotal]?

        public init(usageTotals: [UsageTotal]? = nil) {
            self.usageTotals = usageTotals
        }

        private enum CodingKeys: String, CodingKey {
            case usageTotals = "usageTotals"
        }
    }

    public struct GroupCount: AWSDecodableShape {

        public let count: Int64?
        public let groupKey: String?

        public init(count: Int64? = nil, groupKey: String? = nil) {
            self.count = count
            self.groupKey = groupKey
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case groupKey = "groupKey"
        }
    }

    public struct IamUser: AWSDecodableShape {

        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let userName: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil, userName: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case principalId = "principalId"
            case userName = "userName"
        }
    }

    public struct Invitation: AWSDecodableShape {

        public let accountId: String?
        public let invitationId: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var invitedAt: TimeStamp?
        public let relationshipStatus: RelationshipStatus?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: TimeStamp? = nil, relationshipStatus: RelationshipStatus? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case invitationId = "invitationId"
            case invitedAt = "invitedAt"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct IpAddressDetails: AWSDecodableShape {

        public let ipAddressV4: String?
        public let ipCity: IpCity?
        public let ipCountry: IpCountry?
        public let ipGeoLocation: IpGeoLocation?
        public let ipOwner: IpOwner?

        public init(ipAddressV4: String? = nil, ipCity: IpCity? = nil, ipCountry: IpCountry? = nil, ipGeoLocation: IpGeoLocation? = nil, ipOwner: IpOwner? = nil) {
            self.ipAddressV4 = ipAddressV4
            self.ipCity = ipCity
            self.ipCountry = ipCountry
            self.ipGeoLocation = ipGeoLocation
            self.ipOwner = ipOwner
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressV4 = "ipAddressV4"
            case ipCity = "ipCity"
            case ipCountry = "ipCountry"
            case ipGeoLocation = "ipGeoLocation"
            case ipOwner = "ipOwner"
        }
    }

    public struct IpCity: AWSDecodableShape {

        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct IpCountry: AWSDecodableShape {

        public let code: String?
        public let name: String?

        public init(code: String? = nil, name: String? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case name = "name"
        }
    }

    public struct IpGeoLocation: AWSDecodableShape {

        public let lat: Double?
        public let lon: Double?

        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat = "lat"
            case lon = "lon"
        }
    }

    public struct IpOwner: AWSDecodableShape {

        public let asn: String?
        public let asnOrg: String?
        public let isp: String?
        public let org: String?

        public init(asn: String? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "asn"
            case asnOrg = "asnOrg"
            case isp = "isp"
            case org = "org"
        }
    }

    public struct JobScheduleFrequency: AWSEncodableShape & AWSDecodableShape {

        public let dailySchedule: DailySchedule?
        public let monthlySchedule: MonthlySchedule?
        public let weeklySchedule: WeeklySchedule?

        public init(dailySchedule: DailySchedule? = nil, monthlySchedule: MonthlySchedule? = nil, weeklySchedule: WeeklySchedule? = nil) {
            self.dailySchedule = dailySchedule
            self.monthlySchedule = monthlySchedule
            self.weeklySchedule = weeklySchedule
        }

        private enum CodingKeys: String, CodingKey {
            case dailySchedule = "dailySchedule"
            case monthlySchedule = "monthlySchedule"
            case weeklySchedule = "weeklySchedule"
        }
    }

    public struct JobScopeTerm: AWSEncodableShape & AWSDecodableShape {

        public let simpleScopeTerm: SimpleScopeTerm?
        public let tagScopeTerm: TagScopeTerm?

        public init(simpleScopeTerm: SimpleScopeTerm? = nil, tagScopeTerm: TagScopeTerm? = nil) {
            self.simpleScopeTerm = simpleScopeTerm
            self.tagScopeTerm = tagScopeTerm
        }

        private enum CodingKeys: String, CodingKey {
            case simpleScopeTerm = "simpleScopeTerm"
            case tagScopeTerm = "tagScopeTerm"
        }
    }

    public struct JobScopingBlock: AWSEncodableShape & AWSDecodableShape {

        public let and: [JobScopeTerm]?

        public init(and: [JobScopeTerm]? = nil) {
            self.and = and
        }

        private enum CodingKeys: String, CodingKey {
            case and = "and"
        }
    }

    public struct JobSummary: AWSDecodableShape {

        public let bucketDefinitions: [S3BucketDefinitionForJob]?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let jobId: String?
        public let jobStatus: JobStatus?
        public let jobType: JobType?
        public let name: String?

        public init(bucketDefinitions: [S3BucketDefinitionForJob]? = nil, createdAt: TimeStamp? = nil, jobId: String? = nil, jobStatus: JobStatus? = nil, jobType: JobType? = nil, name: String? = nil) {
            self.bucketDefinitions = bucketDefinitions
            self.createdAt = createdAt
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.jobType = jobType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case bucketDefinitions = "bucketDefinitions"
            case createdAt = "createdAt"
            case jobId = "jobId"
            case jobStatus = "jobStatus"
            case jobType = "jobType"
            case name = "name"
        }
    }

    public struct KeyValuePair: AWSDecodableShape {

        public let key: String?
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ListClassificationJobsRequest: AWSEncodableShape {

        public let filterCriteria: ListJobsFilterCriteria?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: ListJobsSortCriteria?

        public init(filterCriteria: ListJobsFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: ListJobsSortCriteria? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct ListClassificationJobsResponse: AWSDecodableShape {

        public let items: [JobSummary]?
        public let nextToken: String?

        public init(items: [JobSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListCustomDataIdentifiersRequest: AWSEncodableShape {

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCustomDataIdentifiersResponse: AWSDecodableShape {

        public let items: [CustomDataIdentifierSummary]?
        public let nextToken: String?

        public init(items: [CustomDataIdentifierSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingsFiltersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingsFiltersResponse: AWSDecodableShape {

        public let findingsFilterListItems: [FindingsFilterListItem]?
        public let nextToken: String?

        public init(findingsFilterListItems: [FindingsFilterListItem]? = nil, nextToken: String? = nil) {
            self.findingsFilterListItems = findingsFilterListItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingsFilterListItems = "findingsFilterListItems"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {

        public let findingCriteria: FindingCriteria?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: SortCriteria?

        public init(findingCriteria: FindingCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.findingCriteria = findingCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria = "findingCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {

        public let findingIds: [String]?
        public let nextToken: String?

        public init(findingIds: [String]? = nil, nextToken: String? = nil) {
            self.findingIds = findingIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {

        public let invitations: [Invitation]?
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "invitations"
            case nextToken = "nextToken"
        }
    }

    public struct ListJobsFilterCriteria: AWSEncodableShape {

        public let excludes: [ListJobsFilterTerm]?
        public let includes: [ListJobsFilterTerm]?

        public init(excludes: [ListJobsFilterTerm]? = nil, includes: [ListJobsFilterTerm]? = nil) {
            self.excludes = excludes
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case excludes = "excludes"
            case includes = "includes"
        }
    }

    public struct ListJobsFilterTerm: AWSEncodableShape {

        public let comparator: JobComparator?
        public let key: ListJobsFilterKey?
        public let values: [String]?

        public init(comparator: JobComparator? = nil, key: ListJobsFilterKey? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "comparator"
            case key = "key"
            case values = "values"
        }
    }

    public struct ListJobsSortCriteria: AWSEncodableShape {

        public let attributeName: ListJobsSortAttributeName?
        public let orderBy: OrderBy?

        public init(attributeName: ListJobsSortAttributeName? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "onlyAssociated", location: .querystring(locationName: "onlyAssociated"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let onlyAssociated: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {

        public let members: [Member]?
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListOrganizationAdminAccountsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationAdminAccountsResponse: AWSDecodableShape {

        public let adminAccounts: [AdminAccount]?
        public let nextToken: String?

        public init(adminAccounts: [AdminAccount]? = nil, nextToken: String? = nil) {
            self.adminAccounts = adminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccounts = "adminAccounts"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Member: AWSDecodableShape {

        public let accountId: String?
        public let arn: String?
        public let email: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var invitedAt: TimeStamp?
        public let masterAccountId: String?
        public let relationshipStatus: RelationshipStatus?
        public let tags: [String: String]?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var updatedAt: TimeStamp?

        public init(accountId: String? = nil, arn: String? = nil, email: String? = nil, invitedAt: TimeStamp? = nil, masterAccountId: String? = nil, relationshipStatus: RelationshipStatus? = nil, tags: [String: String]? = nil, updatedAt: TimeStamp? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.email = email
            self.invitedAt = invitedAt
            self.masterAccountId = masterAccountId
            self.relationshipStatus = relationshipStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case email = "email"
            case invitedAt = "invitedAt"
            case masterAccountId = "masterAccountId"
            case relationshipStatus = "relationshipStatus"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct MonthlySchedule: AWSEncodableShape & AWSDecodableShape {

        public let dayOfMonth: Int?

        public init(dayOfMonth: Int? = nil) {
            self.dayOfMonth = dayOfMonth
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfMonth = "dayOfMonth"
        }
    }

    public struct ObjectCountByEncryptionType: AWSDecodableShape {

        public let customerManaged: Int64?
        public let kmsManaged: Int64?
        public let s3Managed: Int64?
        public let unencrypted: Int64?

        public init(customerManaged: Int64? = nil, kmsManaged: Int64? = nil, s3Managed: Int64? = nil, unencrypted: Int64? = nil) {
            self.customerManaged = customerManaged
            self.kmsManaged = kmsManaged
            self.s3Managed = s3Managed
            self.unencrypted = unencrypted
        }

        private enum CodingKeys: String, CodingKey {
            case customerManaged = "customerManaged"
            case kmsManaged = "kmsManaged"
            case s3Managed = "s3Managed"
            case unencrypted = "unencrypted"
        }
    }

    public struct PolicyDetails: AWSDecodableShape {

        public let action: FindingAction?
        public let actor: FindingActor?

        public init(action: FindingAction? = nil, actor: FindingActor? = nil) {
            self.action = action
            self.actor = actor
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case actor = "actor"
        }
    }

    public struct PutClassificationExportConfigurationRequest: AWSEncodableShape {

        public let configuration: ClassificationExportConfiguration

        public init(configuration: ClassificationExportConfiguration) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct PutClassificationExportConfigurationResponse: AWSDecodableShape {

        public let configuration: ClassificationExportConfiguration?

        public init(configuration: ClassificationExportConfiguration? = nil) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct ReplicationDetails: AWSDecodableShape {

        public let replicated: Bool?
        public let replicatedExternally: Bool?
        public let replicationAccounts: [String]?

        public init(replicated: Bool? = nil, replicatedExternally: Bool? = nil, replicationAccounts: [String]? = nil) {
            self.replicated = replicated
            self.replicatedExternally = replicatedExternally
            self.replicationAccounts = replicationAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case replicated = "replicated"
            case replicatedExternally = "replicatedExternally"
            case replicationAccounts = "replicationAccounts"
        }
    }

    public struct ResourcesAffected: AWSDecodableShape {

        public let s3Bucket: S3Bucket?
        public let s3Object: S3Object?

        public init(s3Bucket: S3Bucket? = nil, s3Object: S3Object? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Object = s3Object
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3Object = "s3Object"
        }
    }

    public struct S3Bucket: AWSDecodableShape {

        public let arn: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var createdAt: TimeStamp?
        public let defaultServerSideEncryption: ServerSideEncryption?
        public let name: String?
        public let owner: S3BucketOwner?
        public let publicAccess: BucketPublicAccess?
        public let tags: [KeyValuePair]?

        public init(arn: String? = nil, createdAt: TimeStamp? = nil, defaultServerSideEncryption: ServerSideEncryption? = nil, name: String? = nil, owner: S3BucketOwner? = nil, publicAccess: BucketPublicAccess? = nil, tags: [KeyValuePair]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case defaultServerSideEncryption = "defaultServerSideEncryption"
            case name = "name"
            case owner = "owner"
            case publicAccess = "publicAccess"
            case tags = "tags"
        }
    }

    public struct S3BucketDefinitionForJob: AWSEncodableShape & AWSDecodableShape {

        public let accountId: String?
        public let buckets: [String]?

        public init(accountId: String? = nil, buckets: [String]? = nil) {
            self.accountId = accountId
            self.buckets = buckets
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case buckets = "buckets"
        }
    }

    public struct S3BucketOwner: AWSDecodableShape {

        public let displayName: String?
        public let id: String?

        public init(displayName: String? = nil, id: String? = nil) {
            self.displayName = displayName
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case id = "id"
        }
    }

    public struct S3Destination: AWSEncodableShape & AWSDecodableShape {

        public let bucketName: String
        public let keyPrefix: String?
        public let kmsKeyArn: String

        public init(bucketName: String, keyPrefix: String? = nil, kmsKeyArn: String) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case keyPrefix = "keyPrefix"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct S3JobDefinition: AWSEncodableShape & AWSDecodableShape {

        public let bucketDefinitions: [S3BucketDefinitionForJob]?
        public let scoping: Scoping?

        public init(bucketDefinitions: [S3BucketDefinitionForJob]? = nil, scoping: Scoping? = nil) {
            self.bucketDefinitions = bucketDefinitions
            self.scoping = scoping
        }

        private enum CodingKeys: String, CodingKey {
            case bucketDefinitions = "bucketDefinitions"
            case scoping = "scoping"
        }
    }

    public struct S3Object: AWSDecodableShape {

        public let bucketArn: String?
        public let eTag: String?
        public let `extension`: String?
        public let key: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var lastModified: TimeStamp?
        public let path: String?
        public let publicAccess: Bool?
        public let serverSideEncryption: ServerSideEncryption?
        public let size: Int64?
        public let storageClass: StorageClass?
        public let tags: [KeyValuePair]?
        public let versionId: String?

        public init(bucketArn: String? = nil, eTag: String? = nil, extension: String? = nil, key: String? = nil, lastModified: TimeStamp? = nil, path: String? = nil, publicAccess: Bool? = nil, serverSideEncryption: ServerSideEncryption? = nil, size: Int64? = nil, storageClass: StorageClass? = nil, tags: [KeyValuePair]? = nil, versionId: String? = nil) {
            self.bucketArn = bucketArn
            self.eTag = eTag
            self.`extension` = `extension`
            self.key = key
            self.lastModified = lastModified
            self.path = path
            self.publicAccess = publicAccess
            self.serverSideEncryption = serverSideEncryption
            self.size = size
            self.storageClass = storageClass
            self.tags = tags
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case eTag = "eTag"
            case `extension` = "extension"
            case key = "key"
            case lastModified = "lastModified"
            case path = "path"
            case publicAccess = "publicAccess"
            case serverSideEncryption = "serverSideEncryption"
            case size = "size"
            case storageClass = "storageClass"
            case tags = "tags"
            case versionId = "versionId"
        }
    }

    public struct Scoping: AWSEncodableShape & AWSDecodableShape {

        public let excludes: JobScopingBlock?
        public let includes: JobScopingBlock?

        public init(excludes: JobScopingBlock? = nil, includes: JobScopingBlock? = nil) {
            self.excludes = excludes
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case excludes = "excludes"
            case includes = "includes"
        }
    }

    public struct SensitiveDataItem: AWSDecodableShape {

        public let category: SensitiveDataItemCategory?
        public let detections: [DefaultDetection]?
        public let totalCount: Int64?

        public init(category: SensitiveDataItemCategory? = nil, detections: [DefaultDetection]? = nil, totalCount: Int64? = nil) {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case detections = "detections"
            case totalCount = "totalCount"
        }
    }

    public struct ServerSideEncryption: AWSDecodableShape {

        public let encryptionType: EncryptionType?
        public let kmsMasterKeyId: String?

        public init(encryptionType: EncryptionType? = nil, kmsMasterKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsMasterKeyId = kmsMasterKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsMasterKeyId = "kmsMasterKeyId"
        }
    }

    public struct ServiceLimit: AWSDecodableShape {

        public let isServiceLimited: Bool?
        public let unit: Unit?
        public let value: Int64?

        public init(isServiceLimited: Bool? = nil, unit: Unit? = nil, value: Int64? = nil) {
            self.isServiceLimited = isServiceLimited
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case isServiceLimited = "isServiceLimited"
            case unit = "unit"
            case value = "value"
        }
    }

    public struct SessionContext: AWSDecodableShape {

        public let attributes: SessionContextAttributes?
        public let sessionIssuer: SessionIssuer?

        public init(attributes: SessionContextAttributes? = nil, sessionIssuer: SessionIssuer? = nil) {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case sessionIssuer = "sessionIssuer"
        }
    }

    public struct SessionContextAttributes: AWSDecodableShape {

        @OptionalCoding<ISO8601TimeStampCoder>
        public var creationDate: TimeStamp?
        public let mfaAuthenticated: Bool?

        public init(creationDate: TimeStamp? = nil, mfaAuthenticated: Bool? = nil) {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case mfaAuthenticated = "mfaAuthenticated"
        }
    }

    public struct SessionIssuer: AWSDecodableShape {

        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let `type`: String?
        public let userName: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil, type: String? = nil, userName: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.`type` = `type`
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case principalId = "principalId"
            case `type` = "type"
            case userName = "userName"
        }
    }

    public struct Severity: AWSDecodableShape {

        public let description: SeverityDescription?
        public let score: Int64?

        public init(description: SeverityDescription? = nil, score: Int64? = nil) {
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case score = "score"
        }
    }

    public struct SimpleScopeTerm: AWSEncodableShape & AWSDecodableShape {

        public let comparator: JobComparator?
        public let key: ScopeFilterKey?
        public let values: [String]?

        public init(comparator: JobComparator? = nil, key: ScopeFilterKey? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "comparator"
            case key = "key"
            case values = "values"
        }
    }

    public struct SortCriteria: AWSEncodableShape {

        public let attributeName: String?
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct Statistics: AWSDecodableShape {

        public let approximateNumberOfObjectsToProcess: Double?
        public let numberOfRuns: Double?

        public init(approximateNumberOfObjectsToProcess: Double? = nil, numberOfRuns: Double? = nil) {
            self.approximateNumberOfObjectsToProcess = approximateNumberOfObjectsToProcess
            self.numberOfRuns = numberOfRuns
        }

        private enum CodingKeys: String, CodingKey {
            case approximateNumberOfObjectsToProcess = "approximateNumberOfObjectsToProcess"
            case numberOfRuns = "numberOfRuns"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct TagScopeTerm: AWSEncodableShape & AWSDecodableShape {

        public let comparator: JobComparator?
        public let key: String?
        public let tagValues: [TagValuePair]?
        public let target: TagTarget?

        public init(comparator: JobComparator? = nil, key: String? = nil, tagValues: [TagValuePair]? = nil, target: TagTarget? = nil) {
            self.comparator = comparator
            self.key = key
            self.tagValues = tagValues
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "comparator"
            case key = "key"
            case tagValues = "tagValues"
            case target = "target"
        }
    }

    public struct TagValuePair: AWSEncodableShape & AWSDecodableShape {

        public let key: String?
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TestCustomDataIdentifierRequest: AWSEncodableShape {

        public let ignoreWords: [String]?
        public let keywords: [String]?
        public let maximumMatchDistance: Int?
        public let regex: String
        public let sampleText: String

        public init(ignoreWords: [String]? = nil, keywords: [String]? = nil, maximumMatchDistance: Int? = nil, regex: String, sampleText: String) {
            self.ignoreWords = ignoreWords
            self.keywords = keywords
            self.maximumMatchDistance = maximumMatchDistance
            self.regex = regex
            self.sampleText = sampleText
        }

        private enum CodingKeys: String, CodingKey {
            case ignoreWords = "ignoreWords"
            case keywords = "keywords"
            case maximumMatchDistance = "maximumMatchDistance"
            case regex = "regex"
            case sampleText = "sampleText"
        }
    }

    public struct TestCustomDataIdentifierResponse: AWSDecodableShape {

        public let matchCount: Int?

        public init(matchCount: Int? = nil) {
            self.matchCount = matchCount
        }

        private enum CodingKeys: String, CodingKey {
            case matchCount = "matchCount"
        }
    }

    public struct UnarchiveFindingsRequest: AWSEncodableShape {

        public let findingIds: [String]

        public init(findingIds: [String]) {
            self.findingIds = findingIds
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
        }
    }

    public struct UnarchiveFindingsResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UnprocessedAccount: AWSDecodableShape {

        public let accountId: String?
        public let errorCode: ErrorCode?
        public let errorMessage: String?

        public init(accountId: String? = nil, errorCode: ErrorCode? = nil, errorMessage: String? = nil) {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateClassificationJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        public let jobId: String
        public let jobStatus: JobStatus

        public init(jobId: String, jobStatus: JobStatus) {
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus = "jobStatus"
        }
    }

    public struct UpdateClassificationJobResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateFindingsFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let action: FindingsFilterAction?
        public let description: String?
        public let findingCriteria: FindingCriteria?
        public let id: String
        public let name: String?
        public let position: Int?

        public init(action: FindingsFilterAction? = nil, description: String? = nil, findingCriteria: FindingCriteria? = nil, id: String, name: String? = nil, position: Int? = nil) {
            self.action = action
            self.description = description
            self.findingCriteria = findingCriteria
            self.id = id
            self.name = name
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case name = "name"
            case position = "position"
        }
    }

    public struct UpdateFindingsFilterResponse: AWSDecodableShape {

        public let arn: String?
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct UpdateMacieSessionRequest: AWSEncodableShape {

        public let findingPublishingFrequency: FindingPublishingFrequency?
        public let status: MacieStatus?

        public init(findingPublishingFrequency: FindingPublishingFrequency? = nil, status: MacieStatus? = nil) {
            self.findingPublishingFrequency = findingPublishingFrequency
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case findingPublishingFrequency = "findingPublishingFrequency"
            case status = "status"
        }
    }

    public struct UpdateMacieSessionResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateMemberSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String
        public let status: MacieStatus

        public init(id: String, status: MacieStatus) {
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateMemberSessionResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {

        public let autoEnable: Bool

        public init(autoEnable: Bool) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UsageByAccount: AWSDecodableShape {

        public let currency: Currency?
        public let estimatedCost: String?
        public let serviceLimit: ServiceLimit?
        public let `type`: UsageType?

        public init(currency: Currency? = nil, estimatedCost: String? = nil, serviceLimit: ServiceLimit? = nil, type: UsageType? = nil) {
            self.currency = currency
            self.estimatedCost = estimatedCost
            self.serviceLimit = serviceLimit
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "currency"
            case estimatedCost = "estimatedCost"
            case serviceLimit = "serviceLimit"
            case `type` = "type"
        }
    }

    public struct UsageRecord: AWSDecodableShape {

        public let accountId: String?
        @OptionalCoding<ISO8601TimeStampCoder>
        public var freeTrialStartDate: TimeStamp?
        public let usage: [UsageByAccount]?

        public init(accountId: String? = nil, freeTrialStartDate: TimeStamp? = nil, usage: [UsageByAccount]? = nil) {
            self.accountId = accountId
            self.freeTrialStartDate = freeTrialStartDate
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case freeTrialStartDate = "freeTrialStartDate"
            case usage = "usage"
        }
    }

    public struct UsageStatisticsFilter: AWSEncodableShape {

        public let key: UsageStatisticsFilterKey?
        public let values: [String]?

        public init(key: UsageStatisticsFilterKey? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case values = "values"
        }
    }

    public struct UsageStatisticsSortBy: AWSEncodableShape {

        public let key: UsageStatisticsSortKey?
        public let orderBy: OrderBy?

        public init(key: UsageStatisticsSortKey? = nil, orderBy: OrderBy? = nil) {
            self.key = key
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case orderBy = "orderBy"
        }
    }

    public struct UsageTotal: AWSDecodableShape {

        public let currency: Currency?
        public let estimatedCost: String?
        public let `type`: UsageType?

        public init(currency: Currency? = nil, estimatedCost: String? = nil, type: UsageType? = nil) {
            self.currency = currency
            self.estimatedCost = estimatedCost
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "currency"
            case estimatedCost = "estimatedCost"
            case `type` = "type"
        }
    }

    public struct UserIdentity: AWSDecodableShape {

        public let assumedRole: AssumedRole?
        public let awsAccount: AwsAccount?
        public let awsService: AwsService?
        public let federatedUser: FederatedUser?
        public let iamUser: IamUser?
        public let root: UserIdentityRoot?
        public let `type`: UserIdentityType?

        public init(assumedRole: AssumedRole? = nil, awsAccount: AwsAccount? = nil, awsService: AwsService? = nil, federatedUser: FederatedUser? = nil, iamUser: IamUser? = nil, root: UserIdentityRoot? = nil, type: UserIdentityType? = nil) {
            self.assumedRole = assumedRole
            self.awsAccount = awsAccount
            self.awsService = awsService
            self.federatedUser = federatedUser
            self.iamUser = iamUser
            self.root = root
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case assumedRole = "assumedRole"
            case awsAccount = "awsAccount"
            case awsService = "awsService"
            case federatedUser = "federatedUser"
            case iamUser = "iamUser"
            case root = "root"
            case `type` = "type"
        }
    }

    public struct UserIdentityRoot: AWSDecodableShape {

        public let accountId: String?
        public let arn: String?
        public let principalId: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case principalId = "principalId"
        }
    }

    public struct WeeklySchedule: AWSEncodableShape & AWSDecodableShape {

        public let dayOfWeek: DayOfWeek?

        public init(dayOfWeek: DayOfWeek? = nil) {
            self.dayOfWeek = dayOfWeek
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek = "dayOfWeek"
        }
    }
}
