//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore
import Foundation

extension Imagebuilder {
    //MARK: Enums

    public enum ComponentFormat: String, CustomStringConvertible, Codable {
        case shell = "SHELL"
        public var description: String { return self.rawValue }
    }

    public enum ComponentType: String, CustomStringConvertible, Codable {
        case build = "BUILD"
        case test = "TEST"
        public var description: String { return self.rawValue }
    }

    public enum EbsVolumeType: String, CustomStringConvertible, Codable {
        case standard = "standard"
        case io1 = "io1"
        case gp2 = "gp2"
        case sc1 = "sc1"
        case st1 = "st1"
        public var description: String { return self.rawValue }
    }

    public enum ImageStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case creating = "CREATING"
        case building = "BUILDING"
        case testing = "TESTING"
        case distributing = "DISTRIBUTING"
        case integrating = "INTEGRATING"
        case available = "AVAILABLE"
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case deprecated = "DEPRECATED"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public enum Ownership: String, CustomStringConvertible, Codable {
        case `self` = "Self"
        case shared = "Shared"
        case amazon = "Amazon"
        public var description: String { return self.rawValue }
    }

    public enum PipelineExecutionStartCondition: String, CustomStringConvertible, Codable {
        case expressionMatchOnly = "EXPRESSION_MATCH_ONLY"
        case expressionMatchAndDependencyUpdatesAvailable = "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum PipelineStatus: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Platform: String, CustomStringConvertible, Codable {
        case windows = "Windows"
        case linux = "Linux"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct Ami: AWSDecodableShape {

        /// The description of the EC2 AMI. 
        public let description: String?
        /// The AMI ID of the EC2 AMI. 
        public let image: String?
        /// The name of the EC2 AMI. 
        public let name: String?
        /// The AWS Region of the EC2 AMI. 
        public let region: String?
        public let state: ImageState?

        public init(description: String? = nil, image: String? = nil, name: String? = nil, region: String? = nil, state: ImageState? = nil) {
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case image = "image"
            case name = "name"
            case region = "region"
            case state = "state"
        }
    }

    public struct AmiDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// The tags to apply to AMIs distributed to this Region. 
        public let amiTags: [String: String]?
        /// The description of the distribution configuration. 
        public let description: String?
        ///  Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances. 
        public let launchPermission: LaunchPermissionConfiguration?
        /// The name of the distribution configuration. 
        public let name: String?

        public init(amiTags: [String: String]? = nil, description: String? = nil, launchPermission: LaunchPermissionConfiguration? = nil, name: String? = nil) {
            self.amiTags = amiTags
            self.description = description
            self.launchPermission = launchPermission
            self.name = name
        }

        public func validate(name: String) throws {
            try self.amiTags?.forEach {
                try validate($0.key, name: "amiTags.key", parent: name, max: 128)
                try validate($0.key, name: "amiTags.key", parent: name, min: 1)
                try validate($0.key, name: "amiTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "amiTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try self.launchPermission?.validate(name: "\(name).launchPermission")
            try validate(self.name, name: "name", parent: name, max: 127)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z0-9{][-_A-Za-z0-9\\s:{}]+[-_A-Za-z0-9}]$")
        }

        private enum CodingKeys: String, CodingKey {
            case amiTags = "amiTags"
            case description = "description"
            case launchPermission = "launchPermission"
            case name = "name"
        }
    }

    public struct CancelImageCreationRequest: AWSEncodableShape {

        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image whose creation you want to cancel.
        public let imageBuildVersionArn: String

        public init(clientToken: String = CancelImageCreationRequest.idempotencyToken(), imageBuildVersionArn: String) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
        }
    }

    public struct CancelImageCreationResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image whose creation has been cancelled.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct Component: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description of the component.
        public let changeDescription: String?
        /// The data of the component.
        public let data: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The encryption status of the component.
        public let encrypted: Bool?
        /// The KMS key identifier used to encrypt the component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation. 
        public let supportedOsVersions: [String]?
        /// The tags associated with the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let `type`: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, data: String? = nil, dateCreated: String? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.`type` = `type`
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case changeDescription = "changeDescription"
            case data = "data"
            case dateCreated = "dateCreated"
            case description = "description"
            case encrypted = "encrypted"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case owner = "owner"
            case platform = "platform"
            case supportedOsVersions = "supportedOsVersions"
            case tags = "tags"
            case `type` = "type"
            case version = "version"
        }
    }

    public struct ComponentConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the component. 
        public let componentArn: String

        public init(componentArn: String) {
            self.componentArn = componentArn
        }

        public func validate(name: String) throws {
            try validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):component/[a-z0-9-_]+/(?:(?:(\\d+|x)\\.(\\d+|x)\\.(\\d+|x))|(?:\\d+\\.\\d+\\.\\d+/\\d+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
        }
    }

    public struct ComponentSummary: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description of the component.
        public let changeDescription: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation. 
        public let supportedOsVersions: [String]?
        /// The tags associated with the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let `type`: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.`type` = `type`
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case changeDescription = "changeDescription"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case platform = "platform"
            case supportedOsVersions = "supportedOsVersions"
            case tags = "tags"
            case `type` = "type"
            case version = "version"
        }
    }

    public struct ComponentVersion: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        ///  The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation. 
        public let supportedOsVersions: [String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let `type`: ComponentType?
        /// The semantic version of the component.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.`type` = `type`
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case platform = "platform"
            case supportedOsVersions = "supportedOsVersions"
            case `type` = "type"
            case version = "version"
        }
    }

    public struct CreateComponentRequest: AWSEncodableShape {

        /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.
        public let changeDescription: String?
        /// The idempotency token of the component.
        public let clientToken: String
        /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
        public let data: String?
        /// The description of the component. Describes the contents of the component.
        public let description: String?
        /// The ID of the KMS key that should be used to encrypt this component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String
        /// The platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version syntax. For example, major.minor.patch. This could be versioned like software (2.0.1) or like a date (2019.12.01).
        public let semanticVersion: String
        ///  The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation. 
        public let supportedOsVersions: [String]?
        /// The tags of the component.
        public let tags: [String: String]?
        /// The uri of the component. Must be an S3 URL and the requester must have permission to access the S3 bucket. If you use S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = CreateComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.uri = uri
        }

        public func validate(name: String) throws {
            try validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.data, name: "data", parent: name, max: 16000)
            try validate(self.data, name: "data", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.supportedOsVersions?.forEach {
                try validate($0, name: "supportedOsVersions[]", parent: name, min: 1)
            }
            try validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, max: 25)
            try validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription = "changeDescription"
            case clientToken = "clientToken"
            case data = "data"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case platform = "platform"
            case semanticVersion = "semanticVersion"
            case supportedOsVersions = "supportedOsVersions"
            case tags = "tags"
            case uri = "uri"
        }
    }

    public struct CreateComponentResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the component that was created by this request.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case componentBuildVersionArn = "componentBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct CreateDistributionConfigurationRequest: AWSEncodableShape {

        ///  The idempotency token of the distribution configuration. 
        public let clientToken: String
        ///  The description of the distribution configuration. 
        public let description: String?
        ///  The distributions of the distribution configuration. 
        public let distributions: [Distribution]
        ///  The name of the distribution configuration. 
        public let name: String
        ///  The tags of the distribution configuration. 
        public let tags: [String: String]?

        public init(clientToken: String = CreateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributions: [Distribution], name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case distributions = "distributions"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateDistributionConfigurationResponse: AWSDecodableShape {

        ///  The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that was created by this request. 
        public let distributionConfigurationArn: String?
        ///  The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct CreateImagePipelineRequest: AWSEncodableShape {

        ///  The idempotency token used to make this request idempotent. 
        public let clientToken: String
        ///  The description of the image pipeline. 
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images created by this image pipeline. 
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default. 
        public let enhancedImageMetadataEnabled: Bool?
        ///  The Amazon Resource Name (ARN) of the image recipe that will be used to configure images created by this image pipeline. 
        public let imageRecipeArn: String
        ///  The image test configuration of the image pipeline. 
        public let imageTestsConfiguration: ImageTestsConfiguration?
        ///  The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images created by this image pipeline. 
        public let infrastructureConfigurationArn: String
        ///  The name of the image pipeline. 
        public let name: String
        ///  The schedule of the image pipeline. 
        public let schedule: Schedule?
        ///  The status of the image pipeline. 
        public let status: PipelineStatus?
        ///  The tags of the image pipeline. 
        public let tags: [String: String]?

        public init(clientToken: String = CreateImagePipelineRequest.idempotencyToken(), description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, name: String, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.schedule?.validate(name: "\(name).schedule")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case imageRecipeArn = "imageRecipeArn"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case name = "name"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateImagePipelineResponse: AWSDecodableShape {

        ///  The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the image pipeline that was created by this request. 
        public let imagePipelineArn: String?
        ///  The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imagePipelineArn = "imagePipelineArn"
            case requestId = "requestId"
        }
    }

    public struct CreateImageRecipeRequest: AWSEncodableShape {

        /// The block device mappings of the image recipe. 
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String
        /// The components of the image recipe. 
        public let components: [ComponentConfiguration]
        ///  The description of the image recipe. 
        public let description: String?
        ///  The name of the image recipe. 
        public let name: String
        /// The parent image of the image recipe. The value of the string can be the ARN of the parent image or an AMI ID. The format for the ARN follows this example: arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/2019.x.x. The ARN ends with /20xx.x.x, which communicates to EC2 Image Builder that you want to use the latest AMI created in 20xx (year). You can provide the specific version that you want to use, or you can use a wildcard in all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI, and the AMI must be in the same Region in which you are using Image Builder. 
        public let parentImage: String
        /// The semantic version of the image recipe. 
        public let semanticVersion: String
        ///  The tags of the image recipe. 
        public let tags: [String: String]?

        public init(blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, clientToken: String = CreateImageRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], description: String? = nil, name: String, parentImage: String, semanticVersion: String, tags: [String: String]? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.clientToken = clientToken
            self.components = components
            self.description = description
            self.name = name
            self.parentImage = parentImage
            self.semanticVersion = semanticVersion
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try validate(self.components, name: "components", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappings = "blockDeviceMappings"
            case clientToken = "clientToken"
            case components = "components"
            case description = "description"
            case name = "name"
            case parentImage = "parentImage"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
        }
    }

    public struct CreateImageRecipeResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image recipe that was created by this request. 
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageRecipeArn = "imageRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct CreateImageRequest: AWSEncodableShape {

        ///  The idempotency token used to make this request idempotent. 
        public let clientToken: String
        ///  The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline. 
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default. 
        public let enhancedImageMetadataEnabled: Bool?
        ///  The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed. 
        public let imageRecipeArn: String
        ///  The image tests configuration of the image. 
        public let imageTestsConfiguration: ImageTestsConfiguration?
        ///  The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested. 
        public let infrastructureConfigurationArn: String
        ///  The tags of the image. 
        public let tags: [String: String]?

        public init(clientToken: String = CreateImageRequest.idempotencyToken(), distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case imageRecipeArn = "imageRecipeArn"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case tags = "tags"
        }
    }

    public struct CreateImageResponse: AWSDecodableShape {

        ///  The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the image that was created by this request. 
        public let imageBuildVersionArn: String?
        ///  The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct CreateInfrastructureConfigurationRequest: AWSEncodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String
        /// The description of the infrastructure configuration. 
        public let description: String?
        /// The instance profile to associate with the instance used to customize your EC2 AMI. 
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability. 
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. This can be used to log on to and debug the instance used to create your image. 
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration. 
        public let logging: Logging?
        /// The name of the infrastructure configuration. 
        public let name: String
        /// The security group IDs to associate with the instance used to customize your EC2 AMI. 
        public let securityGroupIds: [String]?
        /// The SNS topic on which to send image build events. 
        public let snsTopicArn: String?
        /// The subnet ID in which to place the instance used to customize your EC2 AMI. 
        public let subnetId: String?
        /// The tags of the infrastructure configuration. 
        public let tags: [String: String]?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails. 
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = CreateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 1024)
            try validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:\\d{12}:[a-zA-Z0-9-_]{1,256}$")
            try validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try validate(self.subnetId, name: "subnetId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case keyPair = "keyPair"
            case logging = "logging"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case snsTopicArn = "snsTopicArn"
            case subnetId = "subnetId"
            case tags = "tags"
            case terminateInstanceOnFailure = "terminateInstanceOnFailure"
        }
    }

    public struct CreateInfrastructureConfigurationResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by this request. 
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentBuildVersionArn", location: .querystring(locationName: "componentBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component build version to delete. 
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):component/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the component build version that was deleted. 
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentBuildVersionArn = "componentBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteDistributionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "distributionConfigurationArn", location: .querystring(locationName: "distributionConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the distribution configuration to delete. 
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func validate(name: String) throws {
            try validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDistributionConfigurationResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted. 
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationArn = "distributionConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteImagePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imagePipelineArn", location: .querystring(locationName: "imagePipelineArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image pipeline to delete. 
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImagePipelineResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image pipeline that was deleted. 
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineArn = "imagePipelineArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteImageRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring(locationName: "imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe to delete. 
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageRecipeResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image recipe that was deleted. 
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn = "imageRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageBuildVersionArn", location: .querystring(locationName: "imageBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image to delete. 
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image that was deleted. 
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct DeleteInfrastructureConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "infrastructureConfigurationArn", location: .querystring(locationName: "infrastructureConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete. 
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func validate(name: String) throws {
            try validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInfrastructureConfigurationResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted. 
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct Distribution: AWSEncodableShape & AWSDecodableShape {

        /// The specific AMI settings (for example, launch permissions, AMI tags). 
        public let amiDistributionConfiguration: AmiDistributionConfiguration?
        /// The License Manager Configuration to associate with the AMI in the specified Region.
        public let licenseConfigurationArns: [String]?
        /// The target Region. 
        public let region: String

        public init(amiDistributionConfiguration: AmiDistributionConfiguration? = nil, licenseConfigurationArns: [String]? = nil, region: String) {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
        }

        public func validate(name: String) throws {
            try self.amiDistributionConfiguration?.validate(name: "\(name).amiDistributionConfiguration")
            try validate(self.region, name: "region", parent: name, max: 1024)
            try validate(self.region, name: "region", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amiDistributionConfiguration = "amiDistributionConfiguration"
            case licenseConfigurationArns = "licenseConfigurationArns"
            case region = "region"
        }
    }

    public struct DistributionConfiguration: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which this distribution configuration was created.
        public let dateCreated: String?
        /// The date on which this distribution configuration was last updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The distributions of the distribution configuration.
        public let distributions: [Distribution]?
        /// The name of the distribution configuration.
        public let name: String?
        /// The tags of the distribution configuration.
        public let tags: [String: String]?
        /// The maximum duration in minutes for this distribution configuration.
        public let timeoutMinutes: Int

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributions: [Distribution]? = nil, name: String? = nil, tags: [String: String]? = nil, timeoutMinutes: Int) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case distributions = "distributions"
            case name = "name"
            case tags = "tags"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct DistributionConfigurationSummary: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which the distribution configuration was created.
        public let dateCreated: String?
        /// The date on which the distribution configuration was updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The name of the distribution configuration.
        public let name: String?
        /// The tags associated with the distribution configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct EbsInstanceBlockDeviceSpecification: AWSEncodableShape & AWSDecodableShape {

        /// Use to configure delete on termination of the associated device.
        public let deleteOnTermination: Bool?
        /// Use to configure device encryption.
        public let encrypted: Bool?
        /// Use to configure device IOPS.
        public let iops: Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public let kmsKeyId: String?
        /// The snapshot that defines the device contents.
        public let snapshotId: String?
        /// Use to override the device's volume size.
        public let volumeSize: Int?
        /// Use to override the device's volume type.
        public let volumeType: EbsVolumeType?

        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, snapshotId: String? = nil, volumeSize: Int? = nil, volumeType: EbsVolumeType? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try validate(self.iops, name: "iops", parent: name, max: 10000)
            try validate(self.iops, name: "iops", parent: name, min: 100)
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try validate(self.snapshotId, name: "snapshotId", parent: name, max: 1024)
            try validate(self.snapshotId, name: "snapshotId", parent: name, min: 1)
            try validate(self.volumeSize, name: "volumeSize", parent: name, max: 16000)
            try validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination = "deleteOnTermination"
            case encrypted = "encrypted"
            case iops = "iops"
            case kmsKeyId = "kmsKeyId"
            case snapshotId = "snapshotId"
            case volumeSize = "volumeSize"
            case volumeType = "volumeType"
        }
    }

    public struct Filter: AWSEncodableShape {

        /// The name of the filter. Filter names are case-sensitive. 
        public let name: String?
        /// The filter values. Filter values are case-sensitive. 
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]{1,1024}$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z./_ :-]{1,1024}$")
            }
            try validate(self.values, name: "values", parent: name, max: 10)
            try validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct GetComponentPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentArn", location: .querystring(locationName: "componentArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve. 
        public let componentArn: String

        public init(componentArn: String) {
            self.componentArn = componentArn
        }

        public func validate(name: String) throws {
            try validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):component/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentPolicyResponse: AWSDecodableShape {

        /// The component policy. 
        public let policy: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentBuildVersionArn", location: .querystring(locationName: "componentBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires "/\d+$" suffix.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):component/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentResponse: AWSDecodableShape {

        /// The component object associated with the specified ARN. 
        public let component: Component?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(component: Component? = nil, requestId: String? = nil) {
            self.component = component
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case component = "component"
            case requestId = "requestId"
        }
    }

    public struct GetDistributionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "distributionConfigurationArn", location: .querystring(locationName: "distributionConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to retrieve. 
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func validate(name: String) throws {
            try validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDistributionConfigurationResponse: AWSDecodableShape {

        /// The distribution configuration object. 
        public let distributionConfiguration: DistributionConfiguration?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(distributionConfiguration: DistributionConfiguration? = nil, requestId: String? = nil) {
            self.distributionConfiguration = distributionConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfiguration = "distributionConfiguration"
            case requestId = "requestId"
        }
    }

    public struct GetImagePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imagePipelineArn", location: .querystring(locationName: "imagePipelineArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve. 
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePipelineResponse: AWSDecodableShape {

        /// The image pipeline object. 
        public let imagePipeline: ImagePipeline?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imagePipeline: ImagePipeline? = nil, requestId: String? = nil) {
            self.imagePipeline = imagePipeline
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipeline = "imagePipeline"
            case requestId = "requestId"
        }
    }

    public struct GetImagePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageArn", location: .querystring(locationName: "imageArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve. 
        public let imageArn: String

        public init(imageArn: String) {
            self.imageArn = imageArn
        }

        public func validate(name: String) throws {
            try validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePolicyResponse: AWSDecodableShape {

        /// The image policy object. 
        public let policy: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetImageRecipePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring(locationName: "imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve. 
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipePolicyResponse: AWSDecodableShape {

        /// The image recipe policy object. 
        public let policy: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case requestId = "requestId"
        }
    }

    public struct GetImageRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring(locationName: "imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve. 
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipeResponse: AWSDecodableShape {

        /// The image recipe object. 
        public let imageRecipe: ImageRecipe?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageRecipe: ImageRecipe? = nil, requestId: String? = nil) {
            self.imageRecipe = imageRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipe = "imageRecipe"
            case requestId = "requestId"
        }
    }

    public struct GetImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageBuildVersionArn", location: .querystring(locationName: "imageBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image that you want to retrieve. 
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageResponse: AWSDecodableShape {

        /// The image object. 
        public let image: Image?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(image: Image? = nil, requestId: String? = nil) {
            self.image = image
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
            case requestId = "requestId"
        }
    }

    public struct GetInfrastructureConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "infrastructureConfigurationArn", location: .querystring(locationName: "infrastructureConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to retrieve. 
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func validate(name: String) throws {
            try validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInfrastructureConfigurationResponse: AWSDecodableShape {

        /// The infrastructure configuration object. 
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(infrastructureConfiguration: InfrastructureConfiguration? = nil, requestId: String? = nil) {
            self.infrastructureConfiguration = infrastructureConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfiguration = "infrastructureConfiguration"
            case requestId = "requestId"
        }
    }

    public struct Image: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image.
        public let arn: String?
        /// The date on which this image was created.
        public let dateCreated: String?
        /// The distribution configuration used when creating this image.
        public let distributionConfiguration: DistributionConfiguration?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default. 
        public let enhancedImageMetadataEnabled: Bool?
        /// The image recipe used when creating the image.
        public let imageRecipe: ImageRecipe?
        /// The image tests configuration used when creating this image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The infrastructure used when creating this image.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019. 
        public let osVersion: String?
        /// The output resources produced when creating this image.
        public let outputResources: OutputResources?
        /// The platform of the image.
        public let platform: Platform?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public let sourcePipelineArn: String?
        /// The name of the image pipeline that created this image.
        public let sourcePipelineName: String?
        /// The state of the image.
        public let state: ImageState?
        /// The tags of the image.
        public let tags: [String: String]?
        /// The semantic version of the image.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, distributionConfiguration: DistributionConfiguration? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipe: ImageRecipe? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfiguration: InfrastructureConfiguration? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, platform: Platform? = nil, sourcePipelineArn: String? = nil, sourcePipelineName: String? = nil, state: ImageState? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipe = imageRecipe
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case distributionConfiguration = "distributionConfiguration"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case imageRecipe = "imageRecipe"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfiguration = "infrastructureConfiguration"
            case name = "name"
            case osVersion = "osVersion"
            case outputResources = "outputResources"
            case platform = "platform"
            case sourcePipelineArn = "sourcePipelineArn"
            case sourcePipelineName = "sourcePipelineName"
            case state = "state"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct ImagePipeline: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image pipeline.
        public let arn: String?
        /// The date on which this image pipeline was created.
        public let dateCreated: String?
        /// The date on which this image pipeline was last run.
        public let dateLastRun: String?
        /// The date on which this image pipeline will next be run.
        public let dateNextRun: String?
        /// The date on which this image pipeline was last updated.
        public let dateUpdated: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default. 
        public let enhancedImageMetadataEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.
        public let imageRecipeArn: String?
        /// The image tests configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.
        public let infrastructureConfigurationArn: String?
        /// The name of the image pipeline.
        public let name: String?
        /// The platform of the image pipeline.
        public let platform: Platform?
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?
        /// The tags of this image pipeline.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateLastRun: String? = nil, dateNextRun: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String? = nil, name: String? = nil, platform: Platform? = nil, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateLastRun = "dateLastRun"
            case dateNextRun = "dateNextRun"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case imageRecipeArn = "imageRecipeArn"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case name = "name"
            case platform = "platform"
            case schedule = "schedule"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ImageRecipe: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The block device mappings to apply when creating images from this recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The components of the image recipe.
        public let components: [ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The description of the image recipe.
        public let description: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The parent image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?
        /// The version of the image recipe.
        public let version: String?

        public init(arn: String? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, components: [ComponentConfiguration]? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case blockDeviceMappings = "blockDeviceMappings"
            case components = "components"
            case dateCreated = "dateCreated"
            case description = "description"
            case name = "name"
            case owner = "owner"
            case parentImage = "parentImage"
            case platform = "platform"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct ImageRecipeSummary: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The parent image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case name = "name"
            case owner = "owner"
            case parentImage = "parentImage"
            case platform = "platform"
            case tags = "tags"
        }
    }

    public struct ImageState: AWSDecodableShape {

        /// The reason for the image's status. 
        public let reason: String?
        /// The status of the image. 
        public let status: ImageStatus?

        public init(reason: String? = nil, status: ImageStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct ImageSummary: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image.
        public let arn: String?
        /// The date on which this image was created.
        public let dateCreated: String?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019. 
        public let osVersion: String?
        /// The output resources produced when creating this image.
        public let outputResources: OutputResources?
        /// The owner of the image.
        public let owner: String?
        /// The platform of the image.
        public let platform: Platform?
        /// The state of the image.
        public let state: ImageState?
        /// The tags of the image.
        public let tags: [String: String]?
        /// The version of the image.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, owner: String? = nil, platform: Platform? = nil, state: ImageState? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case name = "name"
            case osVersion = "osVersion"
            case outputResources = "outputResources"
            case owner = "owner"
            case platform = "platform"
            case state = "state"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct ImageTestsConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// Defines if tests should be executed when building this image.
        public let imageTestsEnabled: Bool?
        /// The maximum time in minutes that tests are permitted to run.
        public let timeoutMinutes: Int?

        public init(imageTestsEnabled: Bool? = nil, timeoutMinutes: Int? = nil) {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }

        public func validate(name: String) throws {
            try validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, max: 1440)
            try validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case imageTestsEnabled = "imageTestsEnabled"
            case timeoutMinutes = "timeoutMinutes"
        }
    }

    public struct ImageVersion: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image semantic version.
        public let arn: String?
        /// The date at which this image semantic version was created.
        public let dateCreated: String?
        /// The name of the image semantic version.
        public let name: String?
        ///  The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019. 
        public let osVersion: String?
        /// The owner of the image semantic version.
        public let owner: String?
        /// The platform of the image semantic version.
        public let platform: Platform?
        /// The semantic version of the image semantic version.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, osVersion: String? = nil, owner: String? = nil, platform: Platform? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case name = "name"
            case osVersion = "osVersion"
            case owner = "owner"
            case platform = "platform"
            case version = "version"
        }
    }

    public struct ImportComponentRequest: AWSEncodableShape {

        /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component. 
        public let changeDescription: String?
        /// The idempotency token of the component. 
        public let clientToken: String
        /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
        public let data: String?
        /// The description of the component. Describes the contents of the component. 
        public let description: String?
        /// The format of the resource that you want to import as a component. 
        public let format: ComponentFormat
        /// The ID of the KMS key that should be used to encrypt this component. 
        public let kmsKeyId: String?
        ///  The name of the component. 
        public let name: String
        /// The platform of the component. 
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version syntax. For example, major.minor.patch. This could be versioned like software (2.0.1) or like a date (2019.12.01).
        public let semanticVersion: String
        /// The tags of the component. 
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it. 
        public let `type`: ComponentType
        /// The uri of the component. Must be an S3 URL and the requester must have permission to access the S3 bucket. If you use S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component. 
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = ImportComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, format: ComponentFormat, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, tags: [String: String]? = nil, type: ComponentType, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.format = format
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.`type` = `type`
            self.uri = uri
        }

        public func validate(name: String) throws {
            try validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.data, name: "data", parent: name, max: 1024)
            try validate(self.data, name: "data", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription = "changeDescription"
            case clientToken = "clientToken"
            case data = "data"
            case description = "description"
            case format = "format"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case platform = "platform"
            case semanticVersion = "semanticVersion"
            case tags = "tags"
            case `type` = "type"
            case uri = "uri"
        }
    }

    public struct ImportComponentResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the imported component. 
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case componentBuildVersionArn = "componentBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct InfrastructureConfiguration: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The EC2 key pair of the infrastructure configuration.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The security group IDs of the infrastructure configuration.
        public let securityGroupIds: [String]?
        /// The SNS topic Amazon Resource Name (ARN) of the infrastructure configuration.
        public let snsTopicArn: String?
        /// The subnet ID of the infrastructure configuration.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure configuration of the infrastructure configuration.
        public let terminateInstanceOnFailure: Bool?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case keyPair = "keyPair"
            case logging = "logging"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case snsTopicArn = "snsTopicArn"
            case subnetId = "subnetId"
            case tags = "tags"
            case terminateInstanceOnFailure = "terminateInstanceOnFailure"
        }
    }

    public struct InfrastructureConfigurationSummary: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case dateCreated = "dateCreated"
            case dateUpdated = "dateUpdated"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct InstanceBlockDeviceMapping: AWSEncodableShape & AWSDecodableShape {

        /// The device to which these mappings apply.
        public let deviceName: String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public let ebs: EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the parent image.
        public let noDevice: String?
        /// Use to manage instance ephemeral devices.
        public let virtualName: String?

        public init(deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try validate(self.deviceName, name: "deviceName", parent: name, max: 1024)
            try validate(self.deviceName, name: "deviceName", parent: name, min: 1)
            try self.ebs?.validate(name: "\(name).ebs")
            try validate(self.noDevice, name: "noDevice", parent: name, max: 0)
            try validate(self.noDevice, name: "noDevice", parent: name, min: 0)
            try validate(self.virtualName, name: "virtualName", parent: name, max: 1024)
            try validate(self.virtualName, name: "virtualName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "deviceName"
            case ebs = "ebs"
            case noDevice = "noDevice"
            case virtualName = "virtualName"
        }
    }

    public struct LaunchPermissionConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// The name of the group. 
        public let userGroups: [String]?
        /// The AWS account ID. 
        public let userIds: [String]?

        public init(userGroups: [String]? = nil, userIds: [String]? = nil) {
            self.userGroups = userGroups
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 1024)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 1024)
                try validate($0, name: "userIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userGroups = "userGroups"
            case userIds = "userIds"
        }
    }

    public struct ListComponentBuildVersionsRequest: AWSEncodableShape {

        /// The component version Amazon Resource Name (ARN) whose versions you want to list. 
        public let componentVersionArn: String
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?

        public init(componentVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.componentVersionArn = componentVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.componentVersionArn, name: "componentVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):component/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionArn = "componentVersionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentBuildVersionsResponse: AWSDecodableShape {

        /// The list of component summaries for the specified semantic version. 
        public let componentSummaryList: [ComponentSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(componentSummaryList: [ComponentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentSummaryList = componentSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentSummaryList = "componentSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?
        /// The owner defines which components you want to list. By default, this request will only show components owned by your account. You can use this field to specify if you want to view components owned by yourself, by Amazon, or those components that have been shared with you by other customers. 
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListComponentsResponse: AWSDecodableShape {

        /// The list of component semantic versions. 
        public let componentVersionList: [ComponentVersion]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(componentVersionList: [ComponentVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentVersionList = componentVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionList = "componentVersionList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListDistributionConfigurationsRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDistributionConfigurationsResponse: AWSDecodableShape {

        /// The list of distributions. 
        public let distributionConfigurationSummaryList: [DistributionConfigurationSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(distributionConfigurationSummaryList: [DistributionConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationSummaryList = "distributionConfigurationSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImageBuildVersionsRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve. 
        public let imageVersionArn: String
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imageVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imageVersionArn = imageVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.imageVersionArn, name: "imageVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case imageVersionArn = "imageVersionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImageBuildVersionsResponse: AWSDecodableShape {

        /// The list of image build versions. 
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList = "imageSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagePipelineImagesRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view. 
        public let imagePipelineArn: String
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imagePipelineArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imagePipelineArn = imagePipelineArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case imagePipelineArn = "imagePipelineArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImagePipelineImagesResponse: AWSDecodableShape {

        /// The list of images built by this pipeline. 
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList = "imageSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagePipelinesRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListImagePipelinesResponse: AWSDecodableShape {

        /// The list of image pipelines. 
        public let imagePipelineList: [ImagePipeline]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imagePipelineList: [ImagePipeline]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePipelineList = imagePipelineList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineList = "imagePipelineList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImageRecipesRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?
        /// The owner defines which image recipes you want to list. By default, this request will only show image recipes owned by your account. You can use this field to specify if you want to view image recipes owned by yourself, by Amazon, or those image recipes that have been shared with you by other customers. 
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListImageRecipesResponse: AWSDecodableShape {

        /// The list of image pipelines. 
        public let imageRecipeSummaryList: [ImageRecipeSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageRecipeSummaryList: [ImageRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageRecipeSummaryList = imageRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeSummaryList = "imageRecipeSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?
        /// The owner defines which images you want to list. By default, this request will only show images owned by your account. You can use this field to specify if you want to view images owned by yourself, by Amazon, or those images that have been shared with you by other customers. 
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owner = "owner"
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {

        /// The list of image semantic versions. 
        public let imageVersionList: [ImageVersion]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects. 
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageVersionList: [ImageVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageVersionList = imageVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersionList = "imageVersionList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListInfrastructureConfigurationsRequest: AWSEncodableShape {

        /// The filters. 
        public let filters: [Filter]?
        /// The maximum items to return in a request. 
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response. 
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.filters, name: "filters", parent: name, max: 10)
            try validate(self.filters, name: "filters", parent: name, min: 1)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListInfrastructureConfigurationsResponse: AWSDecodableShape {

        /// The list of infrastructure configurations. 
        public let infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationSummaryList = "infrastructureConfigurationSummaryList"
            case nextToken = "nextToken"
            case requestId = "requestId"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve. 
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):(?:image-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|\\d+)\\.(?:x|\\d+)\\.(?:x|\\d+))(?:/\\d+)?)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// The tags for the specified resource. 
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon S3 logging configuration.
        public let s3Logs: S3Logs?

        public init(s3Logs: S3Logs? = nil) {
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Logs = "s3Logs"
        }
    }

    public struct OutputResources: AWSDecodableShape {

        /// The EC2 AMIs created by this image. 
        public let amis: [Ami]?

        public init(amis: [Ami]? = nil) {
            self.amis = amis
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
        }
    }

    public struct PutComponentPolicyRequest: AWSEncodableShape {

        /// The Amazon Resource Name (ARN) of the component that this policy should be applied to. 
        public let componentArn: String
        /// The policy to apply. 
        public let policy: String

        public init(componentArn: String, policy: String) {
            self.componentArn = componentArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):component/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
            try validate(self.policy, name: "policy", parent: name, max: 30000)
            try validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case policy = "policy"
        }
    }

    public struct PutComponentPolicyResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the component that this policy was applied to. 
        public let componentArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(componentArn: String? = nil, requestId: String? = nil) {
            self.componentArn = componentArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case requestId = "requestId"
        }
    }

    public struct PutImagePolicyRequest: AWSEncodableShape {

        /// The Amazon Resource Name (ARN) of the image that this policy should be applied to. 
        public let imageArn: String
        /// The policy to apply. 
        public let policy: String

        public init(imageArn: String, policy: String) {
            self.imageArn = imageArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+/\\d+$")
            try validate(self.policy, name: "policy", parent: name, max: 30000)
            try validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn = "imageArn"
            case policy = "policy"
        }
    }

    public struct PutImagePolicyResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image that this policy was applied to. 
        public let imageArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageArn: String? = nil, requestId: String? = nil) {
            self.imageArn = imageArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn = "imageArn"
            case requestId = "requestId"
        }
    }

    public struct PutImageRecipePolicyRequest: AWSEncodableShape {

        /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to. 
        public let imageRecipeArn: String
        /// The policy to apply. 
        public let policy: String

        public init(imageRecipeArn: String, policy: String) {
            self.imageRecipeArn = imageRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
            try validate(self.policy, name: "policy", parent: name, max: 30000)
            try validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn = "imageRecipeArn"
            case policy = "policy"
        }
    }

    public struct PutImageRecipePolicyResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to. 
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn = "imageRecipeArn"
            case requestId = "requestId"
        }
    }

    public struct S3Logs: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon S3 bucket in which to store the logs.
        public let s3BucketName: String?
        /// The Amazon S3 path in which to store the logs.
        public let s3KeyPrefix: String?

        public init(s3BucketName: String? = nil, s3KeyPrefix: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 1024)
            try validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 1024)
            try validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3KeyPrefix = "s3KeyPrefix"
        }
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {

        /// The condition configures when the pipeline should trigger a new image build. When the pipelineExecutionStartCondition is set to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, EC2 Image Builder will build a new image only when there are known changes pending. When it is set to EXPRESSION_MATCH_ONLY, it will build a new image every time the CRON expression matches the current time.
        public let pipelineExecutionStartCondition: PipelineExecutionStartCondition?
        /// The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
        public let scheduleExpression: String?

        public init(pipelineExecutionStartCondition: PipelineExecutionStartCondition? = nil, scheduleExpression: String? = nil) {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
        }

        public func validate(name: String) throws {
            try validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 1024)
            try validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionStartCondition = "pipelineExecutionStartCondition"
            case scheduleExpression = "scheduleExpression"
        }
    }

    public struct StartImagePipelineExecutionRequest: AWSEncodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke. 
        public let imagePipelineArn: String

        public init(clientToken: String = StartImagePipelineExecutionRequest.idempotencyToken(), imagePipelineArn: String) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imagePipelineArn = "imagePipelineArn"
        }
    }

    public struct StartImagePipelineExecutionResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image that was created by this request.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imageBuildVersionArn = "imageBuildVersionArn"
            case requestId = "requestId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to tag. 
        public let resourceArn: String
        /// The tags to apply to the resource. 
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):(?:image-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|\\d+)\\.(?:x|\\d+)\\.(?:x|\\d+))(?:/\\d+)?)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to untag. 
        public let resourceArn: String
        /// The tag keys to remove from the resource. 
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):(?:image-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|\\d+)\\.(?:x|\\d+)\\.(?:x|\\d+))(?:/\\d+)?)?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateDistributionConfigurationRequest: AWSEncodableShape {

        /// The idempotency token of the distribution configuration. 
        public let clientToken: String
        /// The description of the distribution configuration. 
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update. 
        public let distributionConfigurationArn: String
        /// The distributions of the distribution configuration. 
        public let distributions: [Distribution]

        public init(clientToken: String = UpdateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributionConfigurationArn: String, distributions: [Distribution]) {
            self.clientToken = clientToken
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case distributions = "distributions"
        }
    }

    public struct UpdateDistributionConfigurationResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this request. 
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case requestId = "requestId"
        }
    }

    public struct UpdateImagePipelineRequest: AWSEncodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String
        /// The description of the image pipeline. 
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images updated by this image pipeline. 
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default. 
        public let enhancedImageMetadataEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to update. 
        public let imagePipelineArn: String
        /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images updated by this image pipeline. 
        public let imageRecipeArn: String
        /// The image test configuration of the image pipeline. 
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images updated by this image pipeline. 
        public let infrastructureConfigurationArn: String
        /// The schedule of the image pipeline. 
        public let schedule: Schedule?
        /// The status of the image pipeline. 
        public let status: PipelineStatus?

        public init(clientToken: String = UpdateImagePipelineRequest.idempotencyToken(), description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imagePipelineArn: String, imageRecipeArn: String, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, schedule: Schedule? = nil, status: PipelineStatus? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imagePipelineArn = imagePipelineArn
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.schedule = schedule
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):image-recipe/[a-z0-9-_]+/\\d+\\.\\d+\\.\\d+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.schedule?.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case distributionConfigurationArn = "distributionConfigurationArn"
            case enhancedImageMetadataEnabled = "enhancedImageMetadataEnabled"
            case imagePipelineArn = "imagePipelineArn"
            case imageRecipeArn = "imageRecipeArn"
            case imageTestsConfiguration = "imageTestsConfiguration"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case schedule = "schedule"
            case status = "status"
        }
    }

    public struct UpdateImagePipelineResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request. 
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case imagePipelineArn = "imagePipelineArn"
            case requestId = "requestId"
        }
    }

    public struct UpdateInfrastructureConfigurationRequest: AWSEncodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String
        /// The description of the infrastructure configuration. 
        public let description: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to update. 
        public let infrastructureConfigurationArn: String
        /// The instance profile to associate with the instance used to customize your EC2 AMI. 
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability. 
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. This can be used to log on to and debug the instance used to create your image. 
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration. 
        public let logging: Logging?
        /// The security group IDs to associate with the instance used to customize your EC2 AMI. 
        public let securityGroupIds: [String]?
        /// The SNS topic on which to send image build events. 
        public let snsTopicArn: String?
        /// The subnet ID to place the instance used to customize your EC2 AMI in. 
        public let subnetId: String?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails. 
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = UpdateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, infrastructureConfigurationArn: String, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 1024)
            try validate(self.description, name: "description", parent: name, min: 1)
            try validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:\\d{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 1024)
            try validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:\\d{12}:[a-zA-Z0-9-_]{1,256}$")
            try validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try validate(self.subnetId, name: "subnetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case instanceProfileName = "instanceProfileName"
            case instanceTypes = "instanceTypes"
            case keyPair = "keyPair"
            case logging = "logging"
            case securityGroupIds = "securityGroupIds"
            case snsTopicArn = "snsTopicArn"
            case subnetId = "subnetId"
            case terminateInstanceOnFailure = "terminateInstanceOnFailure"
        }
    }

    public struct UpdateInfrastructureConfigurationResponse: AWSDecodableShape {

        /// The idempotency token used to make this request idempotent. 
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by this request. 
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request. 
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case infrastructureConfigurationArn = "infrastructureConfigurationArn"
            case requestId = "requestId"
        }
    }
}
