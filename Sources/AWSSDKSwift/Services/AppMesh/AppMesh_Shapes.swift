//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension AppMesh {
    //MARK: Enums

    public enum DurationUnit: String, CustomStringConvertible, Codable {
        case ms = "ms"
        case s = "s"
        public var description: String { return self.rawValue }
    }

    public enum EgressFilterType: String, CustomStringConvertible, Codable {
        case allowAll = "ALLOW_ALL"
        case dropAll = "DROP_ALL"
        public var description: String { return self.rawValue }
    }

    public enum GrpcRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case cancelled = "cancelled"
        case deadlineExceeded = "deadline-exceeded"
        case `internal` = "internal"
        case resourceExhausted = "resource-exhausted"
        case unavailable = "unavailable"
        public var description: String { return self.rawValue }
    }

    public enum HttpMethod: String, CustomStringConvertible, Codable {
        case connect = "CONNECT"
        case delete = "DELETE"
        case get = "GET"
        case head = "HEAD"
        case options = "OPTIONS"
        case patch = "PATCH"
        case post = "POST"
        case put = "PUT"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public enum HttpScheme: String, CustomStringConvertible, Codable {
        case http = "http"
        case https = "https"
        public var description: String { return self.rawValue }
    }

    public enum ListenerTlsMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum MeshStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum PortProtocol: String, CustomStringConvertible, Codable {
        case grpc = "grpc"
        case http = "http"
        case http2 = "http2"
        case tcp = "tcp"
        public var description: String { return self.rawValue }
    }

    public enum RouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TcpRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case connectionError = "connection-error"
        public var description: String { return self.rawValue }
    }

    public enum VirtualNodeStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualRouterStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualServiceStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AccessLog: AWSEncodableShape & AWSDecodableShape {

        /// The file object to send virtual node access logs to.
        public let file: FileAccessLog?

        public init(file: FileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct AwsCloudMapInstanceAttribute: AWSEncodableShape & AWSDecodableShape {

        /// The name of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
        ///          instance that contains the specified key and value is returned.
        public let key: String
        /// The value of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
        ///          instance that contains the specified key and value is returned.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 255)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.key, name:"key", parent: name, pattern: "^[a-zA-Z0-9!-~]+$")
            try validate(self.value, name:"value", parent: name, max: 1024)
            try validate(self.value, name:"value", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, pattern: "^([a-zA-Z0-9!-~][ ta-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct AwsCloudMapServiceDiscovery: AWSEncodableShape & AWSDecodableShape {

        /// A string map that contains attributes with values that you can use to filter instances
        ///          by any custom attribute that you specified when you registered the instance. Only instances
        ///          that match all of the specified key/value pairs will be returned.
        public let attributes: [AwsCloudMapInstanceAttribute]?
        /// The name of the AWS Cloud Map namespace to use.
        public let namespaceName: String
        /// The name of the AWS Cloud Map service to use.
        public let serviceName: String

        public init(attributes: [AwsCloudMapInstanceAttribute]? = nil, namespaceName: String, serviceName: String) {
            self.attributes = attributes
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try validate(self.namespaceName, name:"namespaceName", parent: name, max: 1024)
            try validate(self.namespaceName, name:"namespaceName", parent: name, min: 1)
            try validate(self.namespaceName, name:"namespaceName", parent: name, pattern: "((?=^.{1,127}$)^([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9])(.([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9]))*$)|(^.$)")
            try validate(self.serviceName, name:"serviceName", parent: name, max: 1024)
            try validate(self.serviceName, name:"serviceName", parent: name, min: 1)
            try validate(self.serviceName, name:"serviceName", parent: name, pattern: "((?=^.{1,127}$)^([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9])(.([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9]))*$)|(^.$)")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case namespaceName = "namespaceName"
            case serviceName = "serviceName"
        }
    }

    public struct Backend: AWSEncodableShape & AWSDecodableShape {

        /// Specifies a virtual service to use as a backend for a virtual node. 
        public let virtualService: VirtualServiceBackend?

        public init(virtualService: VirtualServiceBackend? = nil) {
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.virtualService?.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct BackendDefaults: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents a client policy.
        public let clientPolicy: ClientPolicy?

        public init(clientPolicy: ClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
        }
    }

    public struct ClientPolicy: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: ClientPolicyTls?

        public init(tls: ClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls = "tls"
        }
    }

    public struct ClientPolicyTls: AWSEncodableShape & AWSDecodableShape {

        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public let enforce: Bool?
        /// The range of ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a TLS validation context.
        public let validation: TlsValidationContext

        public init(enforce: Bool? = nil, ports: [Int]? = nil, validation: TlsValidationContext) {
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case enforce = "enforce"
            case ports = "ports"
            case validation = "validation"
        }
    }

    public struct CreateMeshInput: AWSEncodableShape {

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the service mesh.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?
        /// Optional metadata that you can apply to the service mesh to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?

        public init(clientToken: String? = CreateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil, tags: [TagRef]? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"

        /// The full description of your service mesh following the create call.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct CreateRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name to use for the route.
        public let routeName: String
        /// The route specification to apply.
        public let spec: RouteSpec
        /// Optional metadata that you can apply to the route to assist with categorization and
        ///          organization. Each tag consists of a key and an optional value, both of which you define.
        ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual router in which to create the route. If the virtual router is in a shared mesh,
        ///          then you must be the owner of the virtual router resource.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case routeName = "routeName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "route"

        /// The full description of your mesh following the create call.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct CreateVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual node in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The virtual node specification to apply.
        public let spec: VirtualNodeSpec
        /// Optional metadata that you can apply to the virtual node to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual node.
        public let virtualNodeName: String

        public init(clientToken: String? = CreateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, tags: [TagRef]? = nil, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct CreateVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"

        /// The full description of your virtual node following the create call.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct CreateVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual router in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The virtual router specification to apply.
        public let spec: VirtualRouterSpec
        /// Optional metadata that you can apply to the virtual router to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual router.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct CreateVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"

        /// The full description of your virtual router following the create call.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct CreateVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual service in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The virtual service specification to apply.
        public let spec: VirtualServiceSpec
        /// Optional metadata that you can apply to the virtual service to assist with
        ///          categorization and organization. Each tag consists of a key and an optional value, both of
        ///          which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual service.
        public let virtualServiceName: String

        public init(clientToken: String? = CreateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, tags: [TagRef]? = nil, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct CreateVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"

        /// The full description of your virtual service following the create call.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DeleteMeshInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName"))
        ]

        /// The name of the service mesh to delete.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"

        /// The service mesh that was deleted.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DeleteRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "routeName", location: .uri(locationName: "routeName")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh to delete the route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the route to delete.
        public let routeName: String
        /// The name of the virtual router to delete the route in.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "route"

        /// The route that was deleted.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DeleteVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"))
        ]

        /// The name of the service mesh to delete the virtual node in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the virtual node to delete.
        public let virtualNodeName: String

        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"

        /// The virtual node that was deleted.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DeleteVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh to delete the virtual router in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the virtual router to delete.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"

        /// The virtual router that was deleted.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DeleteVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"))
        ]

        /// The name of the service mesh to delete the virtual service in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the virtual service to delete.
        public let virtualServiceName: String

        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"

        /// The virtual service that was deleted.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DescribeMeshInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// The name of the service mesh to describe.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?

        public init(meshName: String, meshOwner: String? = nil) {
            self.meshName = meshName
            self.meshOwner = meshOwner
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"

        /// The full description of your service mesh.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DescribeRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "routeName", location: .uri(locationName: "routeName")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the route to describe.
        public let routeName: String
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "route"

        /// The full description of your route.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DescribeVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"))
        ]

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the virtual node to describe.
        public let virtualNodeName: String

        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"

        /// The full description of your virtual node.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DescribeVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the virtual router to describe.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"

        /// The full description of your virtual router.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DescribeVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"))
        ]

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the virtual service to describe.
        public let virtualServiceName: String

        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"

        /// The full description of your virtual service.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DnsServiceDiscovery: AWSEncodableShape & AWSDecodableShape {

        /// Specifies the DNS service discovery hostname for the virtual node. 
        public let hostname: String

        public init(hostname: String) {
            self.hostname = hostname
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
        }
    }

    public struct Duration: AWSEncodableShape & AWSDecodableShape {

        /// A unit of time.
        public let unit: DurationUnit?
        /// A number of time units.
        public let value: Int64?

        public init(unit: DurationUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct EgressFilter: AWSEncodableShape & AWSDecodableShape {

        /// The egress filter type. By default, the type is DROP_ALL, which allows
        ///          egress only from virtual nodes to other defined resources in the service mesh (and any
        ///          traffic to *.amazonaws.com for AWS API calls). You can set the egress filter
        ///          type to ALLOW_ALL to allow egress to any endpoint inside or outside of the
        ///          service mesh.
        public let `type`: EgressFilterType

        public init(type: EgressFilterType) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct FileAccessLog: AWSEncodableShape & AWSDecodableShape {

        /// The file path to write access logs to. You can use /dev/stdout to send
        ///          access logs to standard out and configure your Envoy container to use a log driver, such as
        ///             awslogs, to export the access logs to a log storage service such as Amazon
        ///          CloudWatch Logs. You can also specify a path in the Envoy container's file system to write
        ///          the files to disk.
        ///          
        ///             The Envoy process must have write permissions to the path that you specify here.
        ///             Otherwise, Envoy fails to bootstrap properly.
        ///          
        public let path: String

        public init(path: String) {
            self.path = path
        }

        public func validate(name: String) throws {
            try validate(self.path, name:"path", parent: name, max: 255)
            try validate(self.path, name:"path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
        }
    }

    public struct GrpcRetryPolicy: AWSEncodableShape & AWSDecodableShape {

        /// Specify at least one of the valid values.
        public let grpcRetryEvents: [GrpcRetryPolicyEvent]?
        /// Specify at least one of the following values.
        ///          
        ///             
        ///                
        ///                   server-error  HTTP status codes 500, 501,
        ///                   502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///             
        ///             
        ///                
        ///                   gateway-error  HTTP status codes 502,
        ///                   503, and 504
        ///             
        ///             
        ///                
        ///                   client-error  HTTP status code 409
        ///             
        ///             
        ///                
        ///                   stream-error  Retry on refused
        ///                   stream
        ///             
        ///          
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// An object that represents a duration of time.
        public let perRetryTimeout: Duration
        /// Specify a valid value.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(grpcRetryEvents: [GrpcRetryPolicyEvent]? = nil, httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.grpcRetryEvents = grpcRetryEvents
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try validate(self.grpcRetryEvents, name:"grpcRetryEvents", parent: name, max: 5)
            try validate(self.grpcRetryEvents, name:"grpcRetryEvents", parent: name, min: 1)
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, max: 25)
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, min: 1)
            try validate(self.maxRetries, name:"maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, max: 1)
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRetryEvents = "grpcRetryEvents"
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct GrpcRoute: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the action to take if a match is determined.
        public let action: GrpcRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: GrpcRetryPolicy?

        public init(action: GrpcRouteAction, match: GrpcRouteMatch, retryPolicy: GrpcRetryPolicy? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
        }
    }

    public struct GrpcRouteAction: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct GrpcRouteMatch: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the data to match from the request.
        public let metadata: [GrpcRouteMetadata]?
        /// The method name to match from the request. If you specify a name, you must also specify a serviceName.
        public let methodName: String?
        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        public init(metadata: [GrpcRouteMetadata]? = nil, methodName: String? = nil, serviceName: String? = nil) {
            self.metadata = metadata
            self.methodName = methodName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try validate(self.metadata, name:"metadata", parent: name, max: 10)
            try validate(self.metadata, name:"metadata", parent: name, min: 1)
            try validate(self.methodName, name:"methodName", parent: name, max: 50)
            try validate(self.methodName, name:"methodName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case methodName = "methodName"
            case serviceName = "serviceName"
        }
    }

    public struct GrpcRouteMetadata: AWSEncodableShape & AWSDecodableShape {

        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// An object that represents the data to match from the request.
        public let match: GrpcRouteMetadataMatchMethod?
        /// The name of the route.
        public let name: String

        public init(invert: Bool? = nil, match: GrpcRouteMetadataMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try validate(self.name, name:"name", parent: name, max: 50)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct GrpcRouteMetadataMatchMethod: AWSEncodableShape & AWSDecodableShape {

        /// The value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// An object that represents the range of values to match on.
        public let range: MatchRange?
        /// The value sent by the client must include the specified characters.
        public let regex: String?
        /// The value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try validate(self.exact, name:"exact", parent: name, max: 255)
            try validate(self.exact, name:"exact", parent: name, min: 1)
            try validate(self.prefix, name:"prefix", parent: name, max: 255)
            try validate(self.prefix, name:"prefix", parent: name, min: 1)
            try validate(self.regex, name:"regex", parent: name, max: 255)
            try validate(self.regex, name:"regex", parent: name, min: 1)
            try validate(self.suffix, name:"suffix", parent: name, max: 255)
            try validate(self.suffix, name:"suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public struct HeaderMatchMethod: AWSEncodableShape & AWSDecodableShape {

        /// The value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// An object that represents the range of values to match on.
        public let range: MatchRange?
        /// The value sent by the client must include the specified characters.
        public let regex: String?
        /// The value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try validate(self.exact, name:"exact", parent: name, max: 255)
            try validate(self.exact, name:"exact", parent: name, min: 1)
            try validate(self.prefix, name:"prefix", parent: name, max: 255)
            try validate(self.prefix, name:"prefix", parent: name, min: 1)
            try validate(self.regex, name:"regex", parent: name, max: 255)
            try validate(self.regex, name:"regex", parent: name, min: 1)
            try validate(self.suffix, name:"suffix", parent: name, max: 255)
            try validate(self.suffix, name:"suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public struct HealthCheckPolicy: AWSEncodableShape & AWSDecodableShape {

        /// The number of consecutive successful health checks that must occur before declaring
        ///          listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the specified 
        ///          protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined
        ///          in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the GRPC Health Checking Protocol.
        public let `protocol`: PortProtocol
        /// The amount of time to wait when receiving a response from the health check, in
        ///          milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a
        ///          virtual node unhealthy. 
        public let unhealthyThreshold: Int

        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: PortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, max: 10)
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, min: 2)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, max: 300000)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, min: 5000)
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, max: 60000)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, min: 2000)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, max: 10)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "healthyThreshold"
            case intervalMillis = "intervalMillis"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case timeoutMillis = "timeoutMillis"
            case unhealthyThreshold = "unhealthyThreshold"
        }
    }

    public struct HttpRetryPolicy: AWSEncodableShape & AWSDecodableShape {

        /// Specify at least one of the following values.
        ///          
        ///             
        ///                
        ///                   server-error  HTTP status codes 500, 501,
        ///                   502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///             
        ///             
        ///                
        ///                   gateway-error  HTTP status codes 502,
        ///                   503, and 504
        ///             
        ///             
        ///                
        ///                   client-error  HTTP status code 409
        ///             
        ///             
        ///                
        ///                   stream-error  Retry on refused
        ///                   stream
        ///             
        ///          
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// An object that represents a duration of time.
        public let perRetryTimeout: Duration
        /// Specify a valid value.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, max: 25)
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, min: 1)
            try validate(self.maxRetries, name:"maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, max: 1)
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct HttpRoute: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the action to take if a match is determined.
        public let action: HttpRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: HttpRetryPolicy?

        public init(action: HttpRouteAction, match: HttpRouteMatch, retryPolicy: HttpRetryPolicy? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
        }
    }

    public struct HttpRouteAction: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct HttpRouteHeader: AWSEncodableShape & AWSDecodableShape {

        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// The HeaderMatchMethod object.
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        public let name: String

        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try validate(self.name, name:"name", parent: name, max: 50)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct HttpRouteMatch: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the client request headers to match on.
        public let headers: [HttpRouteHeader]?
        /// The client request method to match on. Specify only one.
        public let method: HttpMethod?
        /// Specifies the path to match requests with. This parameter must always start with
        ///             /, which by itself matches all requests to the virtual service name. You
        ///          can also match for path-based routing of requests. For example, if your virtual service
        ///          name is my-service.local and you want the route to match requests to
        ///             my-service.local/metrics, your prefix should be
        ///          /metrics.
        public let prefix: String
        /// The client request scheme to match on. Specify only one.
        public let scheme: HttpScheme?

        public init(headers: [HttpRouteHeader]? = nil, method: HttpMethod? = nil, prefix: String, scheme: HttpScheme? = nil) {
            self.headers = headers
            self.method = method
            self.prefix = prefix
            self.scheme = scheme
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try validate(self.headers, name:"headers", parent: name, max: 10)
            try validate(self.headers, name:"headers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers = "headers"
            case method = "method"
            case prefix = "prefix"
            case scheme = "scheme"
        }
    }

    public struct ListMeshesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListMeshes in paginated output.
        ///          When you use this parameter, ListMeshes returns only limit
        ///          results in a single page along with a nextToken response element. You can see
        ///          the remaining results of the initial request by sending another ListMeshes
        ///          request with the returned nextToken value. This value can be between
        ///          1 and 100. If you don't use this parameter,
        ///             ListMeshes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated
        ///             ListMeshes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value. 
        ///          
        ///             This token should be treated as an opaque identifier that is used only to
        ///                 retrieve the next items in a list and not for other programmatic purposes.
        ///         
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMeshesOutput: AWSDecodableShape {

        /// The list of existing service meshes.
        public let meshes: [MeshRef]
        /// The nextToken value to include in a future ListMeshes request.
        ///          When the results of a ListMeshes request exceed limit, you can
        ///          use this value to retrieve the next page of results. This value is null when
        ///          there are no more results to return.
        public let nextToken: String?

        public init(meshes: [MeshRef], nextToken: String? = nil) {
            self.meshes = meshes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshes = "meshes"
            case nextToken = "nextToken"
        }
    }

    public struct ListRoutesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")), 
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The maximum number of results returned by ListRoutes in paginated output.
        ///          When you use this parameter, ListRoutes returns only limit
        ///          results in a single page along with a nextToken response element. You can see
        ///          the remaining results of the initial request by sending another ListRoutes
        ///          request with the returned nextToken value. This value can be between
        ///          1 and 100. If you don't use this parameter,
        ///             ListRoutes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list routes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListRoutes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual router to list routes in.
        public let virtualRouterName: String

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualRouterName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutesOutput: AWSDecodableShape {

        /// The nextToken value to include in a future ListRoutes request.
        ///          When the results of a ListRoutes request exceed limit, you can
        ///          use this value to retrieve the next page of results. This value is null when
        ///          there are no more results to return.
        public let nextToken: String?
        /// The list of existing routes for the specified service mesh and virtual router.
        public let routes: [RouteRef]

        public init(nextToken: String? = nil, routes: [RouteRef]) {
            self.nextToken = nextToken
            self.routes = routes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case routes = "routes"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The maximum number of tag results returned by ListTagsForResource in
        ///          paginated output. When this parameter is used, ListTagsForResource returns
        ///          only limit results in a single page along with a nextToken
        ///          response element. You can see the remaining results of the initial request by sending
        ///          another ListTagsForResource request with the returned nextToken
        ///          value. This value can be between 1 and 100. If you don't use
        ///          this parameter, ListTagsForResource returns up to 100
        ///          results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated
        ///             ListTagsForResource request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
        public let resourceArn: String

        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 50)
            try validate(self.limit, name:"limit", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {

        /// The nextToken value to include in a future ListTagsForResource
        ///          request. When the results of a ListTagsForResource request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [TagRef]

        public init(nextToken: String? = nil, tags: [TagRef]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct ListVirtualNodesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")), 
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualNodes in paginated
        ///          output. When you use this parameter, ListVirtualNodes returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualNodes request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualNodes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual nodes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualNodes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualNodesOutput: AWSDecodableShape {

        /// The nextToken value to include in a future ListVirtualNodes
        ///          request. When the results of a ListVirtualNodes request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual nodes for the specified service mesh.
        public let virtualNodes: [VirtualNodeRef]

        public init(nextToken: String? = nil, virtualNodes: [VirtualNodeRef]) {
            self.nextToken = nextToken
            self.virtualNodes = virtualNodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualNodes = "virtualNodes"
        }
    }

    public struct ListVirtualRoutersInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")), 
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualRouters in paginated
        ///          output. When you use this parameter, ListVirtualRouters returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualRouters request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualRouters returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual routers in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualRouters request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualRoutersOutput: AWSDecodableShape {

        /// The nextToken value to include in a future ListVirtualRouters
        ///          request. When the results of a ListVirtualRouters request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual routers for the specified service mesh.
        public let virtualRouters: [VirtualRouterRef]

        public init(nextToken: String? = nil, virtualRouters: [VirtualRouterRef]) {
            self.nextToken = nextToken
            self.virtualRouters = virtualRouters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualRouters = "virtualRouters"
        }
    }

    public struct ListVirtualServicesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")), 
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualServices in paginated
        ///          output. When you use this parameter, ListVirtualServices returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualServices request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualServices returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual services in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualServices request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualServicesOutput: AWSDecodableShape {

        /// The nextToken value to include in a future ListVirtualServices
        ///          request. When the results of a ListVirtualServices request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual services for the specified service mesh.
        public let virtualServices: [VirtualServiceRef]

        public init(nextToken: String? = nil, virtualServices: [VirtualServiceRef]) {
            self.nextToken = nextToken
            self.virtualServices = virtualServices
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualServices = "virtualServices"
        }
    }

    public struct Listener: AWSEncodableShape & AWSDecodableShape {

        /// The health check information for the listener.
        public let healthCheck: HealthCheckPolicy?
        /// The port mapping information for the listener.
        public let portMapping: PortMapping
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.
        public let tls: ListenerTls?

        public init(healthCheck: HealthCheckPolicy? = nil, portMapping: PortMapping, tls: ListenerTls? = nil) {
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
            case portMapping = "portMapping"
            case tls = "tls"
        }
    }

    public struct ListenerTls: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents a listener's TLS certificate.
        public let certificate: ListenerTlsCertificate
        /// Specify one of the following modes.
        ///          
        ///             
        ///                
        ///                   STRICT  Listener only accepts connections with TLS enabled. 
        ///             
        ///             
        ///                
        ///                   PERMISSIVE  Listener accepts connections with or without TLS enabled.
        ///             
        ///             
        ///                
        ///                   DISABLED   Listener only accepts connections without TLS. 
        ///             
        ///          
        public let mode: ListenerTlsMode

        public init(certificate: ListenerTlsCertificate, mode: ListenerTlsMode) {
            self.certificate = certificate
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case mode = "mode"
        }
    }

    public struct ListenerTlsAcmCertificate: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct ListenerTlsCertificate: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents an AWS Certicate Manager (ACM) certificate.
        public let acm: ListenerTlsAcmCertificate?
        /// A reference to an object that represents a local file certificate.
        public let file: ListenerTlsFileCertificate?

        public init(acm: ListenerTlsAcmCertificate? = nil, file: ListenerTlsFileCertificate? = nil) {
            self.acm = acm
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
        }
    }

    public struct ListenerTlsFileCertificate: AWSEncodableShape & AWSDecodableShape {

        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let privateKey: String

        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try validate(self.certificateChain, name:"certificateChain", parent: name, max: 255)
            try validate(self.certificateChain, name:"certificateChain", parent: name, min: 1)
            try validate(self.privateKey, name:"privateKey", parent: name, max: 255)
            try validate(self.privateKey, name:"privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
            case privateKey = "privateKey"
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {

        /// The access log configuration for a virtual node.
        public let accessLog: AccessLog?

        public init(accessLog: AccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "accessLog"
        }
    }

    public struct MatchRange: AWSEncodableShape & AWSDecodableShape {

        /// The end of the range.
        public let end: Int64
        /// The start of the range.
        public let start: Int64

        public init(end: Int64, start: Int64) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct MeshData: AWSDecodableShape {

        /// The name of the service mesh.
        public let meshName: String
        /// The associated metadata for the service mesh.
        public let metadata: ResourceMetadata
        /// The associated specification for the service mesh.
        public let spec: MeshSpec
        /// The status of the service mesh.
        public let status: MeshStatus

        public init(meshName: String, metadata: ResourceMetadata, spec: MeshSpec, status: MeshStatus) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
        }
    }

    public struct MeshRef: AWSDecodableShape {

        /// The full Amazon Resource Name (ARN) of the service mesh.
        public let arn: String
        /// The name of the service mesh.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner, or another account that the mesh is shared with. For more information about mesh sharing, see Working with Shared Meshes.
        public let resourceOwner: String

        public init(arn: String, meshName: String, meshOwner: String, resourceOwner: String) {
            self.arn = arn
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
        }
    }

    public struct MeshSpec: AWSEncodableShape & AWSDecodableShape {

        /// The egress filter rules for the service mesh.
        public let egressFilter: EgressFilter?

        public init(egressFilter: EgressFilter? = nil) {
            self.egressFilter = egressFilter
        }

        private enum CodingKeys: String, CodingKey {
            case egressFilter = "egressFilter"
        }
    }

    public struct MeshStatus: AWSDecodableShape {

        /// The current mesh status.
        public let status: MeshStatusCode?

        public init(status: MeshStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct PortMapping: AWSEncodableShape & AWSDecodableShape {

        /// The port used for the port mapping.
        public let port: Int
        /// The protocol used for the port mapping. Specify one protocol.
        public let `protocol`: PortProtocol

        public init(port: Int, protocol: PortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct ResourceMetadata: AWSDecodableShape {

        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner, or another account that the mesh is shared with. For more information about mesh sharing, see Working with Shared Meshes.
        public let resourceOwner: String
        /// The unique identifier for the resource.
        public let uid: String
        /// The version of the resource. Resources are created at version 1, and this version is
        ///          incremented each time that they're updated.
        public let version: Int64

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshOwner: String, resourceOwner: String, uid: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.uid = uid
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case uid = "uid"
            case version = "version"
        }
    }

    public struct RouteData: AWSDecodableShape {

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The associated metadata for the route.
        public let metadata: ResourceMetadata
        /// The name of the route.
        public let routeName: String
        /// The specifications of the route.
        public let spec: RouteSpec
        /// The status of the route.
        public let status: RouteStatus
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, routeName: String, spec: RouteSpec, status: RouteStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case routeName = "routeName"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteRef: AWSDecodableShape {

        /// The full Amazon Resource Name (ARN) for the route.
        public let arn: String
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner, or another account that the mesh is shared with. For more information about mesh sharing, see Working with Shared Meshes.
        public let resourceOwner: String
        /// The name of the route.
        public let routeName: String
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(arn: String, meshName: String, meshOwner: String, resourceOwner: String, routeName: String, virtualRouterName: String) {
            self.arn = arn
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteSpec: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the specification of a gRPC route.
        public let grpcRoute: GrpcRoute?
        /// An object that represents the specification of an HTTP/2 route.
        public let http2Route: HttpRoute?
        /// An object that represents the specification of an HTTP route.
        public let httpRoute: HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is
        ///          the highest priority.
        public let priority: Int?
        /// An object that represents the specification of a TCP route.
        public let tcpRoute: TcpRoute?

        public init(grpcRoute: GrpcRoute? = nil, http2Route: HttpRoute? = nil, httpRoute: HttpRoute? = nil, priority: Int? = nil, tcpRoute: TcpRoute? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try validate(self.priority, name:"priority", parent: name, max: 1000)
            try validate(self.priority, name:"priority", parent: name, min: 0)
            try self.tcpRoute?.validate(name: "\(name).tcpRoute")
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute = "grpcRoute"
            case http2Route = "http2Route"
            case httpRoute = "httpRoute"
            case priority = "priority"
            case tcpRoute = "tcpRoute"
        }
    }

    public struct RouteStatus: AWSDecodableShape {

        /// The current status for the route.
        public let status: RouteStatusCode

        public init(status: RouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ServiceDiscovery: AWSEncodableShape & AWSDecodableShape {

        /// Specifies any AWS Cloud Map information for the virtual node.
        public let awsCloudMap: AwsCloudMapServiceDiscovery?
        /// Specifies the DNS information for the virtual node.
        public let dns: DnsServiceDiscovery?

        public init(awsCloudMap: AwsCloudMapServiceDiscovery? = nil, dns: DnsServiceDiscovery? = nil) {
            self.awsCloudMap = awsCloudMap
            self.dns = dns
        }

        public func validate(name: String) throws {
            try self.awsCloudMap?.validate(name: "\(name).awsCloudMap")
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudMap = "awsCloudMap"
            case dns = "dns"
        }
    }

    public struct TagRef: AWSEncodableShape & AWSDecodableShape {

        /// One part of a key-value pair that make up a tag. A key is a general label
        ///          that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that make up a tag. A value acts as a
        ///          descriptor within a tag category (key).
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 128)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to add tags to.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs.
        ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]

        public init(resourceArn: String, tags: [TagRef]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct TcpRoute: AWSEncodableShape & AWSDecodableShape {

        /// The action to take if a match is determined.
        public let action: TcpRouteAction

        public init(action: TcpRouteAction) {
            self.action = action
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
        }
    }

    public struct TcpRouteAction: AWSEncodableShape & AWSDecodableShape {

        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct TlsValidationContext: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents a TLS validation context trust.
        public let trust: TlsValidationContextTrust

        public init(trust: TlsValidationContextTrust) {
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case trust = "trust"
        }
    }

    public struct TlsValidationContextAcmTrust: AWSEncodableShape & AWSDecodableShape {

        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try validate(self.certificateAuthorityArns, name:"certificateAuthorityArns", parent: name, max: 3)
            try validate(self.certificateAuthorityArns, name:"certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns = "certificateAuthorityArns"
        }
    }

    public struct TlsValidationContextFileTrust: AWSEncodableShape & AWSDecodableShape {

        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let certificateChain: String

        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try validate(self.certificateChain, name:"certificateChain", parent: name, max: 255)
            try validate(self.certificateChain, name:"certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
        }
    }

    public struct TlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents a TLS validation context trust for an AWS Certicate Manager (ACM) certificate.
        public let acm: TlsValidationContextAcmTrust?
        /// An object that represents a TLS validation context trust for a local file.
        public let file: TlsValidationContextFileTrust?

        public init(acm: TlsValidationContextAcmTrust? = nil, file: TlsValidationContextFileTrust? = nil) {
            self.acm = acm
            self.file = file
        }

        public func validate(name: String) throws {
            try self.acm?.validate(name: "\(name).acm")
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to delete tags from.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateMeshInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to update.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?

        public init(clientToken: String? = UpdateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"

        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct UpdateRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "routeName", location: .uri(locationName: "routeName")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The name of the route to update.
        public let routeName: String
        /// The new route specification to apply. This overwrites the existing data.
        public let spec: RouteSpec
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "route"

        /// A full description of the route that was updated.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct UpdateVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The new virtual node specification to apply. This overwrites the existing data.
        public let spec: VirtualNodeSpec
        /// The name of the virtual node to update.
        public let virtualNodeName: String

        public init(clientToken: String? = UpdateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"

        /// A full description of the virtual node that was updated.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct UpdateVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The new virtual router specification to apply. This overwrites the existing data.
        public let spec: VirtualRouterSpec
        /// The name of the virtual router to update.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"

        /// A full description of the virtual router that was updated.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct UpdateVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")), 
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")), 
            AWSMemberEncoding(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String?
        /// The new virtual service specification to apply. This overwrites the existing
        ///          data.
        public let spec: VirtualServiceSpec
        /// The name of the virtual service to update.
        public let virtualServiceName: String

        public init(clientToken: String? = UpdateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"

        /// A full description of the virtual service that was updated.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct VirtualNodeData: AWSDecodableShape {

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The associated metadata for the virtual node.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual node.
        public let spec: VirtualNodeSpec
        /// The current status for the virtual node.
        public let status: VirtualNodeStatus
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualNodeSpec, status: VirtualNodeStatus, virtualNodeName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeRef: AWSDecodableShape {

        /// The full Amazon Resource Name (ARN) for the virtual node.
        public let arn: String
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner, or another account that the mesh is shared with. For more information about mesh sharing, see Working with Shared Meshes.
        public let resourceOwner: String
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(arn: String, meshName: String, meshOwner: String, resourceOwner: String, virtualNodeName: String) {
            self.arn = arn
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeServiceProvider: AWSEncodableShape & AWSDecodableShape {

        /// The name of the virtual node that is acting as a service provider.
        public let virtualNodeName: String

        public init(virtualNodeName: String) {
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeSpec: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: BackendDefaults?
        /// The backends that the virtual node is expected to send outbound traffic to.
        public let backends: [Backend]?
        /// The listener that the virtual node is expected to receive inbound traffic from.
        ///          You can specify one listener.
        public let listeners: [Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public let logging: Logging?
        /// The service discovery information for the virtual node. If your virtual node does not
        ///          expect ingress traffic, you can omit this parameter. If you specify a listener,
        ///          then you must specify service discovery information.
        public let serviceDiscovery: ServiceDiscovery?

        public init(backendDefaults: BackendDefaults? = nil, backends: [Backend]? = nil, listeners: [Listener]? = nil, logging: Logging? = nil, serviceDiscovery: ServiceDiscovery? = nil) {
            self.backendDefaults = backendDefaults
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.backends?.forEach {
                try $0.validate(name: "\(name).backends[]")
            }
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 0)
            try self.logging?.validate(name: "\(name).logging")
            try self.serviceDiscovery?.validate(name: "\(name).serviceDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults = "backendDefaults"
            case backends = "backends"
            case listeners = "listeners"
            case logging = "logging"
            case serviceDiscovery = "serviceDiscovery"
        }
    }

    public struct VirtualNodeStatus: AWSDecodableShape {

        /// The current status of the virtual node.
        public let status: VirtualNodeStatusCode

        public init(status: VirtualNodeStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualRouterData: AWSDecodableShape {

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The associated metadata for the virtual router.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual router.
        public let spec: VirtualRouterSpec
        /// The current status of the virtual router.
        public let status: VirtualRouterStatus
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualRouterSpec, status: VirtualRouterStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterListener: AWSEncodableShape & AWSDecodableShape {

        public let portMapping: PortMapping

        public init(portMapping: PortMapping) {
            self.portMapping = portMapping
        }

        public func validate(name: String) throws {
            try self.portMapping.validate(name: "\(name).portMapping")
        }

        private enum CodingKeys: String, CodingKey {
            case portMapping = "portMapping"
        }
    }

    public struct VirtualRouterRef: AWSDecodableShape {

        /// The full Amazon Resource Name (ARN) for the virtual router.
        public let arn: String
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner, or another account that the mesh is shared with. For more information about mesh sharing, see Working with Shared Meshes.
        public let resourceOwner: String
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(arn: String, meshName: String, meshOwner: String, resourceOwner: String, virtualRouterName: String) {
            self.arn = arn
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterServiceProvider: AWSEncodableShape & AWSDecodableShape {

        /// The name of the virtual router that is acting as a service provider.
        public let virtualRouterName: String

        public init(virtualRouterName: String) {
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterSpec: AWSEncodableShape & AWSDecodableShape {

        /// The listeners that the virtual router is expected to receive inbound traffic from.
        ///          You can specify one listener.
        public let listeners: [VirtualRouterListener]?

        public init(listeners: [VirtualRouterListener]? = nil) {
            self.listeners = listeners
        }

        public func validate(name: String) throws {
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "listeners"
        }
    }

    public struct VirtualRouterStatus: AWSDecodableShape {

        /// The current status of the virtual router.
        public let status: VirtualRouterStatusCode

        public init(status: VirtualRouterStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualServiceBackend: AWSEncodableShape & AWSDecodableShape {

        /// A reference to an object that represents the client policy for a backend.
        public let clientPolicy: ClientPolicy?
        /// The name of the virtual service that is acting as a virtual node backend.
        public let virtualServiceName: String

        public init(clientPolicy: ClientPolicy? = nil, virtualServiceName: String) {
            self.clientPolicy = clientPolicy
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceData: AWSDecodableShape {

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual service.
        public let spec: VirtualServiceSpec
        /// The current status of the virtual service.
        public let status: VirtualServiceStatus
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualServiceSpec, status: VirtualServiceStatus, virtualServiceName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceProvider: AWSEncodableShape & AWSDecodableShape {

        /// The virtual node associated with a virtual service.
        public let virtualNode: VirtualNodeServiceProvider?
        /// The virtual router associated with a virtual service.
        public let virtualRouter: VirtualRouterServiceProvider?

        public init(virtualNode: VirtualNodeServiceProvider? = nil, virtualRouter: VirtualRouterServiceProvider? = nil) {
            self.virtualNode = virtualNode
            self.virtualRouter = virtualRouter
        }

        public func validate(name: String) throws {
            try self.virtualNode?.validate(name: "\(name).virtualNode")
            try self.virtualRouter?.validate(name: "\(name).virtualRouter")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case virtualRouter = "virtualRouter"
        }
    }

    public struct VirtualServiceRef: AWSDecodableShape {

        /// The full Amazon Resource Name (ARN) for the virtual service.
        public let arn: String
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with Shared Meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner, or another account that the mesh is shared with. For more information about mesh sharing, see Working with Shared Meshes.
        public let resourceOwner: String
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(arn: String, meshName: String, meshOwner: String, resourceOwner: String, virtualServiceName: String) {
            self.arn = arn
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceSpec: AWSEncodableShape & AWSDecodableShape {

        /// The App Mesh object that is acting as the provider for a virtual service. You can specify
        ///          a single virtual node or virtual router.
        public let provider: VirtualServiceProvider?

        public init(provider: VirtualServiceProvider? = nil) {
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.provider?.validate(name: "\(name).provider")
        }

        private enum CodingKeys: String, CodingKey {
            case provider = "provider"
        }
    }

    public struct VirtualServiceStatus: AWSDecodableShape {

        /// The current status of the virtual service.
        public let status: VirtualServiceStatusCode

        public init(status: VirtualServiceStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct WeightedTarget: AWSEncodableShape & AWSDecodableShape {

        /// The virtual node to associate with the weighted target.
        public let virtualNode: String
        /// The relative weight of the weighted target.
        public let weight: Int

        public init(virtualNode: String, weight: Int) {
            self.virtualNode = virtualNode
            self.weight = weight
        }

        public func validate(name: String) throws {
            try validate(self.virtualNode, name:"virtualNode", parent: name, max: 255)
            try validate(self.virtualNode, name:"virtualNode", parent: name, min: 1)
            try validate(self.weight, name:"weight", parent: name, max: 100)
            try validate(self.weight, name:"weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case weight = "weight"
        }
    }
}
