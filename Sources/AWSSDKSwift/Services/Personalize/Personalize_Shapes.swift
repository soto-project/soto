// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Personalize {

    public struct Algorithm: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "algorithmImage", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultHyperParameterRanges", required: false, type: .structure), 
            AWSShapeMember(label: "defaultHyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "defaultResourceConfig", required: false, type: .map), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "trainingInputMode", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String?
        /// The URI of the Docker container for the algorithm image.
        public let algorithmImage: AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public let creationDateTime: TimeStamp?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public let defaultHyperParameterRanges: DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public let defaultHyperParameters: [String: String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public let defaultResourceConfig: [String: String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the algorithm.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String?
        /// The training input mode.
        public let trainingInputMode: String?

        public init(algorithmArn: String? = nil, algorithmImage: AlgorithmImage? = nil, creationDateTime: TimeStamp? = nil, defaultHyperParameterRanges: DefaultHyperParameterRanges? = nil, defaultHyperParameters: [String: String]? = nil, defaultResourceConfig: [String: String]? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, roleArn: String? = nil, trainingInputMode: String? = nil) {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }

        public func validate() throws {
            try validate(algorithmArn, name:"algorithmArn", max: 256)
            try validate(algorithmArn, name:"algorithmArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try algorithmImage?.validate()
            try defaultHyperParameterRanges?.validate()
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(roleArn, name:"roleArn", max: 256)
            try validate(roleArn, name:"roleArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(trainingInputMode, name:"trainingInputMode", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
            case algorithmImage = "algorithmImage"
            case creationDateTime = "creationDateTime"
            case defaultHyperParameterRanges = "defaultHyperParameterRanges"
            case defaultHyperParameters = "defaultHyperParameters"
            case defaultResourceConfig = "defaultResourceConfig"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case roleArn = "roleArn"
            case trainingInputMode = "trainingInputMode"
        }
    }

    public struct AlgorithmImage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dockerURI", required: true, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The URI of the Docker container for the algorithm image.
        public let dockerURI: String
        /// The name of the algorithm image.
        public let name: String?

        public init(dockerURI: String, name: String? = nil) {
            self.dockerURI = dockerURI
            self.name = name
        }

        public func validate() throws {
            try validate(dockerURI, name:"dockerURI", max: 256)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case dockerURI = "dockerURI"
            case name = "name"
        }
    }

    public struct AutoMLConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metricName", required: false, type: .string), 
            AWSShapeMember(label: "recipeList", required: false, type: .list)
        ]

        /// The metric to optimize.
        public let metricName: String?
        /// The list of candidate recipes.
        public let recipeList: [String]?

        public init(metricName: String? = nil, recipeList: [String]? = nil) {
            self.metricName = metricName
            self.recipeList = recipeList
        }

        public func validate() throws {
            try validate(metricName, name:"metricName", max: 256)
            try recipeList?.forEach {
                try validate($0, name:"recipeList[]", max: 256)
                try validate($0, name:"recipeList[]", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            }
            try validate(recipeList, name:"recipeList", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "metricName"
            case recipeList = "recipeList"
        }
    }

    public struct AutoMLResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bestRecipeArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the best recipe.
        public let bestRecipeArn: String?

        public init(bestRecipeArn: String? = nil) {
            self.bestRecipeArn = bestRecipeArn
        }

        public func validate() throws {
            try validate(bestRecipeArn, name:"bestRecipeArn", max: 256)
            try validate(bestRecipeArn, name:"bestRecipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case bestRecipeArn = "bestRecipeArn"
        }
    }

    public struct Campaign: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "latestCampaignUpdate", required: false, type: .structure), 
            AWSShapeMember(label: "minProvisionedTPS", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign. 
        public let campaignArn: String?
        /// The date and time (in Unix format) that the campaign was created.
        public let creationDateTime: TimeStamp?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        public let latestCampaignUpdate: CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second.
        public let minProvisionedTPS: Int32?
        /// The name of the campaign.
        public let name: String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public let solutionVersionArn: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(campaignArn: String? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, latestCampaignUpdate: CampaignUpdateSummary? = nil, minProvisionedTPS: Int32? = nil, name: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try latestCampaignUpdate?.validate()
            try validate(minProvisionedTPS, name:"minProvisionedTPS", min: 1)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestCampaignUpdate = "latestCampaignUpdate"
            case minProvisionedTPS = "minProvisionedTPS"
            case name = "name"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct CampaignSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?
        /// The date and time (in Unix time) that the campaign was created.
        public let creationDateTime: TimeStamp?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the campaign.
        public let name: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(campaignArn: String? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct CampaignUpdateSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "minProvisionedTPS", required: false, type: .integer), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the campaign update was created.
        public let creationDateTime: TimeStamp?
        /// If a campaign update fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int32?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public let solutionVersionArn: String?
        /// The status of the campaign update. A campaign update can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, minProvisionedTPS: Int32? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        public func validate() throws {
            try validate(minProvisionedTPS, name:"minProvisionedTPS", min: 1)
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case minProvisionedTPS = "minProvisionedTPS"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct CategoricalHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "values", required: false, type: .list)
        ]

        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate() throws {
            try validate(name, name:"name", max: 256)
            try values?.forEach {
                try validate($0, name:"values[]", max: 1000)
            }
            try validate(values, name:"values", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct ContinuousHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxValue", required: false, type: .double), 
            AWSShapeMember(label: "minValue", required: false, type: .double), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate() throws {
            try validate(maxValue, name:"maxValue", min: -1000000)
            try validate(minValue, name:"minValue", min: -1000000)
            try validate(name, name:"name", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct CreateCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "minProvisionedTPS", required: true, type: .integer), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int32
        /// A name for the new campaign. The campaign name must be unique within your account.
        public let name: String
        /// The Amazon Resource Name (ARN) of the solution version to deploy.
        public let solutionVersionArn: String

        public init(minProvisionedTPS: Int32, name: String, solutionVersionArn: String) {
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate() throws {
            try validate(minProvisionedTPS, name:"minProvisionedTPS", min: 1)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case minProvisionedTPS = "minProvisionedTPS"
            case name = "name"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct CreateCampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct CreateDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "kmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of a KMS key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The name for the new dataset group.
        public let name: String
        /// The ARN of the IAM role that has permissions to access the KMS key. Supplying an IAM role is only valid when also specifying a KMS key.
        public let roleArn: String?

        public init(kmsKeyArn: String? = nil, name: String, roleArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.roleArn = roleArn
        }

        public func validate() throws {
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(roleArn, name:"roleArn", max: 256)
            try validate(roleArn, name:"roleArn", pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case roleArn = "roleArn"
        }
    }

    public struct CreateDatasetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the new dataset group.
        public let datasetGroupArn: String?

        public init(datasetGroupArn: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct CreateDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: true, type: .string), 
            AWSShapeMember(label: "dataSource", required: true, type: .structure), 
            AWSShapeMember(label: "jobName", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string)
        ]

        /// The ARN of the dataset that receives the imported data.
        public let datasetArn: String
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource
        /// The name for the dataset import job.
        public let jobName: String
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String

        public init(datasetArn: String, dataSource: DataSource, jobName: String, roleArn: String) {
            self.datasetArn = datasetArn
            self.dataSource = dataSource
            self.jobName = jobName
            self.roleArn = roleArn
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try dataSource.validate()
            try validate(jobName, name:"jobName", max: 63)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(roleArn, name:"roleArn", max: 256)
            try validate(roleArn, name:"roleArn", pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case dataSource = "dataSource"
            case jobName = "jobName"
            case roleArn = "roleArn"
        }
    }

    public struct CreateDatasetImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJobArn", required: false, type: .string)
        ]

        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate() throws {
            try validate(datasetImportJobArn, name:"datasetImportJobArn", max: 256)
            try validate(datasetImportJobArn, name:"datasetImportJobArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "datasetImportJobArn"
        }
    }

    public struct CreateDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "datasetType", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "schemaArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
        public let datasetGroupArn: String
        /// The type of dataset. One of the following (case insensitive) values:   Interactions   Items   Users  
        public let datasetType: String
        /// The name for the dataset.
        public let name: String
        /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
        public let schemaArn: String

        public init(datasetGroupArn: String, datasetType: String, name: String, schemaArn: String) {
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.name = name
            self.schemaArn = schemaArn
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(datasetType, name:"datasetType", max: 256)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case datasetType = "datasetType"
            case name = "name"
            case schemaArn = "schemaArn"
        }
    }

    public struct CreateDatasetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: false, type: .string)
        ]

        /// The ARN of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct CreateEventTrackerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String
        /// The name for the event tracker.
        public let name: String

        public init(datasetGroupArn: String, name: String) {
            self.datasetGroupArn = datasetGroupArn
            self.name = name
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case name = "name"
        }
    }

    public struct CreateEventTrackerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackerArn", required: false, type: .string), 
            AWSShapeMember(label: "trackingId", required: false, type: .string)
        ]

        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(eventTrackerArn: String? = nil, trackingId: String? = nil) {
            self.eventTrackerArn = eventTrackerArn
            self.trackingId = trackingId
        }

        public func validate() throws {
            try validate(eventTrackerArn, name:"eventTrackerArn", max: 256)
            try validate(eventTrackerArn, name:"eventTrackerArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(trackingId, name:"trackingId", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
            case trackingId = "trackingId"
        }
    }

    public struct CreateSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "schema", required: true, type: .string)
        ]

        /// The name for the schema.
        public let name: String
        /// A schema in Avro JSON format.
        public let schema: String

        public init(name: String, schema: String) {
            self.name = name
            self.schema = schema
        }

        public func validate() throws {
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(schema, name:"schema", max: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case schema = "schema"
        }
    }

    public struct CreateSchemaResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schemaArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the created schema.
        public let schemaArn: String?

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        public func validate() throws {
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct CreateSolutionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "eventType", required: false, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "performAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "performHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionConfig", required: false, type: .structure)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String
        /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model.
        public let eventType: String?
        /// The name for the solution.
        public let name: String
        /// Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
        public let performHPO: Bool?
        /// The ARN of the recipe to use for model training. Only specified when performAutoML is false.
        public let recipeArn: String?
        /// The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration.
        public let solutionConfig: SolutionConfig?

        public init(datasetGroupArn: String, eventType: String? = nil, name: String, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionConfig: SolutionConfig? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionConfig = solutionConfig
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(eventType, name:"eventType", max: 256)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(recipeArn, name:"recipeArn", max: 256)
            try validate(recipeArn, name:"recipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try solutionConfig?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionConfig = "solutionConfig"
        }
    }

    public struct CreateSolutionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: false, type: .string)
        ]

        /// The ARN of the solution.
        public let solutionArn: String?

        public init(solutionArn: String? = nil) {
            self.solutionArn = solutionArn
        }

        public func validate() throws {
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct CreateSolutionVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate() throws {
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct CreateSolutionVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The ARN of the new solution version.
        public let solutionVersionArn: String?

        public init(solutionVersionArn: String? = nil) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate() throws {
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataLocation", required: false, type: .string)
        ]

        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For example:   s3://bucket-name/training-data.csv 
        public let dataLocation: String?

        public init(dataLocation: String? = nil) {
            self.dataLocation = dataLocation
        }

        public func validate() throws {
            try validate(dataLocation, name:"dataLocation", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case dataLocation = "dataLocation"
        }
    }

    public struct Dataset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetType", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "schemaArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the dataset.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public let datasetArn: String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// One of the following values:   Interactions   Items   Users  
        public let datasetType: String?
        /// A time stamp that shows when the dataset was updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset.
        public let name: String?
        /// The ARN of the associated schema.
        public let schemaArn: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetArn: String? = nil, datasetGroupArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, schemaArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(datasetType, name:"datasetType", max: 256)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetGroupArn = "datasetGroupArn"
            case datasetType = "datasetType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schemaArn = "schemaArn"
            case status = "status"
        }
    }

    public struct DatasetGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "kmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the dataset group.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// If creating a dataset group fails, provides the reason why.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The last update date and time (in Unix time) of the dataset group.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset group.
        public let name: String?
        /// The ARN of the IAM role that has permissions to create the dataset group.
        public let roleArn: String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, kmsKeyArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(roleArn, name:"roleArn", max: 256)
            try validate(roleArn, name:"roleArn", pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case kmsKeyArn = "kmsKeyArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetGroupSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the dataset group was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// If creating a dataset group fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset group.
        public let name: String?
        /// The status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct DatasetImportJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetImportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "dataSource", required: false, type: .structure), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "jobName", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the dataset import job.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource?
        /// If a dataset import job fails, provides the reason why.
        public let failureReason: String?
        /// The name of the import job.
        public let jobName: String?
        /// The date and time (in Unix time) the dataset was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The ARN of the AWS Identity and Access Management (IAM) role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, dataSource: DataSource? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.dataSource = dataSource
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(datasetImportJobArn, name:"datasetImportJobArn", max: 256)
            try validate(datasetImportJobArn, name:"datasetImportJobArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try dataSource?.validate()
            try validate(jobName, name:"jobName", max: 63)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(roleArn, name:"roleArn", max: 256)
            try validate(roleArn, name:"roleArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetImportJobArn = "datasetImportJobArn"
            case dataSource = "dataSource"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetImportJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetImportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "jobName", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the dataset import job was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// If a dataset import job fails, the reason behind the failure.
        public let failureReason: String?
        /// The name of the dataset import job.
        public let jobName: String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetImportJobArn: String? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }

        public func validate() throws {
            try validate(datasetImportJobArn, name:"datasetImportJobArn", max: 256)
            try validate(datasetImportJobArn, name:"datasetImportJobArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(jobName, name:"jobName", max: 63)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetImportJobArn = "datasetImportJobArn"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case status = "status"
        }
    }

    public struct DatasetSchema: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "schema", required: false, type: .string), 
            AWSShapeMember(label: "schemaArn", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the schema.
        public let name: String?
        /// The schema.
        public let schema: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, schema: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }

        public func validate() throws {
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(schema, name:"schema", max: 10000)
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schema = "schema"
            case schemaArn = "schemaArn"
        }
    }

    public struct DatasetSchemaSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "schemaArn", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the schema.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }

        public func validate() throws {
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schemaArn = "schemaArn"
        }
    }

    public struct DatasetSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetType", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the dataset was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The dataset type. One of the following values:   Interactions   Items   Users   Event-Interactions  
        public let datasetType: String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset.
        public let name: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(datasetType, name:"datasetType", max: 256)
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetType = "datasetType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct DefaultCategoricalHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "values", required: false, type: .list)
        ]

        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(isTunable: Bool? = nil, name: String? = nil, values: [String]? = nil) {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }

        public func validate() throws {
            try validate(name, name:"name", max: 256)
            try values?.forEach {
                try validate($0, name:"values[]", max: 1000)
            }
            try validate(values, name:"values", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case name = "name"
            case values = "values"
        }
    }

    public struct DefaultContinuousHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "maxValue", required: false, type: .double), 
            AWSShapeMember(label: "minValue", required: false, type: .double), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate() throws {
            try validate(maxValue, name:"maxValue", min: -1000000)
            try validate(minValue, name:"minValue", min: -1000000)
            try validate(name, name:"name", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct DefaultHyperParameterRanges: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "categoricalHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "continuousHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "integerHyperParameterRanges", required: false, type: .list)
        ]

        /// The categorical hyperparameters and their default ranges.
        public let categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public let continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public let integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        public func validate() throws {
            try categoricalHyperParameterRanges?.forEach {
                try $0.validate()
            }
            try validate(categoricalHyperParameterRanges, name:"categoricalHyperParameterRanges", max: 100)
            try continuousHyperParameterRanges?.forEach {
                try $0.validate()
            }
            try validate(continuousHyperParameterRanges, name:"continuousHyperParameterRanges", max: 100)
            try integerHyperParameterRanges?.forEach {
                try $0.validate()
            }
            try validate(integerHyperParameterRanges, name:"integerHyperParameterRanges", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges = "categoricalHyperParameterRanges"
            case continuousHyperParameterRanges = "continuousHyperParameterRanges"
            case integerHyperParameterRanges = "integerHyperParameterRanges"
        }
    }

    public struct DefaultIntegerHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "maxValue", required: false, type: .integer), 
            AWSShapeMember(label: "minValue", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// Indicates whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int32?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int32?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Int32? = nil, minValue: Int32? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate() throws {
            try validate(maxValue, name:"maxValue", max: 1000000)
            try validate(minValue, name:"minValue", min: -1000000)
            try validate(name, name:"name", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct DeleteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign to delete.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct DeleteDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string)
        ]

        /// The ARN of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct DeleteDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct DeleteEventTrackerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackerArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the event tracker to delete.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate() throws {
            try validate(eventTrackerArn, name:"eventTrackerArn", max: 256)
            try validate(eventTrackerArn, name:"eventTrackerArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
        }
    }

    public struct DeleteSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schemaArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the schema to delete.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate() throws {
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct DeleteSolutionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: true, type: .string)
        ]

        /// The ARN of the solution to delete.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate() throws {
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct DescribeAlgorithmRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm to describe.
        public let algorithmArn: String

        public init(algorithmArn: String) {
            self.algorithmArn = algorithmArn
        }

        public func validate() throws {
            try validate(algorithmArn, name:"algorithmArn", max: 256)
            try validate(algorithmArn, name:"algorithmArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
        }
    }

    public struct DescribeAlgorithmResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithm", required: false, type: .structure)
        ]

        /// A listing of the properties of the algorithm.
        public let algorithm: Algorithm?

        public init(algorithm: Algorithm? = nil) {
            self.algorithm = algorithm
        }

        public func validate() throws {
            try algorithm?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
        }
    }

    public struct DescribeCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct DescribeCampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaign", required: false, type: .structure)
        ]

        /// The properties of the campaign.
        public let campaign: Campaign?

        public init(campaign: Campaign? = nil) {
            self.campaign = campaign
        }

        public func validate() throws {
            try campaign?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case campaign = "campaign"
        }
    }

    public struct DescribeDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group to describe.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct DescribeDatasetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroup", required: false, type: .structure)
        ]

        /// A listing of the dataset group's properties.
        public let datasetGroup: DatasetGroup?

        public init(datasetGroup: DatasetGroup? = nil) {
            self.datasetGroup = datasetGroup
        }

        public func validate() throws {
            try datasetGroup?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroup = "datasetGroup"
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJobArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset import job to describe.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate() throws {
            try validate(datasetImportJobArn, name:"datasetImportJobArn", max: 256)
            try validate(datasetImportJobArn, name:"datasetImportJobArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "datasetImportJobArn"
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJob", required: false, type: .structure)
        ]

        /// Information about the dataset import job, including the status. The status is one of the following values:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED  
        public let datasetImportJob: DatasetImportJob?

        public init(datasetImportJob: DatasetImportJob? = nil) {
            self.datasetImportJob = datasetImportJob
        }

        public func validate() throws {
            try datasetImportJob?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJob = "datasetImportJob"
        }
    }

    public struct DescribeDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to describe.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct DescribeDatasetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataset", required: false, type: .structure)
        ]

        /// A listing of the dataset's properties.
        public let dataset: Dataset?

        public init(dataset: Dataset? = nil) {
            self.dataset = dataset
        }

        public func validate() throws {
            try dataset?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case dataset = "dataset"
        }
    }

    public struct DescribeEventTrackerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackerArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the event tracker to describe.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate() throws {
            try validate(eventTrackerArn, name:"eventTrackerArn", max: 256)
            try validate(eventTrackerArn, name:"eventTrackerArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
        }
    }

    public struct DescribeEventTrackerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTracker", required: false, type: .structure)
        ]

        /// An object that describes the event tracker.
        public let eventTracker: EventTracker?

        public init(eventTracker: EventTracker? = nil) {
            self.eventTracker = eventTracker
        }

        public func validate() throws {
            try eventTracker?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case eventTracker = "eventTracker"
        }
    }

    public struct DescribeFeatureTransformationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "featureTransformationArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the feature transformation to describe.
        public let featureTransformationArn: String

        public init(featureTransformationArn: String) {
            self.featureTransformationArn = featureTransformationArn
        }

        public func validate() throws {
            try validate(featureTransformationArn, name:"featureTransformationArn", max: 256)
            try validate(featureTransformationArn, name:"featureTransformationArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformationArn = "featureTransformationArn"
        }
    }

    public struct DescribeFeatureTransformationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "featureTransformation", required: false, type: .structure)
        ]

        /// A listing of the FeatureTransformation properties.
        public let featureTransformation: FeatureTransformation?

        public init(featureTransformation: FeatureTransformation? = nil) {
            self.featureTransformation = featureTransformation
        }

        public func validate() throws {
            try featureTransformation?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformation = "featureTransformation"
        }
    }

    public struct DescribeRecipeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "recipeArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the recipe to describe.
        public let recipeArn: String

        public init(recipeArn: String) {
            self.recipeArn = recipeArn
        }

        public func validate() throws {
            try validate(recipeArn, name:"recipeArn", max: 256)
            try validate(recipeArn, name:"recipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case recipeArn = "recipeArn"
        }
    }

    public struct DescribeRecipeResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "recipe", required: false, type: .structure)
        ]

        /// An object that describes the recipe.
        public let recipe: Recipe?

        public init(recipe: Recipe? = nil) {
            self.recipe = recipe
        }

        public func validate() throws {
            try recipe?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case recipe = "recipe"
        }
    }

    public struct DescribeSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schemaArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the schema to retrieve.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate() throws {
            try validate(schemaArn, name:"schemaArn", max: 256)
            try validate(schemaArn, name:"schemaArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct DescribeSchemaResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schema", required: false, type: .structure)
        ]

        /// The requested schema.
        public let schema: DatasetSchema?

        public init(schema: DatasetSchema? = nil) {
            self.schema = schema
        }

        public func validate() throws {
            try schema?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct DescribeSolutionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution to describe.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate() throws {
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct DescribeSolutionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solution", required: false, type: .structure)
        ]

        /// An object that describes the solution.
        public let solution: Solution?

        public init(solution: Solution? = nil) {
            self.solution = solution
        }

        public func validate() throws {
            try solution?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case solution = "solution"
        }
    }

    public struct DescribeSolutionVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate() throws {
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct DescribeSolutionVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersion", required: false, type: .structure)
        ]

        /// The solution version.
        public let solutionVersion: SolutionVersion?

        public init(solutionVersion: SolutionVersion? = nil) {
            self.solutionVersion = solutionVersion
        }

        public func validate() throws {
            try solutionVersion?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersion = "solutionVersion"
        }
    }

    public struct EventTracker: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accountId", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "eventTrackerArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string), 
            AWSShapeMember(label: "trackingId", required: false, type: .string)
        ]

        /// The Amazon AWS account that owns the event tracker.
        public let accountId: String?
        /// The date and time (in Unix format) that the event tracker was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String?
        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(accountId: String? = nil, creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil, trackingId: String? = nil) {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }

        public func validate() throws {
            try validate(accountId, name:"accountId", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(eventTrackerArn, name:"eventTrackerArn", max: 256)
            try validate(eventTrackerArn, name:"eventTrackerArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
            try validate(trackingId, name:"trackingId", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventTrackerArn = "eventTrackerArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
            case trackingId = "trackingId"
        }
    }

    public struct EventTrackerSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "eventTrackerArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the event tracker was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        public func validate() throws {
            try validate(eventTrackerArn, name:"eventTrackerArn", max: 256)
            try validate(eventTrackerArn, name:"eventTrackerArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case eventTrackerArn = "eventTrackerArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct FeatureTransformation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultParameters", required: false, type: .map), 
            AWSShapeMember(label: "featureTransformationArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the feature transformation.
        public let creationDateTime: TimeStamp?
        /// Provides the default parameters for feature transformation.
        public let defaultParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the feature transformation.
        public let name: String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, defaultParameters: [String: String]? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        public func validate() throws {
            try validate(featureTransformationArn, name:"featureTransformationArn", max: 256)
            try validate(featureTransformationArn, name:"featureTransformationArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case defaultParameters = "defaultParameters"
            case featureTransformationArn = "featureTransformationArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetSolutionMetricsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate() throws {
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct GetSolutionMetricsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metrics", required: false, type: .map), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The metrics for the solution version.
        public let metrics: [String: Double]?
        /// The same solution version ARN as specified in the request.
        public let solutionVersionArn: String?

        public init(metrics: [String: Double]? = nil, solutionVersionArn: String? = nil) {
            self.metrics = metrics
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate() throws {
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "metrics"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct HPOConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmHyperParameterRanges", required: false, type: .structure), 
            AWSShapeMember(label: "hpoObjective", required: false, type: .structure), 
            AWSShapeMember(label: "hpoResourceConfig", required: false, type: .structure)
        ]

        /// The hyperparameters and their allowable ranges.
        public let algorithmHyperParameterRanges: HyperParameterRanges?
        /// The metric to optimize during HPO.
        public let hpoObjective: HPOObjective?
        /// Describes the resource configuration for HPO.
        public let hpoResourceConfig: HPOResourceConfig?

        public init(algorithmHyperParameterRanges: HyperParameterRanges? = nil, hpoObjective: HPOObjective? = nil, hpoResourceConfig: HPOResourceConfig? = nil) {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }

        public func validate() throws {
            try algorithmHyperParameterRanges?.validate()
            try hpoObjective?.validate()
            try hpoResourceConfig?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameterRanges = "algorithmHyperParameterRanges"
            case hpoObjective = "hpoObjective"
            case hpoResourceConfig = "hpoResourceConfig"
        }
    }

    public struct HPOObjective: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metricName", required: false, type: .string), 
            AWSShapeMember(label: "metricRegex", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .string)
        ]

        /// The name of the metric.
        public let metricName: String?
        /// A regular expression for finding the metric in the training job logs.
        public let metricRegex: String?
        /// The data type of the metric.
        public let `type`: String?

        public init(metricName: String? = nil, metricRegex: String? = nil, type: String? = nil) {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.`type` = `type`
        }

        public func validate() throws {
            try validate(metricName, name:"metricName", max: 256)
            try validate(metricRegex, name:"metricRegex", max: 256)
            try validate(`type`, name:"`type`", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "metricName"
            case metricRegex = "metricRegex"
            case `type` = "type"
        }
    }

    public struct HPOResourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxNumberOfTrainingJobs", required: false, type: .string), 
            AWSShapeMember(label: "maxParallelTrainingJobs", required: false, type: .string)
        ]

        /// The maximum number of training jobs.
        public let maxNumberOfTrainingJobs: String?
        /// The maximum number of parallel training jobs.
        public let maxParallelTrainingJobs: String?

        public init(maxNumberOfTrainingJobs: String? = nil, maxParallelTrainingJobs: String? = nil) {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }

        public func validate() throws {
            try validate(maxNumberOfTrainingJobs, name:"maxNumberOfTrainingJobs", max: 256)
            try validate(maxParallelTrainingJobs, name:"maxParallelTrainingJobs", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxNumberOfTrainingJobs = "maxNumberOfTrainingJobs"
            case maxParallelTrainingJobs = "maxParallelTrainingJobs"
        }
    }

    public struct HyperParameterRanges: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "categoricalHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "continuousHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "integerHyperParameterRanges", required: false, type: .list)
        ]

        /// The categorical hyperparameters and their ranges.
        public let categoricalHyperParameterRanges: [CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public let continuousHyperParameterRanges: [ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public let integerHyperParameterRanges: [IntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [CategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [ContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [IntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        public func validate() throws {
            try categoricalHyperParameterRanges?.forEach {
                try $0.validate()
            }
            try validate(categoricalHyperParameterRanges, name:"categoricalHyperParameterRanges", max: 100)
            try continuousHyperParameterRanges?.forEach {
                try $0.validate()
            }
            try validate(continuousHyperParameterRanges, name:"continuousHyperParameterRanges", max: 100)
            try integerHyperParameterRanges?.forEach {
                try $0.validate()
            }
            try validate(integerHyperParameterRanges, name:"integerHyperParameterRanges", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges = "categoricalHyperParameterRanges"
            case continuousHyperParameterRanges = "continuousHyperParameterRanges"
            case integerHyperParameterRanges = "integerHyperParameterRanges"
        }
    }

    public struct IntegerHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxValue", required: false, type: .integer), 
            AWSShapeMember(label: "minValue", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int32?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int32?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Int32? = nil, minValue: Int32? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate() throws {
            try validate(maxValue, name:"maxValue", max: 1000000)
            try validate(minValue, name:"minValue", min: -1000000)
            try validate(name, name:"name", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct ListCampaignsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string)
        ]

        /// The maximum number of campaigns to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListCampaigns for getting the next set of campaigns (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
        public let solutionArn: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionArn = "solutionArn"
        }
    }

    public struct ListCampaignsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaigns", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// A list of the campaigns.
        public let campaigns: [CampaignSummary]?
        /// A token for getting the next set of campaigns (if they exist).
        public let nextToken: String?

        public init(campaigns: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaigns = campaigns
            self.nextToken = nextToken
        }

        public func validate() throws {
            try campaigns?.forEach {
                try $0.validate()
            }
            try validate(campaigns, name:"campaigns", max: 100)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case campaigns = "campaigns"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The maximum number of dataset groups to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroups", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of your dataset groups.
        public let datasetGroups: [DatasetGroupSummary]?
        /// A token for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        public func validate() throws {
            try datasetGroups?.forEach {
                try $0.validate()
            }
            try validate(datasetGroups, name:"datasetGroups", max: 100)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups = "datasetGroups"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
        public let datasetArn: String?
        /// The maximum number of dataset import jobs to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetArn: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.datasetArn = datasetArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(datasetArn, name:"datasetArn", max: 256)
            try validate(datasetArn, name:"datasetArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetImportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJobs", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of dataset import jobs.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// A token for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        public func validate() throws {
            try datasetImportJobs?.forEach {
                try $0.validate()
            }
            try validate(datasetImportJobs, name:"datasetImportJobs", max: 100)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs = "datasetImportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
        public let datasetGroupArn: String?
        /// The maximum number of datasets to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasets", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// An array of Dataset objects. Each object provides metadata information.
        public let datasets: [DatasetSummary]?
        /// A token for getting the next set of datasets (if they exist).
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        public func validate() throws {
            try datasets?.forEach {
                try $0.validate()
            }
            try validate(datasets, name:"datasets", max: 100)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "datasets"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventTrackersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The ARN of a dataset group used to filter the response.
        public let datasetGroupArn: String?
        /// The maximum number of event trackers to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventTrackersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackers", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// A list of event trackers.
        public let eventTrackers: [EventTrackerSummary]?
        /// A token for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(eventTrackers: [EventTrackerSummary]? = nil, nextToken: String? = nil) {
            self.eventTrackers = eventTrackers
            self.nextToken = nextToken
        }

        public func validate() throws {
            try eventTrackers?.forEach {
                try $0.validate()
            }
            try validate(eventTrackers, name:"eventTrackers", max: 100)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackers = "eventTrackers"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecipesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "recipeProvider", required: false, type: .enum)
        ]

        /// The maximum number of recipes to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
        public let nextToken: String?
        /// The default is SERVICE.
        public let recipeProvider: RecipeProvider?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, recipeProvider: RecipeProvider? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recipeProvider = recipeProvider
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case recipeProvider = "recipeProvider"
        }
    }

    public struct ListRecipesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "recipes", required: false, type: .list)
        ]

        /// A token for getting the next set of recipes.
        public let nextToken: String?
        /// The list of available recipes.
        public let recipes: [RecipeSummary]?

        public init(nextToken: String? = nil, recipes: [RecipeSummary]? = nil) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        public func validate() throws {
            try validate(nextToken, name:"nextToken", max: 1300)
            try recipes?.forEach {
                try $0.validate()
            }
            try validate(recipes, name:"recipes", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recipes = "recipes"
        }
    }

    public struct ListSchemasRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The maximum number of schemas to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSchemasResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "schemas", required: false, type: .list)
        ]

        /// A token used to get the next set of schemas (if they exist).
        public let nextToken: String?
        /// A list of schemas.
        public let schemas: [DatasetSchemaSummary]?

        public init(nextToken: String? = nil, schemas: [DatasetSchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        public func validate() throws {
            try validate(nextToken, name:"nextToken", max: 1300)
            try schemas?.forEach {
                try $0.validate()
            }
            try validate(schemas, name:"schemas", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemas = "schemas"
        }
    }

    public struct ListSolutionVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string)
        ]

        /// The maximum number of solution versions to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionArn = "solutionArn"
        }
    }

    public struct ListSolutionVersionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionVersions", required: false, type: .list)
        ]

        /// A token for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// A list of solution versions describing the version properties.
        public let solutionVersions: [SolutionVersionSummary]?

        public init(nextToken: String? = nil, solutionVersions: [SolutionVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutionVersions = solutionVersions
        }

        public func validate() throws {
            try validate(nextToken, name:"nextToken", max: 1300)
            try solutionVersions?.forEach {
                try $0.validate()
            }
            try validate(solutionVersions, name:"solutionVersions", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case solutionVersions = "solutionVersions"
        }
    }

    public struct ListSolutionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The maximum number of solutions to return.
        public let maxResults: Int32?
        /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(maxResults, name:"maxResults", max: 100)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolutionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutions", required: false, type: .list)
        ]

        /// A token for getting the next set of solutions (if they exist).
        public let nextToken: String?
        /// A list of the current solutions.
        public let solutions: [SolutionSummary]?

        public init(nextToken: String? = nil, solutions: [SolutionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutions = solutions
        }

        public func validate() throws {
            try validate(nextToken, name:"nextToken", max: 1300)
            try solutions?.forEach {
                try $0.validate()
            }
            try validate(solutions, name:"solutions", max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case solutions = "solutions"
        }
    }

    public struct Recipe: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "featureTransformationArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "recipeType", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public let algorithmArn: String?
        /// The date and time (in Unix format) that the recipe was created.
        public let creationDateTime: TimeStamp?
        /// The description of the recipe.
        public let description: String?
        /// The ARN of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// One of the following values:   PERSONALIZED_RANKING   RELATED_ITEMS   USER_PERSONALIZATION  
        public let recipeType: String?
        /// The status of the recipe.
        public let status: String?

        public init(algorithmArn: String? = nil, creationDateTime: TimeStamp? = nil, description: String? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, recipeArn: String? = nil, recipeType: String? = nil, status: String? = nil) {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }

        public func validate() throws {
            try validate(algorithmArn, name:"algorithmArn", max: 256)
            try validate(algorithmArn, name:"algorithmArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(featureTransformationArn, name:"featureTransformationArn", max: 256)
            try validate(featureTransformationArn, name:"featureTransformationArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(recipeArn, name:"recipeArn", max: 256)
            try validate(recipeArn, name:"recipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(recipeType, name:"recipeType", max: 256)
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case featureTransformationArn = "featureTransformationArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case recipeType = "recipeType"
            case status = "status"
        }
    }

    public enum RecipeProvider: String, CustomStringConvertible, Codable {
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public struct RecipeSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the recipe was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the recipe was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// The status of the recipe.
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, recipeArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }

        public func validate() throws {
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(recipeArn, name:"recipeArn", max: 256)
            try validate(recipeArn, name:"recipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case status = "status"
        }
    }

    public struct Solution: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "autoMLResult", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "eventType", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "latestSolutionVersion", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "performAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "performHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// When performAutoML is true, specifies the best recipe found.
        public let autoMLResult: AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public let eventType: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// Describes the latest version of the solution, including the status and the ARN.
        public let latestSolutionVersion: SolutionVersionSummary?
        /// The name of the solution.
        public let name: String?
        /// When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used to create the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(autoMLResult: AutoMLResult? = nil, creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, latestSolutionVersion: SolutionVersionSummary? = nil, name: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, status: String? = nil) {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }

        public func validate() throws {
            try autoMLResult?.validate()
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(eventType, name:"eventType", max: 256)
            try latestSolutionVersion?.validate()
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(recipeArn, name:"recipeArn", max: 256)
            try validate(recipeArn, name:"recipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try solutionConfig?.validate()
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLResult = "autoMLResult"
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestSolutionVersion = "latestSolutionVersion"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case solutionConfig = "solutionConfig"
            case status = "status"
        }
    }

    public struct SolutionConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmHyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "autoMLConfig", required: false, type: .structure), 
            AWSShapeMember(label: "eventValueThreshold", required: false, type: .string), 
            AWSShapeMember(label: "featureTransformationParameters", required: false, type: .map), 
            AWSShapeMember(label: "hpoConfig", required: false, type: .structure)
        ]

        /// Lists the hyperparameter names and ranges.
        public let algorithmHyperParameters: [String: String]?
        /// The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
        public let autoMLConfig: AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public let eventValueThreshold: String?
        /// Lists the feature transformation parameters.
        public let featureTransformationParameters: [String: String]?
        /// Describes the properties for hyperparameter optimization (HPO). For use with the bring-your-own-recipe feature. Not used with Amazon Personalize predefined recipes.
        public let hpoConfig: HPOConfig?

        public init(algorithmHyperParameters: [String: String]? = nil, autoMLConfig: AutoMLConfig? = nil, eventValueThreshold: String? = nil, featureTransformationParameters: [String: String]? = nil, hpoConfig: HPOConfig? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
        }

        public func validate() throws {
            try autoMLConfig?.validate()
            try validate(eventValueThreshold, name:"eventValueThreshold", max: 256)
            try hpoConfig?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters = "algorithmHyperParameters"
            case autoMLConfig = "autoMLConfig"
            case eventValueThreshold = "eventValueThreshold"
            case featureTransformationParameters = "featureTransformationParameters"
            case hpoConfig = "hpoConfig"
        }
    }

    public struct SolutionSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the solution was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the solution.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, solutionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.solutionArn = solutionArn
            self.status = status
        }

        public func validate() throws {
            try validate(name, name:"name", max: 63)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case solutionArn = "solutionArn"
            case status = "status"
        }
    }

    public struct SolutionVersion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "eventType", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "performAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "performHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that this version of the solution was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public let eventType: String?
        /// If training a solution version fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// When true, Amazon Personalize performs a search for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used in the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The ARN of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        public func validate() throws {
            try validate(datasetGroupArn, name:"datasetGroupArn", max: 256)
            try validate(datasetGroupArn, name:"datasetGroupArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(eventType, name:"eventType", max: 256)
            try validate(recipeArn, name:"recipeArn", max: 256)
            try validate(recipeArn, name:"recipeArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(solutionArn, name:"solutionArn", max: 256)
            try validate(solutionArn, name:"solutionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try solutionConfig?.validate()
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case solutionConfig = "solutionConfig"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct SolutionVersionSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that this version of a solution was created.
        public let creationDateTime: TimeStamp?
        /// If a solution version fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        public func validate() throws {
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(status, name:"status", max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct UpdateCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: true, type: .string), 
            AWSShapeMember(label: "minProvisionedTPS", required: false, type: .integer), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int32?
        /// The ARN of a new solution version to deploy.
        public let solutionVersionArn: String?

        public init(campaignArn: String, minProvisionedTPS: Int32? = nil, solutionVersionArn: String? = nil) {
            self.campaignArn = campaignArn
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(minProvisionedTPS, name:"minProvisionedTPS", min: 1)
            try validate(solutionVersionArn, name:"solutionVersionArn", max: 256)
            try validate(solutionVersionArn, name:"solutionVersionArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case minProvisionedTPS = "minProvisionedTPS"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct UpdateCampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string)
        ]

        /// The same campaign ARN as given in the request.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        public func validate() throws {
            try validate(campaignArn, name:"campaignArn", max: 256)
            try validate(campaignArn, name:"campaignArn", pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }
}
