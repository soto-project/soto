// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Ec2 {

    public struct DescribeVpcClassicLinkResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ClassicLink status of one or more VPCs.
        public let vpcs: VpcClassicLinkList?

        public init(vpcs: VpcClassicLinkList? = nil) {
            self.vpcs = vpcs
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcs = dictionary["VpcSet"] as? [String: Any] { self.vpcs = try Ec2.VpcClassicLinkList(dictionary: vpcs) } else { self.vpcs = nil }
        }
    }

    public struct GetConsoleScreenshotRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// When set to true, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.
        public let wakeUp: Bool?
        /// The ID of the instance.
        public let instanceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(wakeUp: Bool? = nil, instanceId: String, dryRun: Bool? = nil) {
            self.wakeUp = wakeUp
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.wakeUp = dictionary["WakeUp"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeIamInstanceProfileAssociationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more IAM instance profile associations.
        public let associationIds: AssociationIdList?
        /// One or more filters.    instance-id - The ID of the instance.    state - The state of the association (associating | associated | disassociating | disassociated).  
        public let filters: FilterList?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(associationIds: AssociationIdList? = nil, filters: FilterList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.associationIds = associationIds
            self.filters = filters
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let associationIds = dictionary["AssociationId"] as? [String: Any] { self.associationIds = try Ec2.AssociationIdList(dictionary: associationIds) } else { self.associationIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct InstanceCountList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceCount]?

        public init(item: [InstanceCount]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceCount(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum MoveStatus: String, CustomStringConvertible {
        case movingtovpc = "movingToVpc"
        case restoringtoclassic = "restoringToClassic"
        public var description: String { return self.rawValue }
    }

    public struct DescribeInstanceAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the instance.
        public let instanceId: String
        /// The instance attribute. Note: The enaSupport attribute is not supported at this time.
        public let attribute: InstanceAttributeName

        public init(dryRun: Bool? = nil, instanceId: String, attribute: InstanceAttributeName) {
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = InstanceAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct BlobAttributeValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let value: Data?

        public init(value: Data? = nil) {
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Data
        }
    }

    public struct ModifyVolumeAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Indicates whether the volume should be auto-enabled for I/O operations.
        public let autoEnableIO: AttributeBooleanValue?
        /// The ID of the volume.
        public let volumeId: String

        public init(dryRun: Bool? = nil, autoEnableIO: AttributeBooleanValue? = nil, volumeId: String) {
            self.dryRun = dryRun
            self.autoEnableIO = autoEnableIO
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let autoEnableIO = dictionary["AutoEnableIO"] as? [String: Any] { self.autoEnableIO = try Ec2.AttributeBooleanValue(dictionary: autoEnableIO) } else { self.autoEnableIO = nil }
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public enum VpnStaticRouteSource: String, CustomStringConvertible {
        case `static` = "Static"
        public var description: String { return self.rawValue }
    }

    public enum TrafficType: String, CustomStringConvertible {
        case accept = "ACCEPT"
        case reject = "REJECT"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum ArchitectureValues: String, CustomStringConvertible {
        case i386 = "i386"
        case x86_64 = "x86_64"
        public var description: String { return self.rawValue }
    }

    public struct InternetGatewayAttachment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// The current state of the attachment.
        public let state: AttachmentStatus?

        public init(vpcId: String? = nil, state: AttachmentStatus? = nil) {
            self.vpcId = vpcId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let state = dictionary["State"] as? String { self.state = AttachmentStatus(rawValue: state) } else { self.state = nil }
        }
    }

    public struct DescribeScheduledInstanceAvailabilityResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the available Scheduled Instances.
        public let scheduledInstanceAvailabilitySet: ScheduledInstanceAvailabilitySet?

        public init(nextToken: String? = nil, scheduledInstanceAvailabilitySet: ScheduledInstanceAvailabilitySet? = nil) {
            self.nextToken = nextToken
            self.scheduledInstanceAvailabilitySet = scheduledInstanceAvailabilitySet
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let scheduledInstanceAvailabilitySet = dictionary["ScheduledInstanceAvailabilitySet"] as? [String: Any] { self.scheduledInstanceAvailabilitySet = try Ec2.ScheduledInstanceAvailabilitySet(dictionary: scheduledInstanceAvailabilitySet) } else { self.scheduledInstanceAvailabilitySet = nil }
        }
    }

    public struct RouteTableAssociationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [RouteTableAssociation]?

        public init(item: [RouteTableAssociation]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try RouteTableAssociation(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeAddressesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more Elastic IP addresses.
        public let addresses: AddressList?

        public init(addresses: AddressList? = nil) {
            self.addresses = addresses
        }

        public init(dictionary: [String: Any]) throws {
            if let addresses = dictionary["AddressesSet"] as? [String: Any] { self.addresses = try Ec2.AddressList(dictionary: addresses) } else { self.addresses = nil }
        }
    }

    public struct DescribeNatGatewaysResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the NAT gateways.
        public let natGateways: NatGatewayList?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(natGateways: NatGatewayList? = nil, nextToken: String? = nil) {
            self.natGateways = natGateways
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let natGateways = dictionary["NatGatewaySet"] as? [String: Any] { self.natGateways = try Ec2.NatGatewayList(dictionary: natGateways) } else { self.natGateways = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CreateEgressOnlyInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC for which to create the egress-only Internet gateway.
        public let vpcId: String
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        public let clientToken: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, clientToken: String? = nil, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.clientToken = clientToken
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.clientToken = dictionary["ClientToken"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ModifyVpcAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" will succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.
        public let enableDnsSupport: AttributeBooleanValue?
        /// Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.
        public let enableDnsHostnames: AttributeBooleanValue?

        public init(vpcId: String, enableDnsSupport: AttributeBooleanValue? = nil, enableDnsHostnames: AttributeBooleanValue? = nil) {
            self.vpcId = vpcId
            self.enableDnsSupport = enableDnsSupport
            self.enableDnsHostnames = enableDnsHostnames
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            if let enableDnsSupport = dictionary["EnableDnsSupport"] as? [String: Any] { self.enableDnsSupport = try Ec2.AttributeBooleanValue(dictionary: enableDnsSupport) } else { self.enableDnsSupport = nil }
            if let enableDnsHostnames = dictionary["EnableDnsHostnames"] as? [String: Any] { self.enableDnsHostnames = try Ec2.AttributeBooleanValue(dictionary: enableDnsHostnames) } else { self.enableDnsHostnames = nil }
        }
    }

    public struct CreateVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account ID of the owner of the peer VPC. Default: Your AWS account ID
        public let peerOwnerId: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the requester VPC.
        public let vpcId: String?
        /// The ID of the VPC with which you are creating the VPC peering connection.
        public let peerVpcId: String?

        public init(peerOwnerId: String? = nil, dryRun: Bool? = nil, vpcId: String? = nil, peerVpcId: String? = nil) {
            self.peerOwnerId = peerOwnerId
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.peerVpcId = peerVpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.peerOwnerId = dictionary["PeerOwnerId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.vpcId = dictionary["VpcId"] as? String
            self.peerVpcId = dictionary["PeerVpcId"] as? String
        }
    }

    public struct Host: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide. 
        public let clientToken: String?
        /// Whether auto-placement is on or off.
        public let autoPlacement: AutoPlacement?
        /// The ID of the Dedicated Host.
        public let hostId: String?
        /// The Dedicated Host's state.
        public let state: AllocationState?
        /// The number of new instances that can be launched onto the Dedicated Host.
        public let availableCapacity: AvailableCapacity?
        /// The reservation ID of the Dedicated Host. This returns a null response if the Dedicated Host doesn't have an associated reservation.
        public let hostReservationId: String?
        /// The IDs and instance type that are currently running on the Dedicated Host.
        public let instances: HostInstanceList?
        /// The hardware specifications of the Dedicated Host.
        public let hostProperties: HostProperties?
        /// The Availability Zone of the Dedicated Host.
        public let availabilityZone: String?

        public init(clientToken: String? = nil, autoPlacement: AutoPlacement? = nil, hostId: String? = nil, state: AllocationState? = nil, availableCapacity: AvailableCapacity? = nil, hostReservationId: String? = nil, instances: HostInstanceList? = nil, hostProperties: HostProperties? = nil, availabilityZone: String? = nil) {
            self.clientToken = clientToken
            self.autoPlacement = autoPlacement
            self.hostId = hostId
            self.state = state
            self.availableCapacity = availableCapacity
            self.hostReservationId = hostReservationId
            self.instances = instances
            self.hostProperties = hostProperties
            self.availabilityZone = availabilityZone
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let autoPlacement = dictionary["AutoPlacement"] as? String { self.autoPlacement = AutoPlacement(rawValue: autoPlacement) } else { self.autoPlacement = nil }
            self.hostId = dictionary["HostId"] as? String
            if let state = dictionary["State"] as? String { self.state = AllocationState(rawValue: state) } else { self.state = nil }
            if let availableCapacity = dictionary["AvailableCapacity"] as? [String: Any] { self.availableCapacity = try Ec2.AvailableCapacity(dictionary: availableCapacity) } else { self.availableCapacity = nil }
            self.hostReservationId = dictionary["HostReservationId"] as? String
            if let instances = dictionary["Instances"] as? [String: Any] { self.instances = try Ec2.HostInstanceList(dictionary: instances) } else { self.instances = nil }
            if let hostProperties = dictionary["HostProperties"] as? [String: Any] { self.hostProperties = try Ec2.HostProperties(dictionary: hostProperties) } else { self.hostProperties = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
        }
    }

    public struct ReservedIntancesIds: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstancesId]?

        public init(item: [ReservedInstancesId]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstancesId(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct TargetReservationValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The configuration of the Convertible Reserved Instances that make up the exchange.
        public let targetConfiguration: TargetConfiguration?
        /// The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.
        public let reservationValue: ReservationValue?

        public init(targetConfiguration: TargetConfiguration? = nil, reservationValue: ReservationValue? = nil) {
            self.targetConfiguration = targetConfiguration
            self.reservationValue = reservationValue
        }

        public init(dictionary: [String: Any]) throws {
            if let targetConfiguration = dictionary["TargetConfiguration"] as? [String: Any] { self.targetConfiguration = try Ec2.TargetConfiguration(dictionary: targetConfiguration) } else { self.targetConfiguration = nil }
            if let reservationValue = dictionary["ReservationValue"] as? [String: Any] { self.reservationValue = try Ec2.ReservationValue(dictionary: reservationValue) } else { self.reservationValue = nil }
        }
    }

    public struct ImportKeyPairResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The key pair name you provided.
        public let keyName: String?
        /// The MD5 public key fingerprint as specified in section 4 of RFC 4716.
        public let keyFingerprint: String?

        public init(keyName: String? = nil, keyFingerprint: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? String
            self.keyFingerprint = dictionary["KeyFingerprint"] as? String
        }
    }

    public struct SpotFleetRequestConfigSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SpotFleetRequestConfig]?

        public init(item: [SpotFleetRequestConfig]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SpotFleetRequestConfig(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CancelSpotFleetRequestsErrorSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [CancelSpotFleetRequestsErrorItem]?

        public init(item: [CancelSpotFleetRequestsErrorItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try CancelSpotFleetRequestsErrorItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeSnapshotsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The NextToken value to include in a future DescribeSnapshots request. When the results of a DescribeSnapshots request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the snapshots.
        public let snapshots: SnapshotList?

        public init(nextToken: String? = nil, snapshots: SnapshotList? = nil) {
            self.nextToken = nextToken
            self.snapshots = snapshots
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let snapshots = dictionary["SnapshotSet"] as? [String: Any] { self.snapshots = try Ec2.SnapshotList(dictionary: snapshots) } else { self.snapshots = nil }
        }
    }

    public struct DescribeInstanceStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    availability-zone - The Availability Zone of the instance.    event.code - The code for the scheduled event (instance-reboot | system-reboot | system-maintenance | instance-retirement | instance-stop).    event.description - A description of the event.    event.not-after - The latest end time for the scheduled event (for example, 2014-09-15T17:15:20.000Z).    event.not-before - The earliest start time for the scheduled event (for example, 2014-09-15T17:15:20.000Z).    instance-state-code - The code for the instance state, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).    instance-state-name - The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).    instance-status.reachability - Filters on instance status where the name is reachability (passed | failed | initializing | insufficient-data).    instance-status.status - The status of the instance (ok | impaired | initializing | insufficient-data | not-applicable).    system-status.reachability - Filters on system status where the name is reachability (passed | failed | initializing | insufficient-data).    system-status.status - The system status of the instance (ok | impaired | initializing | insufficient-data | not-applicable).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// When true, includes the health status for all instances. When false, includes the health status for running instances only. Default: false 
        public let includeAllInstances: Bool?
        /// One or more instance IDs. Default: Describes all your instances. Constraints: Maximum 100 explicitly specified instance IDs.
        public let instanceIds: InstanceIdStringList?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.
        public let maxResults: Int32?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, includeAllInstances: Bool? = nil, instanceIds: InstanceIdStringList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.includeAllInstances = includeAllInstances
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.includeAllInstances = dictionary["IncludeAllInstances"] as? Bool
            if let instanceIds = dictionary["InstanceId"] as? [String: Any] { self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds) } else { self.instanceIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct VolumeStatusItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details of the operation.
        public let actions: VolumeStatusActionsList?
        /// The volume status.
        public let volumeStatus: VolumeStatusInfo?
        /// A list of events associated with the volume.
        public let events: VolumeStatusEventsList?
        /// The Availability Zone of the volume.
        public let availabilityZone: String?
        /// The volume ID.
        public let volumeId: String?

        public init(actions: VolumeStatusActionsList? = nil, volumeStatus: VolumeStatusInfo? = nil, events: VolumeStatusEventsList? = nil, availabilityZone: String? = nil, volumeId: String? = nil) {
            self.actions = actions
            self.volumeStatus = volumeStatus
            self.events = events
            self.availabilityZone = availabilityZone
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            if let actions = dictionary["ActionsSet"] as? [String: Any] { self.actions = try Ec2.VolumeStatusActionsList(dictionary: actions) } else { self.actions = nil }
            if let volumeStatus = dictionary["VolumeStatus"] as? [String: Any] { self.volumeStatus = try Ec2.VolumeStatusInfo(dictionary: volumeStatus) } else { self.volumeStatus = nil }
            if let events = dictionary["EventsSet"] as? [String: Any] { self.events = try Ec2.VolumeStatusEventsList(dictionary: events) } else { self.events = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct CreateRouteTableResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the route table.
        public let routeTable: RouteTable?

        public init(routeTable: RouteTable? = nil) {
            self.routeTable = routeTable
        }

        public init(dictionary: [String: Any]) throws {
            if let routeTable = dictionary["RouteTable"] as? [String: Any] { self.routeTable = try Ec2.RouteTable(dictionary: routeTable) } else { self.routeTable = nil }
        }
    }

    public struct EnableVpcClassicLinkRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct InstanceNetworkInterface: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The MAC address.
        public let macAddress: String?
        /// Indicates whether to validate network traffic to or from this network interface.
        public let sourceDestCheck: Bool?
        /// The private DNS name.
        public let privateDnsName: String?
        /// The ID of the AWS account that created the network interface.
        public let ownerId: String?
        /// The network interface attachment.
        public let attachment: InstanceNetworkInterfaceAttachment?
        /// The description.
        public let description: String?
        /// The IPv4 address of the network interface within the subnet.
        public let privateIpAddress: String?
        /// The status of the network interface.
        public let status: NetworkInterfaceStatus?
        /// One or more private IPv4 addresses associated with the network interface.
        public let privateIpAddresses: InstancePrivateIpAddressList?
        /// The ID of the VPC.
        public let vpcId: String?
        /// One or more IPv6 addresses associated with the network interface.
        public let ipv6Addresses: InstanceIpv6AddressList?
        /// One or more security groups.
        public let groups: GroupIdentifierList?
        /// The association information for an Elastic IPv4 associated with the network interface.
        public let association: InstanceNetworkInterfaceAssociation?

        public init(subnetId: String? = nil, networkInterfaceId: String? = nil, macAddress: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, ownerId: String? = nil, attachment: InstanceNetworkInterfaceAttachment? = nil, description: String? = nil, privateIpAddress: String? = nil, status: NetworkInterfaceStatus? = nil, privateIpAddresses: InstancePrivateIpAddressList? = nil, vpcId: String? = nil, ipv6Addresses: InstanceIpv6AddressList? = nil, groups: GroupIdentifierList? = nil, association: InstanceNetworkInterfaceAssociation? = nil) {
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.macAddress = macAddress
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.ownerId = ownerId
            self.attachment = attachment
            self.description = description
            self.privateIpAddress = privateIpAddress
            self.status = status
            self.privateIpAddresses = privateIpAddresses
            self.vpcId = vpcId
            self.ipv6Addresses = ipv6Addresses
            self.groups = groups
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.macAddress = dictionary["MacAddress"] as? String
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? Bool
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.InstanceNetworkInterfaceAttachment(dictionary: attachment) } else { self.attachment = nil }
            self.description = dictionary["Description"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            if let status = dictionary["Status"] as? String { self.status = NetworkInterfaceStatus(rawValue: status) } else { self.status = nil }
            if let privateIpAddresses = dictionary["PrivateIpAddressesSet"] as? [String: Any] { self.privateIpAddresses = try Ec2.InstancePrivateIpAddressList(dictionary: privateIpAddresses) } else { self.privateIpAddresses = nil }
            self.vpcId = dictionary["VpcId"] as? String
            if let ipv6Addresses = dictionary["Ipv6AddressesSet"] as? [String: Any] { self.ipv6Addresses = try Ec2.InstanceIpv6AddressList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            if let groups = dictionary["GroupSet"] as? [String: Any] { self.groups = try Ec2.GroupIdentifierList(dictionary: groups) } else { self.groups = nil }
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.InstanceNetworkInterfaceAssociation(dictionary: association) } else { self.association = nil }
        }
    }

    public struct CreateNetworkInterfaceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the network interface.
        public let networkInterface: NetworkInterface?

        public init(networkInterface: NetworkInterface? = nil) {
            self.networkInterface = networkInterface
        }

        public init(dictionary: [String: Any]) throws {
            if let networkInterface = dictionary["NetworkInterface"] as? [String: Any] { self.networkInterface = try Ec2.NetworkInterface(dictionary: networkInterface) } else { self.networkInterface = nil }
        }
    }

    public struct ReservedInstancesModificationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstancesModification]?

        public init(item: [ReservedInstancesModification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstancesModification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ResetInstanceAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the instance.
        public let instanceId: String
        /// The attribute to reset.  You can only reset the following attributes: kernel | ramdisk | sourceDestCheck. To change an instance attribute, use ModifyInstanceAttribute. 
        public let attribute: InstanceAttributeName

        public init(dryRun: Bool? = nil, instanceId: String, attribute: InstanceAttributeName) {
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = InstanceAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct Monitoring: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
        public let state: MonitoringState?

        public init(state: MonitoringState? = nil) {
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            if let state = dictionary["State"] as? String { self.state = MonitoringState(rawValue: state) } else { self.state = nil }
        }
    }

    public struct RequestSpotLaunchSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.
        public let blockDeviceMappings: BlockDeviceMappingList?
        /// The ID of the subnet in which to launch the instance.
        public let subnetId: String?
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let userData: String?
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        public let ebsOptimized: Bool?
        /// The ID of the kernel.
        public let kernelId: String?
        public let securityGroupIds: ValueStringList?
        public let monitoring: RunInstancesMonitoringEnabled?
        /// The instance type.
        public let instanceType: InstanceType?
        public let securityGroups: ValueStringList?
        /// The name of the key pair.
        public let keyName: String?
        /// Deprecated.
        public let addressingType: String?
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfileSpecification?
        /// The ID of the AMI.
        public let imageId: String?
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        public let networkInterfaces: InstanceNetworkInterfaceSpecificationList?
        /// The placement information for the instance.
        public let placement: SpotPlacement?
        /// The ID of the RAM disk.
        public let ramdiskId: String?

        public init(blockDeviceMappings: BlockDeviceMappingList? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, securityGroupIds: ValueStringList? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, instanceType: InstanceType? = nil, securityGroups: ValueStringList? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            if let securityGroupIds = dictionary["SecurityGroupId"] as? [String: Any] { self.securityGroupIds = try Ec2.ValueStringList(dictionary: securityGroupIds) } else { self.securityGroupIds = nil }
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.RunInstancesMonitoringEnabled(dictionary: monitoring) } else { self.monitoring = nil }
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            if let securityGroups = dictionary["SecurityGroup"] as? [String: Any] { self.securityGroups = try Ec2.ValueStringList(dictionary: securityGroups) } else { self.securityGroups = nil }
            self.keyName = dictionary["KeyName"] as? String
            self.addressingType = dictionary["AddressingType"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
            self.imageId = dictionary["ImageId"] as? String
            if let networkInterfaces = dictionary["NetworkInterface"] as? [String: Any] { self.networkInterfaces = try Ec2.InstanceNetworkInterfaceSpecificationList(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.SpotPlacement(dictionary: placement) } else { self.placement = nil }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct AssociateVpcCidrBlockRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
        public let amazonProvidedIpv6CidrBlock: Bool?

        public init(vpcId: String, amazonProvidedIpv6CidrBlock: Bool? = nil) {
            self.vpcId = vpcId
            self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.amazonProvidedIpv6CidrBlock = dictionary["AmazonProvidedIpv6CidrBlock"] as? Bool
        }
    }

    public struct ImageDiskContainer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The S3 bucket for the disk image.
        public let userBucket: UserBucket?
        /// The format of the disk image being imported. Valid values: RAW | VHD | VMDK | OVA 
        public let format: String?
        /// The ID of the EBS snapshot to be used for importing the snapshot.
        public let snapshotId: String?
        /// The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)
        public let url: String?
        /// The block device mapping for the disk.
        public let deviceName: String?
        /// The description of the disk image.
        public let description: String?

        public init(userBucket: UserBucket? = nil, format: String? = nil, snapshotId: String? = nil, url: String? = nil, deviceName: String? = nil, description: String? = nil) {
            self.userBucket = userBucket
            self.format = format
            self.snapshotId = snapshotId
            self.url = url
            self.deviceName = deviceName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucket(dictionary: userBucket) } else { self.userBucket = nil }
            self.format = dictionary["Format"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.url = dictionary["Url"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct PurchaseReservedInstancesOfferingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Reserved Instance offering to purchase.
        public let reservedInstancesOfferingId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The number of Reserved Instances to purchase.
        public let instanceCount: Int32
        /// Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.
        public let limitPrice: ReservedInstanceLimitPrice?

        public init(reservedInstancesOfferingId: String, dryRun: Bool? = nil, instanceCount: Int32, limitPrice: ReservedInstanceLimitPrice? = nil) {
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.dryRun = dryRun
            self.instanceCount = instanceCount
            self.limitPrice = limitPrice
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstancesOfferingId = dictionary["ReservedInstancesOfferingId"] as? String else { throw InitializableError.missingRequiredParam("ReservedInstancesOfferingId") }
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceCount = dictionary["InstanceCount"] as? Int32 else { throw InitializableError.missingRequiredParam("InstanceCount") }
            self.instanceCount = instanceCount
            if let limitPrice = dictionary["LimitPrice"] as? [String: Any] { self.limitPrice = try Ec2.ReservedInstanceLimitPrice(dictionary: limitPrice) } else { self.limitPrice = nil }
        }
    }

    public struct ReservedInstances: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The recurring charge tag assigned to the resource.
        public let recurringCharges: RecurringChargesList?
        /// Any tags assigned to the resource.
        public let tags: TagList?
        /// The usage price of the Reserved Instance, per hour.
        public let usagePrice: Float?
        /// The state of the Reserved Instance purchase.
        public let state: ReservedInstanceState?
        /// The tenancy of the instance.
        public let instanceTenancy: Tenancy?
        /// The instance type on which the Reserved Instance can be used.
        public let instanceType: InstanceType?
        /// The Reserved Instance offering type.
        public let offeringType: OfferingTypeValues?
        /// The Reserved Instance product platform description.
        public let productDescription: RIProductDescription?
        /// The offering class of the Reserved Instance.
        public let offeringClass: OfferingClassType?
        /// The Availability Zone in which the Reserved Instance can be used.
        public let availabilityZone: String?
        /// The date and time the Reserved Instance started.
        public let start: Date?
        /// The time when the Reserved Instance expires.
        public let end: Date?
        /// The ID of the Reserved Instance.
        public let reservedInstancesId: String?
        /// The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The number of reservations purchased.
        public let instanceCount: Int32?
        /// The duration of the Reserved Instance, in seconds.
        public let duration: Int64?
        /// The scope of the Reserved Instance.
        public let scope: Scope?
        /// The purchase price of the Reserved Instance.
        public let fixedPrice: Float?

        public init(recurringCharges: RecurringChargesList? = nil, tags: TagList? = nil, usagePrice: Float? = nil, state: ReservedInstanceState? = nil, instanceTenancy: Tenancy? = nil, instanceType: InstanceType? = nil, offeringType: OfferingTypeValues? = nil, productDescription: RIProductDescription? = nil, offeringClass: OfferingClassType? = nil, availabilityZone: String? = nil, start: Date? = nil, end: Date? = nil, reservedInstancesId: String? = nil, currencyCode: CurrencyCodeValues? = nil, instanceCount: Int32? = nil, duration: Int64? = nil, scope: Scope? = nil, fixedPrice: Float? = nil) {
            self.recurringCharges = recurringCharges
            self.tags = tags
            self.usagePrice = usagePrice
            self.state = state
            self.instanceTenancy = instanceTenancy
            self.instanceType = instanceType
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.offeringClass = offeringClass
            self.availabilityZone = availabilityZone
            self.start = start
            self.end = end
            self.reservedInstancesId = reservedInstancesId
            self.currencyCode = currencyCode
            self.instanceCount = instanceCount
            self.duration = duration
            self.scope = scope
            self.fixedPrice = fixedPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let recurringCharges = dictionary["RecurringCharges"] as? [String: Any] { self.recurringCharges = try Ec2.RecurringChargesList(dictionary: recurringCharges) } else { self.recurringCharges = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.usagePrice = dictionary["UsagePrice"] as? Float
            if let state = dictionary["State"] as? String { self.state = ReservedInstanceState(rawValue: state) } else { self.state = nil }
            if let instanceTenancy = dictionary["InstanceTenancy"] as? String { self.instanceTenancy = Tenancy(rawValue: instanceTenancy) } else { self.instanceTenancy = nil }
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            if let offeringType = dictionary["OfferingType"] as? String { self.offeringType = OfferingTypeValues(rawValue: offeringType) } else { self.offeringType = nil }
            if let productDescription = dictionary["ProductDescription"] as? String { self.productDescription = RIProductDescription(rawValue: productDescription) } else { self.productDescription = nil }
            if let offeringClass = dictionary["OfferingClass"] as? String { self.offeringClass = OfferingClassType(rawValue: offeringClass) } else { self.offeringClass = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.start = dictionary["Start"] as? Date
            self.end = dictionary["End"] as? Date
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.duration = dictionary["Duration"] as? Int64
            if let scope = dictionary["Scope"] as? String { self.scope = Scope(rawValue: scope) } else { self.scope = nil }
            self.fixedPrice = dictionary["FixedPrice"] as? Float
        }
    }

    public struct NetworkInterfaceIpv6Address: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 address.
        public let ipv6Address: String?

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6Address = dictionary["Ipv6Address"] as? String
        }
    }

    public struct DescribeCustomerGatewaysRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more customer gateway IDs. Default: Describes all your customer gateways.
        public let customerGatewayIds: CustomerGatewayIdStringList?
        /// One or more filters.    bgp-asn - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).    customer-gateway-id - The ID of the customer gateway.    ip-address - The IP address of the customer gateway's Internet-routable external interface.    state - The state of the customer gateway (pending | available | deleting | deleted).    type - The type of customer gateway. Currently, the only supported type is ipsec.1.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(customerGatewayIds: CustomerGatewayIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.customerGatewayIds = customerGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let customerGatewayIds = dictionary["CustomerGatewayId"] as? [String: Any] { self.customerGatewayIds = try Ec2.CustomerGatewayIdStringList(dictionary: customerGatewayIds) } else { self.customerGatewayIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct NetworkInterface: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The MAC address.
        public let macAddress: String?
        /// Indicates whether traffic to or from the instance is validated.
        public let sourceDestCheck: Bool?
        /// The private DNS name.
        public let privateDnsName: String?
        /// The network interface attachment.
        public let attachment: NetworkInterfaceAttachment?
        /// The type of interface.
        public let interfaceType: NetworkInterfaceType?
        /// Any tags assigned to the network interface.
        public let tagSet: TagList?
        /// The IPv4 address of the network interface within the subnet.
        public let privateIpAddress: String?
        /// The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).
        public let requesterId: String?
        /// A description.
        public let description: String?
        /// The AWS account ID of the owner of the network interface.
        public let ownerId: String?
        /// The private IPv4 addresses associated with the network interface.
        public let privateIpAddresses: NetworkInterfacePrivateIpAddressList?
        /// The ID of the VPC.
        public let vpcId: String?
        /// The Availability Zone.
        public let availabilityZone: String?
        /// The status of the network interface.
        public let status: NetworkInterfaceStatus?
        /// Indicates whether the network interface is being managed by AWS.
        public let requesterManaged: Bool?
        /// The IPv6 addresses associated with the network interface.
        public let ipv6Addresses: NetworkInterfaceIpv6AddressesList?
        /// Any security groups for the network interface.
        public let groups: GroupIdentifierList?
        /// The association information for an Elastic IP address (IPv4) associated with the network interface.
        public let association: NetworkInterfaceAssociation?

        public init(subnetId: String? = nil, networkInterfaceId: String? = nil, macAddress: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, attachment: NetworkInterfaceAttachment? = nil, interfaceType: NetworkInterfaceType? = nil, tagSet: TagList? = nil, privateIpAddress: String? = nil, requesterId: String? = nil, description: String? = nil, ownerId: String? = nil, privateIpAddresses: NetworkInterfacePrivateIpAddressList? = nil, vpcId: String? = nil, availabilityZone: String? = nil, status: NetworkInterfaceStatus? = nil, requesterManaged: Bool? = nil, ipv6Addresses: NetworkInterfaceIpv6AddressesList? = nil, groups: GroupIdentifierList? = nil, association: NetworkInterfaceAssociation? = nil) {
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.macAddress = macAddress
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.attachment = attachment
            self.interfaceType = interfaceType
            self.tagSet = tagSet
            self.privateIpAddress = privateIpAddress
            self.requesterId = requesterId
            self.description = description
            self.ownerId = ownerId
            self.privateIpAddresses = privateIpAddresses
            self.vpcId = vpcId
            self.availabilityZone = availabilityZone
            self.status = status
            self.requesterManaged = requesterManaged
            self.ipv6Addresses = ipv6Addresses
            self.groups = groups
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.macAddress = dictionary["MacAddress"] as? String
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? Bool
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.NetworkInterfaceAttachment(dictionary: attachment) } else { self.attachment = nil }
            if let interfaceType = dictionary["InterfaceType"] as? String { self.interfaceType = NetworkInterfaceType(rawValue: interfaceType) } else { self.interfaceType = nil }
            if let tagSet = dictionary["TagSet"] as? [String: Any] { self.tagSet = try Ec2.TagList(dictionary: tagSet) } else { self.tagSet = nil }
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.requesterId = dictionary["RequesterId"] as? String
            self.description = dictionary["Description"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let privateIpAddresses = dictionary["PrivateIpAddressesSet"] as? [String: Any] { self.privateIpAddresses = try Ec2.NetworkInterfacePrivateIpAddressList(dictionary: privateIpAddresses) } else { self.privateIpAddresses = nil }
            self.vpcId = dictionary["VpcId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let status = dictionary["Status"] as? String { self.status = NetworkInterfaceStatus(rawValue: status) } else { self.status = nil }
            self.requesterManaged = dictionary["RequesterManaged"] as? Bool
            if let ipv6Addresses = dictionary["Ipv6AddressesSet"] as? [String: Any] { self.ipv6Addresses = try Ec2.NetworkInterfaceIpv6AddressesList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            if let groups = dictionary["GroupSet"] as? [String: Any] { self.groups = try Ec2.GroupIdentifierList(dictionary: groups) } else { self.groups = nil }
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.NetworkInterfaceAssociation(dictionary: association) } else { self.association = nil }
        }
    }

    public struct VolumeModificationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VolumeModification]?

        public init(item: [VolumeModification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VolumeModification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum VolumeModificationState: String, CustomStringConvertible {
        case modifying = "modifying"
        case optimizing = "optimizing"
        case completed = "completed"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public struct Subnet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether instances launched in this subnet receive a public IPv4 address.
        public let mapPublicIpOnLaunch: Bool?
        /// The ID of the subnet.
        public let subnetId: String?
        /// Indicates whether this is the default subnet for the Availability Zone.
        public let defaultForAz: Bool?
        /// The ID of the VPC the subnet is in.
        public let vpcId: String?
        /// The current state of the subnet.
        public let state: SubnetState?
        /// Any tags assigned to the subnet.
        public let tags: TagList?
        /// Indicates whether a network interface created in this subnet (including a network interface created by RunInstances) receives an IPv6 address.
        public let assignIpv6AddressOnCreation: Bool?
        /// Information about the IPv6 CIDR blocks associated with the subnet.
        public let ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociationSet?
        /// The number of unused private IPv4 addresses in the subnet. Note that the IPv4 addresses for any stopped instances are considered unavailable.
        public let availableIpAddressCount: Int32?
        /// The Availability Zone of the subnet.
        public let availabilityZone: String?
        /// The IPv4 CIDR block assigned to the subnet.
        public let cidrBlock: String?

        public init(mapPublicIpOnLaunch: Bool? = nil, subnetId: String? = nil, defaultForAz: Bool? = nil, vpcId: String? = nil, state: SubnetState? = nil, tags: TagList? = nil, assignIpv6AddressOnCreation: Bool? = nil, ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociationSet? = nil, availableIpAddressCount: Int32? = nil, availabilityZone: String? = nil, cidrBlock: String? = nil) {
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.subnetId = subnetId
            self.defaultForAz = defaultForAz
            self.vpcId = vpcId
            self.state = state
            self.tags = tags
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.availableIpAddressCount = availableIpAddressCount
            self.availabilityZone = availabilityZone
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.mapPublicIpOnLaunch = dictionary["MapPublicIpOnLaunch"] as? Bool
            self.subnetId = dictionary["SubnetId"] as? String
            self.defaultForAz = dictionary["DefaultForAz"] as? Bool
            self.vpcId = dictionary["VpcId"] as? String
            if let state = dictionary["State"] as? String { self.state = SubnetState(rawValue: state) } else { self.state = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.assignIpv6AddressOnCreation = dictionary["AssignIpv6AddressOnCreation"] as? Bool
            if let ipv6CidrBlockAssociationSet = dictionary["Ipv6CidrBlockAssociationSet"] as? [String: Any] { self.ipv6CidrBlockAssociationSet = try Ec2.SubnetIpv6CidrBlockAssociationSet(dictionary: ipv6CidrBlockAssociationSet) } else { self.ipv6CidrBlockAssociationSet = nil }
            self.availableIpAddressCount = dictionary["AvailableIpAddressCount"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.cidrBlock = dictionary["CidrBlock"] as? String
        }
    }

    public struct CancelSpotInstanceRequestsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Spot instance requests.
        public let cancelledSpotInstanceRequests: CancelledSpotInstanceRequestList?

        public init(cancelledSpotInstanceRequests: CancelledSpotInstanceRequestList? = nil) {
            self.cancelledSpotInstanceRequests = cancelledSpotInstanceRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let cancelledSpotInstanceRequests = dictionary["SpotInstanceRequestSet"] as? [String: Any] { self.cancelledSpotInstanceRequests = try Ec2.CancelledSpotInstanceRequestList(dictionary: cancelledSpotInstanceRequests) } else { self.cancelledSpotInstanceRequests = nil }
        }
    }

    public struct DhcpConfigurationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [DhcpConfiguration]?

        public init(item: [DhcpConfiguration]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try DhcpConfiguration(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct EnableVolumeIORequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the volume.
        public let volumeId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(volumeId: String, dryRun: Bool? = nil) {
            self.volumeId = volumeId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct VolumeIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let volumeId: [String]?

        public init(volumeId: [String]? = nil) {
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.volumeId = dictionary["VolumeId"] as? [String]
        }
    }

    public struct AssociateSubnetCidrBlockResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String?
        /// Information about the IPv6 CIDR block association.
        public let ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation?

        public init(subnetId: String? = nil, ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil) {
            self.subnetId = subnetId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.SubnetIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) } else { self.ipv6CidrBlockAssociation = nil }
        }
    }

    public struct EventInformation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The event. The following are the error events.    iamFleetRoleInvalid - The Spot fleet did not have the required permissions either to launch or terminate an instance.    launchSpecTemporarilyBlacklisted - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.    spotFleetRequestConfigurationInvalid - The configuration is not valid. For more information, see the description of the event.    spotInstanceCountLimitExceeded - You've reached the limit on the number of Spot instances that you can launch.   The following are the fleetRequestChange events.    active - The Spot fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot instances.    cancelled - The Spot fleet is canceled and has no running Spot instances. The Spot fleet will be deleted two days after its instances were terminated.    cancelled_running - The Spot fleet is canceled and will not launch additional Spot instances, but its existing Spot instances continue to run until they are interrupted or terminated.    cancelled_terminating - The Spot fleet is canceled and its Spot instances are terminating.    expired - The Spot fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with TerminateInstancesWithExpiration set.    modify_in_progress - A request to modify the Spot fleet request was accepted and is in progress.    modify_successful - The Spot fleet request was modified.    price_update - The bid price for a launch configuration was adjusted because it was too high. This change is permanent.    submitted - The Spot fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot instances.   The following are the instanceChange events.    launched - A bid was fulfilled and a new instance was launched.    terminated - An instance was terminated by the user.  
        public let eventSubType: String?
        /// The ID of the instance. This information is available only for instanceChange events.
        public let instanceId: String?
        /// The description of the event.
        public let eventDescription: String?

        public init(eventSubType: String? = nil, instanceId: String? = nil, eventDescription: String? = nil) {
            self.eventSubType = eventSubType
            self.instanceId = instanceId
            self.eventDescription = eventDescription
        }

        public init(dictionary: [String: Any]) throws {
            self.eventSubType = dictionary["EventSubType"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.eventDescription = dictionary["EventDescription"] as? String
        }
    }

    public struct ProductCodeList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ProductCode]?

        public init(item: [ProductCode]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ProductCode(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ExecutableByStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let executableBy: [String]?

        public init(executableBy: [String]? = nil) {
            self.executableBy = executableBy
        }

        public init(dictionary: [String: Any]) throws {
            self.executableBy = dictionary["ExecutableBy"] as? [String]
        }
    }

    public struct DescribeSubnetsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more subnet IDs. Default: Describes all your subnets.
        public let subnetIds: SubnetIdStringList?
        /// One or more filters.    availabilityZone - The Availability Zone for the subnet. You can also use availability-zone as the filter name.    available-ip-address-count - The number of IPv4 addresses in the subnet that are available.    cidrBlock - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use cidr or cidr-block as the filter names.    defaultForAz - Indicates whether this is the default subnet for the Availability Zone. You can also use default-for-az as the filter name.    ipv6-cidr-block-association.ipv6-cidr-block - An IPv6 CIDR block associated with the subnet.    ipv6-cidr-block-association.association-id - An association ID for an IPv6 CIDR block associated with the subnet.    ipv6-cidr-block-association.state - The state of an IPv6 CIDR block associated with the subnet.    state - The state of the subnet (pending | available).    subnet-id - The ID of the subnet.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the subnet.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(subnetIds: SubnetIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.subnetIds = subnetIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let subnetIds = dictionary["SubnetId"] as? [String: Any] { self.subnetIds = try Ec2.SubnetIdStringList(dictionary: subnetIds) } else { self.subnetIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeTagsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return..
        public let nextToken: String?
        /// A list of tags.
        public let tags: TagDescriptionList?

        public init(nextToken: String? = nil, tags: TagDescriptionList? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagDescriptionList(dictionary: tags) } else { self.tags = nil }
        }
    }

    public struct AcceptReservedInstancesExchangeQuoteResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the successful exchange.
        public let exchangeId: String?

        public init(exchangeId: String? = nil) {
            self.exchangeId = exchangeId
        }

        public init(dictionary: [String: Any]) throws {
            self.exchangeId = dictionary["ExchangeId"] as? String
        }
    }

    public struct DescribeNatGatewaysRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    nat-gateway-id - The ID of the NAT gateway.    state - The state of the NAT gateway (pending | failed | available | deleting | deleted).    subnet-id - The ID of the subnet in which the NAT gateway resides.    vpc-id - The ID of the VPC in which the NAT gateway resides.  
        public let filter: FilterList?
        /// One or more NAT gateway IDs.
        public let natGatewayIds: ValueStringList?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value specified is greater than 1000, we return only 1000 items.
        public let maxResults: Int32?

        public init(filter: FilterList? = nil, natGatewayIds: ValueStringList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.natGatewayIds = natGatewayIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [String: Any] { self.filter = try Ec2.FilterList(dictionary: filter) } else { self.filter = nil }
            if let natGatewayIds = dictionary["NatGatewayId"] as? [String: Any] { self.natGatewayIds = try Ec2.ValueStringList(dictionary: natGatewayIds) } else { self.natGatewayIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public enum ExportEnvironment: String, CustomStringConvertible {
        case citrix = "citrix"
        case vmware = "vmware"
        case microsoft = "microsoft"
        public var description: String { return self.rawValue }
    }

    public enum DatafeedSubscriptionState: String, CustomStringConvertible {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum DomainType: String, CustomStringConvertible {
        case vpc = "vpc"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public enum FlowLogsResourceType: String, CustomStringConvertible {
        case vpc = "VPC"
        case subnet = "Subnet"
        case networkinterface = "NetworkInterface"
        public var description: String { return self.rawValue }
    }

    public struct NetworkInterfacePrivateIpAddress: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The private IPv4 address.
        public let privateIpAddress: String?
        /// The private DNS name.
        public let privateDnsName: String?
        /// Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.
        public let primary: Bool?
        /// The association information for an Elastic IP address (IPv4) associated with the network interface.
        public let association: NetworkInterfaceAssociation?

        public init(privateIpAddress: String? = nil, privateDnsName: String? = nil, primary: Bool? = nil, association: NetworkInterfaceAssociation? = nil) {
            self.privateIpAddress = privateIpAddress
            self.privateDnsName = privateDnsName
            self.primary = primary
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.primary = dictionary["Primary"] as? Bool
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.NetworkInterfaceAssociation(dictionary: association) } else { self.association = nil }
        }
    }

    public struct DescribeNetworkAclsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more network ACLs.
        public let networkAcls: NetworkAclList?

        public init(networkAcls: NetworkAclList? = nil) {
            self.networkAcls = networkAcls
        }

        public init(dictionary: [String: Any]) throws {
            if let networkAcls = dictionary["NetworkAclSet"] as? [String: Any] { self.networkAcls = try Ec2.NetworkAclList(dictionary: networkAcls) } else { self.networkAcls = nil }
        }
    }

    public struct ReservedInstancesListing: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the Reserved Instance listing.
        public let status: ListingStatus?
        /// The price of the Reserved Instance listing.
        public let priceSchedules: PriceScheduleList?
        /// The ID of the Reserved Instance listing.
        public let reservedInstancesListingId: String?
        /// A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see Ensuring Idempotency.
        public let clientToken: String?
        /// Any tags assigned to the resource.
        public let tags: TagList?
        /// The last modified timestamp of the listing.
        public let updateDate: Date?
        /// The ID of the Reserved Instance.
        public let reservedInstancesId: String?
        /// The time the listing was created.
        public let createDate: Date?
        /// The reason for the current status of the Reserved Instance listing. The response can be blank.
        public let statusMessage: String?
        /// The number of instances in this state.
        public let instanceCounts: InstanceCountList?

        public init(status: ListingStatus? = nil, priceSchedules: PriceScheduleList? = nil, reservedInstancesListingId: String? = nil, clientToken: String? = nil, tags: TagList? = nil, updateDate: Date? = nil, reservedInstancesId: String? = nil, createDate: Date? = nil, statusMessage: String? = nil, instanceCounts: InstanceCountList? = nil) {
            self.status = status
            self.priceSchedules = priceSchedules
            self.reservedInstancesListingId = reservedInstancesListingId
            self.clientToken = clientToken
            self.tags = tags
            self.updateDate = updateDate
            self.reservedInstancesId = reservedInstancesId
            self.createDate = createDate
            self.statusMessage = statusMessage
            self.instanceCounts = instanceCounts
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["Status"] as? String { self.status = ListingStatus(rawValue: status) } else { self.status = nil }
            if let priceSchedules = dictionary["PriceSchedules"] as? [String: Any] { self.priceSchedules = try Ec2.PriceScheduleList(dictionary: priceSchedules) } else { self.priceSchedules = nil }
            self.reservedInstancesListingId = dictionary["ReservedInstancesListingId"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.updateDate = dictionary["UpdateDate"] as? Date
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            self.createDate = dictionary["CreateDate"] as? Date
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let instanceCounts = dictionary["InstanceCounts"] as? [String: Any] { self.instanceCounts = try Ec2.InstanceCountList(dictionary: instanceCounts) } else { self.instanceCounts = nil }
        }
    }

    public struct ReservedInstanceIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let reservedInstanceId: [String]?

        public init(reservedInstanceId: [String]? = nil) {
            self.reservedInstanceId = reservedInstanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstanceId = dictionary["ReservedInstanceId"] as? [String]
        }
    }

    public struct DeleteNetworkAclRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the network ACL.
        public let networkAclId: String

        public init(dryRun: Bool? = nil, networkAclId: String) {
            self.dryRun = dryRun
            self.networkAclId = networkAclId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
        }
    }

    public struct DescribeConversionTaskList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ConversionTask]?

        public init(item: [ConversionTask]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ConversionTask(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AllocateHostsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID. Default: Enabled
        public let autoPlacement: AutoPlacement?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide. 
        public let clientToken: String?
        /// Specify the instance type that you want your Dedicated Hosts to be configured for. When you specify the instance type, that is the only instance type that you can launch onto that host.
        public let instanceType: String
        /// The Availability Zone for the Dedicated Hosts.
        public let availabilityZone: String
        /// The number of Dedicated Hosts you want to allocate to your account with these parameters.
        public let quantity: Int32

        public init(autoPlacement: AutoPlacement? = nil, clientToken: String? = nil, instanceType: String, availabilityZone: String, quantity: Int32) {
            self.autoPlacement = autoPlacement
            self.clientToken = clientToken
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.quantity = quantity
        }

        public init(dictionary: [String: Any]) throws {
            if let autoPlacement = dictionary["AutoPlacement"] as? String { self.autoPlacement = AutoPlacement(rawValue: autoPlacement) } else { self.autoPlacement = nil }
            self.clientToken = dictionary["ClientToken"] as? String
            guard let instanceType = dictionary["InstanceType"] as? String else { throw InitializableError.missingRequiredParam("InstanceType") }
            self.instanceType = instanceType
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            guard let quantity = dictionary["Quantity"] as? Int32 else { throw InitializableError.missingRequiredParam("Quantity") }
            self.quantity = quantity
        }
    }

    public struct DescribeVpcEndpointServicesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public let nextToken: String?
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value is greater than 1000, we return only 1000 items.
        public let maxResults: Int32?

        public init(dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct UnassignIpv6AddressesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 addresses to unassign from the network interface.
        public let ipv6Addresses: Ipv6AddressList
        /// The ID of the network interface.
        public let networkInterfaceId: String

        public init(ipv6Addresses: Ipv6AddressList, networkInterfaceId: String) {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let ipv6Addresses = dictionary["Ipv6Addresses"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Ipv6Addresses") }
            self.ipv6Addresses = try Ec2.Ipv6AddressList(dictionary: ipv6Addresses)
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
        }
    }

    public struct BundleInstanceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the bundle task.
        public let bundleTask: BundleTask?

        public init(bundleTask: BundleTask? = nil) {
            self.bundleTask = bundleTask
        }

        public init(dictionary: [String: Any]) throws {
            if let bundleTask = dictionary["BundleInstanceTask"] as? [String: Any] { self.bundleTask = try Ec2.BundleTask(dictionary: bundleTask) } else { self.bundleTask = nil }
        }
    }

    public struct DeletePlacementGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The name of the placement group.
        public let groupName: String

        public init(dryRun: Bool? = nil, groupName: String) {
            self.dryRun = dryRun
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let groupName = dictionary["GroupName"] as? String else { throw InitializableError.missingRequiredParam("GroupName") }
            self.groupName = groupName
        }
    }

    public struct PrefixListId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the prefix.
        public let prefixListId: String?

        public init(prefixListId: String? = nil) {
            self.prefixListId = prefixListId
        }

        public init(dictionary: [String: Any]) throws {
            self.prefixListId = dictionary["PrefixListId"] as? String
        }
    }

    public struct PeeringConnectionOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.
        public let allowEgressFromLocalVpcToRemoteClassicLink: Bool?
        /// If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        public let allowDnsResolutionFromRemoteVpc: Bool?
        /// If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.
        public let allowEgressFromLocalClassicLinkToRemoteVpc: Bool?

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

        public init(dictionary: [String: Any]) throws {
            self.allowEgressFromLocalVpcToRemoteClassicLink = dictionary["AllowEgressFromLocalVpcToRemoteClassicLink"] as? Bool
            self.allowDnsResolutionFromRemoteVpc = dictionary["AllowDnsResolutionFromRemoteVpc"] as? Bool
            self.allowEgressFromLocalClassicLinkToRemoteVpc = dictionary["AllowEgressFromLocalClassicLinkToRemoteVpc"] as? Bool
        }
    }

    public struct AccountAttributeValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of the attribute.
        public let attributeValue: String?

        public init(attributeValue: String? = nil) {
            self.attributeValue = attributeValue
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeValue = dictionary["AttributeValue"] as? String
        }
    }

    public struct PurchaseScheduledInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more purchase requests.
        public let purchaseRequests: PurchaseRequestSet
        /// Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see Ensuring Idempotency.
        public let clientToken: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(purchaseRequests: PurchaseRequestSet, clientToken: String? = nil, dryRun: Bool? = nil) {
            self.purchaseRequests = purchaseRequests
            self.clientToken = clientToken
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let purchaseRequests = dictionary["PurchaseRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("PurchaseRequest") }
            self.purchaseRequests = try Ec2.PurchaseRequestSet(dictionary: purchaseRequests)
            self.clientToken = dictionary["ClientToken"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeHostReservationOfferingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// This is the maximum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.
        public let maxDuration: Int32?
        /// This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.
        public let minDuration: Int32?
        /// One or more filters.    instance-family - The instance family of the offering (e.g., m4).    payment-option - The payment option (NoUpfront | PartialUpfront | AllUpfront).  
        public let filter: FilterList?
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?
        /// The ID of the reservation offering.
        public let offeringId: String?
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error.
        public let maxResults: Int32?

        public init(maxDuration: Int32? = nil, minDuration: Int32? = nil, filter: FilterList? = nil, nextToken: String? = nil, offeringId: String? = nil, maxResults: Int32? = nil) {
            self.maxDuration = maxDuration
            self.minDuration = minDuration
            self.filter = filter
            self.nextToken = nextToken
            self.offeringId = offeringId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.maxDuration = dictionary["MaxDuration"] as? Int32
            self.minDuration = dictionary["MinDuration"] as? Int32
            if let filter = dictionary["Filter"] as? [String: Any] { self.filter = try Ec2.FilterList(dictionary: filter) } else { self.filter = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.offeringId = dictionary["OfferingId"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct StopInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more stopped instances.
        public let stoppingInstances: InstanceStateChangeList?

        public init(stoppingInstances: InstanceStateChangeList? = nil) {
            self.stoppingInstances = stoppingInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let stoppingInstances = dictionary["InstancesSet"] as? [String: Any] { self.stoppingInstances = try Ec2.InstanceStateChangeList(dictionary: stoppingInstances) } else { self.stoppingInstances = nil }
        }
    }

    public struct OccurrenceDaySet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Int32]?

        public init(item: [Int32]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [Int32]
        }
    }

    public struct DescribeScheduledInstanceAvailabilityRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time period for the first schedule to start.
        public let firstSlotStartTimeRange: SlotDateTimeRangeRequest
        /// The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.
        public let minSlotDurationInHours: Int32?
        /// The maximum available duration, in hours. This value must be greater than MinSlotDurationInHours and less than 1,720.
        public let maxSlotDurationInHours: Int32?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    availability-zone - The Availability Zone (for example, us-west-2a).    instance-type - The instance type (for example, c4.large).    network-platform - The network platform (EC2-Classic or EC2-VPC).    platform - The platform (Linux/UNIX or Windows).  
        public let filters: FilterList?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The schedule recurrence.
        public let recurrence: ScheduledInstanceRecurrenceRequest
        /// The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(firstSlotStartTimeRange: SlotDateTimeRangeRequest, minSlotDurationInHours: Int32? = nil, maxSlotDurationInHours: Int32? = nil, dryRun: Bool? = nil, filters: FilterList? = nil, nextToken: String? = nil, recurrence: ScheduledInstanceRecurrenceRequest, maxResults: Int32? = nil) {
            self.firstSlotStartTimeRange = firstSlotStartTimeRange
            self.minSlotDurationInHours = minSlotDurationInHours
            self.maxSlotDurationInHours = maxSlotDurationInHours
            self.dryRun = dryRun
            self.filters = filters
            self.nextToken = nextToken
            self.recurrence = recurrence
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let firstSlotStartTimeRange = dictionary["FirstSlotStartTimeRange"] as? [String: Any] else { throw InitializableError.missingRequiredParam("FirstSlotStartTimeRange") }
            self.firstSlotStartTimeRange = try Ec2.SlotDateTimeRangeRequest(dictionary: firstSlotStartTimeRange)
            self.minSlotDurationInHours = dictionary["MinSlotDurationInHours"] as? Int32
            self.maxSlotDurationInHours = dictionary["MaxSlotDurationInHours"] as? Int32
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.nextToken = dictionary["NextToken"] as? String
            guard let recurrence = dictionary["Recurrence"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Recurrence") }
            self.recurrence = try Ec2.ScheduledInstanceRecurrenceRequest(dictionary: recurrence)
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ReservedInstancesModificationResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.
        public let reservedInstancesId: String?
        /// The target Reserved Instances configurations supplied as part of the modification request.
        public let targetConfiguration: ReservedInstancesConfiguration?

        public init(reservedInstancesId: String? = nil, targetConfiguration: ReservedInstancesConfiguration? = nil) {
            self.reservedInstancesId = reservedInstancesId
            self.targetConfiguration = targetConfiguration
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            if let targetConfiguration = dictionary["TargetConfiguration"] as? [String: Any] { self.targetConfiguration = try Ec2.ReservedInstancesConfiguration(dictionary: targetConfiguration) } else { self.targetConfiguration = nil }
        }
    }

    public struct EnableVpcClassicLinkDnsSupportResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ImportVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The disk image.
        public let image: DiskImageDetail
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The volume size.
        public let volume: VolumeDetail
        /// The Availability Zone for the resulting EBS volume.
        public let availabilityZone: String
        /// A description of the volume.
        public let description: String?

        public init(image: DiskImageDetail, dryRun: Bool? = nil, volume: VolumeDetail, availabilityZone: String, description: String? = nil) {
            self.image = image
            self.dryRun = dryRun
            self.volume = volume
            self.availabilityZone = availabilityZone
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Ec2.DiskImageDetail(dictionary: image)
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let volume = dictionary["Volume"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volume") }
            self.volume = try Ec2.VolumeDetail(dictionary: volume)
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ScheduledInstancesNetworkInterfaceSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let networkInterface: [ScheduledInstancesNetworkInterface]?

        public init(networkInterface: [ScheduledInstancesNetworkInterface]? = nil) {
            self.networkInterface = networkInterface
        }

        public init(dictionary: [String: Any]) throws {
            if let networkInterface = dictionary["NetworkInterface"] as? [[String: Any]] {
                self.networkInterface = try networkInterface.map({ try ScheduledInstancesNetworkInterface(dictionary: $0) })
            } else { 
                self.networkInterface = nil
            }
        }
    }

    public enum VolumeAttachmentState: String, CustomStringConvertible {
        case attaching = "attaching"
        case attached = "attached"
        case detaching = "detaching"
        case detached = "detached"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible {
        case instancechange = "instanceChange"
        case fleetrequestchange = "fleetRequestChange"
        case error = "error"
        public var description: String { return self.rawValue }
    }

    public struct DescribeAddressesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-Classic] One or more Elastic IP addresses. Default: Describes all your Elastic IP addresses.
        public let publicIps: PublicIpStringList?
        /// [EC2-VPC] One or more allocation IDs. Default: Describes all your Elastic IP addresses.
        public let allocationIds: AllocationIdList?
        /// One or more filters. Filter names and values are case-sensitive.    allocation-id - [EC2-VPC] The allocation ID for the address.    association-id - [EC2-VPC] The association ID for the address.    domain - Indicates whether the address is for use in EC2-Classic (standard) or in a VPC (vpc).    instance-id - The ID of the instance the address is associated with, if any.    network-interface-id - [EC2-VPC] The ID of the network interface that the address is associated with, if any.    network-interface-owner-id - The AWS account ID of the owner.    private-ip-address - [EC2-VPC] The private IP address associated with the Elastic IP address.    public-ip - The Elastic IP address.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(publicIps: PublicIpStringList? = nil, allocationIds: AllocationIdList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.publicIps = publicIps
            self.allocationIds = allocationIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let publicIps = dictionary["PublicIp"] as? [String: Any] { self.publicIps = try Ec2.PublicIpStringList(dictionary: publicIps) } else { self.publicIps = nil }
            if let allocationIds = dictionary["AllocationId"] as? [String: Any] { self.allocationIds = try Ec2.AllocationIdList(dictionary: allocationIds) } else { self.allocationIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct Ipv6CidrBlock: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 CIDR block.
        public let ipv6CidrBlock: String?

        public init(ipv6CidrBlock: String? = nil) {
            self.ipv6CidrBlock = ipv6CidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
        }
    }

    public struct VolumeStatusActionsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VolumeStatusAction]?

        public init(item: [VolumeStatusAction]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VolumeStatusAction(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SecurityGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-VPC] One or more outbound rules associated with the security group.
        public let ipPermissionsEgress: IpPermissionList?
        /// The name of the security group.
        public let groupName: String?
        /// [EC2-VPC] The ID of the VPC for the security group.
        public let vpcId: String?
        /// One or more inbound rules associated with the security group.
        public let ipPermissions: IpPermissionList?
        /// Any tags assigned to the security group.
        public let tags: TagList?
        /// The AWS account ID of the owner of the security group.
        public let ownerId: String?
        /// The ID of the security group.
        public let groupId: String?
        /// A description of the security group.
        public let description: String?

        public init(ipPermissionsEgress: IpPermissionList? = nil, groupName: String? = nil, vpcId: String? = nil, ipPermissions: IpPermissionList? = nil, tags: TagList? = nil, ownerId: String? = nil, groupId: String? = nil, description: String? = nil) {
            self.ipPermissionsEgress = ipPermissionsEgress
            self.groupName = groupName
            self.vpcId = vpcId
            self.ipPermissions = ipPermissions
            self.tags = tags
            self.ownerId = ownerId
            self.groupId = groupId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let ipPermissionsEgress = dictionary["IpPermissionsEgress"] as? [String: Any] { self.ipPermissionsEgress = try Ec2.IpPermissionList(dictionary: ipPermissionsEgress) } else { self.ipPermissionsEgress = nil }
            self.groupName = dictionary["GroupName"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [String: Any] { self.ipPermissions = try Ec2.IpPermissionList(dictionary: ipPermissions) } else { self.ipPermissions = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.ownerId = dictionary["OwnerId"] as? String
            self.groupId = dictionary["GroupId"] as? String
            self.description = dictionary["GroupDescription"] as? String
        }
    }

    public struct DescribeAccountAttributesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more account attributes.
        public let accountAttributes: AccountAttributeList?

        public init(accountAttributes: AccountAttributeList? = nil) {
            self.accountAttributes = accountAttributes
        }

        public init(dictionary: [String: Any]) throws {
            if let accountAttributes = dictionary["AccountAttributeSet"] as? [String: Any] { self.accountAttributes = try Ec2.AccountAttributeList(dictionary: accountAttributes) } else { self.accountAttributes = nil }
        }
    }

    public struct ReplaceRouteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [IPv4 traffic only] The ID of a NAT gateway.
        public let natGatewayId: String?
        /// The ID of a network interface.
        public let networkInterfaceId: String?
        /// The ID of a NAT instance in your VPC.
        public let instanceId: String?
        /// The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.
        public let destinationIpv6CidrBlock: String?
        /// The ID of a VPC peering connection.
        public let vpcPeeringConnectionId: String?
        /// The ID of the route table.
        public let routeTableId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// [IPv6 traffic only] The ID of an egress-only Internet gateway.
        public let egressOnlyInternetGatewayId: String?
        /// The ID of an Internet gateway or virtual private gateway.
        public let gatewayId: String?
        /// The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.
        public let destinationCidrBlock: String?

        public init(natGatewayId: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, destinationIpv6CidrBlock: String? = nil, vpcPeeringConnectionId: String? = nil, routeTableId: String, dryRun: Bool? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            self.gatewayId = dictionary["GatewayId"] as? String
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
        }
    }

    public struct CreateRouteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [IPv4 traffic only] The ID of a NAT gateway.
        public let natGatewayId: String?
        /// The ID of a network interface.
        public let networkInterfaceId: String?
        /// The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        public let instanceId: String?
        /// The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.
        public let destinationIpv6CidrBlock: String?
        /// The ID of a VPC peering connection.
        public let vpcPeeringConnectionId: String?
        /// The ID of the route table for the route.
        public let routeTableId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// [IPv6 traffic only] The ID of an egress-only Internet gateway.
        public let egressOnlyInternetGatewayId: String?
        /// The ID of an Internet gateway or virtual private gateway attached to your VPC.
        public let gatewayId: String?
        /// The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.
        public let destinationCidrBlock: String?

        public init(natGatewayId: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, destinationIpv6CidrBlock: String? = nil, vpcPeeringConnectionId: String? = nil, routeTableId: String, dryRun: Bool? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            self.gatewayId = dictionary["GatewayId"] as? String
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
        }
    }

    public struct ImageIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let imageId: [String]?

        public init(imageId: [String]? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? [String]
        }
    }

    public struct DeleteVpnConnectionRouteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPN connection.
        public let vpnConnectionId: String
        /// The CIDR block associated with the local subnet of the customer network.
        public let destinationCidrBlock: String

        public init(vpnConnectionId: String, destinationCidrBlock: String) {
            self.vpnConnectionId = vpnConnectionId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpnConnectionId = dictionary["VpnConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpnConnectionId") }
            self.vpnConnectionId = vpnConnectionId
            guard let destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String else { throw InitializableError.missingRequiredParam("DestinationCidrBlock") }
            self.destinationCidrBlock = destinationCidrBlock
        }
    }

    public struct KeyPairInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the key pair.
        public let keyName: String?
        /// If you used CreateKeyPair to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used ImportKeyPair to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.
        public let keyFingerprint: String?

        public init(keyName: String? = nil, keyFingerprint: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? String
            self.keyFingerprint = dictionary["KeyFingerprint"] as? String
        }
    }

    public struct VolumeAttachment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time stamp when the attachment initiated.
        public let attachTime: Date?
        /// Indicates whether the EBS volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The device name.
        public let device: String?
        /// The ID of the instance.
        public let instanceId: String?
        /// The ID of the volume.
        public let volumeId: String?
        /// The attachment state of the volume.
        public let state: VolumeAttachmentState?

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, device: String? = nil, instanceId: String? = nil, volumeId: String? = nil, state: VolumeAttachmentState? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.device = device
            self.instanceId = instanceId
            self.volumeId = volumeId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.device = dictionary["Device"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
            if let state = dictionary["Status"] as? String { self.state = VolumeAttachmentState(rawValue: state) } else { self.state = nil }
        }
    }

    public struct ImportSnapshotTask: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description of the import snapshot task.
        public let description: String?
        /// Describes an import snapshot task.
        public let snapshotTaskDetail: SnapshotTaskDetail?
        /// The ID of the import snapshot task.
        public let importTaskId: String?

        public init(description: String? = nil, snapshotTaskDetail: SnapshotTaskDetail? = nil, importTaskId: String? = nil) {
            self.description = description
            self.snapshotTaskDetail = snapshotTaskDetail
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            if let snapshotTaskDetail = dictionary["SnapshotTaskDetail"] as? [String: Any] { self.snapshotTaskDetail = try Ec2.SnapshotTaskDetail(dictionary: snapshotTaskDetail) } else { self.snapshotTaskDetail = nil }
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct CreateNatGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The subnet in which to create the NAT gateway.
        public let subnetId: String
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency. Constraint: Maximum 64 ASCII characters.
        public let clientToken: String?
        /// The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.
        public let allocationId: String

        public init(subnetId: String, clientToken: String? = nil, allocationId: String) {
            self.subnetId = subnetId
            self.clientToken = clientToken
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            self.clientToken = dictionary["ClientToken"] as? String
            guard let allocationId = dictionary["AllocationId"] as? String else { throw InitializableError.missingRequiredParam("AllocationId") }
            self.allocationId = allocationId
        }
    }

    public struct LaunchPermissionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [LaunchPermission]?

        public init(item: [LaunchPermission]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try LaunchPermission(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AttachVpnGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the attachment.
        public let vpcAttachment: VpcAttachment?

        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcAttachment = dictionary["Attachment"] as? [String: Any] { self.vpcAttachment = try Ec2.VpcAttachment(dictionary: vpcAttachment) } else { self.vpcAttachment = nil }
        }
    }

    public struct RequestSpotInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360). The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates. Note that you can't specify an Availability Zone group or a launch group if you specify a duration.
        public let blockDurationMinutes: Int32?
        /// The user-specified name for a logical grouping of bids. When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active. If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group. Default: Instances are launched in any available Availability Zone.
        public let availabilityZoneGroup: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        public let clientToken: String?
        public let launchSpecification: RequestSpotLaunchSpecification?
        /// The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled. Default: The request is effective indefinitely.
        public let validFrom: Date?
        /// The maximum hourly price (bid) for any Spot instance launched to fulfill the request.
        public let spotPrice: String
        /// The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. Default: The request is effective indefinitely.
        public let validUntil: Date?
        /// The Spot instance request type. Default: one-time 
        public let `type`: SpotInstanceType?
        /// The maximum number of Spot instances to launch. Default: 1
        public let instanceCount: Int32?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The instance launch group. Launch groups are Spot instances that launch together and terminate together. Default: Instances are launched and terminated individually
        public let launchGroup: String?

        public init(blockDurationMinutes: Int32? = nil, availabilityZoneGroup: String? = nil, clientToken: String? = nil, launchSpecification: RequestSpotLaunchSpecification? = nil, validFrom: Date? = nil, spotPrice: String, validUntil: Date? = nil, type: SpotInstanceType? = nil, instanceCount: Int32? = nil, dryRun: Bool? = nil, launchGroup: String? = nil) {
            self.blockDurationMinutes = blockDurationMinutes
            self.availabilityZoneGroup = availabilityZoneGroup
            self.clientToken = clientToken
            self.launchSpecification = launchSpecification
            self.validFrom = validFrom
            self.spotPrice = spotPrice
            self.validUntil = validUntil
            self.`type` = `type`
            self.instanceCount = instanceCount
            self.dryRun = dryRun
            self.launchGroup = launchGroup
        }

        public init(dictionary: [String: Any]) throws {
            self.blockDurationMinutes = dictionary["BlockDurationMinutes"] as? Int32
            self.availabilityZoneGroup = dictionary["AvailabilityZoneGroup"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            if let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] { self.launchSpecification = try Ec2.RequestSpotLaunchSpecification(dictionary: launchSpecification) } else { self.launchSpecification = nil }
            self.validFrom = dictionary["ValidFrom"] as? Date
            guard let spotPrice = dictionary["SpotPrice"] as? String else { throw InitializableError.missingRequiredParam("SpotPrice") }
            self.spotPrice = spotPrice
            self.validUntil = dictionary["ValidUntil"] as? Date
            if let `type` = dictionary["Type"] as? String { self.`type` = SpotInstanceType(rawValue: `type`) } else { self.`type` = nil }
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.dryRun = dictionary["DryRun"] as? Bool
            self.launchGroup = dictionary["LaunchGroup"] as? String
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    architecture - The image architecture (i386 | x86_64).    block-device-mapping.delete-on-termination - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.    block-device-mapping.device-name - The device name for the EBS volume (for example, /dev/sdh).    block-device-mapping.snapshot-id - The ID of the snapshot used for the EBS volume.    block-device-mapping.volume-size - The volume size of the EBS volume, in GiB.    block-device-mapping.volume-type - The volume type of the EBS volume (gp2 | io1 | st1 | sc1 | standard).    description - The description of the image (provided during image creation).    ena-support - A Boolean that indicates whether enhanced networking with ENA is enabled.    hypervisor - The hypervisor type (ovm | xen).    image-id - The ID of the image.    image-type - The image type (machine | kernel | ramdisk).    is-public - A Boolean that indicates whether the image is public.    kernel-id - The kernel ID.    manifest-location - The location of the image manifest.    name - The name of the AMI (provided during image creation).    owner-alias - String value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.    owner-id - The AWS account ID of the image owner.    platform - The platform. To only list Windows-based AMIs, use windows.    product-code - The product code.    product-code.type - The type of the product code (devpay | marketplace).    ramdisk-id - The RAM disk ID.    root-device-name - The name of the root device volume (for example, /dev/sda1).    root-device-type - The type of the root device volume (ebs | instance-store).    state - The state of the image (available | pending | failed).    state-reason-code - The reason code for the state change.    state-reason-message - The message for the state change.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    virtualization-type - The virtualization type (paravirtual | hvm).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Scopes the images by users with explicit launch permissions. Specify an AWS account ID, self (the sender of the request), or all (public AMIs).
        public let executableUsers: ExecutableByStringList?
        /// One or more image IDs. Default: Describes all images available to you.
        public let imageIds: ImageIdStringList?
        /// Filters the images by the owner. Specify an AWS account ID, self (owner is the sender of the request), or an AWS owner alias (valid values are amazon | aws-marketplace | microsoft). Omitting this option returns all images for which you have launch permissions, regardless of ownership.
        public let owners: OwnerStringList?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, executableUsers: ExecutableByStringList? = nil, imageIds: ImageIdStringList? = nil, owners: OwnerStringList? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.executableUsers = executableUsers
            self.imageIds = imageIds
            self.owners = owners
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let executableUsers = dictionary["ExecutableBy"] as? [String: Any] { self.executableUsers = try Ec2.ExecutableByStringList(dictionary: executableUsers) } else { self.executableUsers = nil }
            if let imageIds = dictionary["ImageId"] as? [String: Any] { self.imageIds = try Ec2.ImageIdStringList(dictionary: imageIds) } else { self.imageIds = nil }
            if let owners = dictionary["Owner"] as? [String: Any] { self.owners = try Ec2.OwnerStringList(dictionary: owners) } else { self.owners = nil }
        }
    }

    public struct HostOffering: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upfront price of the offering. Does not apply to No Upfront offerings.
        public let upfrontPrice: String?
        /// The available payment option.
        public let paymentOption: PaymentOption?
        /// The ID of the offering.
        public let offeringId: String?
        /// The hourly price of the offering.
        public let hourlyPrice: String?
        /// The currency of the offering.
        public let currencyCode: CurrencyCodeValues?
        /// The duration of the offering (in seconds).
        public let duration: Int32?
        /// The instance family of the offering.
        public let instanceFamily: String?

        public init(upfrontPrice: String? = nil, paymentOption: PaymentOption? = nil, offeringId: String? = nil, hourlyPrice: String? = nil, currencyCode: CurrencyCodeValues? = nil, duration: Int32? = nil, instanceFamily: String? = nil) {
            self.upfrontPrice = upfrontPrice
            self.paymentOption = paymentOption
            self.offeringId = offeringId
            self.hourlyPrice = hourlyPrice
            self.currencyCode = currencyCode
            self.duration = duration
            self.instanceFamily = instanceFamily
        }

        public init(dictionary: [String: Any]) throws {
            self.upfrontPrice = dictionary["UpfrontPrice"] as? String
            if let paymentOption = dictionary["PaymentOption"] as? String { self.paymentOption = PaymentOption(rawValue: paymentOption) } else { self.paymentOption = nil }
            self.offeringId = dictionary["OfferingId"] as? String
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.duration = dictionary["Duration"] as? Int32
            self.instanceFamily = dictionary["InstanceFamily"] as? String
        }
    }

    public struct InstanceNetworkInterfaceSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a RunInstances request, you must provide the device index.
        public let deviceIndex: Int32?
        /// The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.
        public let subnetId: String?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The description of the network interface. Applies only if creating a network interface when launching an instance.
        public let description: String?
        /// The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        public let privateIpAddress: String?
        /// The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        public let secondaryPrivateIpAddressCount: Int32?
        /// One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        public let privateIpAddresses: PrivateIpAddressSpecificationList?
        /// A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        public let ipv6AddressCount: Int32?
        /// One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        public let ipv6Addresses: InstanceIpv6AddressList?
        /// If set to true, the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance.
        public let deleteOnTermination: Bool?
        /// Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
        public let associatePublicIpAddress: Bool?
        /// The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        public let groups: SecurityGroupIdStringList?

        public init(deviceIndex: Int32? = nil, subnetId: String? = nil, networkInterfaceId: String? = nil, description: String? = nil, privateIpAddress: String? = nil, secondaryPrivateIpAddressCount: Int32? = nil, privateIpAddresses: PrivateIpAddressSpecificationList? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: InstanceIpv6AddressList? = nil, deleteOnTermination: Bool? = nil, associatePublicIpAddress: Bool? = nil, groups: SecurityGroupIdStringList? = nil) {
            self.deviceIndex = deviceIndex
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.description = description
            self.privateIpAddress = privateIpAddress
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.privateIpAddresses = privateIpAddresses
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.deleteOnTermination = deleteOnTermination
            self.associatePublicIpAddress = associatePublicIpAddress
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.description = dictionary["Description"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            if let privateIpAddresses = dictionary["PrivateIpAddressesSet"] as? [String: Any] { self.privateIpAddresses = try Ec2.PrivateIpAddressSpecificationList(dictionary: privateIpAddresses) } else { self.privateIpAddresses = nil }
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6AddressesSet"] as? [String: Any] { self.ipv6Addresses = try Ec2.InstanceIpv6AddressList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.associatePublicIpAddress = dictionary["AssociatePublicIpAddress"] as? Bool
            if let groups = dictionary["SecurityGroupId"] as? [String: Any] { self.groups = try Ec2.SecurityGroupIdStringList(dictionary: groups) } else { self.groups = nil }
        }
    }

    public struct DeleteRouteTableRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the route table.
        public let routeTableId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(routeTableId: String, dryRun: Bool? = nil) {
            self.routeTableId = routeTableId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct NatGatewayAddress: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the network interface associated with the NAT gateway.
        public let networkInterfaceId: String?
        /// The Elastic IP address associated with the NAT gateway.
        public let publicIp: String?
        /// The private IP address associated with the Elastic IP address.
        public let privateIp: String?
        /// The allocation ID of the Elastic IP address that's associated with the NAT gateway.
        public let allocationId: String?

        public init(networkInterfaceId: String? = nil, publicIp: String? = nil, privateIp: String? = nil, allocationId: String? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.publicIp = publicIp
            self.privateIp = privateIp
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
            self.privateIp = dictionary["PrivateIp"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
        }
    }

    public struct DescribeNetworkInterfaceAttributeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description of the network interface.
        public let description: AttributeValue?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The attachment (if any) of the network interface.
        public let attachment: NetworkInterfaceAttachment?
        /// The security groups associated with the network interface.
        public let groups: GroupIdentifierList?
        /// Indicates whether source/destination checking is enabled.
        public let sourceDestCheck: AttributeBooleanValue?

        public init(description: AttributeValue? = nil, networkInterfaceId: String? = nil, attachment: NetworkInterfaceAttachment? = nil, groups: GroupIdentifierList? = nil, sourceDestCheck: AttributeBooleanValue? = nil) {
            self.description = description
            self.networkInterfaceId = networkInterfaceId
            self.attachment = attachment
            self.groups = groups
            self.sourceDestCheck = sourceDestCheck
        }

        public init(dictionary: [String: Any]) throws {
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) } else { self.description = nil }
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.NetworkInterfaceAttachment(dictionary: attachment) } else { self.attachment = nil }
            if let groups = dictionary["GroupSet"] as? [String: Any] { self.groups = try Ec2.GroupIdentifierList(dictionary: groups) } else { self.groups = nil }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) } else { self.sourceDestCheck = nil }
        }
    }

    public struct ModifyVpcEndpointResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ImportSnapshotRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Token to enable idempotency for VM import requests.
        public let clientToken: String?
        /// The name of the role to use when not using the default role, 'vmimport'.
        public let roleName: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The client-specific data.
        public let clientData: ClientData?
        /// Information about the disk container.
        public let diskContainer: SnapshotDiskContainer?
        /// The description string for the import snapshot task.
        public let description: String?

        public init(clientToken: String? = nil, roleName: String? = nil, dryRun: Bool? = nil, clientData: ClientData? = nil, diskContainer: SnapshotDiskContainer? = nil, description: String? = nil) {
            self.clientToken = clientToken
            self.roleName = roleName
            self.dryRun = dryRun
            self.clientData = clientData
            self.diskContainer = diskContainer
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.roleName = dictionary["RoleName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            if let clientData = dictionary["ClientData"] as? [String: Any] { self.clientData = try Ec2.ClientData(dictionary: clientData) } else { self.clientData = nil }
            if let diskContainer = dictionary["DiskContainer"] as? [String: Any] { self.diskContainer = try Ec2.SnapshotDiskContainer(dictionary: diskContainer) } else { self.diskContainer = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateVpcRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The tenancy options for instances launched into the VPC. For default, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For dedicated, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of dedicated or host into a dedicated tenancy VPC.   Important: The host value cannot be used with this parameter. Use the default or dedicated values only. Default: default 
        public let instanceTenancy: Tenancy?
        /// Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.
        public let amazonProvidedIpv6CidrBlock: Bool?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The IPv4 network range for the VPC, in CIDR notation. For example, 10.0.0.0/16.
        public let cidrBlock: String

        public init(instanceTenancy: Tenancy? = nil, amazonProvidedIpv6CidrBlock: Bool? = nil, dryRun: Bool? = nil, cidrBlock: String) {
            self.instanceTenancy = instanceTenancy
            self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
            self.dryRun = dryRun
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceTenancy = dictionary["InstanceTenancy"] as? String { self.instanceTenancy = Tenancy(rawValue: instanceTenancy) } else { self.instanceTenancy = nil }
            self.amazonProvidedIpv6CidrBlock = dictionary["AmazonProvidedIpv6CidrBlock"] as? Bool
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let cidrBlock = dictionary["CidrBlock"] as? String else { throw InitializableError.missingRequiredParam("CidrBlock") }
            self.cidrBlock = cidrBlock
        }
    }

    public struct DhcpOptionsIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let dhcpOptionsId: [String]?

        public init(dhcpOptionsId: [String]? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
        }

        public init(dictionary: [String: Any]) throws {
            self.dhcpOptionsId = dictionary["DhcpOptionsId"] as? [String]
        }
    }

    public struct CreateRouteTableRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVpcsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more VPCs.
        public let vpcs: VpcList?

        public init(vpcs: VpcList? = nil) {
            self.vpcs = vpcs
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcs = dictionary["VpcSet"] as? [String: Any] { self.vpcs = try Ec2.VpcList(dictionary: vpcs) } else { self.vpcs = nil }
        }
    }

    public struct ImportInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The disk image.
        public let diskImages: [DiskImage]?
        /// The instance operating system.
        public let platform: PlatformValues
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The launch specification.
        public let launchSpecification: ImportInstanceLaunchSpecification?
        /// A description for the instance being imported.
        public let description: String?

        public init(diskImages: [DiskImage]? = nil, platform: PlatformValues, dryRun: Bool? = nil, launchSpecification: ImportInstanceLaunchSpecification? = nil, description: String? = nil) {
            self.diskImages = diskImages
            self.platform = platform
            self.dryRun = dryRun
            self.launchSpecification = launchSpecification
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let diskImages = dictionary["DiskImage"] as? [[String: Any]] {
                self.diskImages = try diskImages.map({ try DiskImage(dictionary: $0) })
            } else { 
                self.diskImages = nil
            }
            guard let rawPlatform = dictionary["Platform"] as? String, let platform = PlatformValues(rawValue: rawPlatform) else { throw InitializableError.missingRequiredParam("Platform") }
            self.platform = platform
            self.dryRun = dictionary["DryRun"] as? Bool
            if let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] { self.launchSpecification = try Ec2.ImportInstanceLaunchSpecification(dictionary: launchSpecification) } else { self.launchSpecification = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateVpcEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        public let clientToken: String?
        /// The AWS service name, in the form com.amazonaws.region.service . To get a list of available services, use the DescribeVpcEndpointServices request.
        public let serviceName: String
        /// The ID of the VPC in which the endpoint will be used.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.
        public let policyDocument: String?
        /// One or more route table IDs.
        public let routeTableIds: ValueStringList?

        public init(clientToken: String? = nil, serviceName: String, vpcId: String, dryRun: Bool? = nil, policyDocument: String? = nil, routeTableIds: ValueStringList? = nil) {
            self.clientToken = clientToken
            self.serviceName = serviceName
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.policyDocument = policyDocument
            self.routeTableIds = routeTableIds
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            guard let serviceName = dictionary["ServiceName"] as? String else { throw InitializableError.missingRequiredParam("ServiceName") }
            self.serviceName = serviceName
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.policyDocument = dictionary["PolicyDocument"] as? String
            if let routeTableIds = dictionary["RouteTableId"] as? [String: Any] { self.routeTableIds = try Ec2.ValueStringList(dictionary: routeTableIds) } else { self.routeTableIds = nil }
        }
    }

    public struct MovingAddressStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.
        public let moveStatus: MoveStatus?
        /// The Elastic IP address.
        public let publicIp: String?

        public init(moveStatus: MoveStatus? = nil, publicIp: String? = nil) {
            self.moveStatus = moveStatus
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            if let moveStatus = dictionary["MoveStatus"] as? String { self.moveStatus = MoveStatus(rawValue: moveStatus) } else { self.moveStatus = nil }
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public enum SubnetState: String, CustomStringConvertible {
        case pending = "pending"
        case available = "available"
        public var description: String { return self.rawValue }
    }

    public struct AvailabilityZoneList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [AvailabilityZone]?

        public init(item: [AvailabilityZone]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try AvailabilityZone(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VpcIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let vpcId: [String]?

        public init(vpcId: [String]? = nil) {
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? [String]
        }
    }

    public struct DeregisterImageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the AMI.
        public let imageId: String

        public init(dryRun: Bool? = nil, imageId: String) {
            self.dryRun = dryRun
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct SpotPriceHistoryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SpotPrice]?

        public init(item: [SpotPrice]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SpotPrice(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DeleteSnapshotRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the EBS snapshot.
        public let snapshotId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(snapshotId: String, dryRun: Bool? = nil) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeReservedInstancesOfferingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum duration (in seconds) to filter when searching for offerings. Default: 94608000 (3 years)
        public let maxDuration: Int64?
        /// The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of dedicated is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances). Default: default 
        public let instanceTenancy: Tenancy?
        /// One or more Reserved Instances offering IDs.
        public let reservedInstancesOfferingIds: [String]?
        /// One or more filters.    availability-zone - The Availability Zone where the Reserved Instance can be used.    duration - The duration of the Reserved Instance (for example, one year or three years), in seconds (31536000 | 94608000).    fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).    instance-type - The instance type that is covered by the reservation.    marketplace - Set to true to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.    product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web |  Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC))     reserved-instances-offering-id - The Reserved Instances offering ID.    scope - The scope of the Reserved Instance (Availability Zone or Region).    usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The instance type that the reservation will cover (for example, m1.small). For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide.
        public let instanceType: InstanceType?
        /// The Availability Zone in which the Reserved Instance can be used.
        public let availabilityZone: String?
        /// The Reserved Instance product platform description. Instances that include (Amazon VPC) in the description are for use with Amazon VPC.
        public let productDescription: RIProductDescription?
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. The maximum is 100. Default: 100
        public let maxResults: Int32?
        /// The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type. 
        public let offeringType: OfferingTypeValues?
        /// The offering class of the Reserved Instance. Can be standard or convertible.
        public let offeringClass: OfferingClassType?
        /// Include Reserved Instance Marketplace offerings in the response.
        public let includeMarketplace: Bool?
        /// The minimum duration (in seconds) to filter when searching for offerings. Default: 2592000 (1 month)
        public let minDuration: Int64?
        /// The maximum number of instances to filter when searching for offerings. Default: 20
        public let maxInstanceCount: Int32?
        /// The token to retrieve the next page of results.
        public let nextToken: String?

        public init(maxDuration: Int64? = nil, instanceTenancy: Tenancy? = nil, reservedInstancesOfferingIds: [String]? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, instanceType: InstanceType? = nil, availabilityZone: String? = nil, productDescription: RIProductDescription? = nil, maxResults: Int32? = nil, offeringType: OfferingTypeValues? = nil, offeringClass: OfferingClassType? = nil, includeMarketplace: Bool? = nil, minDuration: Int64? = nil, maxInstanceCount: Int32? = nil, nextToken: String? = nil) {
            self.maxDuration = maxDuration
            self.instanceTenancy = instanceTenancy
            self.reservedInstancesOfferingIds = reservedInstancesOfferingIds
            self.filters = filters
            self.dryRun = dryRun
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.productDescription = productDescription
            self.maxResults = maxResults
            self.offeringType = offeringType
            self.offeringClass = offeringClass
            self.includeMarketplace = includeMarketplace
            self.minDuration = minDuration
            self.maxInstanceCount = maxInstanceCount
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.maxDuration = dictionary["MaxDuration"] as? Int64
            if let instanceTenancy = dictionary["InstanceTenancy"] as? String { self.instanceTenancy = Tenancy(rawValue: instanceTenancy) } else { self.instanceTenancy = nil }
            self.reservedInstancesOfferingIds = dictionary["ReservedInstancesOfferingId"] as? [String]
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let productDescription = dictionary["ProductDescription"] as? String { self.productDescription = RIProductDescription(rawValue: productDescription) } else { self.productDescription = nil }
            self.maxResults = dictionary["MaxResults"] as? Int32
            if let offeringType = dictionary["OfferingType"] as? String { self.offeringType = OfferingTypeValues(rawValue: offeringType) } else { self.offeringType = nil }
            if let offeringClass = dictionary["OfferingClass"] as? String { self.offeringClass = OfferingClassType(rawValue: offeringClass) } else { self.offeringClass = nil }
            self.includeMarketplace = dictionary["IncludeMarketplace"] as? Bool
            self.minDuration = dictionary["MinDuration"] as? Int64
            self.maxInstanceCount = dictionary["MaxInstanceCount"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CancelledSpotInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Spot instance request.
        public let spotInstanceRequestId: String?
        /// The state of the Spot instance request.
        public let state: CancelSpotInstanceRequestState?

        public init(spotInstanceRequestId: String? = nil, state: CancelSpotInstanceRequestState? = nil) {
            self.spotInstanceRequestId = spotInstanceRequestId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
            if let state = dictionary["State"] as? String { self.state = CancelSpotInstanceRequestState(rawValue: state) } else { self.state = nil }
        }
    }

    public struct VpcPeeringConnectionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpcPeeringConnection]?

        public init(item: [VpcPeeringConnection]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpcPeeringConnection(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct MovingAddressStatusSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [MovingAddressStatus]?

        public init(item: [MovingAddressStatus]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try MovingAddressStatus(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ModifyImageAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more product codes. After you add a product code to an AMI, it can't be removed. This is only valid when modifying the productCodes attribute.
        public let productCodes: ProductCodeStringList?
        /// A description for the AMI.
        public let description: AttributeValue?
        /// One or more AWS account IDs. This is only valid when modifying the launchPermission attribute.
        public let userIds: UserIdStringList?
        /// The ID of the AMI.
        public let imageId: String
        /// One or more user groups. This is only valid when modifying the launchPermission attribute.
        public let userGroups: UserGroupStringList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The name of the attribute to modify.
        public let attribute: String?
        /// The value of the attribute being modified. This is only valid when modifying the description attribute.
        public let value: String?
        /// A launch permission modification.
        public let launchPermission: LaunchPermissionModifications?
        /// The operation type.
        public let operationType: OperationType?

        public init(productCodes: ProductCodeStringList? = nil, description: AttributeValue? = nil, userIds: UserIdStringList? = nil, imageId: String, userGroups: UserGroupStringList? = nil, dryRun: Bool? = nil, attribute: String? = nil, value: String? = nil, launchPermission: LaunchPermissionModifications? = nil, operationType: OperationType? = nil) {
            self.productCodes = productCodes
            self.description = description
            self.userIds = userIds
            self.imageId = imageId
            self.userGroups = userGroups
            self.dryRun = dryRun
            self.attribute = attribute
            self.value = value
            self.launchPermission = launchPermission
            self.operationType = operationType
        }

        public init(dictionary: [String: Any]) throws {
            if let productCodes = dictionary["ProductCode"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeStringList(dictionary: productCodes) } else { self.productCodes = nil }
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) } else { self.description = nil }
            if let userIds = dictionary["UserId"] as? [String: Any] { self.userIds = try Ec2.UserIdStringList(dictionary: userIds) } else { self.userIds = nil }
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
            if let userGroups = dictionary["UserGroup"] as? [String: Any] { self.userGroups = try Ec2.UserGroupStringList(dictionary: userGroups) } else { self.userGroups = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.attribute = dictionary["Attribute"] as? String
            self.value = dictionary["Value"] as? String
            if let launchPermission = dictionary["LaunchPermission"] as? [String: Any] { self.launchPermission = try Ec2.LaunchPermissionModifications(dictionary: launchPermission) } else { self.launchPermission = nil }
            if let operationType = dictionary["OperationType"] as? String { self.operationType = OperationType(rawValue: operationType) } else { self.operationType = nil }
        }
    }

    public struct SubnetIpv6CidrBlockAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the state of the CIDR block.
        public let ipv6CidrBlockState: SubnetCidrBlockState?
        /// The IPv6 CIDR block.
        public let ipv6CidrBlock: String?
        /// The association ID for the CIDR block.
        public let associationId: String?

        public init(ipv6CidrBlockState: SubnetCidrBlockState? = nil, ipv6CidrBlock: String? = nil, associationId: String? = nil) {
            self.ipv6CidrBlockState = ipv6CidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            if let ipv6CidrBlockState = dictionary["Ipv6CidrBlockState"] as? [String: Any] { self.ipv6CidrBlockState = try Ec2.SubnetCidrBlockState(dictionary: ipv6CidrBlockState) } else { self.ipv6CidrBlockState = nil }
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct NetworkAclList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NetworkAcl]?

        public init(item: [NetworkAcl]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NetworkAcl(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VolumeStatusDetailsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VolumeStatusDetails]?

        public init(item: [VolumeStatusDetails]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VolumeStatusDetails(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CreateDhcpOptionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A set of DHCP options.
        public let dhcpOptions: DhcpOptions?

        public init(dhcpOptions: DhcpOptions? = nil) {
            self.dhcpOptions = dhcpOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let dhcpOptions = dictionary["DhcpOptions"] as? [String: Any] { self.dhcpOptions = try Ec2.DhcpOptions(dictionary: dhcpOptions) } else { self.dhcpOptions = nil }
        }
    }

    public struct InstanceNetworkInterfaceAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The public DNS name.
        public let publicDnsName: String?
        /// The ID of the owner of the Elastic IP address.
        public let ipOwnerId: String?
        /// The public IP address or Elastic IP address bound to the network interface.
        public let publicIp: String?

        public init(publicDnsName: String? = nil, ipOwnerId: String? = nil, publicIp: String? = nil) {
            self.publicDnsName = publicDnsName
            self.ipOwnerId = ipOwnerId
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.publicDnsName = dictionary["PublicDnsName"] as? String
            self.ipOwnerId = dictionary["IpOwnerId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct AddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Address]?

        public init(item: [Address]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Address(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct EbsInstanceBlockDevice: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time stamp when the attachment initiated.
        public let attachTime: Date?
        /// Indicates whether the volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The attachment state.
        public let status: AttachmentStatus?
        /// The ID of the EBS volume.
        public let volumeId: String?

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, status: AttachmentStatus? = nil, volumeId: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.status = status
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            if let status = dictionary["Status"] as? String { self.status = AttachmentStatus(rawValue: status) } else { self.status = nil }
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct CancelImportTaskRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The reason for canceling the task.
        public let cancelReason: String?
        /// The ID of the import image or import snapshot task to be canceled.
        public let importTaskId: String?

        public init(dryRun: Bool? = nil, cancelReason: String? = nil, importTaskId: String? = nil) {
            self.dryRun = dryRun
            self.cancelReason = cancelReason
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.cancelReason = dictionary["CancelReason"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct ReservedInstanceReservationValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Convertible Reserved Instance that you are exchanging.
        public let reservedInstanceId: String?
        /// The total value of the Convertible Reserved Instance that you are exchanging.
        public let reservationValue: ReservationValue?

        public init(reservedInstanceId: String? = nil, reservationValue: ReservationValue? = nil) {
            self.reservedInstanceId = reservedInstanceId
            self.reservationValue = reservationValue
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstanceId = dictionary["ReservedInstanceId"] as? String
            if let reservationValue = dictionary["ReservationValue"] as? [String: Any] { self.reservationValue = try Ec2.ReservationValue(dictionary: reservationValue) } else { self.reservationValue = nil }
        }
    }

    public struct CreateFlowLogsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the flow logs.
        public let flowLogIds: ValueStringList?
        /// Information about the flow logs that could not be created successfully.
        public let unsuccessful: UnsuccessfulItemSet?
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        public let clientToken: String?

        public init(flowLogIds: ValueStringList? = nil, unsuccessful: UnsuccessfulItemSet? = nil, clientToken: String? = nil) {
            self.flowLogIds = flowLogIds
            self.unsuccessful = unsuccessful
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            if let flowLogIds = dictionary["FlowLogIdSet"] as? [String: Any] { self.flowLogIds = try Ec2.ValueStringList(dictionary: flowLogIds) } else { self.flowLogIds = nil }
            if let unsuccessful = dictionary["Unsuccessful"] as? [String: Any] { self.unsuccessful = try Ec2.UnsuccessfulItemSet(dictionary: unsuccessful) } else { self.unsuccessful = nil }
            self.clientToken = dictionary["ClientToken"] as? String
        }
    }

    public struct StopInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more instance IDs.
        public let instanceIds: InstanceIdStringList
        /// Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances. Default: false 
        public let force: Bool?

        public init(dryRun: Bool? = nil, instanceIds: InstanceIdStringList, force: Bool? = nil) {
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.force = force
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceIds = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds)
            self.force = dictionary["Force"] as? Bool
        }
    }

    public struct AvailabilityZone: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the Availability Zone.
        public let zoneName: String?
        /// The state of the Availability Zone.
        public let state: AvailabilityZoneState?
        /// Any messages about the Availability Zone.
        public let messages: AvailabilityZoneMessageList?
        /// The name of the region.
        public let regionName: String?

        public init(zoneName: String? = nil, state: AvailabilityZoneState? = nil, messages: AvailabilityZoneMessageList? = nil, regionName: String? = nil) {
            self.zoneName = zoneName
            self.state = state
            self.messages = messages
            self.regionName = regionName
        }

        public init(dictionary: [String: Any]) throws {
            self.zoneName = dictionary["ZoneName"] as? String
            if let state = dictionary["ZoneState"] as? String { self.state = AvailabilityZoneState(rawValue: state) } else { self.state = nil }
            if let messages = dictionary["MessageSet"] as? [String: Any] { self.messages = try Ec2.AvailabilityZoneMessageList(dictionary: messages) } else { self.messages = nil }
            self.regionName = dictionary["RegionName"] as? String
        }
    }

    public struct VolumeStatusDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the volume status.
        public let name: VolumeStatusName?
        /// The intended status of the volume status.
        public let status: String?

        public init(name: VolumeStatusName? = nil, status: String? = nil) {
            self.name = name
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let name = dictionary["Name"] as? String { self.name = VolumeStatusName(rawValue: name) } else { self.name = nil }
            self.status = dictionary["Status"] as? String
        }
    }

    public struct DisassociateIamInstanceProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the IAM instance profile association.
        public let iamInstanceProfileAssociation: IamInstanceProfileAssociation?

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

        public init(dictionary: [String: Any]) throws {
            if let iamInstanceProfileAssociation = dictionary["IamInstanceProfileAssociation"] as? [String: Any] { self.iamInstanceProfileAssociation = try Ec2.IamInstanceProfileAssociation(dictionary: iamInstanceProfileAssociation) } else { self.iamInstanceProfileAssociation = nil }
        }
    }

    public enum AvailabilityZoneState: String, CustomStringConvertible {
        case available = "available"
        case information = "information"
        case impaired = "impaired"
        case unavailable = "unavailable"
        public var description: String { return self.rawValue }
    }

    public struct DescribeReservedInstancesModificationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// One or more filters.    client-token - The idempotency token for the modification request.    create-date - The time when the modification request was created.    effective-date - The time when the modification becomes effective.    modification-result.reserved-instances-id - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is fulfilled.    modification-result.target-configuration.availability-zone - The Availability Zone for the new Reserved Instances.    modification-result.target-configuration.instance-count  - The number of new Reserved Instances.    modification-result.target-configuration.instance-type - The instance type of the new Reserved Instances.    modification-result.target-configuration.platform - The network platform of the new Reserved Instances (EC2-Classic | EC2-VPC).    reserved-instances-id - The ID of the Reserved Instances modified.    reserved-instances-modification-id - The ID of the modification request.    status - The status of the Reserved Instances modification request (processing | fulfilled | failed).    status-message - The reason for the status.    update-date - The time when the modification request was last updated.  
        public let filters: FilterList?
        /// IDs for the submitted modification request.
        public let reservedInstancesModificationIds: ReservedInstancesModificationIdStringList?

        public init(nextToken: String? = nil, filters: FilterList? = nil, reservedInstancesModificationIds: ReservedInstancesModificationIdStringList? = nil) {
            self.nextToken = nextToken
            self.filters = filters
            self.reservedInstancesModificationIds = reservedInstancesModificationIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let reservedInstancesModificationIds = dictionary["ReservedInstancesModificationId"] as? [String: Any] { self.reservedInstancesModificationIds = try Ec2.ReservedInstancesModificationIdStringList(dictionary: reservedInstancesModificationIds) } else { self.reservedInstancesModificationIds = nil }
        }
    }

    public struct SpotInstanceStateFault: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The reason code for the Spot instance state change.
        public let code: String?
        /// The message for the Spot instance state change.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DescribeImagesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more images.
        public let images: ImageList?

        public init(images: ImageList? = nil) {
            self.images = images
        }

        public init(dictionary: [String: Any]) throws {
            if let images = dictionary["ImagesSet"] as? [String: Any] { self.images = try Ec2.ImageList(dictionary: images) } else { self.images = nil }
        }
    }

    public struct SecurityGroupIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let securityGroupId: [String]?

        public init(securityGroupId: [String]? = nil) {
            self.securityGroupId = securityGroupId
        }

        public init(dictionary: [String: Any]) throws {
            self.securityGroupId = dictionary["SecurityGroupId"] as? [String]
        }
    }

    public struct ScheduledInstancesPlacement: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Availability Zone.
        public let availabilityZone: String?
        /// The name of the placement group.
        public let groupName: String?

        public init(availabilityZone: String? = nil, groupName: String? = nil) {
            self.availabilityZone = availabilityZone
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct CancelSpotFleetRequestsSuccessItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The current state of the Spot fleet request.
        public let currentSpotFleetRequestState: BatchState
        /// The previous state of the Spot fleet request.
        public let previousSpotFleetRequestState: BatchState
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String

        public init(currentSpotFleetRequestState: BatchState, previousSpotFleetRequestState: BatchState, spotFleetRequestId: String) {
            self.currentSpotFleetRequestState = currentSpotFleetRequestState
            self.previousSpotFleetRequestState = previousSpotFleetRequestState
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawCurrentSpotFleetRequestState = dictionary["CurrentSpotFleetRequestState"] as? String, let currentSpotFleetRequestState = BatchState(rawValue: rawCurrentSpotFleetRequestState) else { throw InitializableError.missingRequiredParam("CurrentSpotFleetRequestState") }
            self.currentSpotFleetRequestState = currentSpotFleetRequestState
            guard let rawPreviousSpotFleetRequestState = dictionary["PreviousSpotFleetRequestState"] as? String, let previousSpotFleetRequestState = BatchState(rawValue: rawPreviousSpotFleetRequestState) else { throw InitializableError.missingRequiredParam("PreviousSpotFleetRequestState") }
            self.previousSpotFleetRequestState = previousSpotFleetRequestState
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct AuthorizeSecurityGroupIngressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-Classic] The AWS account number for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.
        public let sourceSecurityGroupOwnerId: String?
        /// [EC2-Classic, default VPC] The name of the security group.
        public let groupName: String?
        /// A set of IP permissions. Can be used to specify multiple rules in a single command.
        public let ipPermissions: IpPermissionList?
        /// The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.
        public let cidrIp: String?
        /// [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.
        public let sourceSecurityGroupName: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use -1 to specify all codes.
        public let toPort: Int32?
        /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use -1 to specify all types.
        public let fromPort: Int32?
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). (VPC only) Use -1 to specify all protocols. If you specify -1, or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For tcp, udp, and icmp, you must specify a port range. For protocol 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.
        public let ipProtocol: String?
        /// The ID of the security group. Required for a nondefault VPC.
        public let groupId: String?

        public init(sourceSecurityGroupOwnerId: String? = nil, groupName: String? = nil, ipPermissions: IpPermissionList? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, toPort: Int32? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, groupId: String? = nil) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.toPort = toPort
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            self.groupName = dictionary["GroupName"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [String: Any] { self.ipPermissions = try Ec2.IpPermissionList(dictionary: ipPermissions) } else { self.ipPermissions = nil }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.toPort = dictionary["ToPort"] as? Int32
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.groupId = dictionary["GroupId"] as? String
        }
    }

    public struct KeyNameStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let keyName: [String]?

        public init(keyName: [String]? = nil) {
            self.keyName = keyName
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? [String]
        }
    }

    public struct PortRange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The first port in the range.
        public let from: Int32?
        /// The last port in the range.
        public let to: Int32?

        public init(from: Int32? = nil, to: Int32? = nil) {
            self.from = from
            self.to = to
        }

        public init(dictionary: [String: Any]) throws {
            self.from = dictionary["From"] as? Int32
            self.to = dictionary["To"] as? Int32
        }
    }

    public struct InstanceState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The current state of the instance.
        public let name: InstanceStateName?
        /// The low byte represents the state. The high byte is an opaque internal value and should be ignored.    0 : pending     16 : running     32 : shutting-down     48 : terminated     64 : stopping     80 : stopped   
        public let code: Int32?

        public init(name: InstanceStateName? = nil, code: Int32? = nil) {
            self.name = name
            self.code = code
        }

        public init(dictionary: [String: Any]) throws {
            if let name = dictionary["Name"] as? String { self.name = InstanceStateName(rawValue: name) } else { self.name = nil }
            self.code = dictionary["Code"] as? Int32
        }
    }

    public enum Tenancy: String, CustomStringConvertible {
        case `default` = "default"
        case dedicated = "dedicated"
        case host = "host"
        public var description: String { return self.rawValue }
    }

    public struct VgwTelemetryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VgwTelemetry]?

        public init(item: [VgwTelemetry]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VgwTelemetry(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct InstancePrivateIpAddress: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The private IPv4 address of the network interface.
        public let privateIpAddress: String?
        /// The private IPv4 DNS name.
        public let privateDnsName: String?
        /// Indicates whether this IPv4 address is the primary private IP address of the network interface.
        public let primary: Bool?
        /// The association information for an Elastic IP address for the network interface.
        public let association: InstanceNetworkInterfaceAssociation?

        public init(privateIpAddress: String? = nil, privateDnsName: String? = nil, primary: Bool? = nil, association: InstanceNetworkInterfaceAssociation? = nil) {
            self.privateIpAddress = privateIpAddress
            self.privateDnsName = privateDnsName
            self.primary = primary
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.primary = dictionary["Primary"] as? Bool
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.InstanceNetworkInterfaceAssociation(dictionary: association) } else { self.association = nil }
        }
    }

    public struct HostProperties: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of sockets on the Dedicated Host.
        public let sockets: Int32?
        /// The instance type size that the Dedicated Host supports (for example, m3.medium).
        public let instanceType: String?
        /// The number of vCPUs on the Dedicated Host.
        public let totalVCpus: Int32?
        /// The number of cores on the Dedicated Host.
        public let cores: Int32?

        public init(sockets: Int32? = nil, instanceType: String? = nil, totalVCpus: Int32? = nil, cores: Int32? = nil) {
            self.sockets = sockets
            self.instanceType = instanceType
            self.totalVCpus = totalVCpus
            self.cores = cores
        }

        public init(dictionary: [String: Any]) throws {
            self.sockets = dictionary["Sockets"] as? Int32
            self.instanceType = dictionary["InstanceType"] as? String
            self.totalVCpus = dictionary["TotalVCpus"] as? Int32
            self.cores = dictionary["Cores"] as? Int32
        }
    }

    public struct UnassignPrivateIpAddressesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.
        public let privateIpAddresses: PrivateIpAddressStringList

        public init(networkInterfaceId: String, privateIpAddresses: PrivateIpAddressStringList) {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
        }

        public init(dictionary: [String: Any]) throws {
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            guard let privateIpAddresses = dictionary["PrivateIpAddress"] as? [String: Any] else { throw InitializableError.missingRequiredParam("PrivateIpAddress") }
            self.privateIpAddresses = try Ec2.PrivateIpAddressStringList(dictionary: privateIpAddresses)
        }
    }

    public struct SecurityGroupReference: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC with the referencing security group.
        public let referencingVpcId: String
        /// The ID of your security group.
        public let groupId: String
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String?

        public init(referencingVpcId: String, groupId: String, vpcPeeringConnectionId: String? = nil) {
            self.referencingVpcId = referencingVpcId
            self.groupId = groupId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let referencingVpcId = dictionary["ReferencingVpcId"] as? String else { throw InitializableError.missingRequiredParam("ReferencingVpcId") }
            self.referencingVpcId = referencingVpcId
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct RegionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Region]?

        public init(item: [Region]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Region(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct PriceSchedule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The current price schedule, as determined by the term remaining for the Reserved Instance in the listing. A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.
        public let active: Bool?
        /// The currency for transacting the Reserved Instance resale. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.
        public let term: Int64?
        /// The fixed price for the term.
        public let price: Double?

        public init(active: Bool? = nil, currencyCode: CurrencyCodeValues? = nil, term: Int64? = nil, price: Double? = nil) {
            self.active = active
            self.currencyCode = currencyCode
            self.term = term
            self.price = price
        }

        public init(dictionary: [String: Any]) throws {
            self.active = dictionary["Active"] as? Bool
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.term = dictionary["Term"] as? Int64
            self.price = dictionary["Price"] as? Double
        }
    }

    public struct DescribePrefixListsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more prefix list IDs.
        public let prefixListIds: ValueStringList?
        /// One or more filters.    prefix-list-id: The ID of a prefix list.    prefix-list-name: The name of a prefix list.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public let nextToken: String?
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value specified is greater than 1000, we return only 1000 items.
        public let maxResults: Int32?

        public init(prefixListIds: ValueStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.prefixListIds = prefixListIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let prefixListIds = dictionary["PrefixListId"] as? [String: Any] { self.prefixListIds = try Ec2.ValueStringList(dictionary: prefixListIds) } else { self.prefixListIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DiskImage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the disk image.
        public let image: DiskImageDetail?
        /// Information about the volume.
        public let volume: VolumeDetail?
        /// A description of the disk image.
        public let description: String?

        public init(image: DiskImageDetail? = nil, volume: VolumeDetail? = nil, description: String? = nil) {
            self.image = image
            self.volume = volume
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let image = dictionary["Image"] as? [String: Any] { self.image = try Ec2.DiskImageDetail(dictionary: image) } else { self.image = nil }
            if let volume = dictionary["Volume"] as? [String: Any] { self.volume = try Ec2.VolumeDetail(dictionary: volume) } else { self.volume = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeRouteTablesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more route table IDs. Default: Describes all your route tables.
        public let routeTableIds: ValueStringList?
        /// One or more filters.    association.route-table-association-id - The ID of an association ID for the route table.    association.route-table-id - The ID of the route table involved in the association.    association.subnet-id - The ID of the subnet involved in the association.    association.main - Indicates whether the route table is the main route table for the VPC (true | false).    route-table-id - The ID of the route table.    route.destination-cidr-block - The IPv4 CIDR range specified in a route in the table.    route.destination-ipv6-cidr-block - The IPv6 CIDR range specified in a route in the route table.    route.destination-prefix-list-id - The ID (prefix) of the AWS service specified in a route in the table.    route.egress-only-internet-gateway-id - The ID of an egress-only Internet gateway specified in a route in the route table.    route.gateway-id - The ID of a gateway specified in a route in the table.    route.instance-id - The ID of an instance specified in a route in the table.    route.nat-gateway-id - The ID of a NAT gateway.    route.origin - Describes how the route was created. CreateRouteTable indicates that the route was automatically created when the route table was created; CreateRoute indicates that the route was manually added to the route table; EnableVgwRoutePropagation indicates that the route was propagated by route propagation.    route.state - The state of a route in the route table (active | blackhole). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).    route.vpc-peering-connection-id - The ID of a VPC peering connection specified in a route in the table.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the route table.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(routeTableIds: ValueStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.routeTableIds = routeTableIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let routeTableIds = dictionary["RouteTableId"] as? [String: Any] { self.routeTableIds = try Ec2.ValueStringList(dictionary: routeTableIds) } else { self.routeTableIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeInternetGatewaysResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more Internet gateways.
        public let internetGateways: InternetGatewayList?

        public init(internetGateways: InternetGatewayList? = nil) {
            self.internetGateways = internetGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let internetGateways = dictionary["InternetGatewaySet"] as? [String: Any] { self.internetGateways = try Ec2.InternetGatewayList(dictionary: internetGateways) } else { self.internetGateways = nil }
        }
    }

    public struct InstanceNetworkInterfaceAttachment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time stamp when the attachment initiated.
        public let attachTime: Date?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The index of the device on the instance for the network interface attachment.
        public let deviceIndex: Int32?
        /// The ID of the network interface attachment.
        public let attachmentId: String?
        /// The attachment state.
        public let status: AttachmentStatus?

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, deviceIndex: Int32? = nil, attachmentId: String? = nil, status: AttachmentStatus? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.attachmentId = attachmentId
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.attachmentId = dictionary["AttachmentId"] as? String
            if let status = dictionary["Status"] as? String { self.status = AttachmentStatus(rawValue: status) } else { self.status = nil }
        }
    }

    public struct NetworkInterfaceIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct DisassociateVpcCidrBlockRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The association ID for the CIDR block.
        public let associationId: String

        public init(associationId: String) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct DescribeVpcPeeringConnectionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    accepter-vpc-info.cidr-block - The IPv4 CIDR block of the peer VPC.    accepter-vpc-info.owner-id - The AWS account ID of the owner of the peer VPC.    accepter-vpc-info.vpc-id - The ID of the peer VPC.    expiration-time - The expiration date and time for the VPC peering connection.    requester-vpc-info.cidr-block - The IPv4 CIDR block of the requester's VPC.    requester-vpc-info.owner-id - The AWS account ID of the owner of the requester VPC.    requester-vpc-info.vpc-id - The ID of the requester VPC.    status-code - The status of the VPC peering connection (pending-acceptance | failed | expired | provisioning | active | deleted | rejected).    status-message - A message that provides more information about the status of the VPC peering connection, if applicable.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-peering-connection-id - The ID of the VPC peering connection.  
        public let filters: FilterList?
        /// One or more VPC peering connection IDs. Default: Describes all your VPC peering connections.
        public let vpcPeeringConnectionIds: ValueStringList?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, vpcPeeringConnectionIds: ValueStringList? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcPeeringConnectionIds = vpcPeeringConnectionIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let vpcPeeringConnectionIds = dictionary["VpcPeeringConnectionId"] as? [String: Any] { self.vpcPeeringConnectionIds = try Ec2.ValueStringList(dictionary: vpcPeeringConnectionIds) } else { self.vpcPeeringConnectionIds = nil }
        }
    }

    public struct DetachClassicLinkVpcRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC to which the instance is linked.
        public let vpcId: String
        /// The ID of the instance to unlink from the VPC.
        public let instanceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, instanceId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReservationValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The hourly rate of the reservation.
        public let hourlyPrice: String?
        /// The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).
        public let remainingTotalValue: String?
        /// The remaining upfront cost of the reservation.
        public let remainingUpfrontValue: String?

        public init(hourlyPrice: String? = nil, remainingTotalValue: String? = nil, remainingUpfrontValue: String? = nil) {
            self.hourlyPrice = hourlyPrice
            self.remainingTotalValue = remainingTotalValue
            self.remainingUpfrontValue = remainingUpfrontValue
        }

        public init(dictionary: [String: Any]) throws {
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.remainingTotalValue = dictionary["RemainingTotalValue"] as? String
            self.remainingUpfrontValue = dictionary["RemainingUpfrontValue"] as? String
        }
    }

    public struct DetachClassicLinkVpcResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct UnsuccessfulItemList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [UnsuccessfulItem]?

        public init(item: [UnsuccessfulItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try UnsuccessfulItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct PrivateIpAddressSpecificationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PrivateIpAddressSpecification]?

        public init(item: [PrivateIpAddressSpecification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PrivateIpAddressSpecification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct S3Storage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.
        public let bucket: String?
        /// The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in Best Practices for Managing AWS Access Keys.
        public let aWSAccessKeyId: String?
        /// The signature of the JSON document.
        public let uploadPolicySignature: String?
        /// The beginning of the file name of the AMI.
        public let prefix: String?
        /// An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.
        public let uploadPolicy: Data?

        public init(bucket: String? = nil, aWSAccessKeyId: String? = nil, uploadPolicySignature: String? = nil, prefix: String? = nil, uploadPolicy: Data? = nil) {
            self.bucket = bucket
            self.aWSAccessKeyId = aWSAccessKeyId
            self.uploadPolicySignature = uploadPolicySignature
            self.prefix = prefix
            self.uploadPolicy = uploadPolicy
        }

        public init(dictionary: [String: Any]) throws {
            self.bucket = dictionary["Bucket"] as? String
            self.aWSAccessKeyId = dictionary["AWSAccessKeyId"] as? String
            self.uploadPolicySignature = dictionary["UploadPolicySignature"] as? String
            self.prefix = dictionary["Prefix"] as? String
            self.uploadPolicy = dictionary["UploadPolicy"] as? Data
        }
    }

    public struct VolumeAttachmentList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VolumeAttachment]?

        public init(item: [VolumeAttachment]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VolumeAttachment(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Zero or more reservations.
        public let reservations: ReservationList?

        public init(nextToken: String? = nil, reservations: ReservationList? = nil) {
            self.nextToken = nextToken
            self.reservations = reservations
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let reservations = dictionary["ReservationSet"] as? [String: Any] { self.reservations = try Ec2.ReservationList(dictionary: reservations) } else { self.reservations = nil }
        }
    }

    public struct DescribeReservedInstancesListingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Reserved Instance IDs.
        public let reservedInstancesId: String?
        /// One or more Reserved Instance listing IDs.
        public let reservedInstancesListingId: String?
        /// One or more filters.    reserved-instances-id - The ID of the Reserved Instances.    reserved-instances-listing-id - The ID of the Reserved Instances listing.    status - The status of the Reserved Instance listing (pending | active | cancelled | closed).    status-message - The reason for the status.  
        public let filters: FilterList?

        public init(reservedInstancesId: String? = nil, reservedInstancesListingId: String? = nil, filters: FilterList? = nil) {
            self.reservedInstancesId = reservedInstancesId
            self.reservedInstancesListingId = reservedInstancesListingId
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            self.reservedInstancesListingId = dictionary["ReservedInstancesListingId"] as? String
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
        }
    }

    public struct ScheduledInstancesSecurityGroupIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let securityGroupId: [String]?

        public init(securityGroupId: [String]? = nil) {
            self.securityGroupId = securityGroupId
        }

        public init(dictionary: [String: Any]) throws {
            self.securityGroupId = dictionary["SecurityGroupId"] as? [String]
        }
    }

    public enum MonitoringState: String, CustomStringConvertible {
        case disabled = "disabled"
        case disabling = "disabling"
        case enabled = "enabled"
        case pending = "pending"
        public var description: String { return self.rawValue }
    }

    public struct AccountAttributeList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [AccountAttribute]?

        public init(item: [AccountAttribute]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try AccountAttribute(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CancelBundleTaskRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the bundle task.
        public let bundleId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(bundleId: String, dryRun: Bool? = nil) {
            self.bundleId = bundleId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let bundleId = dictionary["BundleId"] as? String else { throw InitializableError.missingRequiredParam("BundleId") }
            self.bundleId = bundleId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ImageDiskContainerList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ImageDiskContainer]?

        public init(item: [ImageDiskContainer]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ImageDiskContainer(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DeleteCustomerGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the customer gateway.
        public let customerGatewayId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(customerGatewayId: String, dryRun: Bool? = nil) {
            self.customerGatewayId = customerGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let customerGatewayId = dictionary["CustomerGatewayId"] as? String else { throw InitializableError.missingRequiredParam("CustomerGatewayId") }
            self.customerGatewayId = customerGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeHostsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the Dedicated Hosts.
        public let hosts: HostList?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(hosts: HostList? = nil, nextToken: String? = nil) {
            self.hosts = hosts
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let hosts = dictionary["HostSet"] as? [String: Any] { self.hosts = try Ec2.HostList(dictionary: hosts) } else { self.hosts = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public enum SnapshotAttributeName: String, CustomStringConvertible {
        case productcodes = "productCodes"
        case createvolumepermission = "createVolumePermission"
        public var description: String { return self.rawValue }
    }

    public struct NatGatewayAddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NatGatewayAddress]?

        public init(item: [NatGatewayAddress]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NatGatewayAddress(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct PurchaseHostReservationResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Describes the details of the purchase.
        public let purchase: [Purchase]?
        /// The total amount that will be charged to your account when you purchase the reservation.
        public let totalUpfrontPrice: String?
        /// The currency in which the totalUpfrontPrice and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide 
        public let clientToken: String?
        /// The total hourly price of the reservation calculated per hour.
        public let totalHourlyPrice: String?

        public init(purchase: [Purchase]? = nil, totalUpfrontPrice: String? = nil, currencyCode: CurrencyCodeValues? = nil, clientToken: String? = nil, totalHourlyPrice: String? = nil) {
            self.purchase = purchase
            self.totalUpfrontPrice = totalUpfrontPrice
            self.currencyCode = currencyCode
            self.clientToken = clientToken
            self.totalHourlyPrice = totalHourlyPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let purchase = dictionary["Purchase"] as? [[String: Any]] {
                self.purchase = try purchase.map({ try Purchase(dictionary: $0) })
            } else { 
                self.purchase = nil
            }
            self.totalUpfrontPrice = dictionary["TotalUpfrontPrice"] as? String
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.clientToken = dictionary["ClientToken"] as? String
            self.totalHourlyPrice = dictionary["TotalHourlyPrice"] as? String
        }
    }

    public struct DeleteEgressOnlyInternetGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let returnCode: Bool?

        public init(returnCode: Bool? = nil) {
            self.returnCode = returnCode
        }

        public init(dictionary: [String: Any]) throws {
            self.returnCode = dictionary["ReturnCode"] as? Bool
        }
    }

    public struct DeleteVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the volume.
        public let volumeId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(volumeId: String, dryRun: Bool? = nil) {
            self.volumeId = volumeId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct EgressOnlyInternetGatewayIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct RequestHostIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct TargetConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Convertible Reserved Instance offering.
        public let offeringId: String?
        /// The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request
        public let instanceCount: Int32?

        public init(offeringId: String? = nil, instanceCount: Int32? = nil) {
            self.offeringId = offeringId
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            self.offeringId = dictionary["OfferingId"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
        }
    }

    public struct FilterList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let filter: [Filter]?

        public init(filter: [Filter]? = nil) {
            self.filter = filter
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [[String: Any]] {
                self.filter = try filter.map({ try Filter(dictionary: $0) })
            } else { 
                self.filter = nil
            }
        }
    }

    public struct CreateCustomerGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the customer gateway.
        public let customerGateway: CustomerGateway?

        public init(customerGateway: CustomerGateway? = nil) {
            self.customerGateway = customerGateway
        }

        public init(dictionary: [String: Any]) throws {
            if let customerGateway = dictionary["CustomerGateway"] as? [String: Any] { self.customerGateway = try Ec2.CustomerGateway(dictionary: customerGateway) } else { self.customerGateway = nil }
        }
    }

    public struct DescribeBundleTasksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more bundle tasks.
        public let bundleTasks: BundleTaskList?

        public init(bundleTasks: BundleTaskList? = nil) {
            self.bundleTasks = bundleTasks
        }

        public init(dictionary: [String: Any]) throws {
            if let bundleTasks = dictionary["BundleInstanceTasksSet"] as? [String: Any] { self.bundleTasks = try Ec2.BundleTaskList(dictionary: bundleTasks) } else { self.bundleTasks = nil }
        }
    }

    public struct GetReservedInstancesExchangeQuoteResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The new end date of the reservation term.
        public let outputReservedInstancesWillExpireAt: Date?
        /// The cost associated with the Reserved Instance.
        public let targetConfigurationValueRollup: ReservationValue?
        /// If true, the exchange is valid. If false, the exchange cannot be completed.
        public let isValidExchange: Bool?
        /// The cost associated with the Reserved Instance.
        public let reservedInstanceValueRollup: ReservationValue?
        /// The configuration of your Convertible Reserved Instances.
        public let reservedInstanceValueSet: ReservedInstanceReservationValueSet?
        /// The total true upfront charge for the exchange.
        public let paymentDue: String?
        /// The currency of the transaction.
        public let currencyCode: String?
        /// The values of the target Convertible Reserved Instances.
        public let targetConfigurationValueSet: TargetReservationValueSet?
        /// Describes the reason why the exchange cannot be completed.
        public let validationFailureReason: String?

        public init(outputReservedInstancesWillExpireAt: Date? = nil, targetConfigurationValueRollup: ReservationValue? = nil, isValidExchange: Bool? = nil, reservedInstanceValueRollup: ReservationValue? = nil, reservedInstanceValueSet: ReservedInstanceReservationValueSet? = nil, paymentDue: String? = nil, currencyCode: String? = nil, targetConfigurationValueSet: TargetReservationValueSet? = nil, validationFailureReason: String? = nil) {
            self.outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAt
            self.targetConfigurationValueRollup = targetConfigurationValueRollup
            self.isValidExchange = isValidExchange
            self.reservedInstanceValueRollup = reservedInstanceValueRollup
            self.reservedInstanceValueSet = reservedInstanceValueSet
            self.paymentDue = paymentDue
            self.currencyCode = currencyCode
            self.targetConfigurationValueSet = targetConfigurationValueSet
            self.validationFailureReason = validationFailureReason
        }

        public init(dictionary: [String: Any]) throws {
            self.outputReservedInstancesWillExpireAt = dictionary["OutputReservedInstancesWillExpireAt"] as? Date
            if let targetConfigurationValueRollup = dictionary["TargetConfigurationValueRollup"] as? [String: Any] { self.targetConfigurationValueRollup = try Ec2.ReservationValue(dictionary: targetConfigurationValueRollup) } else { self.targetConfigurationValueRollup = nil }
            self.isValidExchange = dictionary["IsValidExchange"] as? Bool
            if let reservedInstanceValueRollup = dictionary["ReservedInstanceValueRollup"] as? [String: Any] { self.reservedInstanceValueRollup = try Ec2.ReservationValue(dictionary: reservedInstanceValueRollup) } else { self.reservedInstanceValueRollup = nil }
            if let reservedInstanceValueSet = dictionary["ReservedInstanceValueSet"] as? [String: Any] { self.reservedInstanceValueSet = try Ec2.ReservedInstanceReservationValueSet(dictionary: reservedInstanceValueSet) } else { self.reservedInstanceValueSet = nil }
            self.paymentDue = dictionary["PaymentDue"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            if let targetConfigurationValueSet = dictionary["TargetConfigurationValueSet"] as? [String: Any] { self.targetConfigurationValueSet = try Ec2.TargetReservationValueSet(dictionary: targetConfigurationValueSet) } else { self.targetConfigurationValueSet = nil }
            self.validationFailureReason = dictionary["ValidationFailureReason"] as? String
        }
    }

    public struct InstanceExportDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the resource being exported.
        public let instanceId: String?
        /// The target virtualization environment.
        public let targetEnvironment: ExportEnvironment?

        public init(instanceId: String? = nil, targetEnvironment: ExportEnvironment? = nil) {
            self.instanceId = instanceId
            self.targetEnvironment = targetEnvironment
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
            if let targetEnvironment = dictionary["TargetEnvironment"] as? String { self.targetEnvironment = ExportEnvironment(rawValue: targetEnvironment) } else { self.targetEnvironment = nil }
        }
    }

    public struct NetworkAcl: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether this is the default network ACL for the VPC.
        public let isDefault: Bool?
        /// One or more entries (rules) in the network ACL.
        public let entries: NetworkAclEntryList?
        /// The ID of the network ACL.
        public let networkAclId: String?
        /// The ID of the VPC for the network ACL.
        public let vpcId: String?
        /// Any tags assigned to the network ACL.
        public let tags: TagList?
        /// Any associations between the network ACL and one or more subnets
        public let associations: NetworkAclAssociationList?

        public init(isDefault: Bool? = nil, entries: NetworkAclEntryList? = nil, networkAclId: String? = nil, vpcId: String? = nil, tags: TagList? = nil, associations: NetworkAclAssociationList? = nil) {
            self.isDefault = isDefault
            self.entries = entries
            self.networkAclId = networkAclId
            self.vpcId = vpcId
            self.tags = tags
            self.associations = associations
        }

        public init(dictionary: [String: Any]) throws {
            self.isDefault = dictionary["Default"] as? Bool
            if let entries = dictionary["EntrySet"] as? [String: Any] { self.entries = try Ec2.NetworkAclEntryList(dictionary: entries) } else { self.entries = nil }
            self.networkAclId = dictionary["NetworkAclId"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            if let associations = dictionary["AssociationSet"] as? [String: Any] { self.associations = try Ec2.NetworkAclAssociationList(dictionary: associations) } else { self.associations = nil }
        }
    }

    public enum InstanceHealthStatus: String, CustomStringConvertible {
        case healthy = "healthy"
        case unhealthy = "unhealthy"
        public var description: String { return self.rawValue }
    }

    public struct RevokeSecurityGroupIngressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.
        public let sourceSecurityGroupOwnerId: String?
        /// [EC2-Classic, default VPC] The name of the security group.
        public let groupName: String?
        /// A set of IP permissions. You can't specify a source security group and a CIDR IP address range.
        public let ipPermissions: IpPermissionList?
        /// The CIDR IP address range. You can't specify this parameter when specifying a source security group.
        public let cidrIp: String?
        /// [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.
        public let sourceSecurityGroupName: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use -1 to specify all ICMP codes for the ICMP type.
        public let toPort: Int32?
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use -1 to specify all ICMP types.
        public let fromPort: Int32?
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). Use -1 to specify all.
        public let ipProtocol: String?
        /// The ID of the security group. Required for a security group in a nondefault VPC.
        public let groupId: String?

        public init(sourceSecurityGroupOwnerId: String? = nil, groupName: String? = nil, ipPermissions: IpPermissionList? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, toPort: Int32? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, groupId: String? = nil) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.toPort = toPort
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            self.groupName = dictionary["GroupName"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [String: Any] { self.ipPermissions = try Ec2.IpPermissionList(dictionary: ipPermissions) } else { self.ipPermissions = nil }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.toPort = dictionary["ToPort"] as? Int32
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.groupId = dictionary["GroupId"] as? String
        }
    }

    public struct DescribeKeyPairsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more key pairs.
        public let keyPairs: KeyPairList?

        public init(keyPairs: KeyPairList? = nil) {
            self.keyPairs = keyPairs
        }

        public init(dictionary: [String: Any]) throws {
            if let keyPairs = dictionary["KeySet"] as? [String: Any] { self.keyPairs = try Ec2.KeyPairList(dictionary: keyPairs) } else { self.keyPairs = nil }
        }
    }

    public struct ScheduledInstancesPrivateIpAddressConfig: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.
        public let primary: Bool?
        /// The IPv4 address.
        public let privateIpAddress: String?

        public init(primary: Bool? = nil, privateIpAddress: String? = nil) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.primary = dictionary["Primary"] as? Bool
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
        }
    }

    public struct CancelReservedInstancesListingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Reserved Instance listing.
        public let reservedInstancesListings: ReservedInstancesListingList?

        public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesListings = dictionary["ReservedInstancesListingsSet"] as? [String: Any] { self.reservedInstancesListings = try Ec2.ReservedInstancesListingList(dictionary: reservedInstancesListings) } else { self.reservedInstancesListings = nil }
        }
    }

    public struct ReservationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Reservation]?

        public init(item: [Reservation]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Reservation(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AcceptReservedInstancesExchangeQuoteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the Convertible Reserved Instances to exchange for other Convertible Reserved Instances of the same or higher value.
        public let reservedInstanceIds: ReservedInstanceIdSet
        /// The configurations of the Convertible Reserved Instance offerings that you are purchasing in this exchange.
        public let targetConfigurations: TargetConfigurationRequestSet?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(reservedInstanceIds: ReservedInstanceIdSet, targetConfigurations: TargetConfigurationRequestSet? = nil, dryRun: Bool? = nil) {
            self.reservedInstanceIds = reservedInstanceIds
            self.targetConfigurations = targetConfigurations
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstanceIds = dictionary["ReservedInstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ReservedInstanceId") }
            self.reservedInstanceIds = try Ec2.ReservedInstanceIdSet(dictionary: reservedInstanceIds)
            if let targetConfigurations = dictionary["TargetConfiguration"] as? [String: Any] { self.targetConfigurations = try Ec2.TargetConfigurationRequestSet(dictionary: targetConfigurations) } else { self.targetConfigurations = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public enum State: String, CustomStringConvertible {
        case pending = "Pending"
        case available = "Available"
        case deleting = "Deleting"
        case deleted = "Deleted"
        public var description: String { return self.rawValue }
    }

    public struct BundleInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the instance to bundle. Type: String Default: None Required: Yes
        public let instanceId: String
        /// The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.
        public let storage: Storage
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceId: String, storage: Storage, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.storage = storage
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let storage = dictionary["Storage"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Storage") }
            self.storage = try Ec2.Storage(dictionary: storage)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVolumesModificationsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Token for pagination, null if there are no more results 
        public let nextToken: String?
        /// A list of returned VolumeModification objects.
        public let volumesModifications: VolumeModificationList?

        public init(nextToken: String? = nil, volumesModifications: VolumeModificationList? = nil) {
            self.nextToken = nextToken
            self.volumesModifications = volumesModifications
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let volumesModifications = dictionary["VolumeModificationSet"] as? [String: Any] { self.volumesModifications = try Ec2.VolumeModificationList(dictionary: volumesModifications) } else { self.volumesModifications = nil }
        }
    }

    public struct DescribeVpcClassicLinkRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    is-classic-link-enabled - Whether the VPC is enabled for ClassicLink (true | false).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public let filters: FilterList?
        /// One or more VPCs for which you want to describe the ClassicLink status.
        public let vpcIds: VpcClassicLinkIdList?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, vpcIds: VpcClassicLinkIdList? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcIds = vpcIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let vpcIds = dictionary["VpcId"] as? [String: Any] { self.vpcIds = try Ec2.VpcClassicLinkIdList(dictionary: vpcIds) } else { self.vpcIds = nil }
        }
    }

    public struct DhcpOptionsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [DhcpOptions]?

        public init(item: [DhcpOptions]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try DhcpOptions(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VpcClassicLinkList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpcClassicLink]?

        public init(item: [VpcClassicLink]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpcClassicLink(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SpotInstanceRequestList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SpotInstanceRequest]?

        public init(item: [SpotInstanceRequest]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SpotInstanceRequest(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeVolumeAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the volume.
        public let volumeId: String
        /// The instance attribute.
        public let attribute: VolumeAttributeName?

        public init(dryRun: Bool? = nil, volumeId: String, attribute: VolumeAttributeName? = nil) {
            self.dryRun = dryRun
            self.volumeId = volumeId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            if let attribute = dictionary["Attribute"] as? String { self.attribute = VolumeAttributeName(rawValue: attribute) } else { self.attribute = nil }
        }
    }

    public struct GetPasswordDataRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Windows instance.
        public let instanceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceId: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public enum RIProductDescription: String, CustomStringConvertible {
        case linux_unix = "Linux/UNIX"
        case linux_unix__amazon_vpc_ = "Linux/UNIX (Amazon VPC)"
        case windows = "Windows"
        case windows__amazon_vpc_ = "Windows (Amazon VPC)"
        public var description: String { return self.rawValue }
    }

    public struct ReportInstanceStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time at which the reported instance health state began.
        public let startTime: Date?
        /// The status of all instances listed.
        public let status: ReportStatusType
        /// The time at which the reported instance health state ended.
        public let endTime: Date?
        /// One or more instances.
        public let instances: InstanceIdStringList
        /// One or more reason codes that describes the health state of your instance.    instance-stuck-in-state: My instance is stuck in a state.    unresponsive: My instance is unresponsive.    not-accepting-credentials: My instance is not accepting my credentials.    password-not-available: A password is not available for my instance.    performance-network: My instance is experiencing performance problems which I believe are network related.    performance-instance-store: My instance is experiencing performance problems which I believe are related to the instance stores.    performance-ebs-volume: My instance is experiencing performance problems which I believe are related to an EBS volume.    performance-other: My instance is experiencing performance problems.    other: [explain using the description parameter]  
        public let reasonCodes: ReasonCodesList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Descriptive text about the health state of your instance.
        public let description: String?

        public init(startTime: Date? = nil, status: ReportStatusType, endTime: Date? = nil, instances: InstanceIdStringList, reasonCodes: ReasonCodesList, dryRun: Bool? = nil, description: String? = nil) {
            self.startTime = startTime
            self.status = status
            self.endTime = endTime
            self.instances = instances
            self.reasonCodes = reasonCodes
            self.dryRun = dryRun
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            guard let rawStatus = dictionary["Status"] as? String, let status = ReportStatusType(rawValue: rawStatus) else { throw InitializableError.missingRequiredParam("Status") }
            self.status = status
            self.endTime = dictionary["EndTime"] as? Date
            guard let instances = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instances = try Ec2.InstanceIdStringList(dictionary: instances)
            guard let reasonCodes = dictionary["ReasonCode"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ReasonCode") }
            self.reasonCodes = try Ec2.ReasonCodesList(dictionary: reasonCodes)
            self.dryRun = dictionary["DryRun"] as? Bool
            self.description = dictionary["Description"] as? String
        }
    }

    public struct AllocateHostsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the allocated Dedicated Host. This is used when you want to launch an instance onto a specific host.
        public let hostIds: ResponseHostIdList?

        public init(hostIds: ResponseHostIdList? = nil) {
            self.hostIds = hostIds
        }

        public init(dictionary: [String: Any]) throws {
            if let hostIds = dictionary["HostIdSet"] as? [String: Any] { self.hostIds = try Ec2.ResponseHostIdList(dictionary: hostIds) } else { self.hostIds = nil }
        }
    }

    public struct InternetGatewayAttachmentList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InternetGatewayAttachment]?

        public init(item: [InternetGatewayAttachment]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InternetGatewayAttachment(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        public let value: String?
        /// The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws: 
        public let key: String?

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct DescribeRegionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The names of one or more regions.
        public let regionNames: RegionNameStringList?
        /// One or more filters.    endpoint - The endpoint of the region (for example, ec2.us-east-1.amazonaws.com).    region-name - The name of the region (for example, us-east-1).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(regionNames: RegionNameStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.regionNames = regionNames
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let regionNames = dictionary["RegionName"] as? [String: Any] { self.regionNames = try Ec2.RegionNameStringList(dictionary: regionNames) } else { self.regionNames = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct TagDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The tag key.
        public let key: String?
        /// The ID of the resource. For example, ami-1a2b3c4d.
        public let resourceId: String?
        /// The tag value.
        public let value: String?
        /// The resource type.
        public let resourceType: ResourceType?

        public init(key: String? = nil, resourceId: String? = nil, value: String? = nil, resourceType: ResourceType? = nil) {
            self.key = key
            self.resourceId = resourceId
            self.value = value
            self.resourceType = resourceType
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            self.resourceId = dictionary["ResourceId"] as? String
            self.value = dictionary["Value"] as? String
            if let resourceType = dictionary["ResourceType"] as? String { self.resourceType = ResourceType(rawValue: resourceType) } else { self.resourceType = nil }
        }
    }

    public struct RegionNameStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let regionName: [String]?

        public init(regionName: [String]? = nil) {
            self.regionName = regionName
        }

        public init(dictionary: [String: Any]) throws {
            self.regionName = dictionary["RegionName"] as? [String]
        }
    }

    public struct ProvisionedBandwidth: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public let provisioned: String?
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public let status: String?
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public let requestTime: Date?
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public let provisionTime: Date?
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public let requested: String?

        public init(provisioned: String? = nil, status: String? = nil, requestTime: Date? = nil, provisionTime: Date? = nil, requested: String? = nil) {
            self.provisioned = provisioned
            self.status = status
            self.requestTime = requestTime
            self.provisionTime = provisionTime
            self.requested = requested
        }

        public init(dictionary: [String: Any]) throws {
            self.provisioned = dictionary["Provisioned"] as? String
            self.status = dictionary["Status"] as? String
            self.requestTime = dictionary["RequestTime"] as? Date
            self.provisionTime = dictionary["ProvisionTime"] as? Date
            self.requested = dictionary["Requested"] as? String
        }
    }

    public struct DescribeSnapshotAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the EBS snapshot.
        public let snapshotId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The snapshot attribute you would like to view.
        public let attribute: SnapshotAttributeName

        public init(snapshotId: String, dryRun: Bool? = nil, attribute: SnapshotAttributeName) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = SnapshotAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct DescribeSpotDatafeedSubscriptionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeSnapshotAttributeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of permissions for creating volumes from the snapshot.
        public let createVolumePermissions: CreateVolumePermissionList?
        /// A list of product codes.
        public let productCodes: ProductCodeList?
        /// The ID of the EBS snapshot.
        public let snapshotId: String?

        public init(createVolumePermissions: CreateVolumePermissionList? = nil, productCodes: ProductCodeList? = nil, snapshotId: String? = nil) {
            self.createVolumePermissions = createVolumePermissions
            self.productCodes = productCodes
            self.snapshotId = snapshotId
        }

        public init(dictionary: [String: Any]) throws {
            if let createVolumePermissions = dictionary["CreateVolumePermission"] as? [String: Any] { self.createVolumePermissions = try Ec2.CreateVolumePermissionList(dictionary: createVolumePermissions) } else { self.createVolumePermissions = nil }
            if let productCodes = dictionary["ProductCodes"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeList(dictionary: productCodes) } else { self.productCodes = nil }
            self.snapshotId = dictionary["SnapshotId"] as? String
        }
    }

    public struct RecurringCharge: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The frequency of the recurring charge.
        public let frequency: RecurringChargeFrequency?
        /// The amount of the recurring charge.
        public let amount: Double?

        public init(frequency: RecurringChargeFrequency? = nil, amount: Double? = nil) {
            self.frequency = frequency
            self.amount = amount
        }

        public init(dictionary: [String: Any]) throws {
            if let frequency = dictionary["Frequency"] as? String { self.frequency = RecurringChargeFrequency(rawValue: frequency) } else { self.frequency = nil }
            self.amount = dictionary["Amount"] as? Double
        }
    }

    public struct DeleteVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpcPeeringConnectionId") }
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

    public struct DescribeAvailabilityZonesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The names of one or more Availability Zones.
        public let zoneNames: ZoneNameStringList?
        /// One or more filters.    message - Information about the Availability Zone.    region-name - The name of the region for the Availability Zone (for example, us-east-1).    state - The state of the Availability Zone (available | information | impaired | unavailable).    zone-name - The name of the Availability Zone (for example, us-east-1a).  
        public let filters: FilterList?

        public init(dryRun: Bool? = nil, zoneNames: ZoneNameStringList? = nil, filters: FilterList? = nil) {
            self.dryRun = dryRun
            self.zoneNames = zoneNames
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let zoneNames = dictionary["ZoneName"] as? [String: Any] { self.zoneNames = try Ec2.ZoneNameStringList(dictionary: zoneNames) } else { self.zoneNames = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
        }
    }

    public struct AssociateRouteTableResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The route table association ID (needed to disassociate the route table).
        public let associationId: String?

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct Ipv6AddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct IcmpTypeCode: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ICMP type. A value of -1 means all types.
        public let `type`: Int32?
        /// The ICMP code. A value of -1 means all codes for the specified ICMP type.
        public let code: Int32?

        public init(type: Int32? = nil, code: Int32? = nil) {
            self.`type` = `type`
            self.code = code
        }

        public init(dictionary: [String: Any]) throws {
            self.`type` = dictionary["Type"] as? Int32
            self.code = dictionary["Code"] as? Int32
        }
    }

    public struct DeleteFlowLogsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more flow log IDs.
        public let flowLogIds: ValueStringList

        public init(flowLogIds: ValueStringList) {
            self.flowLogIds = flowLogIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let flowLogIds = dictionary["FlowLogId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("FlowLogId") }
            self.flowLogIds = try Ec2.ValueStringList(dictionary: flowLogIds)
        }
    }

    public struct DescribeVpnConnectionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more VPN connection IDs. Default: Describes your VPN connections.
        public let vpnConnectionIds: VpnConnectionIdStringList?
        /// One or more filters.    customer-gateway-configuration - The configuration information for the customer gateway.    customer-gateway-id - The ID of a customer gateway associated with the VPN connection.    state - The state of the VPN connection (pending | available | deleting | deleted).    option.static-routes-only - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).    route.destination-cidr-block - The destination CIDR block. This corresponds to the subnet used in a customer data center.    bgp-asn - The BGP Autonomous System Number (ASN) associated with a BGP device.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of VPN connection. Currently the only supported type is ipsec.1.    vpn-connection-id - The ID of the VPN connection.    vpn-gateway-id - The ID of a virtual private gateway associated with the VPN connection.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpnConnectionIds: VpnConnectionIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.vpnConnectionIds = vpnConnectionIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnConnectionIds = dictionary["VpnConnectionId"] as? [String: Any] { self.vpnConnectionIds = try Ec2.VpnConnectionIdStringList(dictionary: vpnConnectionIds) } else { self.vpnConnectionIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReservedInstanceLimitPrice: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The currency in which the limitPrice amount is specified. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).
        public let amount: Double?

        public init(currencyCode: CurrencyCodeValues? = nil, amount: Double? = nil) {
            self.currencyCode = currencyCode
            self.amount = amount
        }

        public init(dictionary: [String: Any]) throws {
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.amount = dictionary["Amount"] as? Double
        }
    }

    public struct NewDhcpConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let key: String?
        public let values: ValueStringList?

        public init(key: String? = nil, values: ValueStringList? = nil) {
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            if let values = dictionary["Value"] as? [String: Any] { self.values = try Ec2.ValueStringList(dictionary: values) } else { self.values = nil }
        }
    }

    public struct KeyPairList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [KeyPairInfo]?

        public init(item: [KeyPairInfo]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try KeyPairInfo(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct NetworkAclEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv4 network range to allow or deny, in CIDR notation.
        public let cidrBlock: String?
        /// ICMP protocol: The ICMP type and code.
        public let icmpTypeCode: IcmpTypeCode?
        /// The rule number for the entry. ACL entries are processed in ascending order by rule number.
        public let ruleNumber: Int32?
        /// The protocol. A value of -1 means all protocols.
        public let `protocol`: String?
        /// Indicates whether to allow or deny the traffic that matches the rule.
        public let ruleAction: RuleAction?
        /// Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).
        public let egress: Bool?
        /// The IPv6 network range to allow or deny, in CIDR notation.
        public let ipv6CidrBlock: String?
        /// TCP or UDP protocols: The range of ports the rule applies to.
        public let portRange: PortRange?

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32? = nil, protocol: String? = nil, ruleAction: RuleAction? = nil, egress: Bool? = nil, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrBlock = dictionary["CidrBlock"] as? String
            if let icmpTypeCode = dictionary["IcmpTypeCode"] as? [String: Any] { self.icmpTypeCode = try Ec2.IcmpTypeCode(dictionary: icmpTypeCode) } else { self.icmpTypeCode = nil }
            self.ruleNumber = dictionary["RuleNumber"] as? Int32
            self.`protocol` = dictionary["Protocol"] as? String
            if let ruleAction = dictionary["RuleAction"] as? String { self.ruleAction = RuleAction(rawValue: ruleAction) } else { self.ruleAction = nil }
            self.egress = dictionary["Egress"] as? Bool
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            if let portRange = dictionary["PortRange"] as? [String: Any] { self.portRange = try Ec2.PortRange(dictionary: portRange) } else { self.portRange = nil }
        }
    }

    public struct Vpc: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the VPC is the default VPC.
        public let isDefault: Bool?
        /// The ID of the VPC.
        public let vpcId: String?
        /// The current state of the VPC.
        public let state: VpcState?
        /// Any tags assigned to the VPC.
        public let tags: TagList?
        /// The ID of the set of DHCP options you've associated with the VPC (or default if the default options are associated with the VPC).
        public let dhcpOptionsId: String?
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        public let ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociationSet?
        /// The allowed tenancy of instances launched into the VPC.
        public let instanceTenancy: Tenancy?
        /// The IPv4 CIDR block for the VPC.
        public let cidrBlock: String?

        public init(isDefault: Bool? = nil, vpcId: String? = nil, state: VpcState? = nil, tags: TagList? = nil, dhcpOptionsId: String? = nil, ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociationSet? = nil, instanceTenancy: Tenancy? = nil, cidrBlock: String? = nil) {
            self.isDefault = isDefault
            self.vpcId = vpcId
            self.state = state
            self.tags = tags
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.instanceTenancy = instanceTenancy
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.isDefault = dictionary["IsDefault"] as? Bool
            self.vpcId = dictionary["VpcId"] as? String
            if let state = dictionary["State"] as? String { self.state = VpcState(rawValue: state) } else { self.state = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.dhcpOptionsId = dictionary["DhcpOptionsId"] as? String
            if let ipv6CidrBlockAssociationSet = dictionary["Ipv6CidrBlockAssociationSet"] as? [String: Any] { self.ipv6CidrBlockAssociationSet = try Ec2.VpcIpv6CidrBlockAssociationSet(dictionary: ipv6CidrBlockAssociationSet) } else { self.ipv6CidrBlockAssociationSet = nil }
            if let instanceTenancy = dictionary["InstanceTenancy"] as? String { self.instanceTenancy = Tenancy(rawValue: instanceTenancy) } else { self.instanceTenancy = nil }
            self.cidrBlock = dictionary["CidrBlock"] as? String
        }
    }

    public struct AvailabilityZoneMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The message about the Availability Zone.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DescribeStaleSecurityGroupsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the VPC.
        public let vpcId: String
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public let nextToken: String?
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int32?

        public init(dryRun: Bool? = nil, vpcId: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct RestoreAddressToClassicRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The Elastic IP address.
        public let publicIp: String

        public init(dryRun: Bool? = nil, publicIp: String) {
            self.dryRun = dryRun
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let publicIp = dictionary["PublicIp"] as? String else { throw InitializableError.missingRequiredParam("PublicIp") }
            self.publicIp = publicIp
        }
    }

    public struct RouteTable: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The routes in the route table.
        public let routes: RouteList?
        /// Any virtual private gateway (VGW) propagating routes.
        public let propagatingVgws: PropagatingVgwList?
        /// The ID of the route table.
        public let routeTableId: String?
        /// The ID of the VPC.
        public let vpcId: String?
        /// Any tags assigned to the route table.
        public let tags: TagList?
        /// The associations between the route table and one or more subnets.
        public let associations: RouteTableAssociationList?

        public init(routes: RouteList? = nil, propagatingVgws: PropagatingVgwList? = nil, routeTableId: String? = nil, vpcId: String? = nil, tags: TagList? = nil, associations: RouteTableAssociationList? = nil) {
            self.routes = routes
            self.propagatingVgws = propagatingVgws
            self.routeTableId = routeTableId
            self.vpcId = vpcId
            self.tags = tags
            self.associations = associations
        }

        public init(dictionary: [String: Any]) throws {
            if let routes = dictionary["RouteSet"] as? [String: Any] { self.routes = try Ec2.RouteList(dictionary: routes) } else { self.routes = nil }
            if let propagatingVgws = dictionary["PropagatingVgwSet"] as? [String: Any] { self.propagatingVgws = try Ec2.PropagatingVgwList(dictionary: propagatingVgws) } else { self.propagatingVgws = nil }
            self.routeTableId = dictionary["RouteTableId"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            if let associations = dictionary["AssociationSet"] as? [String: Any] { self.associations = try Ec2.RouteTableAssociationList(dictionary: associations) } else { self.associations = nil }
        }
    }

    public enum RuleAction: String, CustomStringConvertible {
        case allow = "allow"
        case deny = "deny"
        public var description: String { return self.rawValue }
    }

    public struct VolumeStatusEvent: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The earliest start time of the event.
        public let notBefore: Date?
        /// The type of this event.
        public let eventType: String?
        /// The latest end time of the event.
        public let notAfter: Date?
        /// The ID of this event.
        public let eventId: String?
        /// A description of the event.
        public let description: String?

        public init(notBefore: Date? = nil, eventType: String? = nil, notAfter: Date? = nil, eventId: String? = nil, description: String? = nil) {
            self.notBefore = notBefore
            self.eventType = eventType
            self.notAfter = notAfter
            self.eventId = eventId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.notBefore = dictionary["NotBefore"] as? Date
            self.eventType = dictionary["EventType"] as? String
            self.notAfter = dictionary["NotAfter"] as? Date
            self.eventId = dictionary["EventId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ModifyVpcEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more route tables IDs to associate with the endpoint.
        public let addRouteTableIds: ValueStringList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the endpoint.
        public let vpcEndpointId: String
        /// A policy document to attach to the endpoint. The policy must be in valid JSON format.
        public let policyDocument: String?
        /// Specify true to reset the policy document to the default policy. The default policy allows access to the service.
        public let resetPolicy: Bool?
        /// One or more route table IDs to disassociate from the endpoint.
        public let removeRouteTableIds: ValueStringList?

        public init(addRouteTableIds: ValueStringList? = nil, dryRun: Bool? = nil, vpcEndpointId: String, policyDocument: String? = nil, resetPolicy: Bool? = nil, removeRouteTableIds: ValueStringList? = nil) {
            self.addRouteTableIds = addRouteTableIds
            self.dryRun = dryRun
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = policyDocument
            self.resetPolicy = resetPolicy
            self.removeRouteTableIds = removeRouteTableIds
        }

        public init(dictionary: [String: Any]) throws {
            if let addRouteTableIds = dictionary["AddRouteTableId"] as? [String: Any] { self.addRouteTableIds = try Ec2.ValueStringList(dictionary: addRouteTableIds) } else { self.addRouteTableIds = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcEndpointId = dictionary["VpcEndpointId"] as? String else { throw InitializableError.missingRequiredParam("VpcEndpointId") }
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = dictionary["PolicyDocument"] as? String
            self.resetPolicy = dictionary["ResetPolicy"] as? Bool
            if let removeRouteTableIds = dictionary["RemoveRouteTableId"] as? [String: Any] { self.removeRouteTableIds = try Ec2.ValueStringList(dictionary: removeRouteTableIds) } else { self.removeRouteTableIds = nil }
        }
    }

    public struct VpcClassicLink: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// Any tags assigned to the VPC.
        public let tags: TagList?
        /// Indicates whether the VPC is enabled for ClassicLink.
        public let classicLinkEnabled: Bool?

        public init(vpcId: String? = nil, tags: TagList? = nil, classicLinkEnabled: Bool? = nil) {
            self.vpcId = vpcId
            self.tags = tags
            self.classicLinkEnabled = classicLinkEnabled
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.classicLinkEnabled = dictionary["ClassicLinkEnabled"] as? Bool
        }
    }

    public enum InstanceType: String, CustomStringConvertible {
        case t1_micro = "t1.micro"
        case t2_nano = "t2.nano"
        case t2_micro = "t2.micro"
        case t2_small = "t2.small"
        case t2_medium = "t2.medium"
        case t2_large = "t2.large"
        case t2_xlarge = "t2.xlarge"
        case t2_2xlarge = "t2.2xlarge"
        case m1_small = "m1.small"
        case m1_medium = "m1.medium"
        case m1_large = "m1.large"
        case m1_xlarge = "m1.xlarge"
        case m3_medium = "m3.medium"
        case m3_large = "m3.large"
        case m3_xlarge = "m3.xlarge"
        case m3_2xlarge = "m3.2xlarge"
        case m4_large = "m4.large"
        case m4_xlarge = "m4.xlarge"
        case m4_2xlarge = "m4.2xlarge"
        case m4_4xlarge = "m4.4xlarge"
        case m4_10xlarge = "m4.10xlarge"
        case m4_16xlarge = "m4.16xlarge"
        case m2_xlarge = "m2.xlarge"
        case m2_2xlarge = "m2.2xlarge"
        case m2_4xlarge = "m2.4xlarge"
        case cr1_8xlarge = "cr1.8xlarge"
        case r3_large = "r3.large"
        case r3_xlarge = "r3.xlarge"
        case r3_2xlarge = "r3.2xlarge"
        case r3_4xlarge = "r3.4xlarge"
        case r3_8xlarge = "r3.8xlarge"
        case r4_large = "r4.large"
        case r4_xlarge = "r4.xlarge"
        case r4_2xlarge = "r4.2xlarge"
        case r4_4xlarge = "r4.4xlarge"
        case r4_8xlarge = "r4.8xlarge"
        case r4_16xlarge = "r4.16xlarge"
        case x1_16xlarge = "x1.16xlarge"
        case x1_32xlarge = "x1.32xlarge"
        case i2_xlarge = "i2.xlarge"
        case i2_2xlarge = "i2.2xlarge"
        case i2_4xlarge = "i2.4xlarge"
        case i2_8xlarge = "i2.8xlarge"
        case i3_large = "i3.large"
        case i3_xlarge = "i3.xlarge"
        case i3_2xlarge = "i3.2xlarge"
        case i3_4xlarge = "i3.4xlarge"
        case i3_8xlarge = "i3.8xlarge"
        case i3_16xlarge = "i3.16xlarge"
        case hi1_4xlarge = "hi1.4xlarge"
        case hs1_8xlarge = "hs1.8xlarge"
        case c1_medium = "c1.medium"
        case c1_xlarge = "c1.xlarge"
        case c3_large = "c3.large"
        case c3_xlarge = "c3.xlarge"
        case c3_2xlarge = "c3.2xlarge"
        case c3_4xlarge = "c3.4xlarge"
        case c3_8xlarge = "c3.8xlarge"
        case c4_large = "c4.large"
        case c4_xlarge = "c4.xlarge"
        case c4_2xlarge = "c4.2xlarge"
        case c4_4xlarge = "c4.4xlarge"
        case c4_8xlarge = "c4.8xlarge"
        case cc1_4xlarge = "cc1.4xlarge"
        case cc2_8xlarge = "cc2.8xlarge"
        case g2_2xlarge = "g2.2xlarge"
        case g2_8xlarge = "g2.8xlarge"
        case cg1_4xlarge = "cg1.4xlarge"
        case p2_xlarge = "p2.xlarge"
        case p2_8xlarge = "p2.8xlarge"
        case p2_16xlarge = "p2.16xlarge"
        case d2_xlarge = "d2.xlarge"
        case d2_2xlarge = "d2.2xlarge"
        case d2_4xlarge = "d2.4xlarge"
        case d2_8xlarge = "d2.8xlarge"
        case f1_2xlarge = "f1.2xlarge"
        case f1_16xlarge = "f1.16xlarge"
        public var description: String { return self.rawValue }
    }

    public struct DisassociateIamInstanceProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the IAM instance profile association.
        public let associationId: String

        public init(associationId: String) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct DescribeHostReservationOfferingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the offerings.
        public let offeringSet: [HostOffering]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(offeringSet: [HostOffering]? = nil, nextToken: String? = nil) {
            self.offeringSet = offeringSet
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let offeringSet = dictionary["OfferingSet"] as? [[String: Any]] {
                self.offeringSet = try offeringSet.map({ try HostOffering(dictionary: $0) })
            } else { 
                self.offeringSet = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct NatGatewayList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NatGateway]?

        public init(item: [NatGateway]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NatGateway(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VpcCidrBlockState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state of the CIDR block.
        public let state: VpcCidrBlockStateCode?
        /// A message about the status of the CIDR block, if applicable.
        public let statusMessage: String?

        public init(state: VpcCidrBlockStateCode? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            if let state = dictionary["State"] as? String { self.state = VpcCidrBlockStateCode(rawValue: state) } else { self.state = nil }
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct NetworkAclAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String?
        /// The ID of the association between a network ACL and a subnet.
        public let networkAclAssociationId: String?
        /// The ID of the network ACL.
        public let networkAclId: String?

        public init(subnetId: String? = nil, networkAclAssociationId: String? = nil, networkAclId: String? = nil) {
            self.subnetId = subnetId
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkAclAssociationId = dictionary["NetworkAclAssociationId"] as? String
            self.networkAclId = dictionary["NetworkAclId"] as? String
        }
    }

    public enum OfferingClassType: String, CustomStringConvertible {
        case standard = "standard"
        case convertible = "convertible"
        public var description: String { return self.rawValue }
    }

    public struct DeleteNatGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the NAT gateway.
        public let natGatewayId: String

        public init(natGatewayId: String) {
            self.natGatewayId = natGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let natGatewayId = dictionary["NatGatewayId"] as? String else { throw InitializableError.missingRequiredParam("NatGatewayId") }
            self.natGatewayId = natGatewayId
        }
    }

    public struct PurchaseScheduledInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the Scheduled Instances.
        public let scheduledInstanceSet: PurchasedScheduledInstanceSet?

        public init(scheduledInstanceSet: PurchasedScheduledInstanceSet? = nil) {
            self.scheduledInstanceSet = scheduledInstanceSet
        }

        public init(dictionary: [String: Any]) throws {
            if let scheduledInstanceSet = dictionary["ScheduledInstanceSet"] as? [String: Any] { self.scheduledInstanceSet = try Ec2.PurchasedScheduledInstanceSet(dictionary: scheduledInstanceSet) } else { self.scheduledInstanceSet = nil }
        }
    }

    public struct DescribeVolumeStatusResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of volumes.
        public let volumeStatuses: VolumeStatusList?

        public init(nextToken: String? = nil, volumeStatuses: VolumeStatusList? = nil) {
            self.nextToken = nextToken
            self.volumeStatuses = volumeStatuses
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let volumeStatuses = dictionary["VolumeStatusSet"] as? [String: Any] { self.volumeStatuses = try Ec2.VolumeStatusList(dictionary: volumeStatuses) } else { self.volumeStatuses = nil }
        }
    }

    public struct AvailableCapacity: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The total number of instances that the Dedicated Host supports.
        public let availableInstanceCapacity: AvailableInstanceCapacityList?
        /// The number of vCPUs available on the Dedicated Host.
        public let availableVCpus: Int32?

        public init(availableInstanceCapacity: AvailableInstanceCapacityList? = nil, availableVCpus: Int32? = nil) {
            self.availableInstanceCapacity = availableInstanceCapacity
            self.availableVCpus = availableVCpus
        }

        public init(dictionary: [String: Any]) throws {
            if let availableInstanceCapacity = dictionary["AvailableInstanceCapacity"] as? [String: Any] { self.availableInstanceCapacity = try Ec2.AvailableInstanceCapacityList(dictionary: availableInstanceCapacity) } else { self.availableInstanceCapacity = nil }
            self.availableVCpus = dictionary["AvailableVCpus"] as? Int32
        }
    }

    public struct SpotPrice: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time the request was created, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let timestamp: Date?
        /// The instance type. Note that T2 and HS1 instance types are not supported.
        public let instanceType: InstanceType?
        /// The Availability Zone.
        public let availabilityZone: String?
        /// The maximum price (bid) that you are willing to pay for a Spot instance.
        public let spotPrice: String?
        /// A general description of the AMI.
        public let productDescription: RIProductDescription?

        public init(timestamp: Date? = nil, instanceType: InstanceType? = nil, availabilityZone: String? = nil, spotPrice: String? = nil, productDescription: RIProductDescription? = nil) {
            self.timestamp = timestamp
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.spotPrice = spotPrice
            self.productDescription = productDescription
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.spotPrice = dictionary["SpotPrice"] as? String
            if let productDescription = dictionary["ProductDescription"] as? String { self.productDescription = RIProductDescription(rawValue: productDescription) } else { self.productDescription = nil }
        }
    }

    public struct SnapshotList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Snapshot]?

        public init(item: [Snapshot]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Snapshot(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ReservedInstancesConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.
        public let platform: String?
        /// The number of modified Reserved Instances.
        public let instanceCount: Int32?
        /// The instance type for the modified Reserved Instances.
        public let instanceType: InstanceType?
        /// The Availability Zone for the modified Reserved Instances.
        public let availabilityZone: String?
        /// Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.
        public let scope: Scope?

        public init(platform: String? = nil, instanceCount: Int32? = nil, instanceType: InstanceType? = nil, availabilityZone: String? = nil, scope: Scope? = nil) {
            self.platform = platform
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.scope = scope
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let scope = dictionary["Scope"] as? String { self.scope = Scope(rawValue: scope) } else { self.scope = nil }
        }
    }

    public struct CreatePlacementGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The placement strategy.
        public let strategy: PlacementStrategy
        /// A name for the placement group. Constraints: Up to 255 ASCII characters
        public let groupName: String

        public init(dryRun: Bool? = nil, strategy: PlacementStrategy, groupName: String) {
            self.dryRun = dryRun
            self.strategy = strategy
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let rawStrategy = dictionary["Strategy"] as? String, let strategy = PlacementStrategy(rawValue: rawStrategy) else { throw InitializableError.missingRequiredParam("Strategy") }
            self.strategy = strategy
            guard let groupName = dictionary["GroupName"] as? String else { throw InitializableError.missingRequiredParam("GroupName") }
            self.groupName = groupName
        }
    }

    public struct DescribeSecurityGroupReferencesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more security group IDs in your account.
        public let groupId: GroupIds
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(groupId: GroupIds, dryRun: Bool? = nil) {
            self.groupId = groupId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let groupId = dictionary["GroupId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = try Ec2.GroupIds(dictionary: groupId)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct AvailableInstanceCapacityList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceCapacity]?

        public init(item: [InstanceCapacity]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceCapacity(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct PurchasedScheduledInstanceSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ScheduledInstance]?

        public init(item: [ScheduledInstance]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ScheduledInstance(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum CancelBatchErrorCode: String, CustomStringConvertible {
        case fleetrequestiddoesnotexist = "fleetRequestIdDoesNotExist"
        case fleetrequestidmalformed = "fleetRequestIdMalformed"
        case fleetrequestnotincancellablestate = "fleetRequestNotInCancellableState"
        case unexpectederror = "unexpectedError"
        public var description: String { return self.rawValue }
    }

    public struct DescribeVolumesModificationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more volume IDs for which in-progress modifications will be described.
        public let volumeIds: VolumeIdStringList?
        /// One or more filters. Supported filters: volume-id, modification-state, target-size, target-iops, target-volume-type, original-size, original-iops, original-volume-type, start-time. 
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The nextToken value returned by a previous paginated request.
        public let nextToken: String?
        /// The maximum number of results (up to a limit of 500) to be returned in a paginated request.
        public let maxResults: Int32?

        public init(volumeIds: VolumeIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeIds = dictionary["VolumeId"] as? [String: Any] { self.volumeIds = try Ec2.VolumeIdStringList(dictionary: volumeIds) } else { self.volumeIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ImageAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more block device mapping entries.
        public let blockDeviceMappings: BlockDeviceMappingList?
        /// One or more product codes.
        public let productCodes: ProductCodeList?
        /// One or more launch permissions.
        public let launchPermissions: LaunchPermissionList?
        /// Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public let sriovNetSupport: AttributeValue?
        /// The kernel ID.
        public let kernelId: AttributeValue?
        /// The ID of the AMI.
        public let imageId: String?
        /// The RAM disk ID.
        public let ramdiskId: AttributeValue?
        /// A description for the AMI.
        public let description: AttributeValue?

        public init(blockDeviceMappings: BlockDeviceMappingList? = nil, productCodes: ProductCodeList? = nil, launchPermissions: LaunchPermissionList? = nil, sriovNetSupport: AttributeValue? = nil, kernelId: AttributeValue? = nil, imageId: String? = nil, ramdiskId: AttributeValue? = nil, description: AttributeValue? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.productCodes = productCodes
            self.launchPermissions = launchPermissions
            self.sriovNetSupport = sriovNetSupport
            self.kernelId = kernelId
            self.imageId = imageId
            self.ramdiskId = ramdiskId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            if let productCodes = dictionary["ProductCodes"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeList(dictionary: productCodes) } else { self.productCodes = nil }
            if let launchPermissions = dictionary["LaunchPermission"] as? [String: Any] { self.launchPermissions = try Ec2.LaunchPermissionList(dictionary: launchPermissions) } else { self.launchPermissions = nil }
            if let sriovNetSupport = dictionary["SriovNetSupport"] as? [String: Any] { self.sriovNetSupport = try Ec2.AttributeValue(dictionary: sriovNetSupport) } else { self.sriovNetSupport = nil }
            if let kernelId = dictionary["Kernel"] as? [String: Any] { self.kernelId = try Ec2.AttributeValue(dictionary: kernelId) } else { self.kernelId = nil }
            self.imageId = dictionary["ImageId"] as? String
            if let ramdiskId = dictionary["Ramdisk"] as? [String: Any] { self.ramdiskId = try Ec2.AttributeValue(dictionary: ramdiskId) } else { self.ramdiskId = nil }
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) } else { self.description = nil }
        }
    }

    public struct CreateInstanceExportTaskRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The target virtualization environment.
        public let targetEnvironment: ExportEnvironment?
        /// The format and location for an instance export task.
        public let exportToS3Task: ExportToS3TaskSpecification?
        /// The ID of the instance.
        public let instanceId: String
        /// A description for the conversion task or the resource being exported. The maximum length is 255 bytes.
        public let description: String?

        public init(targetEnvironment: ExportEnvironment? = nil, exportToS3Task: ExportToS3TaskSpecification? = nil, instanceId: String, description: String? = nil) {
            self.targetEnvironment = targetEnvironment
            self.exportToS3Task = exportToS3Task
            self.instanceId = instanceId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let targetEnvironment = dictionary["TargetEnvironment"] as? String { self.targetEnvironment = ExportEnvironment(rawValue: targetEnvironment) } else { self.targetEnvironment = nil }
            if let exportToS3Task = dictionary["ExportToS3"] as? [String: Any] { self.exportToS3Task = try Ec2.ExportToS3TaskSpecification(dictionary: exportToS3Task) } else { self.exportToS3Task = nil }
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateFlowLogsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of traffic to log.
        public let trafficType: TrafficType
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        public let clientToken: String?
        /// One or more subnet, network interface, or VPC IDs. Constraints: Maximum of 1000 resources
        public let resourceIds: ValueStringList
        /// The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group.
        public let deliverLogsPermissionArn: String
        /// The type of resource on which to create the flow log.
        public let resourceType: FlowLogsResourceType
        /// The name of the CloudWatch log group.
        public let logGroupName: String

        public init(trafficType: TrafficType, clientToken: String? = nil, resourceIds: ValueStringList, deliverLogsPermissionArn: String, resourceType: FlowLogsResourceType, logGroupName: String) {
            self.trafficType = trafficType
            self.clientToken = clientToken
            self.resourceIds = resourceIds
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            self.resourceType = resourceType
            self.logGroupName = logGroupName
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawTrafficType = dictionary["TrafficType"] as? String, let trafficType = TrafficType(rawValue: rawTrafficType) else { throw InitializableError.missingRequiredParam("TrafficType") }
            self.trafficType = trafficType
            self.clientToken = dictionary["ClientToken"] as? String
            guard let resourceIds = dictionary["ResourceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceIds = try Ec2.ValueStringList(dictionary: resourceIds)
            guard let deliverLogsPermissionArn = dictionary["DeliverLogsPermissionArn"] as? String else { throw InitializableError.missingRequiredParam("DeliverLogsPermissionArn") }
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            guard let rawResourceType = dictionary["ResourceType"] as? String, let resourceType = FlowLogsResourceType(rawValue: rawResourceType) else { throw InitializableError.missingRequiredParam("ResourceType") }
            self.resourceType = resourceType
            guard let logGroupName = dictionary["LogGroupName"] as? String else { throw InitializableError.missingRequiredParam("LogGroupName") }
            self.logGroupName = logGroupName
        }
    }

    public struct ScheduledInstancesIpv6AddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let ipv6Address: [ScheduledInstancesIpv6Address]?

        public init(ipv6Address: [ScheduledInstancesIpv6Address]? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            if let ipv6Address = dictionary["Ipv6Address"] as? [[String: Any]] {
                self.ipv6Address = try ipv6Address.map({ try ScheduledInstancesIpv6Address(dictionary: $0) })
            } else { 
                self.ipv6Address = nil
            }
        }
    }

    public struct AccountAttributeValueList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [AccountAttributeValue]?

        public init(item: [AccountAttributeValue]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try AccountAttributeValue(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct TargetConfigurationRequestSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let targetConfigurationRequest: [TargetConfigurationRequest]?

        public init(targetConfigurationRequest: [TargetConfigurationRequest]? = nil) {
            self.targetConfigurationRequest = targetConfigurationRequest
        }

        public init(dictionary: [String: Any]) throws {
            if let targetConfigurationRequest = dictionary["TargetConfigurationRequest"] as? [[String: Any]] {
                self.targetConfigurationRequest = try targetConfigurationRequest.map({ try TargetConfigurationRequest(dictionary: $0) })
            } else { 
                self.targetConfigurationRequest = nil
            }
        }
    }

    public struct ImportImageTask: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The license type of the virtual machine.
        public let licenseType: String?
        /// A brief status for the import image task.
        public let status: String?
        /// The description string for the import image task.
        public let platform: String?
        /// The percentage of progress of the import image task.
        public let progress: String?
        /// The target hypervisor for the import task. Valid values: xen 
        public let hypervisor: String?
        /// The architecture of the virtual machine. Valid values: i386 | x86_64 
        public let architecture: String?
        /// The ID of the Amazon Machine Image (AMI) of the imported virtual machine.
        public let imageId: String?
        /// The ID of the import image task.
        public let importTaskId: String?
        /// A descriptive status message for the import image task.
        public let statusMessage: String?
        /// Information about the snapshots.
        public let snapshotDetails: SnapshotDetailList?
        /// A description of the import task.
        public let description: String?

        public init(licenseType: String? = nil, status: String? = nil, platform: String? = nil, progress: String? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, importTaskId: String? = nil, statusMessage: String? = nil, snapshotDetails: SnapshotDetailList? = nil, description: String? = nil) {
            self.licenseType = licenseType
            self.status = status
            self.platform = platform
            self.progress = progress
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.importTaskId = importTaskId
            self.statusMessage = statusMessage
            self.snapshotDetails = snapshotDetails
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.licenseType = dictionary["LicenseType"] as? String
            self.status = dictionary["Status"] as? String
            self.platform = dictionary["Platform"] as? String
            self.progress = dictionary["Progress"] as? String
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.imageId = dictionary["ImageId"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let snapshotDetails = dictionary["SnapshotDetailSet"] as? [String: Any] { self.snapshotDetails = try Ec2.SnapshotDetailList(dictionary: snapshotDetails) } else { self.snapshotDetails = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVolumesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the volumes.
        public let volumes: VolumeList?
        /// The NextToken value to include in a future DescribeVolumes request. When the results of a DescribeVolumes request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(volumes: VolumeList? = nil, nextToken: String? = nil) {
            self.volumes = volumes
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let volumes = dictionary["VolumeSet"] as? [String: Any] { self.volumes = try Ec2.VolumeList(dictionary: volumes) } else { self.volumes = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct ResponseHostIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct ModifyInstancePlacementRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The new affinity setting for the instance.
        public let affinity: Affinity?
        /// The ID of the Dedicated Host that the instance will have affinity with.
        public let hostId: String?
        /// The ID of the instance that you are modifying.
        public let instanceId: String
        /// The tenancy of the instance that you are modifying.
        public let tenancy: HostTenancy?

        public init(affinity: Affinity? = nil, hostId: String? = nil, instanceId: String, tenancy: HostTenancy? = nil) {
            self.affinity = affinity
            self.hostId = hostId
            self.instanceId = instanceId
            self.tenancy = tenancy
        }

        public init(dictionary: [String: Any]) throws {
            if let affinity = dictionary["Affinity"] as? String { self.affinity = Affinity(rawValue: affinity) } else { self.affinity = nil }
            self.hostId = dictionary["HostId"] as? String
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            if let tenancy = dictionary["Tenancy"] as? String { self.tenancy = HostTenancy(rawValue: tenancy) } else { self.tenancy = nil }
        }
    }

    public struct ScheduledInstancesLaunchSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more block device mapping entries.
        public let blockDeviceMappings: ScheduledInstancesBlockDeviceMappingSet?
        /// The ID of the subnet in which to launch the instances.
        public let subnetId: String?
        /// The base64-encoded MIME user data.
        public let userData: String?
        /// Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false 
        public let ebsOptimized: Bool?
        /// The ID of the kernel.
        public let kernelId: String?
        /// The IDs of one or more security groups.
        public let securityGroupIds: ScheduledInstancesSecurityGroupIdSet?
        /// Enable or disable monitoring for the instances.
        public let monitoring: ScheduledInstancesMonitoring?
        /// The instance type.
        public let instanceType: String?
        /// The name of the key pair.
        public let keyName: String?
        /// The IAM instance profile.
        public let iamInstanceProfile: ScheduledInstancesIamInstanceProfile?
        /// The ID of the Amazon Machine Image (AMI).
        public let imageId: String
        /// One or more network interfaces.
        public let networkInterfaces: ScheduledInstancesNetworkInterfaceSet?
        /// The placement information.
        public let placement: ScheduledInstancesPlacement?
        /// The ID of the RAM disk.
        public let ramdiskId: String?

        public init(blockDeviceMappings: ScheduledInstancesBlockDeviceMappingSet? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, securityGroupIds: ScheduledInstancesSecurityGroupIdSet? = nil, monitoring: ScheduledInstancesMonitoring? = nil, instanceType: String? = nil, keyName: String? = nil, iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil, imageId: String, networkInterfaces: ScheduledInstancesNetworkInterfaceSet? = nil, placement: ScheduledInstancesPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.keyName = keyName
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.ScheduledInstancesBlockDeviceMappingSet(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            if let securityGroupIds = dictionary["SecurityGroupId"] as? [String: Any] { self.securityGroupIds = try Ec2.ScheduledInstancesSecurityGroupIdSet(dictionary: securityGroupIds) } else { self.securityGroupIds = nil }
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.ScheduledInstancesMonitoring(dictionary: monitoring) } else { self.monitoring = nil }
            self.instanceType = dictionary["InstanceType"] as? String
            self.keyName = dictionary["KeyName"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.ScheduledInstancesIamInstanceProfile(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
            if let networkInterfaces = dictionary["NetworkInterface"] as? [String: Any] { self.networkInterfaces = try Ec2.ScheduledInstancesNetworkInterfaceSet(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.ScheduledInstancesPlacement(dictionary: placement) } else { self.placement = nil }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct DisableVpcClassicLinkRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct MoveAddressToVpcResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the move of the IP address.
        public let status: Status?
        /// The allocation ID for the Elastic IP address.
        public let allocationId: String?

        public init(status: Status? = nil, allocationId: String? = nil) {
            self.status = status
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["Status"] as? String { self.status = Status(rawValue: status) } else { self.status = nil }
            self.allocationId = dictionary["AllocationId"] as? String
        }
    }

    public struct DeleteVpnConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPN connection.
        public let vpnConnectionId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpnConnectionId: String, dryRun: Bool? = nil) {
            self.vpnConnectionId = vpnConnectionId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpnConnectionId = dictionary["VpnConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpnConnectionId") }
            self.vpnConnectionId = vpnConnectionId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateVolumePermission: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.
        public let userId: String?
        /// The specific group that is to be added or removed from a volume's list of create volume permissions.
        public let group: PermissionGroup?

        public init(userId: String? = nil, group: PermissionGroup? = nil) {
            self.userId = userId
            self.group = group
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            if let group = dictionary["Group"] as? String { self.group = PermissionGroup(rawValue: group) } else { self.group = nil }
        }
    }

    public struct ReservedInstancesModificationIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let reservedInstancesModificationId: [String]?

        public init(reservedInstancesModificationId: [String]? = nil) {
            self.reservedInstancesModificationId = reservedInstancesModificationId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesModificationId = dictionary["ReservedInstancesModificationId"] as? [String]
        }
    }

    public struct BlockDeviceMappingList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [BlockDeviceMapping]?

        public init(item: [BlockDeviceMapping]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try BlockDeviceMapping(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CustomerGateway: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the customer gateway.
        public let customerGatewayId: String?
        /// The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).
        public let bgpAsn: String?
        /// The type of VPN connection the customer gateway supports (ipsec.1).
        public let `type`: String?
        /// Any tags assigned to the customer gateway.
        public let tags: TagList?
        /// The current state of the customer gateway (pending | available | deleting | deleted).
        public let state: String?
        /// The Internet-routable IP address of the customer gateway's outside interface.
        public let ipAddress: String?

        public init(customerGatewayId: String? = nil, bgpAsn: String? = nil, type: String? = nil, tags: TagList? = nil, state: String? = nil, ipAddress: String? = nil) {
            self.customerGatewayId = customerGatewayId
            self.bgpAsn = bgpAsn
            self.`type` = `type`
            self.tags = tags
            self.state = state
            self.ipAddress = ipAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.customerGatewayId = dictionary["CustomerGatewayId"] as? String
            self.bgpAsn = dictionary["BgpAsn"] as? String
            self.`type` = dictionary["Type"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.state = dictionary["State"] as? String
            self.ipAddress = dictionary["IpAddress"] as? String
        }
    }

    public struct DescribeAccountAttributesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more account attribute names.
        public let attributeNames: AccountAttributeNameStringList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(attributeNames: AccountAttributeNameStringList? = nil, dryRun: Bool? = nil) {
            self.attributeNames = attributeNames
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeNames = dictionary["AttributeName"] as? [String: Any] { self.attributeNames = try Ec2.AccountAttributeNameStringList(dictionary: attributeNames) } else { self.attributeNames = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct HistoryRecords: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [HistoryRecord]?

        public init(item: [HistoryRecord]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try HistoryRecord(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ReservedInstancesModificationResultList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstancesModificationResult]?

        public init(item: [ReservedInstancesModificationResult]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstancesModificationResult(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VpnGatewayIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let vpnGatewayId: [String]?

        public init(vpnGatewayId: [String]? = nil) {
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpnGatewayId = dictionary["VpnGatewayId"] as? [String]
        }
    }

    public struct CreateVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of VPN connection this virtual private gateway supports.
        public let `type`: GatewayType
        /// The Availability Zone for the virtual private gateway.
        public let availabilityZone: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(type: GatewayType, availabilityZone: String? = nil, dryRun: Bool? = nil) {
            self.`type` = `type`
            self.availabilityZone = availabilityZone
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawType = dictionary["Type"] as? String, let `type` = GatewayType(rawValue: rawType) else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DeleteSpotDatafeedSubscriptionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct Route: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the egress-only Internet gateway.
        public let egressOnlyInternetGatewayId: String?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The ID of a NAT gateway.
        public let natGatewayId: String?
        /// Describes how the route was created.    CreateRouteTable - The route was automatically created when the route table was created.    CreateRoute - The route was manually added to the route table.    EnableVgwRoutePropagation - The route was propagated by route propagation.  
        public let origin: RouteOrigin?
        /// The state of the route. The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).
        public let state: RouteState?
        /// The IPv6 CIDR block used for the destination match.
        public let destinationIpv6CidrBlock: String?
        /// The prefix of the AWS service.
        public let destinationPrefixListId: String?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String?
        /// The ID of a NAT instance in your VPC.
        public let instanceId: String?
        /// The AWS account ID of the owner of the instance.
        public let instanceOwnerId: String?
        /// The ID of a gateway attached to your VPC.
        public let gatewayId: String?
        /// The IPv4 CIDR block used for the destination match.
        public let destinationCidrBlock: String?

        public init(egressOnlyInternetGatewayId: String? = nil, networkInterfaceId: String? = nil, natGatewayId: String? = nil, origin: RouteOrigin? = nil, state: RouteState? = nil, destinationIpv6CidrBlock: String? = nil, destinationPrefixListId: String? = nil, vpcPeeringConnectionId: String? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.natGatewayId = natGatewayId
            self.origin = origin
            self.state = state
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            if let origin = dictionary["Origin"] as? String { self.origin = RouteOrigin(rawValue: origin) } else { self.origin = nil }
            if let state = dictionary["State"] as? String { self.state = RouteState(rawValue: state) } else { self.state = nil }
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
            self.destinationPrefixListId = dictionary["DestinationPrefixListId"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.instanceOwnerId = dictionary["InstanceOwnerId"] as? String
            self.gatewayId = dictionary["GatewayId"] as? String
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
        }
    }

    public struct CancelSpotFleetRequestsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the Spot fleet requests that are successfully canceled.
        public let successfulFleetRequests: CancelSpotFleetRequestsSuccessSet?
        /// Information about the Spot fleet requests that are not successfully canceled.
        public let unsuccessfulFleetRequests: CancelSpotFleetRequestsErrorSet?

        public init(successfulFleetRequests: CancelSpotFleetRequestsSuccessSet? = nil, unsuccessfulFleetRequests: CancelSpotFleetRequestsErrorSet? = nil) {
            self.successfulFleetRequests = successfulFleetRequests
            self.unsuccessfulFleetRequests = unsuccessfulFleetRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let successfulFleetRequests = dictionary["SuccessfulFleetRequestSet"] as? [String: Any] { self.successfulFleetRequests = try Ec2.CancelSpotFleetRequestsSuccessSet(dictionary: successfulFleetRequests) } else { self.successfulFleetRequests = nil }
            if let unsuccessfulFleetRequests = dictionary["UnsuccessfulFleetRequestSet"] as? [String: Any] { self.unsuccessfulFleetRequests = try Ec2.CancelSpotFleetRequestsErrorSet(dictionary: unsuccessfulFleetRequests) } else { self.unsuccessfulFleetRequests = nil }
        }
    }

    public struct VpnGatewayList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpnGateway]?

        public init(item: [VpnGateway]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpnGateway(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DeleteSecurityGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the security group. Required for a nondefault VPC.
        public let groupId: String?
        /// [EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.
        public let groupName: String?

        public init(dryRun: Bool? = nil, groupId: String? = nil, groupName: String? = nil) {
            self.dryRun = dryRun
            self.groupId = groupId
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.groupId = dictionary["GroupId"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct CreateVpcResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPC.
        public let vpc: Vpc?

        public init(vpc: Vpc? = nil) {
            self.vpc = vpc
        }

        public init(dictionary: [String: Any]) throws {
            if let vpc = dictionary["Vpc"] as? [String: Any] { self.vpc = try Ec2.Vpc(dictionary: vpc) } else { self.vpc = nil }
        }
    }

    public struct DescribeInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    affinity - The affinity setting for an instance running on a Dedicated Host (default | host).    architecture - The instance architecture (i386 | x86_64).    association.public-ip - The address of the Elastic IP address (IPv4) bound to the network interface.    association.ip-owner-id - The owner of the Elastic IP address (IPv4) associated with the network interface.    association.allocation-id - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.    association.association-id - The association ID returned when the network interface was associated with an IPv4 address.    availability-zone - The Availability Zone of the instance.    block-device-mapping.attach-time - The attach time for an EBS volume mapped to the instance, for example, 2010-09-15T17:15:20.000Z.    block-device-mapping.delete-on-termination - A Boolean that indicates whether the EBS volume is deleted on instance termination.    block-device-mapping.device-name - The device name for the EBS volume (for example, /dev/sdh or xvdh).    block-device-mapping.status - The status for the EBS volume (attaching | attached | detaching | detached).    block-device-mapping.volume-id - The volume ID of the EBS volume.    client-token - The idempotency token you provided when you launched the instance.    dns-name - The public DNS name of the instance.    group-id - The ID of the security group for the instance. EC2-Classic only.    group-name - The name of the security group for the instance. EC2-Classic only.    host-id - The ID of the Dedicated Host on which the instance is running, if applicable.    hypervisor - The hypervisor type of the instance (ovm | xen).    iam-instance-profile.arn - The instance profile associated with the instance. Specified as an ARN.    image-id - The ID of the image used to launch the instance.    instance-id - The ID of the instance.    instance-lifecycle - Indicates whether this is a Spot Instance or a Scheduled Instance (spot | scheduled).    instance-state-code - The state of the instance, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).    instance-state-name - The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).    instance-type - The type of instance (for example, t2.micro).    instance.group-id - The ID of the security group for the instance.     instance.group-name - The name of the security group for the instance.     ip-address - The public IPv4 address of the instance.    kernel-id - The kernel ID.    key-name - The name of the key pair used when the instance was launched.    launch-index - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on).     launch-time - The time when the instance was launched.    monitoring-state - Indicates whether detailed monitoring is enabled (disabled | enabled).    network-interface.addresses.private-ip-address - The private IPv4 address associated with the network interface.    network-interface.addresses.primary - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.    network-interface.addresses.association.public-ip - The ID of the association of an Elastic IP address (IPv4) with a network interface.    network-interface.addresses.association.ip-owner-id - The owner ID of the private IPv4 address associated with the network interface.    network-interface.attachment.attachment-id - The ID of the interface attachment.    network-interface.attachment.instance-id - The ID of the instance to which the network interface is attached.    network-interface.attachment.instance-owner-id - The owner ID of the instance to which the network interface is attached.    network-interface.attachment.device-index - The device index to which the network interface is attached.    network-interface.attachment.status - The status of the attachment (attaching | attached | detaching | detached).    network-interface.attachment.attach-time - The time that the network interface was attached to an instance.    network-interface.attachment.delete-on-termination - Specifies whether the attachment is deleted when an instance is terminated.    network-interface.availability-zone - The Availability Zone for the network interface.    network-interface.description - The description of the network interface.    network-interface.group-id - The ID of a security group associated with the network interface.    network-interface.group-name - The name of a security group associated with the network interface.    network-interface.ipv6-addresses.ipv6-address - The IPv6 address associated with the network interface.    network-interface.mac-address - The MAC address of the network interface.    network-interface.network-interface-id - The ID of the network interface.    network-interface.owner-id - The ID of the owner of the network interface.    network-interface.private-dns-name - The private DNS name of the network interface.    network-interface.requester-id - The requester ID for the network interface.    network-interface.requester-managed - Indicates whether the network interface is being managed by AWS.    network-interface.status - The status of the network interface (available) | in-use).    network-interface.source-dest-check - Whether the network interface performs source/destination checking. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the network interface to perform network address translation (NAT) in your VPC.    network-interface.subnet-id - The ID of the subnet for the network interface.    network-interface.vpc-id - The ID of the VPC for the network interface.    owner-id - The AWS account ID of the instance owner.    placement-group-name - The name of the placement group for the instance.    platform - The platform. Use windows if you have Windows instances; otherwise, leave blank.    private-dns-name - The private IPv4 DNS name of the instance.    private-ip-address - The private IPv4 address of the instance.    product-code - The product code associated with the AMI used to launch the instance.    product-code.type - The type of product code (devpay | marketplace).    ramdisk-id - The RAM disk ID.    reason - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.    requester-id - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).    reservation-id - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you'll get one reservation ID. If you launch ten instances using the same launch request, you'll also get one reservation ID.    root-device-name - The name of the root device for the instance (for example, /dev/sda1 or /dev/xvda).    root-device-type - The type of root device that the instance uses (ebs | instance-store).    source-dest-check - Indicates whether the instance performs source/destination checking. A value of true means that checking is enabled, and false means checking is disabled. The value must be false for the instance to perform network address translation (NAT) in your VPC.     spot-instance-request-id - The ID of the Spot instance request.    state-reason-code - The reason code for the state change.    state-reason-message - A message that describes the state change.    subnet-id - The ID of the subnet for the instance.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    tenancy - The tenancy of an instance (dedicated | default | host).    virtualization-type - The virtualization type of the instance (paravirtual | hvm).    vpc-id - The ID of the VPC that the instance is running in.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more instance IDs. Default: Describes all your instances.
        public let instanceIds: InstanceIdStringList?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter or tag filters in the same call.
        public let maxResults: Int32?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, instanceIds: InstanceIdStringList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceIds = dictionary["InstanceId"] as? [String: Any] { self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds) } else { self.instanceIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct UserGroupStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let userGroup: [String]?

        public init(userGroup: [String]? = nil) {
            self.userGroup = userGroup
        }

        public init(dictionary: [String: Any]) throws {
            self.userGroup = dictionary["UserGroup"] as? [String]
        }
    }

    public struct DescribeScheduledInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the Scheduled Instances.
        public let scheduledInstanceSet: ScheduledInstanceSet?

        public init(nextToken: String? = nil, scheduledInstanceSet: ScheduledInstanceSet? = nil) {
            self.nextToken = nextToken
            self.scheduledInstanceSet = scheduledInstanceSet
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let scheduledInstanceSet = dictionary["ScheduledInstanceSet"] as? [String: Any] { self.scheduledInstanceSet = try Ec2.ScheduledInstanceSet(dictionary: scheduledInstanceSet) } else { self.scheduledInstanceSet = nil }
        }
    }

    public struct DeleteNetworkAclEntryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the network ACL.
        public let networkAclId: String
        /// The rule number of the entry to delete.
        public let ruleNumber: Int32
        /// Indicates whether the rule is an egress rule.
        public let egress: Bool
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(networkAclId: String, ruleNumber: Int32, egress: Bool, dryRun: Bool? = nil) {
            self.networkAclId = networkAclId
            self.ruleNumber = ruleNumber
            self.egress = egress
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
            guard let ruleNumber = dictionary["RuleNumber"] as? Int32 else { throw InitializableError.missingRequiredParam("RuleNumber") }
            self.ruleNumber = ruleNumber
            guard let egress = dictionary["Egress"] as? Bool else { throw InitializableError.missingRequiredParam("Egress") }
            self.egress = egress
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct NewDhcpConfigurationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NewDhcpConfiguration]?

        public init(item: [NewDhcpConfiguration]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NewDhcpConfiguration(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ResetSnapshotAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the snapshot.
        public let snapshotId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.
        public let attribute: SnapshotAttributeName

        public init(snapshotId: String, dryRun: Bool? = nil, attribute: SnapshotAttributeName) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = SnapshotAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct VpnGateway: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Any VPCs attached to the virtual private gateway.
        public let vpcAttachments: VpcAttachmentList?
        /// The ID of the virtual private gateway.
        public let vpnGatewayId: String?
        /// The type of VPN connection the virtual private gateway supports.
        public let `type`: GatewayType?
        /// The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.
        public let availabilityZone: String?
        /// Any tags assigned to the virtual private gateway.
        public let tags: TagList?
        /// The current state of the virtual private gateway.
        public let state: VpnState?

        public init(vpcAttachments: VpcAttachmentList? = nil, vpnGatewayId: String? = nil, type: GatewayType? = nil, availabilityZone: String? = nil, tags: TagList? = nil, state: VpnState? = nil) {
            self.vpcAttachments = vpcAttachments
            self.vpnGatewayId = vpnGatewayId
            self.`type` = `type`
            self.availabilityZone = availabilityZone
            self.tags = tags
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcAttachments = dictionary["Attachments"] as? [String: Any] { self.vpcAttachments = try Ec2.VpcAttachmentList(dictionary: vpcAttachments) } else { self.vpcAttachments = nil }
            self.vpnGatewayId = dictionary["VpnGatewayId"] as? String
            if let `type` = dictionary["Type"] as? String { self.`type` = GatewayType(rawValue: `type`) } else { self.`type` = nil }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            if let state = dictionary["State"] as? String { self.state = VpnState(rawValue: state) } else { self.state = nil }
        }
    }

    public struct CancelSpotFleetRequestsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Indicates whether to terminate instances for a Spot fleet request if it is canceled successfully.
        public let terminateInstances: Bool
        /// The IDs of the Spot fleet requests.
        public let spotFleetRequestIds: ValueStringList

        public init(dryRun: Bool? = nil, terminateInstances: Bool, spotFleetRequestIds: ValueStringList) {
            self.dryRun = dryRun
            self.terminateInstances = terminateInstances
            self.spotFleetRequestIds = spotFleetRequestIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let terminateInstances = dictionary["TerminateInstances"] as? Bool else { throw InitializableError.missingRequiredParam("TerminateInstances") }
            self.terminateInstances = terminateInstances
            guard let spotFleetRequestIds = dictionary["SpotFleetRequestId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestIds = try Ec2.ValueStringList(dictionary: spotFleetRequestIds)
        }
    }

    public struct InstanceIpv6AddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceIpv6Address]?

        public init(item: [InstanceIpv6Address]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceIpv6Address(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ScheduledInstanceSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ScheduledInstance]?

        public init(item: [ScheduledInstance]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ScheduledInstance(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeVolumeStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more volume IDs. Default: Describes all your volumes.
        public let volumeIds: VolumeIdStringList?
        /// One or more filters.    action.code - The action code for the event (for example, enable-volume-io).    action.description - A description of the action.    action.event-id - The event ID associated with the action.    availability-zone - The Availability Zone of the instance.    event.description - A description of the event.    event.event-id - The event ID.    event.event-type - The event type (for io-enabled: passed | failed; for io-performance: io-performance:degraded | io-performance:severely-degraded | io-performance:stalled).    event.not-after - The latest end time for the event.    event.not-before - The earliest start time for the event.    volume-status.details-name - The cause for volume-status.status (io-enabled | io-performance).    volume-status.details-status - The status of volume-status.details-name (for io-enabled: passed | failed; for io-performance: normal | degraded | severely-degraded | stalled).    volume-status.status - The status of the volume (ok | impaired | warning | insufficient-data).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The NextToken value to include in a future DescribeVolumeStatus request. When the results of the request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The maximum number of volume results returned by DescribeVolumeStatus in paginated output. When this parameter is used, the request only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then DescribeVolumeStatus returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.
        public let maxResults: Int32?

        public init(volumeIds: VolumeIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeIds = dictionary["VolumeId"] as? [String: Any] { self.volumeIds = try Ec2.VolumeIdStringList(dictionary: volumeIds) } else { self.volumeIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct InstanceStatusList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceStatus]?

        public init(item: [InstanceStatus]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceStatus(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeSecurityGroupsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more security group IDs. Required for security groups in a nondefault VPC. Default: Describes all your security groups.
        public let groupIds: GroupIdStringList?
        /// One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.    description - The description of the security group.    egress.ip-permission.prefix-list-id - The ID (prefix) of the AWS service to which the security group allows access.    group-id - The ID of the security group.     group-name - The name of the security group.    ip-permission.cidr - An IPv4 CIDR range that has been granted permission in a security group rule.    ip-permission.from-port - The start of port range for the TCP and UDP protocols, or an ICMP type number.    ip-permission.group-id - The ID of a security group that has been granted permission.    ip-permission.group-name - The name of a security group that has been granted permission.    ip-permission.ipv6-cidr - An IPv6 CIDR range that has been granted permission in a security group rule.    ip-permission.protocol - The IP protocol for the permission (tcp | udp | icmp or a protocol number).    ip-permission.to-port - The end of port range for the TCP and UDP protocols, or an ICMP code.    ip-permission.user-id - The ID of an AWS account that has been granted permission.    owner-id - The AWS account ID of the owner of the security group.    tag-key - The key of a tag assigned to the security group.    tag-value - The value of a tag assigned to the security group.    vpc-id - The ID of the VPC specified when the security group was created.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// [EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the group-name filter to describe security groups by name. Default: Describes all your security groups.
        public let groupNames: GroupNameStringList?

        public init(groupIds: GroupIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, groupNames: GroupNameStringList? = nil) {
            self.groupIds = groupIds
            self.filters = filters
            self.dryRun = dryRun
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            if let groupIds = dictionary["GroupId"] as? [String: Any] { self.groupIds = try Ec2.GroupIdStringList(dictionary: groupIds) } else { self.groupIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let groupNames = dictionary["GroupName"] as? [String: Any] { self.groupNames = try Ec2.GroupNameStringList(dictionary: groupNames) } else { self.groupNames = nil }
        }
    }

    public struct Snapshot: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the DescribeSnapshots API operation.
        public let stateMessage: String?
        /// The snapshot state.
        public let state: SnapshotState?
        /// The ID of the volume that was used to create the snapshot. Snapshots created by the CopySnapshot action have an arbitrary volume ID that should not be used for any purpose.
        public let volumeId: String?
        /// Indicates whether the snapshot is encrypted.
        public let encrypted: Bool?
        /// Any tags assigned to the snapshot.
        public let tags: TagList?
        /// The AWS account ID of the EBS snapshot owner.
        public let ownerId: String?
        /// The description for the snapshot.
        public let description: String?
        /// The time stamp when the snapshot was initiated.
        public let startTime: Date?
        /// The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the DescribeSnapshots API operation.
        public let dataEncryptionKeyId: String?
        /// The progress of the snapshot, as a percentage.
        public let progress: String?
        /// The ID of the snapshot. Each snapshot receives a unique identifier when it is created.
        public let snapshotId: String?
        /// The size of the volume, in GiB.
        public let volumeSize: Int32?
        ///  Value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. 
        public let ownerAlias: String?
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.
        public let kmsKeyId: String?

        public init(stateMessage: String? = nil, state: SnapshotState? = nil, volumeId: String? = nil, encrypted: Bool? = nil, tags: TagList? = nil, ownerId: String? = nil, description: String? = nil, startTime: Date? = nil, dataEncryptionKeyId: String? = nil, progress: String? = nil, snapshotId: String? = nil, volumeSize: Int32? = nil, ownerAlias: String? = nil, kmsKeyId: String? = nil) {
            self.stateMessage = stateMessage
            self.state = state
            self.volumeId = volumeId
            self.encrypted = encrypted
            self.tags = tags
            self.ownerId = ownerId
            self.description = description
            self.startTime = startTime
            self.dataEncryptionKeyId = dataEncryptionKeyId
            self.progress = progress
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.ownerAlias = ownerAlias
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            self.stateMessage = dictionary["StatusMessage"] as? String
            if let state = dictionary["Status"] as? String { self.state = SnapshotState(rawValue: state) } else { self.state = nil }
            self.volumeId = dictionary["VolumeId"] as? String
            self.encrypted = dictionary["Encrypted"] as? Bool
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.ownerId = dictionary["OwnerId"] as? String
            self.description = dictionary["Description"] as? String
            self.startTime = dictionary["StartTime"] as? Date
            self.dataEncryptionKeyId = dictionary["DataEncryptionKeyId"] as? String
            self.progress = dictionary["Progress"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.ownerAlias = dictionary["OwnerAlias"] as? String
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct DescribeVpcsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    cidr - The IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, /28).    dhcp-options-id - The ID of a set of DHCP options.    ipv6-cidr-block-association.ipv6-cidr-block - An IPv6 CIDR block associated with the VPC.    ipv6-cidr-block-association.association-id - The association ID for an IPv6 CIDR block associated with the VPC.    ipv6-cidr-block-association.state - The state of an IPv6 CIDR block associated with the VPC.    isDefault - Indicates whether the VPC is the default VPC.    state - The state of the VPC (pending | available).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC.  
        public let filters: FilterList?
        /// One or more VPC IDs. Default: Describes all your VPCs.
        public let vpcIds: VpcIdStringList?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, vpcIds: VpcIdStringList? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcIds = vpcIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let vpcIds = dictionary["VpcId"] as? [String: Any] { self.vpcIds = try Ec2.VpcIdStringList(dictionary: vpcIds) } else { self.vpcIds = nil }
        }
    }

    public struct PurchaseRequestSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let purchaseRequest: [PurchaseRequest]?

        public init(purchaseRequest: [PurchaseRequest]? = nil) {
            self.purchaseRequest = purchaseRequest
        }

        public init(dictionary: [String: Any]) throws {
            if let purchaseRequest = dictionary["PurchaseRequest"] as? [[String: Any]] {
                self.purchaseRequest = try purchaseRequest.map({ try PurchaseRequest(dictionary: $0) })
            } else { 
                self.purchaseRequest = nil
            }
        }
    }

    public struct DescribeIdFormatResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the ID format for the resource.
        public let statuses: IdFormatList?

        public init(statuses: IdFormatList? = nil) {
            self.statuses = statuses
        }

        public init(dictionary: [String: Any]) throws {
            if let statuses = dictionary["StatusSet"] as? [String: Any] { self.statuses = try Ec2.IdFormatList(dictionary: statuses) } else { self.statuses = nil }
        }
    }

    public struct RegisterImageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The billing product codes.
        public let billingProducts: BillingProductList?
        /// One or more block device mapping entries.
        public let blockDeviceMappings: BlockDeviceMappingRequestList?
        /// Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI. There is no way to disable sriovNetSupport at this time. This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.
        public let sriovNetSupport: String?
        /// The name of the root device (for example, /dev/sda1, or /dev/xvda).
        public let rootDeviceName: String?
        /// The full path to your AMI manifest in Amazon S3 storage.
        public let imageLocation: String?
        /// The ID of the kernel.
        public let kernelId: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A description for your AMI.
        public let description: String?
        /// A name for your AMI. Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)
        public let name: String
        /// The architecture of the AMI. Default: For Amazon EBS-backed AMIs, i386. For instance store-backed AMIs, the architecture specified in the manifest file.
        public let architecture: ArchitectureValues?
        /// Set to true to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI. This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.
        public let enaSupport: Bool?
        /// The type of virtualization. Default: paravirtual 
        public let virtualizationType: String?
        /// The ID of the RAM disk.
        public let ramdiskId: String?

        public init(billingProducts: BillingProductList? = nil, blockDeviceMappings: BlockDeviceMappingRequestList? = nil, sriovNetSupport: String? = nil, rootDeviceName: String? = nil, imageLocation: String? = nil, kernelId: String? = nil, dryRun: Bool? = nil, description: String? = nil, name: String, architecture: ArchitectureValues? = nil, enaSupport: Bool? = nil, virtualizationType: String? = nil, ramdiskId: String? = nil) {
            self.billingProducts = billingProducts
            self.blockDeviceMappings = blockDeviceMappings
            self.sriovNetSupport = sriovNetSupport
            self.rootDeviceName = rootDeviceName
            self.imageLocation = imageLocation
            self.kernelId = kernelId
            self.dryRun = dryRun
            self.description = description
            self.name = name
            self.architecture = architecture
            self.enaSupport = enaSupport
            self.virtualizationType = virtualizationType
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let billingProducts = dictionary["BillingProduct"] as? [String: Any] { self.billingProducts = try Ec2.BillingProductList(dictionary: billingProducts) } else { self.billingProducts = nil }
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingRequestList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.sriovNetSupport = dictionary["SriovNetSupport"] as? String
            self.rootDeviceName = dictionary["RootDeviceName"] as? String
            self.imageLocation = dictionary["ImageLocation"] as? String
            self.kernelId = dictionary["KernelId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.description = dictionary["Description"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            if let architecture = dictionary["Architecture"] as? String { self.architecture = ArchitectureValues(rawValue: architecture) } else { self.architecture = nil }
            self.enaSupport = dictionary["EnaSupport"] as? Bool
            self.virtualizationType = dictionary["VirtualizationType"] as? String
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct DescribeMovingAddressesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Elastic IP addresses.
        public let publicIps: ValueStringList?
        /// One or more filters.    moving-status - The status of the Elastic IP address (MovingToVpc | RestoringToClassic).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value outside of this range, an error is returned. Default: If no value is provided, the default is 1000.
        public let maxResults: Int32?

        public init(publicIps: ValueStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.publicIps = publicIps
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let publicIps = dictionary["PublicIp"] as? [String: Any] { self.publicIps = try Ec2.ValueStringList(dictionary: publicIps) } else { self.publicIps = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BillingProductList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct MonitorInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The monitoring information.
        public let instanceMonitorings: InstanceMonitoringList?

        public init(instanceMonitorings: InstanceMonitoringList? = nil) {
            self.instanceMonitorings = instanceMonitorings
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceMonitorings = dictionary["InstancesSet"] as? [String: Any] { self.instanceMonitorings = try Ec2.InstanceMonitoringList(dictionary: instanceMonitorings) } else { self.instanceMonitorings = nil }
        }
    }

    public struct AssignIpv6AddressesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 addresses assigned to the network interface.
        public let assignedIpv6Addresses: Ipv6AddressList?
        /// The ID of the network interface.
        public let networkInterfaceId: String?

        public init(assignedIpv6Addresses: Ipv6AddressList? = nil, networkInterfaceId: String? = nil) {
            self.assignedIpv6Addresses = assignedIpv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            if let assignedIpv6Addresses = dictionary["AssignedIpv6Addresses"] as? [String: Any] { self.assignedIpv6Addresses = try Ec2.Ipv6AddressList(dictionary: assignedIpv6Addresses) } else { self.assignedIpv6Addresses = nil }
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
        }
    }

    public struct AssignPrivateIpAddressesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.
        public let allowReassignment: Bool?
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.
        public let secondaryPrivateIpAddressCount: Int32?
        /// One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses. If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.
        public let privateIpAddresses: PrivateIpAddressStringList?

        public init(allowReassignment: Bool? = nil, networkInterfaceId: String, secondaryPrivateIpAddressCount: Int32? = nil, privateIpAddresses: PrivateIpAddressStringList? = nil) {
            self.allowReassignment = allowReassignment
            self.networkInterfaceId = networkInterfaceId
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.privateIpAddresses = privateIpAddresses
        }

        public init(dictionary: [String: Any]) throws {
            self.allowReassignment = dictionary["AllowReassignment"] as? Bool
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            if let privateIpAddresses = dictionary["PrivateIpAddress"] as? [String: Any] { self.privateIpAddresses = try Ec2.PrivateIpAddressStringList(dictionary: privateIpAddresses) } else { self.privateIpAddresses = nil }
        }
    }

    public enum ImageTypeValues: String, CustomStringConvertible {
        case machine = "machine"
        case kernel = "kernel"
        case ramdisk = "ramdisk"
        public var description: String { return self.rawValue }
    }

    public struct RunInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to false after launch, use ModifyInstanceAttribute. Alternatively, if you set InstanceInitiatedShutdownBehavior to terminate, you can terminate the instance by running the shutdown command from the instance. Default: false 
        public let disableApiTermination: Bool?
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see Ensuring Idempotency. Constraints: Maximum 64 ASCII characters
        public let clientToken: String?
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false 
        public let ebsOptimized: Bool?
        /// The ID of the kernel.  We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see  PV-GRUB in the Amazon Elastic Compute Cloud User Guide. 
        public let kernelId: String?
        /// [EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        public let ipv6AddressCount: Int32?
        /// The instance type. For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide. Default: m1.small 
        public let instanceType: InstanceType?
        /// [EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
        public let privateIpAddress: String?
        /// The name of the key pair. You can create a key pair using CreateKeyPair or ImportKeyPair.  If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in. 
        public let keyName: String?
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfileSpecification?
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: stop 
        public let instanceInitiatedShutdownBehavior: ShutdownBehavior?
        /// [EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        public let ipv6Addresses: InstanceIpv6AddressList?
        /// The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances. Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see How many instances can I run in Amazon EC2 in the Amazon EC2 General FAQ.
        public let minCount: Int32
        /// The ID of the RAM disk.  We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see  PV-GRUB in the Amazon Elastic Compute Cloud User Guide. 
        public let ramdiskId: String?
        /// The block device mapping.  Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action. 
        public let blockDeviceMappings: BlockDeviceMappingRequestList?
        /// [EC2-VPC] The ID of the subnet to launch the instance into.
        public let subnetId: String?
        /// The user data to make available to the instance. For more information, see Running Commands on Your Linux Instance at Launch (Linux) and Adding User Data (Windows). If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let userData: String?
        /// One or more security group IDs. You can create a security group using CreateSecurityGroup. Default: Amazon EC2 uses the default security group.
        public let securityGroupIds: SecurityGroupIdStringList?
        /// The monitoring for the instance.
        public let monitoring: RunInstancesMonitoringEnabled?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// [EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead. Default: Amazon EC2 uses the default security group.
        public let securityGroups: SecurityGroupStringList?
        /// The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above MinCount. Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see How many instances can I run in Amazon EC2 in the Amazon EC2 FAQ.
        public let maxCount: Int32
        /// Reserved.
        public let additionalInfo: String?
        /// The placement for the instance.
        public let placement: Placement?
        /// One or more network interfaces.
        public let networkInterfaces: InstanceNetworkInterfaceSpecificationList?
        /// The ID of the AMI, which you can get by calling DescribeImages.
        public let imageId: String

        public init(disableApiTermination: Bool? = nil, clientToken: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, ipv6AddressCount: Int32? = nil, instanceType: InstanceType? = nil, privateIpAddress: String? = nil, keyName: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil, ipv6Addresses: InstanceIpv6AddressList? = nil, minCount: Int32, ramdiskId: String? = nil, blockDeviceMappings: BlockDeviceMappingRequestList? = nil, subnetId: String? = nil, userData: String? = nil, securityGroupIds: SecurityGroupIdStringList? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, dryRun: Bool? = nil, securityGroups: SecurityGroupStringList? = nil, maxCount: Int32, additionalInfo: String? = nil, placement: Placement? = nil, networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil, imageId: String) {
            self.disableApiTermination = disableApiTermination
            self.clientToken = clientToken
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.ipv6AddressCount = ipv6AddressCount
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.keyName = keyName
            self.iamInstanceProfile = iamInstanceProfile
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.ipv6Addresses = ipv6Addresses
            self.minCount = minCount
            self.ramdiskId = ramdiskId
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.dryRun = dryRun
            self.securityGroups = securityGroups
            self.maxCount = maxCount
            self.additionalInfo = additionalInfo
            self.placement = placement
            self.networkInterfaces = networkInterfaces
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.disableApiTermination = dictionary["DisableApiTermination"] as? Bool
            self.clientToken = dictionary["ClientToken"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.keyName = dictionary["KeyName"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
            if let instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? String { self.instanceInitiatedShutdownBehavior = ShutdownBehavior(rawValue: instanceInitiatedShutdownBehavior) } else { self.instanceInitiatedShutdownBehavior = nil }
            if let ipv6Addresses = dictionary["Ipv6Address"] as? [String: Any] { self.ipv6Addresses = try Ec2.InstanceIpv6AddressList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            guard let minCount = dictionary["MinCount"] as? Int32 else { throw InitializableError.missingRequiredParam("MinCount") }
            self.minCount = minCount
            self.ramdiskId = dictionary["RamdiskId"] as? String
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingRequestList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            if let securityGroupIds = dictionary["SecurityGroupId"] as? [String: Any] { self.securityGroupIds = try Ec2.SecurityGroupIdStringList(dictionary: securityGroupIds) } else { self.securityGroupIds = nil }
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.RunInstancesMonitoringEnabled(dictionary: monitoring) } else { self.monitoring = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let securityGroups = dictionary["SecurityGroup"] as? [String: Any] { self.securityGroups = try Ec2.SecurityGroupStringList(dictionary: securityGroups) } else { self.securityGroups = nil }
            guard let maxCount = dictionary["MaxCount"] as? Int32 else { throw InitializableError.missingRequiredParam("MaxCount") }
            self.maxCount = maxCount
            self.additionalInfo = dictionary["AdditionalInfo"] as? String
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.Placement(dictionary: placement) } else { self.placement = nil }
            if let networkInterfaces = dictionary["NetworkInterface"] as? [String: Any] { self.networkInterfaces = try Ec2.InstanceNetworkInterfaceSpecificationList(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct SpotInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Availability Zone in which the bid is launched.
        public let launchedAvailabilityZone: String?
        /// The ID of the Spot instance request.
        public let spotInstanceRequestId: String?
        /// The state of the Spot instance request. Spot bid status information can help you track your Spot instance requests. For more information, see Spot Bid Status in the Amazon Elastic Compute Cloud User Guide.
        public let state: SpotInstanceState?
        /// The maximum hourly price (bid) for the Spot instance launched to fulfill the request.
        public let spotPrice: String?
        /// Any tags assigned to the resource.
        public let tags: TagList?
        /// The end date of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached.
        public let validUntil: Date?
        /// The fault codes for the Spot instance request, if any.
        public let fault: SpotInstanceStateFault?
        /// The product description associated with the Spot instance.
        public let productDescription: RIProductDescription?
        /// The Availability Zone group. If you specify the same Availability Zone group for all Spot instance requests, all Spot instances are launched in the same Availability Zone.
        public let availabilityZoneGroup: String?
        /// The status code and status message describing the Spot instance request.
        public let status: SpotInstanceStatus?
        /// The start date of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). The request becomes active at this date and time.
        public let validFrom: Date?
        /// The instance ID, if an instance has been launched to fulfill the Spot instance request.
        public let instanceId: String?
        /// If you specified a duration and your Spot instance request was fulfilled, this is the fixed hourly price in effect for the Spot instance while it runs.
        public let actualBlockHourlyPrice: String?
        /// The duration for the Spot instance, in minutes.
        public let blockDurationMinutes: Int32?
        /// Additional information for launching instances.
        public let launchSpecification: LaunchSpecification?
        /// The Spot instance request type.
        public let `type`: SpotInstanceType?
        /// The instance launch group. Launch groups are Spot instances that launch together and terminate together.
        public let launchGroup: String?
        /// The date and time when the Spot instance request was created, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let createTime: Date?

        public init(launchedAvailabilityZone: String? = nil, spotInstanceRequestId: String? = nil, state: SpotInstanceState? = nil, spotPrice: String? = nil, tags: TagList? = nil, validUntil: Date? = nil, fault: SpotInstanceStateFault? = nil, productDescription: RIProductDescription? = nil, availabilityZoneGroup: String? = nil, status: SpotInstanceStatus? = nil, validFrom: Date? = nil, instanceId: String? = nil, actualBlockHourlyPrice: String? = nil, blockDurationMinutes: Int32? = nil, launchSpecification: LaunchSpecification? = nil, type: SpotInstanceType? = nil, launchGroup: String? = nil, createTime: Date? = nil) {
            self.launchedAvailabilityZone = launchedAvailabilityZone
            self.spotInstanceRequestId = spotInstanceRequestId
            self.state = state
            self.spotPrice = spotPrice
            self.tags = tags
            self.validUntil = validUntil
            self.fault = fault
            self.productDescription = productDescription
            self.availabilityZoneGroup = availabilityZoneGroup
            self.status = status
            self.validFrom = validFrom
            self.instanceId = instanceId
            self.actualBlockHourlyPrice = actualBlockHourlyPrice
            self.blockDurationMinutes = blockDurationMinutes
            self.launchSpecification = launchSpecification
            self.`type` = `type`
            self.launchGroup = launchGroup
            self.createTime = createTime
        }

        public init(dictionary: [String: Any]) throws {
            self.launchedAvailabilityZone = dictionary["LaunchedAvailabilityZone"] as? String
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
            if let state = dictionary["State"] as? String { self.state = SpotInstanceState(rawValue: state) } else { self.state = nil }
            self.spotPrice = dictionary["SpotPrice"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.validUntil = dictionary["ValidUntil"] as? Date
            if let fault = dictionary["Fault"] as? [String: Any] { self.fault = try Ec2.SpotInstanceStateFault(dictionary: fault) } else { self.fault = nil }
            if let productDescription = dictionary["ProductDescription"] as? String { self.productDescription = RIProductDescription(rawValue: productDescription) } else { self.productDescription = nil }
            self.availabilityZoneGroup = dictionary["AvailabilityZoneGroup"] as? String
            if let status = dictionary["Status"] as? [String: Any] { self.status = try Ec2.SpotInstanceStatus(dictionary: status) } else { self.status = nil }
            self.validFrom = dictionary["ValidFrom"] as? Date
            self.instanceId = dictionary["InstanceId"] as? String
            self.actualBlockHourlyPrice = dictionary["ActualBlockHourlyPrice"] as? String
            self.blockDurationMinutes = dictionary["BlockDurationMinutes"] as? Int32
            if let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] { self.launchSpecification = try Ec2.LaunchSpecification(dictionary: launchSpecification) } else { self.launchSpecification = nil }
            if let `type` = dictionary["Type"] as? String { self.`type` = SpotInstanceType(rawValue: `type`) } else { self.`type` = nil }
            self.launchGroup = dictionary["LaunchGroup"] as? String
            self.createTime = dictionary["CreateTime"] as? Date
        }
    }

    public struct RebootInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more instance IDs.
        public let instanceIds: InstanceIdStringList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceIds: InstanceIdStringList, dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct VpcPeeringConnectionStateReason: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the VPC peering connection.
        public let code: VpcPeeringConnectionStateReasonCode?
        /// A message that provides more information about the status, if applicable.
        public let message: String?

        public init(code: VpcPeeringConnectionStateReasonCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            if let code = dictionary["Code"] as? String { self.code = VpcPeeringConnectionStateReasonCode(rawValue: code) } else { self.code = nil }
            self.message = dictionary["Message"] as? String
        }
    }

    public enum ExportTaskState: String, CustomStringConvertible {
        case active = "active"
        case cancelling = "cancelling"
        case cancelled = "cancelled"
        case completed = "completed"
        public var description: String { return self.rawValue }
    }

    public enum IamInstanceProfileAssociationState: String, CustomStringConvertible {
        case associating = "associating"
        case associated = "associated"
        case disassociating = "disassociating"
        case disassociated = "disassociated"
        public var description: String { return self.rawValue }
    }

    public struct ScheduledInstance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The platform (Linux/UNIX or Windows).
        public let platform: String?
        /// The time that the previous schedule ended or will end.
        public let previousSlotEndTime: Date?
        /// The total number of hours for a single instance for the entire term.
        public let totalScheduledInstanceHours: Int32?
        /// The date when the Scheduled Instance was purchased.
        public let createDate: Date?
        /// The hourly price for a single instance.
        public let hourlyPrice: String?
        /// The instance type.
        public let instanceType: String?
        /// The number of hours in the schedule.
        public let slotDurationInHours: Int32?
        /// The Scheduled Instance ID.
        public let scheduledInstanceId: String?
        /// The Availability Zone.
        public let availabilityZone: String?
        /// The start date for the Scheduled Instance.
        public let termStartDate: Date?
        /// The end date for the Scheduled Instance.
        public let termEndDate: Date?
        /// The time for the next schedule to start.
        public let nextSlotStartTime: Date?
        /// The number of instances.
        public let instanceCount: Int32?
        /// The network platform (EC2-Classic or EC2-VPC).
        public let networkPlatform: String?
        /// The schedule recurrence.
        public let recurrence: ScheduledInstanceRecurrence?

        public init(platform: String? = nil, previousSlotEndTime: Date? = nil, totalScheduledInstanceHours: Int32? = nil, createDate: Date? = nil, hourlyPrice: String? = nil, instanceType: String? = nil, slotDurationInHours: Int32? = nil, scheduledInstanceId: String? = nil, availabilityZone: String? = nil, termStartDate: Date? = nil, termEndDate: Date? = nil, nextSlotStartTime: Date? = nil, instanceCount: Int32? = nil, networkPlatform: String? = nil, recurrence: ScheduledInstanceRecurrence? = nil) {
            self.platform = platform
            self.previousSlotEndTime = previousSlotEndTime
            self.totalScheduledInstanceHours = totalScheduledInstanceHours
            self.createDate = createDate
            self.hourlyPrice = hourlyPrice
            self.instanceType = instanceType
            self.slotDurationInHours = slotDurationInHours
            self.scheduledInstanceId = scheduledInstanceId
            self.availabilityZone = availabilityZone
            self.termStartDate = termStartDate
            self.termEndDate = termEndDate
            self.nextSlotStartTime = nextSlotStartTime
            self.instanceCount = instanceCount
            self.networkPlatform = networkPlatform
            self.recurrence = recurrence
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            self.previousSlotEndTime = dictionary["PreviousSlotEndTime"] as? Date
            self.totalScheduledInstanceHours = dictionary["TotalScheduledInstanceHours"] as? Int32
            self.createDate = dictionary["CreateDate"] as? Date
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.slotDurationInHours = dictionary["SlotDurationInHours"] as? Int32
            self.scheduledInstanceId = dictionary["ScheduledInstanceId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.termStartDate = dictionary["TermStartDate"] as? Date
            self.termEndDate = dictionary["TermEndDate"] as? Date
            self.nextSlotStartTime = dictionary["NextSlotStartTime"] as? Date
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.networkPlatform = dictionary["NetworkPlatform"] as? String
            if let recurrence = dictionary["Recurrence"] as? [String: Any] { self.recurrence = try Ec2.ScheduledInstanceRecurrence(dictionary: recurrence) } else { self.recurrence = nil }
        }
    }

    public struct DescribeSpotFleetInstancesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String
        /// The running instances. Note that this list is refreshed periodically and might be out of date.
        public let activeInstances: ActiveInstanceSet

        public init(nextToken: String? = nil, spotFleetRequestId: String, activeInstances: ActiveInstanceSet) {
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.activeInstances = activeInstances
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            guard let activeInstances = dictionary["ActiveInstanceSet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ActiveInstanceSet") }
            self.activeInstances = try Ec2.ActiveInstanceSet(dictionary: activeInstances)
        }
    }

    public struct ProductCode: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of product code.
        public let productCodeType: ProductCodeValues?
        /// The product code.
        public let productCodeId: String?

        public init(productCodeType: ProductCodeValues? = nil, productCodeId: String? = nil) {
            self.productCodeType = productCodeType
            self.productCodeId = productCodeId
        }

        public init(dictionary: [String: Any]) throws {
            if let productCodeType = dictionary["Type"] as? String { self.productCodeType = ProductCodeValues(rawValue: productCodeType) } else { self.productCodeType = nil }
            self.productCodeId = dictionary["ProductCode"] as? String
        }
    }

    public struct InstanceStatusEvent: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The event code.
        public let code: EventCode?
        /// The earliest scheduled start time for the event.
        public let notBefore: Date?
        /// The latest scheduled end time for the event.
        public let notAfter: Date?
        /// A description of the event. After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].
        public let description: String?

        public init(code: EventCode? = nil, notBefore: Date? = nil, notAfter: Date? = nil, description: String? = nil) {
            self.code = code
            self.notBefore = notBefore
            self.notAfter = notAfter
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let code = dictionary["Code"] as? String { self.code = EventCode(rawValue: code) } else { self.code = nil }
            self.notBefore = dictionary["NotBefore"] as? Date
            self.notAfter = dictionary["NotAfter"] as? Date
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVolumeAttributeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of product codes.
        public let productCodes: ProductCodeList?
        /// The ID of the volume.
        public let volumeId: String?
        /// The state of autoEnableIO attribute.
        public let autoEnableIO: AttributeBooleanValue?

        public init(productCodes: ProductCodeList? = nil, volumeId: String? = nil, autoEnableIO: AttributeBooleanValue? = nil) {
            self.productCodes = productCodes
            self.volumeId = volumeId
            self.autoEnableIO = autoEnableIO
        }

        public init(dictionary: [String: Any]) throws {
            if let productCodes = dictionary["ProductCodes"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeList(dictionary: productCodes) } else { self.productCodes = nil }
            self.volumeId = dictionary["VolumeId"] as? String
            if let autoEnableIO = dictionary["AutoEnableIO"] as? [String: Any] { self.autoEnableIO = try Ec2.AttributeBooleanValue(dictionary: autoEnableIO) } else { self.autoEnableIO = nil }
        }
    }

    public struct DeleteNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(networkInterfaceId: String, dryRun: Bool? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct SpotDatafeedSubscription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon S3 bucket where the Spot instance data feed is located.
        public let bucket: String?
        /// The AWS account ID of the account.
        public let ownerId: String?
        /// The state of the Spot instance data feed subscription.
        public let state: DatafeedSubscriptionState?
        /// The fault codes for the Spot instance request, if any.
        public let fault: SpotInstanceStateFault?
        /// The prefix that is prepended to data feed files.
        public let prefix: String?

        public init(bucket: String? = nil, ownerId: String? = nil, state: DatafeedSubscriptionState? = nil, fault: SpotInstanceStateFault? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.ownerId = ownerId
            self.state = state
            self.fault = fault
            self.prefix = prefix
        }

        public init(dictionary: [String: Any]) throws {
            self.bucket = dictionary["Bucket"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let state = dictionary["State"] as? String { self.state = DatafeedSubscriptionState(rawValue: state) } else { self.state = nil }
            if let fault = dictionary["Fault"] as? [String: Any] { self.fault = try Ec2.SpotInstanceStateFault(dictionary: fault) } else { self.fault = nil }
            self.prefix = dictionary["Prefix"] as? String
        }
    }

    public struct ImportImageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the disk containers.
        public let diskContainers: ImageDiskContainerList?
        /// The operating system of the virtual machine. Valid values: Windows | Linux 
        public let platform: String?
        /// The token to enable idempotency for VM import requests.
        public let clientToken: String?
        /// The license type to be used for the Amazon Machine Image (AMI) after importing.  Note: You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see Prerequisites in the VM Import/Export User Guide. Valid values: AWS | BYOL 
        public let licenseType: String?
        /// The target hypervisor platform. Valid values: xen 
        public let hypervisor: String?
        /// The architecture of the virtual machine. Valid values: i386 | x86_64 
        public let architecture: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The name of the role to use when not using the default role, 'vmimport'.
        public let roleName: String?
        /// The client-specific data.
        public let clientData: ClientData?
        /// A description string for the import image task.
        public let description: String?

        public init(diskContainers: ImageDiskContainerList? = nil, platform: String? = nil, clientToken: String? = nil, licenseType: String? = nil, hypervisor: String? = nil, architecture: String? = nil, dryRun: Bool? = nil, roleName: String? = nil, clientData: ClientData? = nil, description: String? = nil) {
            self.diskContainers = diskContainers
            self.platform = platform
            self.clientToken = clientToken
            self.licenseType = licenseType
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.dryRun = dryRun
            self.roleName = roleName
            self.clientData = clientData
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let diskContainers = dictionary["DiskContainer"] as? [String: Any] { self.diskContainers = try Ec2.ImageDiskContainerList(dictionary: diskContainers) } else { self.diskContainers = nil }
            self.platform = dictionary["Platform"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            self.licenseType = dictionary["LicenseType"] as? String
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.roleName = dictionary["RoleName"] as? String
            if let clientData = dictionary["ClientData"] as? [String: Any] { self.clientData = try Ec2.ClientData(dictionary: clientData) } else { self.clientData = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct OwnerStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let owner: [String]?

        public init(owner: [String]? = nil) {
            self.owner = owner
        }

        public init(dictionary: [String: Any]) throws {
            self.owner = dictionary["Owner"] as? [String]
        }
    }

    public struct ImportInstanceVolumeDetailItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the import of this particular disk image.
        public let status: String
        /// The number of bytes converted so far.
        public let bytesConverted: Int64
        /// The volume.
        public let volume: DiskImageVolumeDescription
        /// The image.
        public let image: DiskImageDescription
        /// The status information or errors related to the disk image.
        public let statusMessage: String?
        /// The Availability Zone where the resulting instance will reside.
        public let availabilityZone: String
        /// A description of the task.
        public let description: String?

        public init(status: String, bytesConverted: Int64, volume: DiskImageVolumeDescription, image: DiskImageDescription, statusMessage: String? = nil, availabilityZone: String, description: String? = nil) {
            self.status = status
            self.bytesConverted = bytesConverted
            self.volume = volume
            self.image = image
            self.statusMessage = statusMessage
            self.availabilityZone = availabilityZone
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let status = dictionary["Status"] as? String else { throw InitializableError.missingRequiredParam("Status") }
            self.status = status
            guard let bytesConverted = dictionary["BytesConverted"] as? Int64 else { throw InitializableError.missingRequiredParam("BytesConverted") }
            self.bytesConverted = bytesConverted
            guard let volume = dictionary["Volume"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volume") }
            self.volume = try Ec2.DiskImageVolumeDescription(dictionary: volume)
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Ec2.DiskImageDescription(dictionary: image)
            self.statusMessage = dictionary["StatusMessage"] as? String
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.description = dictionary["Description"] as? String
        }
    }

    public struct RecurringChargesList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [RecurringCharge]?

        public init(item: [RecurringCharge]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try RecurringCharge(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct UnsuccessfulItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the resource.
        public let resourceId: String?
        /// Information about the error.
        public let error: UnsuccessfulItemError

        public init(resourceId: String? = nil, error: UnsuccessfulItemError) {
            self.resourceId = resourceId
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.resourceId = dictionary["ResourceId"] as? String
            guard let error = dictionary["Error"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Error") }
            self.error = try Ec2.UnsuccessfulItemError(dictionary: error)
        }
    }

    public struct DescribeIamInstanceProfileAssociationsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about one or more IAM instance profile associations.
        public let iamInstanceProfileAssociations: IamInstanceProfileAssociationSet?

        public init(nextToken: String? = nil, iamInstanceProfileAssociations: IamInstanceProfileAssociationSet? = nil) {
            self.nextToken = nextToken
            self.iamInstanceProfileAssociations = iamInstanceProfileAssociations
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let iamInstanceProfileAssociations = dictionary["IamInstanceProfileAssociationSet"] as? [String: Any] { self.iamInstanceProfileAssociations = try Ec2.IamInstanceProfileAssociationSet(dictionary: iamInstanceProfileAssociations) } else { self.iamInstanceProfileAssociations = nil }
        }
    }

    public struct ModifySpotFleetRequestResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Is true if the request succeeds, and an error otherwise.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct OccurrenceDayRequestSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let occurenceDay: [Int32]?

        public init(occurenceDay: [Int32]? = nil) {
            self.occurenceDay = occurenceDay
        }

        public init(dictionary: [String: Any]) throws {
            self.occurenceDay = dictionary["OccurenceDay"] as? [Int32]
        }
    }

    public enum VolumeType: String, CustomStringConvertible {
        case standard = "standard"
        case io1 = "io1"
        case gp2 = "gp2"
        case sc1 = "sc1"
        case st1 = "st1"
        public var description: String { return self.rawValue }
    }

    public struct Volume: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.
        public let volumeType: VolumeType?
        /// The volume state.
        public let state: VolumeState?
        /// The ID of the volume.
        public let volumeId: String?
        /// Any tags assigned to the volume.
        public let tags: TagList?
        /// The snapshot from which the volume was created, if applicable.
        public let snapshotId: String?
        /// The size of the volume, in GiBs.
        public let size: Int32?
        /// Indicates whether the volume will be encrypted.
        public let encrypted: Bool?
        /// The time stamp when volume creation was initiated.
        public let createTime: Date?
        /// The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information on General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        public let iops: Int32?
        /// The Availability Zone for the volume.
        public let availabilityZone: String?
        /// Information about the volume attachments.
        public let attachments: VolumeAttachmentList?
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.
        public let kmsKeyId: String?

        public init(volumeType: VolumeType? = nil, state: VolumeState? = nil, volumeId: String? = nil, tags: TagList? = nil, snapshotId: String? = nil, size: Int32? = nil, encrypted: Bool? = nil, createTime: Date? = nil, iops: Int32? = nil, availabilityZone: String? = nil, attachments: VolumeAttachmentList? = nil, kmsKeyId: String? = nil) {
            self.volumeType = volumeType
            self.state = state
            self.volumeId = volumeId
            self.tags = tags
            self.snapshotId = snapshotId
            self.size = size
            self.encrypted = encrypted
            self.createTime = createTime
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.attachments = attachments
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeType = dictionary["VolumeType"] as? String { self.volumeType = VolumeType(rawValue: volumeType) } else { self.volumeType = nil }
            if let state = dictionary["Status"] as? String { self.state = VolumeState(rawValue: state) } else { self.state = nil }
            self.volumeId = dictionary["VolumeId"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.size = dictionary["Size"] as? Int32
            self.encrypted = dictionary["Encrypted"] as? Bool
            self.createTime = dictionary["CreateTime"] as? Date
            self.iops = dictionary["Iops"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let attachments = dictionary["AttachmentSet"] as? [String: Any] { self.attachments = try Ec2.VolumeAttachmentList(dictionary: attachments) } else { self.attachments = nil }
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct PurchaseHostReservationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The currency in which the totalUpfrontPrice, LimitPrice, and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        public let clientToken: String?
        /// The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request will fail. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is USD. For example, to indicate a limit price of USD 100, specify 100.00.
        public let limitPrice: String?
        /// The ID of the offering.
        public let offeringId: String
        /// The ID/s of the Dedicated Host/s that the reservation will be associated with.
        public let hostIdSet: RequestHostIdSet

        public init(currencyCode: CurrencyCodeValues? = nil, clientToken: String? = nil, limitPrice: String? = nil, offeringId: String, hostIdSet: RequestHostIdSet) {
            self.currencyCode = currencyCode
            self.clientToken = clientToken
            self.limitPrice = limitPrice
            self.offeringId = offeringId
            self.hostIdSet = hostIdSet
        }

        public init(dictionary: [String: Any]) throws {
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.clientToken = dictionary["ClientToken"] as? String
            self.limitPrice = dictionary["LimitPrice"] as? String
            guard let offeringId = dictionary["OfferingId"] as? String else { throw InitializableError.missingRequiredParam("OfferingId") }
            self.offeringId = offeringId
            guard let hostIdSet = dictionary["HostIdSet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("HostIdSet") }
            self.hostIdSet = try Ec2.RequestHostIdSet(dictionary: hostIdSet)
        }
    }

    public struct SubnetCidrBlockState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state of a CIDR block.
        public let state: SubnetCidrBlockStateCode?
        /// A message about the status of the CIDR block, if applicable.
        public let statusMessage: String?

        public init(state: SubnetCidrBlockStateCode? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            if let state = dictionary["State"] as? String { self.state = SubnetCidrBlockStateCode(rawValue: state) } else { self.state = nil }
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct InstanceAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The block device mapping of the instance.
        public let blockDeviceMappings: InstanceBlockDeviceMappingList?
        /// If the value is true, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.
        public let disableApiTermination: AttributeBooleanValue?
        /// The user data.
        public let userData: AttributeValue?
        /// Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public let sriovNetSupport: AttributeValue?
        /// The name of the root device (for example, /dev/sda1 or /dev/xvda).
        public let rootDeviceName: AttributeValue?
        /// Indicates whether the instance is optimized for EBS I/O.
        public let ebsOptimized: AttributeBooleanValue?
        /// Indicates whether source/destination checking is enabled. A value of true means checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.
        public let sourceDestCheck: AttributeBooleanValue?
        /// The kernel ID.
        public let kernelId: AttributeValue?
        /// The instance type.
        public let instanceType: AttributeValue?
        /// A list of product codes.
        public let productCodes: ProductCodeList?
        /// The ID of the instance.
        public let instanceId: String?
        /// Indicates whether enhanced networking with ENA is enabled.
        public let enaSupport: AttributeBooleanValue?
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        public let instanceInitiatedShutdownBehavior: AttributeValue?
        /// The RAM disk ID.
        public let ramdiskId: AttributeValue?
        /// The security groups associated with the instance.
        public let groups: GroupIdentifierList?

        public init(blockDeviceMappings: InstanceBlockDeviceMappingList? = nil, disableApiTermination: AttributeBooleanValue? = nil, userData: AttributeValue? = nil, sriovNetSupport: AttributeValue? = nil, rootDeviceName: AttributeValue? = nil, ebsOptimized: AttributeBooleanValue? = nil, sourceDestCheck: AttributeBooleanValue? = nil, kernelId: AttributeValue? = nil, instanceType: AttributeValue? = nil, productCodes: ProductCodeList? = nil, instanceId: String? = nil, enaSupport: AttributeBooleanValue? = nil, instanceInitiatedShutdownBehavior: AttributeValue? = nil, ramdiskId: AttributeValue? = nil, groups: GroupIdentifierList? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.disableApiTermination = disableApiTermination
            self.userData = userData
            self.sriovNetSupport = sriovNetSupport
            self.rootDeviceName = rootDeviceName
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.kernelId = kernelId
            self.instanceType = instanceType
            self.productCodes = productCodes
            self.instanceId = instanceId
            self.enaSupport = enaSupport
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.ramdiskId = ramdiskId
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.InstanceBlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            if let disableApiTermination = dictionary["DisableApiTermination"] as? [String: Any] { self.disableApiTermination = try Ec2.AttributeBooleanValue(dictionary: disableApiTermination) } else { self.disableApiTermination = nil }
            if let userData = dictionary["UserData"] as? [String: Any] { self.userData = try Ec2.AttributeValue(dictionary: userData) } else { self.userData = nil }
            if let sriovNetSupport = dictionary["SriovNetSupport"] as? [String: Any] { self.sriovNetSupport = try Ec2.AttributeValue(dictionary: sriovNetSupport) } else { self.sriovNetSupport = nil }
            if let rootDeviceName = dictionary["RootDeviceName"] as? [String: Any] { self.rootDeviceName = try Ec2.AttributeValue(dictionary: rootDeviceName) } else { self.rootDeviceName = nil }
            if let ebsOptimized = dictionary["EbsOptimized"] as? [String: Any] { self.ebsOptimized = try Ec2.AttributeBooleanValue(dictionary: ebsOptimized) } else { self.ebsOptimized = nil }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) } else { self.sourceDestCheck = nil }
            if let kernelId = dictionary["Kernel"] as? [String: Any] { self.kernelId = try Ec2.AttributeValue(dictionary: kernelId) } else { self.kernelId = nil }
            if let instanceType = dictionary["InstanceType"] as? [String: Any] { self.instanceType = try Ec2.AttributeValue(dictionary: instanceType) } else { self.instanceType = nil }
            if let productCodes = dictionary["ProductCodes"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeList(dictionary: productCodes) } else { self.productCodes = nil }
            self.instanceId = dictionary["InstanceId"] as? String
            if let enaSupport = dictionary["EnaSupport"] as? [String: Any] { self.enaSupport = try Ec2.AttributeBooleanValue(dictionary: enaSupport) } else { self.enaSupport = nil }
            if let instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? [String: Any] { self.instanceInitiatedShutdownBehavior = try Ec2.AttributeValue(dictionary: instanceInitiatedShutdownBehavior) } else { self.instanceInitiatedShutdownBehavior = nil }
            if let ramdiskId = dictionary["Ramdisk"] as? [String: Any] { self.ramdiskId = try Ec2.AttributeValue(dictionary: ramdiskId) } else { self.ramdiskId = nil }
            if let groups = dictionary["GroupSet"] as? [String: Any] { self.groups = try Ec2.GroupIdentifierList(dictionary: groups) } else { self.groups = nil }
        }
    }

    public struct DescribeConversionTasksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the conversion tasks.
        public let conversionTasks: DescribeConversionTaskList?

        public init(conversionTasks: DescribeConversionTaskList? = nil) {
            self.conversionTasks = conversionTasks
        }

        public init(dictionary: [String: Any]) throws {
            if let conversionTasks = dictionary["ConversionTasks"] as? [String: Any] { self.conversionTasks = try Ec2.DescribeConversionTaskList(dictionary: conversionTasks) } else { self.conversionTasks = nil }
        }
    }

    public struct ModifySnapshotAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The account ID to modify for the snapshot.
        public let userIds: UserIdStringList?
        /// The ID of the snapshot.
        public let snapshotId: String
        /// A JSON representation of the snapshot attribute modification.
        public let createVolumePermission: CreateVolumePermissionModifications?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The snapshot attribute to modify.  Only volume creation permissions may be modified at the customer level. 
        public let attribute: SnapshotAttributeName?
        /// The type of operation to perform to the attribute.
        public let operationType: OperationType?
        /// The group to modify for the snapshot.
        public let groupNames: GroupNameStringList?

        public init(userIds: UserIdStringList? = nil, snapshotId: String, createVolumePermission: CreateVolumePermissionModifications? = nil, dryRun: Bool? = nil, attribute: SnapshotAttributeName? = nil, operationType: OperationType? = nil, groupNames: GroupNameStringList? = nil) {
            self.userIds = userIds
            self.snapshotId = snapshotId
            self.createVolumePermission = createVolumePermission
            self.dryRun = dryRun
            self.attribute = attribute
            self.operationType = operationType
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            if let userIds = dictionary["UserId"] as? [String: Any] { self.userIds = try Ec2.UserIdStringList(dictionary: userIds) } else { self.userIds = nil }
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            if let createVolumePermission = dictionary["CreateVolumePermission"] as? [String: Any] { self.createVolumePermission = try Ec2.CreateVolumePermissionModifications(dictionary: createVolumePermission) } else { self.createVolumePermission = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let attribute = dictionary["Attribute"] as? String { self.attribute = SnapshotAttributeName(rawValue: attribute) } else { self.attribute = nil }
            if let operationType = dictionary["OperationType"] as? String { self.operationType = OperationType(rawValue: operationType) } else { self.operationType = nil }
            if let groupNames = dictionary["UserGroup"] as? [String: Any] { self.groupNames = try Ec2.GroupNameStringList(dictionary: groupNames) } else { self.groupNames = nil }
        }
    }

    public struct CancelledSpotInstanceRequestList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [CancelledSpotInstanceRequest]?

        public init(item: [CancelledSpotInstanceRequest]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try CancelledSpotInstanceRequest(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AttachClassicLinkVpcResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ModifySpotFleetRequestRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The size of the fleet.
        public let targetCapacity: Int32?
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String
        /// Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.
        public let excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy?

        public init(targetCapacity: Int32? = nil, spotFleetRequestId: String, excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy? = nil) {
            self.targetCapacity = targetCapacity
            self.spotFleetRequestId = spotFleetRequestId
            self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        }

        public init(dictionary: [String: Any]) throws {
            self.targetCapacity = dictionary["TargetCapacity"] as? Int32
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            if let excessCapacityTerminationPolicy = dictionary["ExcessCapacityTerminationPolicy"] as? String { self.excessCapacityTerminationPolicy = ExcessCapacityTerminationPolicy(rawValue: excessCapacityTerminationPolicy) } else { self.excessCapacityTerminationPolicy = nil }
        }
    }

    public struct BundleTaskList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [BundleTask]?

        public init(item: [BundleTask]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try BundleTask(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct HostReservation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upfront price of the reservation.
        public let upfrontPrice: String?
        /// The state of the reservation.
        public let state: ReservationState?
        /// The payment option selected for this reservation.
        public let paymentOption: PaymentOption?
        /// The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.
        public let offeringId: String?
        /// The number of Dedicated Hosts the reservation is associated with.
        public let count: Int32?
        /// The ID of the reservation that specifies the associated Dedicated Hosts.
        public let hostReservationId: String?
        /// The hourly price of the reservation.
        public let hourlyPrice: String?
        /// The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.
        public let instanceFamily: String?
        /// The date and time that the reservation started.
        public let start: Date?
        /// The date and time that the reservation ends.
        public let end: Date?
        /// The IDs of the Dedicated Hosts associated with the reservation.
        public let hostIdSet: ResponseHostIdSet?
        /// The currency in which the upfrontPrice and hourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The length of the reservation's term, specified in seconds. Can be 31536000 (1 year) | 94608000 (3 years).
        public let duration: Int32?

        public init(upfrontPrice: String? = nil, state: ReservationState? = nil, paymentOption: PaymentOption? = nil, offeringId: String? = nil, count: Int32? = nil, hostReservationId: String? = nil, hourlyPrice: String? = nil, instanceFamily: String? = nil, start: Date? = nil, end: Date? = nil, hostIdSet: ResponseHostIdSet? = nil, currencyCode: CurrencyCodeValues? = nil, duration: Int32? = nil) {
            self.upfrontPrice = upfrontPrice
            self.state = state
            self.paymentOption = paymentOption
            self.offeringId = offeringId
            self.count = count
            self.hostReservationId = hostReservationId
            self.hourlyPrice = hourlyPrice
            self.instanceFamily = instanceFamily
            self.start = start
            self.end = end
            self.hostIdSet = hostIdSet
            self.currencyCode = currencyCode
            self.duration = duration
        }

        public init(dictionary: [String: Any]) throws {
            self.upfrontPrice = dictionary["UpfrontPrice"] as? String
            if let state = dictionary["State"] as? String { self.state = ReservationState(rawValue: state) } else { self.state = nil }
            if let paymentOption = dictionary["PaymentOption"] as? String { self.paymentOption = PaymentOption(rawValue: paymentOption) } else { self.paymentOption = nil }
            self.offeringId = dictionary["OfferingId"] as? String
            self.count = dictionary["Count"] as? Int32
            self.hostReservationId = dictionary["HostReservationId"] as? String
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.instanceFamily = dictionary["InstanceFamily"] as? String
            self.start = dictionary["Start"] as? Date
            self.end = dictionary["End"] as? Date
            if let hostIdSet = dictionary["HostIdSet"] as? [String: Any] { self.hostIdSet = try Ec2.ResponseHostIdSet(dictionary: hostIdSet) } else { self.hostIdSet = nil }
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.duration = dictionary["Duration"] as? Int32
        }
    }

    public struct CreateReservedInstancesListingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the Standard Reserved Instance listing.
        public let reservedInstancesListings: ReservedInstancesListingList?

        public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesListings = dictionary["ReservedInstancesListingsSet"] as? [String: Any] { self.reservedInstancesListings = try Ec2.ReservedInstancesListingList(dictionary: reservedInstancesListings) } else { self.reservedInstancesListings = nil }
        }
    }

    public struct DescribeHostsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    instance-type - The instance type size that the Dedicated Host is configured to support.    auto-placement - Whether auto-placement is enabled or disabled (on | off).    host-reservation-id - The ID of the reservation assigned to this host.    client-token - The idempotency token you provided when you launched the instance    state- The allocation state of the Dedicated Host (available | under-assessment | permanent-failure | released | released-permanent-failure).    availability-zone - The Availability Zone of the host.  
        public let filter: FilterList?
        /// The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.
        public let hostIds: RequestHostIdList?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error. You cannot specify this parameter and the host IDs parameter in the same request.
        public let maxResults: Int32?

        public init(filter: FilterList? = nil, hostIds: RequestHostIdList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.hostIds = hostIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [String: Any] { self.filter = try Ec2.FilterList(dictionary: filter) } else { self.filter = nil }
            if let hostIds = dictionary["HostId"] as? [String: Any] { self.hostIds = try Ec2.RequestHostIdList(dictionary: hostIds) } else { self.hostIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct AllocateAddressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Set to vpc to allocate the address for use with instances in a VPC. Default: The address is for use with instances in EC2-Classic.
        public let domain: DomainType?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(domain: DomainType? = nil, dryRun: Bool? = nil) {
            self.domain = domain
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let domain = dictionary["Domain"] as? String { self.domain = DomainType(rawValue: domain) } else { self.domain = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeBundleTasksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    bundle-id - The ID of the bundle task.    error-code - If the task failed, the error code returned.    error-message - If the task failed, the error message returned.    instance-id - The ID of the instance.    progress - The level of task completion, as a percentage (for example, 20%).    s3-bucket - The Amazon S3 bucket to store the AMI.    s3-prefix - The beginning of the AMI name.    start-time - The time the task started (for example, 2013-09-15T17:15:20.000Z).    state - The state of the task (pending | waiting-for-shutdown | bundling | storing | cancelling | complete | failed).    update-time - The time of the most recent update for the task.  
        public let filters: FilterList?
        /// One or more bundle task IDs. Default: Describes all your bundle tasks.
        public let bundleIds: BundleIdStringList?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, bundleIds: BundleIdStringList? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.bundleIds = bundleIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let bundleIds = dictionary["BundleId"] as? [String: Any] { self.bundleIds = try Ec2.BundleIdStringList(dictionary: bundleIds) } else { self.bundleIds = nil }
        }
    }

    public struct CustomerGatewayList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [CustomerGateway]?

        public init(item: [CustomerGateway]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try CustomerGateway(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct RunScheduledInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the newly launched instances.
        public let instanceIdSet: InstanceIdSet?

        public init(instanceIdSet: InstanceIdSet? = nil) {
            self.instanceIdSet = instanceIdSet
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceIdSet = dictionary["InstanceIdSet"] as? [String: Any] { self.instanceIdSet = try Ec2.InstanceIdSet(dictionary: instanceIdSet) } else { self.instanceIdSet = nil }
        }
    }

    public struct DescribeVpcEndpointServicesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of supported AWS services.
        public let serviceNames: ValueStringList?
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public let nextToken: String?

        public init(serviceNames: ValueStringList? = nil, nextToken: String? = nil) {
            self.serviceNames = serviceNames
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceNames = dictionary["ServiceNameSet"] as? [String: Any] { self.serviceNames = try Ec2.ValueStringList(dictionary: serviceNames) } else { self.serviceNames = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct AssociateVpcCidrBlockResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// Information about the IPv6 CIDR block association.
        public let ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation?

        public init(vpcId: String? = nil, ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil) {
            self.vpcId = vpcId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.VpcIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) } else { self.ipv6CidrBlockAssociation = nil }
        }
    }

    public struct ExportTaskList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ExportTask]?

        public init(item: [ExportTask]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ExportTask(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum ActivityStatus: String, CustomStringConvertible {
        case error = "error"
        case pending_fulfillment = "pending_fulfillment"
        case pending_termination = "pending_termination"
        case fulfilled = "fulfilled"
        public var description: String { return self.rawValue }
    }

    public struct UserData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let data: String?

        public init(data: String? = nil) {
            self.data = data
        }

        public init(dictionary: [String: Any]) throws {
            self.data = dictionary["Data"] as? String
        }
    }

    public struct AssociateAddressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
        public let privateIpAddress: String?
        /// [EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.
        public let networkInterfaceId: String?
        /// The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        public let instanceId: String?
        /// [EC2-VPC] The allocation ID. This is required for EC2-VPC.
        public let allocationId: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The Elastic IP address. This is required for EC2-Classic.
        public let publicIp: String?
        /// [EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.
        public let allowReassociation: Bool?

        public init(privateIpAddress: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, allocationId: String? = nil, dryRun: Bool? = nil, publicIp: String? = nil, allowReassociation: Bool? = nil) {
            self.privateIpAddress = privateIpAddress
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.allocationId = allocationId
            self.dryRun = dryRun
            self.publicIp = publicIp
            self.allowReassociation = allowReassociation
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.publicIp = dictionary["PublicIp"] as? String
            self.allowReassociation = dictionary["AllowReassociation"] as? Bool
        }
    }

    public enum HypervisorType: String, CustomStringConvertible {
        case ovm = "ovm"
        case xen = "xen"
        public var description: String { return self.rawValue }
    }

    public struct DisassociateSubnetCidrBlockRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The association ID for the CIDR block.
        public let associationId: String

        public init(associationId: String) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct DeleteEgressOnlyInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the egress-only Internet gateway.
        public let egressOnlyInternetGatewayId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(egressOnlyInternetGatewayId: String, dryRun: Bool? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("EgressOnlyInternetGatewayId") }
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public enum Affinity: String, CustomStringConvertible {
        case `default` = "default"
        case host = "host"
        public var description: String { return self.rawValue }
    }

    public struct AuthorizeSecurityGroupEgressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account number for a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public let sourceSecurityGroupOwnerId: String?
        /// A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.
        public let ipPermissions: IpPermissionList?
        /// The CIDR IPv4 address range. We recommend that you specify the CIDR range in a set of IP permissions instead.
        public let cidrIp: String?
        /// The name of a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public let sourceSecurityGroupName: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public let fromPort: Int32?
        /// The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.
        public let ipProtocol: String?
        /// The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public let toPort: Int32?
        /// The ID of the security group.
        public let groupId: String

        public init(sourceSecurityGroupOwnerId: String? = nil, ipPermissions: IpPermissionList? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, toPort: Int32? = nil, groupId: String) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.toPort = toPort
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [String: Any] { self.ipPermissions = try Ec2.IpPermissionList(dictionary: ipPermissions) } else { self.ipPermissions = nil }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.toPort = dictionary["ToPort"] as? Int32
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
        }
    }

    public struct VpcList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Vpc]?

        public init(item: [Vpc]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Vpc(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct FlowLog: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the flow log group.
        public let logGroupName: String?
        /// The status of the flow log (ACTIVE).
        public let flowLogStatus: String?
        /// The flow log ID.
        public let flowLogId: String?
        /// The date and time the flow log was created.
        public let creationTime: Date?
        /// The type of traffic captured for the flow log.
        public let trafficType: TrafficType?
        /// The ARN of the IAM role that posts logs to CloudWatch Logs.
        public let deliverLogsPermissionArn: String?
        /// The ID of the resource on which the flow log was created.
        public let resourceId: String?
        /// The status of the logs delivery (SUCCESS | FAILED).
        public let deliverLogsStatus: String?
        /// Information about the error that occurred. Rate limited indicates that CloudWatch logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of CloudWatch Logs log groups that you can create. Access error indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. Unknown error indicates an internal error.
        public let deliverLogsErrorMessage: String?

        public init(logGroupName: String? = nil, flowLogStatus: String? = nil, flowLogId: String? = nil, creationTime: Date? = nil, trafficType: TrafficType? = nil, deliverLogsPermissionArn: String? = nil, resourceId: String? = nil, deliverLogsStatus: String? = nil, deliverLogsErrorMessage: String? = nil) {
            self.logGroupName = logGroupName
            self.flowLogStatus = flowLogStatus
            self.flowLogId = flowLogId
            self.creationTime = creationTime
            self.trafficType = trafficType
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            self.resourceId = resourceId
            self.deliverLogsStatus = deliverLogsStatus
            self.deliverLogsErrorMessage = deliverLogsErrorMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.logGroupName = dictionary["LogGroupName"] as? String
            self.flowLogStatus = dictionary["FlowLogStatus"] as? String
            self.flowLogId = dictionary["FlowLogId"] as? String
            self.creationTime = dictionary["CreationTime"] as? Date
            if let trafficType = dictionary["TrafficType"] as? String { self.trafficType = TrafficType(rawValue: trafficType) } else { self.trafficType = nil }
            self.deliverLogsPermissionArn = dictionary["DeliverLogsPermissionArn"] as? String
            self.resourceId = dictionary["ResourceId"] as? String
            self.deliverLogsStatus = dictionary["DeliverLogsStatus"] as? String
            self.deliverLogsErrorMessage = dictionary["DeliverLogsErrorMessage"] as? String
        }
    }

    public struct CreateVpcEndpointResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// Information about the endpoint.
        public let vpcEndpoint: VpcEndpoint?

        public init(clientToken: String? = nil, vpcEndpoint: VpcEndpoint? = nil) {
            self.clientToken = clientToken
            self.vpcEndpoint = vpcEndpoint
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let vpcEndpoint = dictionary["VpcEndpoint"] as? [String: Any] { self.vpcEndpoint = try Ec2.VpcEndpoint(dictionary: vpcEndpoint) } else { self.vpcEndpoint = nil }
        }
    }

    public struct AttachNetworkInterfaceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the network interface attachment.
        public let attachmentId: String?

        public init(attachmentId: String? = nil) {
            self.attachmentId = attachmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.attachmentId = dictionary["AttachmentId"] as? String
        }
    }

    public struct DescribeVpcEndpointsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public let nextToken: String?
        /// Information about the endpoints.
        public let vpcEndpoints: VpcEndpointSet?

        public init(nextToken: String? = nil, vpcEndpoints: VpcEndpointSet? = nil) {
            self.nextToken = nextToken
            self.vpcEndpoints = vpcEndpoints
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let vpcEndpoints = dictionary["VpcEndpointSet"] as? [String: Any] { self.vpcEndpoints = try Ec2.VpcEndpointSet(dictionary: vpcEndpoints) } else { self.vpcEndpoints = nil }
        }
    }

    public struct CreateKeyPairRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A unique name for the key pair. Constraints: Up to 255 ASCII characters
        public let keyName: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(keyName: String, dryRun: Bool? = nil) {
            self.keyName = keyName
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let keyName = dictionary["KeyName"] as? String else { throw InitializableError.missingRequiredParam("KeyName") }
            self.keyName = keyName
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct StaleSecurityGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the stale inbound rules in the security group.
        public let staleIpPermissions: StaleIpPermissionSet?
        /// Information about the stale outbound rules in the security group.
        public let staleIpPermissionsEgress: StaleIpPermissionSet?
        /// The name of the security group.
        public let groupName: String?
        /// The ID of the VPC for the security group.
        public let vpcId: String?
        /// The ID of the security group.
        public let groupId: String
        /// The description of the security group.
        public let description: String?

        public init(staleIpPermissions: StaleIpPermissionSet? = nil, staleIpPermissionsEgress: StaleIpPermissionSet? = nil, groupName: String? = nil, vpcId: String? = nil, groupId: String, description: String? = nil) {
            self.staleIpPermissions = staleIpPermissions
            self.staleIpPermissionsEgress = staleIpPermissionsEgress
            self.groupName = groupName
            self.vpcId = vpcId
            self.groupId = groupId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let staleIpPermissions = dictionary["StaleIpPermissions"] as? [String: Any] { self.staleIpPermissions = try Ec2.StaleIpPermissionSet(dictionary: staleIpPermissions) } else { self.staleIpPermissions = nil }
            if let staleIpPermissionsEgress = dictionary["StaleIpPermissionsEgress"] as? [String: Any] { self.staleIpPermissionsEgress = try Ec2.StaleIpPermissionSet(dictionary: staleIpPermissionsEgress) } else { self.staleIpPermissionsEgress = nil }
            self.groupName = dictionary["GroupName"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ConfirmProductInstanceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.
        public let ownerId: String?
        /// The return value of the request. Returns true if the specified product code is owned by the requester and associated with the specified instance.
        public let `return`: Bool?

        public init(ownerId: String? = nil, return: Bool? = nil) {
            self.ownerId = ownerId
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.ownerId = dictionary["OwnerId"] as? String
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public enum SnapshotState: String, CustomStringConvertible {
        case pending = "pending"
        case completed = "completed"
        case error = "error"
        public var description: String { return self.rawValue }
    }

    public struct UserIdGroupPairList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [UserIdGroupPair]?

        public init(item: [UserIdGroupPair]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try UserIdGroupPair(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ImportKeyPairRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A unique name for the key pair.
        public let keyName: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.
        public let publicKeyMaterial: Data

        public init(keyName: String, dryRun: Bool? = nil, publicKeyMaterial: Data) {
            self.keyName = keyName
            self.dryRun = dryRun
            self.publicKeyMaterial = publicKeyMaterial
        }

        public init(dictionary: [String: Any]) throws {
            guard let keyName = dictionary["KeyName"] as? String else { throw InitializableError.missingRequiredParam("KeyName") }
            self.keyName = keyName
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let publicKeyMaterial = dictionary["PublicKeyMaterial"] as? Data else { throw InitializableError.missingRequiredParam("PublicKeyMaterial") }
            self.publicKeyMaterial = publicKeyMaterial
        }
    }

    public struct InstanceIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let instanceId: [String]?

        public init(instanceId: [String]? = nil) {
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? [String]
        }
    }

    public struct VpcClassicLinkIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let vpcId: [String]?

        public init(vpcId: [String]? = nil) {
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? [String]
        }
    }

    public struct RunInstancesMonitoringEnabled: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            guard let enabled = dictionary["Enabled"] as? Bool else { throw InitializableError.missingRequiredParam("Enabled") }
            self.enabled = enabled
        }
    }

    public struct GetPasswordDataResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time the data was last updated.
        public let timestamp: Date?
        /// The password of the instance.
        public let passwordData: String?
        /// The ID of the Windows instance.
        public let instanceId: String?

        public init(timestamp: Date? = nil, passwordData: String? = nil, instanceId: String? = nil) {
            self.timestamp = timestamp
            self.passwordData = passwordData
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.passwordData = dictionary["PasswordData"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct AvailabilityZoneMessageList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [AvailabilityZoneMessage]?

        public init(item: [AvailabilityZoneMessage]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try AvailabilityZoneMessage(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum PlatformValues: String, CustomStringConvertible {
        case windows = "Windows"
        public var description: String { return self.rawValue }
    }

    public struct IdFormat: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.
        public let deadline: Date?
        /// The type of resource.
        public let resource: String?
        /// Indicates whether longer IDs (17-character IDs) are enabled for the resource.
        public let useLongIds: Bool?

        public init(deadline: Date? = nil, resource: String? = nil, useLongIds: Bool? = nil) {
            self.deadline = deadline
            self.resource = resource
            self.useLongIds = useLongIds
        }

        public init(dictionary: [String: Any]) throws {
            self.deadline = dictionary["Deadline"] as? Date
            self.resource = dictionary["Resource"] as? String
            self.useLongIds = dictionary["UseLongIds"] as? Bool
        }
    }

    public struct DescribeClassicLinkInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    group-id - The ID of a VPC security group that's associated with the instance.    instance-id - The ID of the instance.    tag:key=value - The key/value combination of a tag assigned to the resource.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC that the instance is linked to.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more instance IDs. Must be instances linked to a VPC through ClassicLink.
        public let instanceIds: InstanceIdStringList?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request. Constraint: If the value is greater than 1000, we return only 1000 items.
        public let maxResults: Int32?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, instanceIds: InstanceIdStringList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceIds = dictionary["InstanceId"] as? [String: Any] { self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds) } else { self.instanceIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct RunScheduledInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see Ensuring Idempotency.
        public let clientToken: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.
        public let launchSpecification: ScheduledInstancesLaunchSpecification
        /// The number of instances. Default: 1
        public let instanceCount: Int32?
        /// The Scheduled Instance ID.
        public let scheduledInstanceId: String

        public init(clientToken: String? = nil, dryRun: Bool? = nil, launchSpecification: ScheduledInstancesLaunchSpecification, instanceCount: Int32? = nil, scheduledInstanceId: String) {
            self.clientToken = clientToken
            self.dryRun = dryRun
            self.launchSpecification = launchSpecification
            self.instanceCount = instanceCount
            self.scheduledInstanceId = scheduledInstanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] else { throw InitializableError.missingRequiredParam("LaunchSpecification") }
            self.launchSpecification = try Ec2.ScheduledInstancesLaunchSpecification(dictionary: launchSpecification)
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            guard let scheduledInstanceId = dictionary["ScheduledInstanceId"] as? String else { throw InitializableError.missingRequiredParam("ScheduledInstanceId") }
            self.scheduledInstanceId = scheduledInstanceId
        }
    }

    public struct BlockDeviceMapping: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Suppresses the specified device included in the block device mapping of the AMI.
        public let noDevice: String?
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        public let virtualName: String?
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public let deviceName: String?
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        public let ebs: EbsBlockDevice?

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsBlockDevice? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.EbsBlockDevice(dictionary: ebs) } else { self.ebs = nil }
        }
    }

    public enum InstanceStateName: String, CustomStringConvertible {
        case pending = "pending"
        case running = "running"
        case shutting_down = "shutting-down"
        case terminated = "terminated"
        case stopping = "stopping"
        case stopped = "stopped"
        public var description: String { return self.rawValue }
    }

    public struct ReplaceIamInstanceProfileAssociationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfileSpecification
        /// The ID of the existing IAM instance profile association.
        public let associationId: String

        public init(iamInstanceProfile: IamInstanceProfileSpecification, associationId: String) {
            self.iamInstanceProfile = iamInstanceProfile
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IamInstanceProfile") }
            self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile)
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct AllocationIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let allocationId: [String]?

        public init(allocationId: [String]? = nil) {
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            self.allocationId = dictionary["AllocationId"] as? [String]
        }
    }

    public struct ScheduledInstancesIpv6Address: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 address.
        public let ipv6Address: String?

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6Address = dictionary["Ipv6Address"] as? String
        }
    }

    public enum ProductCodeValues: String, CustomStringConvertible {
        case devpay = "devpay"
        case marketplace = "marketplace"
        public var description: String { return self.rawValue }
    }

    public enum SpotInstanceType: String, CustomStringConvertible {
        case one_time = "one-time"
        case persistent = "persistent"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSpotFleetRequestHistoryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The starting date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let startTime: Date
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The type of events to describe. By default, all events are described.
        public let eventType: EventType?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(startTime: Date, dryRun: Bool? = nil, eventType: EventType? = nil, nextToken: String? = nil, spotFleetRequestId: String, maxResults: Int32? = nil) {
            self.startTime = startTime
            self.dryRun = dryRun
            self.eventType = eventType
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            self.dryRun = dictionary["DryRun"] as? Bool
            if let eventType = dictionary["EventType"] as? String { self.eventType = EventType(rawValue: eventType) } else { self.eventType = nil }
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ScheduledInstanceAvailability: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The platform (Linux/UNIX or Windows).
        public let platform: String?
        /// The total number of hours for a single instance for the entire term.
        public let totalScheduledInstanceHours: Int32?
        /// The minimum term. The only possible value is 365 days.
        public let minTermDurationInDays: Int32?
        /// The maximum term. The only possible value is 365 days.
        public let maxTermDurationInDays: Int32?
        /// The hourly price for a single instance.
        public let hourlyPrice: String?
        /// The instance type. You can specify one of the C3, C4, M4, or R3 instance types.
        public let instanceType: String?
        /// The number of hours in the schedule.
        public let slotDurationInHours: Int32?
        /// The Availability Zone.
        public let availabilityZone: String?
        /// The number of available instances.
        public let availableInstanceCount: Int32?
        /// The time period for the first schedule to start.
        public let firstSlotStartTime: Date?
        /// The network platform (EC2-Classic or EC2-VPC).
        public let networkPlatform: String?
        /// The purchase token. This token expires in two hours.
        public let purchaseToken: String?
        /// The schedule recurrence.
        public let recurrence: ScheduledInstanceRecurrence?

        public init(platform: String? = nil, totalScheduledInstanceHours: Int32? = nil, minTermDurationInDays: Int32? = nil, maxTermDurationInDays: Int32? = nil, hourlyPrice: String? = nil, instanceType: String? = nil, slotDurationInHours: Int32? = nil, availabilityZone: String? = nil, availableInstanceCount: Int32? = nil, firstSlotStartTime: Date? = nil, networkPlatform: String? = nil, purchaseToken: String? = nil, recurrence: ScheduledInstanceRecurrence? = nil) {
            self.platform = platform
            self.totalScheduledInstanceHours = totalScheduledInstanceHours
            self.minTermDurationInDays = minTermDurationInDays
            self.maxTermDurationInDays = maxTermDurationInDays
            self.hourlyPrice = hourlyPrice
            self.instanceType = instanceType
            self.slotDurationInHours = slotDurationInHours
            self.availabilityZone = availabilityZone
            self.availableInstanceCount = availableInstanceCount
            self.firstSlotStartTime = firstSlotStartTime
            self.networkPlatform = networkPlatform
            self.purchaseToken = purchaseToken
            self.recurrence = recurrence
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            self.totalScheduledInstanceHours = dictionary["TotalScheduledInstanceHours"] as? Int32
            self.minTermDurationInDays = dictionary["MinTermDurationInDays"] as? Int32
            self.maxTermDurationInDays = dictionary["MaxTermDurationInDays"] as? Int32
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.slotDurationInHours = dictionary["SlotDurationInHours"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.availableInstanceCount = dictionary["AvailableInstanceCount"] as? Int32
            self.firstSlotStartTime = dictionary["FirstSlotStartTime"] as? Date
            self.networkPlatform = dictionary["NetworkPlatform"] as? String
            self.purchaseToken = dictionary["PurchaseToken"] as? String
            if let recurrence = dictionary["Recurrence"] as? [String: Any] { self.recurrence = try Ec2.ScheduledInstanceRecurrence(dictionary: recurrence) } else { self.recurrence = nil }
        }
    }

    public struct PricingDetailsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PricingDetail]?

        public init(item: [PricingDetail]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PricingDetail(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VolumeDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The size of the volume, in GiB.
        public let size: Int64

        public init(size: Int64) {
            self.size = size
        }

        public init(dictionary: [String: Any]) throws {
            guard let size = dictionary["Size"] as? Int64 else { throw InitializableError.missingRequiredParam("Size") }
            self.size = size
        }
    }

    public struct ReleaseHostsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the Dedicated Hosts you want to release.
        public let hostIds: RequestHostIdList

        public init(hostIds: RequestHostIdList) {
            self.hostIds = hostIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let hostIds = dictionary["HostId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("HostId") }
            self.hostIds = try Ec2.RequestHostIdList(dictionary: hostIds)
        }
    }

    public enum CancelSpotInstanceRequestState: String, CustomStringConvertible {
        case active = "active"
        case open = "open"
        case closed = "closed"
        case cancelled = "cancelled"
        case completed = "completed"
        public var description: String { return self.rawValue }
    }

    public struct InstanceStatusDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of instance status.
        public let name: StatusName?
        /// The status.
        public let status: StatusType?
        /// The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.
        public let impairedSince: Date?

        public init(name: StatusName? = nil, status: StatusType? = nil, impairedSince: Date? = nil) {
            self.name = name
            self.status = status
            self.impairedSince = impairedSince
        }

        public init(dictionary: [String: Any]) throws {
            if let name = dictionary["Name"] as? String { self.name = StatusName(rawValue: name) } else { self.name = nil }
            if let status = dictionary["Status"] as? String { self.status = StatusType(rawValue: status) } else { self.status = nil }
            self.impairedSince = dictionary["ImpairedSince"] as? Date
        }
    }

    public struct StartInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more instance IDs.
        public let instanceIds: InstanceIdStringList
        /// Reserved.
        public let additionalInfo: String?

        public init(dryRun: Bool? = nil, instanceIds: InstanceIdStringList, additionalInfo: String? = nil) {
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.additionalInfo = additionalInfo
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceIds = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds)
            self.additionalInfo = dictionary["AdditionalInfo"] as? String
        }
    }

    public struct FlowLogSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [FlowLog]?

        public init(item: [FlowLog]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try FlowLog(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SlotStartTimeRangeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The earliest date and time, in UTC, for the Scheduled Instance to start.
        public let earliestTime: Date?
        /// The latest date and time, in UTC, for the Scheduled Instance to start.
        public let latestTime: Date?

        public init(earliestTime: Date? = nil, latestTime: Date? = nil) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

        public init(dictionary: [String: Any]) throws {
            self.earliestTime = dictionary["EarliestTime"] as? Date
            self.latestTime = dictionary["LatestTime"] as? Date
        }
    }

    public struct CreateRouteResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct VolumeStatusEventsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VolumeStatusEvent]?

        public init(item: [VolumeStatusEvent]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VolumeStatusEvent(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum NetworkInterfaceType: String, CustomStringConvertible {
        case interface = "interface"
        case natgateway = "natGateway"
        public var description: String { return self.rawValue }
    }

    public struct DescribeReservedInstancesListingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the Reserved Instance listing.
        public let reservedInstancesListings: ReservedInstancesListingList?

        public init(reservedInstancesListings: ReservedInstancesListingList? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesListings = dictionary["ReservedInstancesListingsSet"] as? [String: Any] { self.reservedInstancesListings = try Ec2.ReservedInstancesListingList(dictionary: reservedInstancesListings) } else { self.reservedInstancesListings = nil }
        }
    }

    public struct GetHostReservationPurchasePreviewResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The purchase information of the Dedicated Host Reservation and the Dedicated Hosts associated with it.
        public let purchase: [Purchase]?
        /// The potential total upfront price. This is billed immediately.
        public let totalUpfrontPrice: String?
        /// The currency in which the totalUpfrontPrice and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The potential total hourly price of the reservation per hour.
        public let totalHourlyPrice: String?

        public init(purchase: [Purchase]? = nil, totalUpfrontPrice: String? = nil, currencyCode: CurrencyCodeValues? = nil, totalHourlyPrice: String? = nil) {
            self.purchase = purchase
            self.totalUpfrontPrice = totalUpfrontPrice
            self.currencyCode = currencyCode
            self.totalHourlyPrice = totalHourlyPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let purchase = dictionary["Purchase"] as? [[String: Any]] {
                self.purchase = try purchase.map({ try Purchase(dictionary: $0) })
            } else { 
                self.purchase = nil
            }
            self.totalUpfrontPrice = dictionary["TotalUpfrontPrice"] as? String
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.totalHourlyPrice = dictionary["TotalHourlyPrice"] as? String
        }
    }

    public struct ExportTask: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the instance to export.
        public let instanceExportDetails: InstanceExportDetails?
        /// The ID of the export task.
        public let exportTaskId: String?
        /// Information about the export task.
        public let exportToS3Task: ExportToS3Task?
        /// The state of the export task.
        public let state: ExportTaskState?
        /// The status message related to the export task.
        public let statusMessage: String?
        /// A description of the resource being exported.
        public let description: String?

        public init(instanceExportDetails: InstanceExportDetails? = nil, exportTaskId: String? = nil, exportToS3Task: ExportToS3Task? = nil, state: ExportTaskState? = nil, statusMessage: String? = nil, description: String? = nil) {
            self.instanceExportDetails = instanceExportDetails
            self.exportTaskId = exportTaskId
            self.exportToS3Task = exportToS3Task
            self.state = state
            self.statusMessage = statusMessage
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceExportDetails = dictionary["InstanceExport"] as? [String: Any] { self.instanceExportDetails = try Ec2.InstanceExportDetails(dictionary: instanceExportDetails) } else { self.instanceExportDetails = nil }
            self.exportTaskId = dictionary["ExportTaskId"] as? String
            if let exportToS3Task = dictionary["ExportToS3"] as? [String: Any] { self.exportToS3Task = try Ec2.ExportToS3Task(dictionary: exportToS3Task) } else { self.exportToS3Task = nil }
            if let state = dictionary["State"] as? String { self.state = ExportTaskState(rawValue: state) } else { self.state = nil }
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateSpotDatafeedSubscriptionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon S3 bucket in which to store the Spot instance data feed.
        public let bucket: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A prefix for the data feed file names.
        public let prefix: String?

        public init(bucket: String, dryRun: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.dryRun = dryRun
            self.prefix = prefix
        }

        public init(dictionary: [String: Any]) throws {
            guard let bucket = dictionary["Bucket"] as? String else { throw InitializableError.missingRequiredParam("Bucket") }
            self.bucket = bucket
            self.dryRun = dictionary["DryRun"] as? Bool
            self.prefix = dictionary["Prefix"] as? String
        }
    }

    public struct EgressOnlyInternetGatewayList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [EgressOnlyInternetGateway]?

        public init(item: [EgressOnlyInternetGateway]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try EgressOnlyInternetGateway(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeScheduledInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time period for the first schedule to start.
        public let slotStartTimeRange: SlotStartTimeRangeRequest?
        /// The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?
        /// One or more filters.    availability-zone - The Availability Zone (for example, us-west-2a).    instance-type - The instance type (for example, c4.large).    network-platform - The network platform (EC2-Classic or EC2-VPC).    platform - The platform (Linux/UNIX or Windows).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token for the next set of results.
        public let nextToken: String?
        /// One or more Scheduled Instance IDs.
        public let scheduledInstanceIds: ScheduledInstanceIdRequestSet?

        public init(slotStartTimeRange: SlotStartTimeRangeRequest? = nil, maxResults: Int32? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, scheduledInstanceIds: ScheduledInstanceIdRequestSet? = nil) {
            self.slotStartTimeRange = slotStartTimeRange
            self.maxResults = maxResults
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.scheduledInstanceIds = scheduledInstanceIds
        }

        public init(dictionary: [String: Any]) throws {
            if let slotStartTimeRange = dictionary["SlotStartTimeRange"] as? [String: Any] { self.slotStartTimeRange = try Ec2.SlotStartTimeRangeRequest(dictionary: slotStartTimeRange) } else { self.slotStartTimeRange = nil }
            self.maxResults = dictionary["MaxResults"] as? Int32
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            if let scheduledInstanceIds = dictionary["ScheduledInstanceId"] as? [String: Any] { self.scheduledInstanceIds = try Ec2.ScheduledInstanceIdRequestSet(dictionary: scheduledInstanceIds) } else { self.scheduledInstanceIds = nil }
        }
    }

    public struct DeleteSubnetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(subnetId: String, dryRun: Bool? = nil) {
            self.subnetId = subnetId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct EbsInstanceBlockDeviceSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The ID of the EBS volume.
        public let volumeId: String?

        public init(deleteOnTermination: Bool? = nil, volumeId: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct NetworkInterfaceAttachment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device index of the network interface attachment on the instance.
        public let deviceIndex: Int32?
        /// The attachment state.
        public let status: AttachmentStatus?
        /// The ID of the instance.
        public let instanceId: String?
        /// The timestamp indicating when the attachment initiated.
        public let attachTime: Date?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The ID of the network interface attachment.
        public let attachmentId: String?
        /// The AWS account ID of the owner of the instance.
        public let instanceOwnerId: String?

        public init(deviceIndex: Int32? = nil, status: AttachmentStatus? = nil, instanceId: String? = nil, attachTime: Date? = nil, deleteOnTermination: Bool? = nil, attachmentId: String? = nil, instanceOwnerId: String? = nil) {
            self.deviceIndex = deviceIndex
            self.status = status
            self.instanceId = instanceId
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.attachmentId = attachmentId
            self.instanceOwnerId = instanceOwnerId
        }

        public init(dictionary: [String: Any]) throws {
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            if let status = dictionary["Status"] as? String { self.status = AttachmentStatus(rawValue: status) } else { self.status = nil }
            self.instanceId = dictionary["InstanceId"] as? String
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.attachmentId = dictionary["AttachmentId"] as? String
            self.instanceOwnerId = dictionary["InstanceOwnerId"] as? String
        }
    }

    public struct DescribePrefixListsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public let nextToken: String?
        /// All available prefix lists.
        public let prefixLists: PrefixListSet?

        public init(nextToken: String? = nil, prefixLists: PrefixListSet? = nil) {
            self.nextToken = nextToken
            self.prefixLists = prefixLists
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let prefixLists = dictionary["PrefixListSet"] as? [String: Any] { self.prefixLists = try Ec2.PrefixListSet(dictionary: prefixLists) } else { self.prefixLists = nil }
        }
    }

    public struct ReplaceRouteTableAssociationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the new route table to associate with the subnet.
        public let routeTableId: String
        /// The association ID.
        public let associationId: String

        public init(dryRun: Bool? = nil, routeTableId: String, associationId: String) {
            self.dryRun = dryRun
            self.routeTableId = routeTableId
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct AccountAttributeNameStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let attributeName: [AccountAttributeName]?

        public init(attributeName: [AccountAttributeName]? = nil) {
            self.attributeName = attributeName
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeName = dictionary["AttributeName"] as? [String] { self.attributeName = attributeName.flatMap({ AccountAttributeName(rawValue: $0)}) } else { self.attributeName = nil }
        }
    }

    public enum ImageAttributeName: String, CustomStringConvertible {
        case description = "description"
        case kernel = "kernel"
        case ramdisk = "ramdisk"
        case launchpermission = "launchPermission"
        case productcodes = "productCodes"
        case blockdevicemapping = "blockDeviceMapping"
        case sriovnetsupport = "sriovNetSupport"
        public var description: String { return self.rawValue }
    }

    public enum PlacementGroupState: String, CustomStringConvertible {
        case pending = "pending"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct ScheduledInstancesBlockDeviceMappingSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let blockDeviceMapping: [ScheduledInstancesBlockDeviceMapping]?

        public init(blockDeviceMapping: [ScheduledInstancesBlockDeviceMapping]? = nil) {
            self.blockDeviceMapping = blockDeviceMapping
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMapping = dictionary["BlockDeviceMapping"] as? [[String: Any]] {
                self.blockDeviceMapping = try blockDeviceMapping.map({ try ScheduledInstancesBlockDeviceMapping(dictionary: $0) })
            } else { 
                self.blockDeviceMapping = nil
            }
        }
    }

    public struct SecurityGroupReferences: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SecurityGroupReference]?

        public init(item: [SecurityGroupReference]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SecurityGroupReference(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct InstanceStatusSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The system instance health or application instance health.
        public let details: InstanceStatusDetailsList?
        /// The status.
        public let status: SummaryStatus?

        public init(details: InstanceStatusDetailsList? = nil, status: SummaryStatus? = nil) {
            self.details = details
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let details = dictionary["Details"] as? [String: Any] { self.details = try Ec2.InstanceStatusDetailsList(dictionary: details) } else { self.details = nil }
            if let status = dictionary["Status"] as? String { self.status = SummaryStatus(rawValue: status) } else { self.status = nil }
        }
    }

    public struct UnsuccessfulItemError: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error code.
        public let code: String
        /// The error message accompanying the error code.
        public let message: String

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            guard let code = dictionary["Code"] as? String else { throw InitializableError.missingRequiredParam("Code") }
            self.code = code
            guard let message = dictionary["Message"] as? String else { throw InitializableError.missingRequiredParam("Message") }
            self.message = message
        }
    }

    public struct SnapshotIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let snapshotId: [String]?

        public init(snapshotId: [String]? = nil) {
            self.snapshotId = snapshotId
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? [String]
        }
    }

    public struct RestoreAddressToClassicResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The move status for the IP address.
        public let status: Status?
        /// The Elastic IP address.
        public let publicIp: String?

        public init(status: Status? = nil, publicIp: String? = nil) {
            self.status = status
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["Status"] as? String { self.status = Status(rawValue: status) } else { self.status = nil }
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct CopyImageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the new AMI.
        public let imageId: String?

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct DescribeSecurityGroupReferencesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPCs with the referencing security groups.
        public let securityGroupReferenceSet: SecurityGroupReferences?

        public init(securityGroupReferenceSet: SecurityGroupReferences? = nil) {
            self.securityGroupReferenceSet = securityGroupReferenceSet
        }

        public init(dictionary: [String: Any]) throws {
            if let securityGroupReferenceSet = dictionary["SecurityGroupReferenceSet"] as? [String: Any] { self.securityGroupReferenceSet = try Ec2.SecurityGroupReferences(dictionary: securityGroupReferenceSet) } else { self.securityGroupReferenceSet = nil }
        }
    }

    public struct InstanceStateChangeList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceStateChange]?

        public init(item: [InstanceStateChange]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceStateChange(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct LaunchPermission: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account ID.
        public let userId: String?
        /// The name of the group.
        public let group: PermissionGroup?

        public init(userId: String? = nil, group: PermissionGroup? = nil) {
            self.userId = userId
            self.group = group
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            if let group = dictionary["Group"] as? String { self.group = PermissionGroup(rawValue: group) } else { self.group = nil }
        }
    }

    public enum ContainerFormat: String, CustomStringConvertible {
        case ova = "ova"
        public var description: String { return self.rawValue }
    }

    public struct ImportImageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The license type of the virtual machine.
        public let licenseType: String?
        /// A brief status of the task.
        public let status: String?
        /// The operating system of the virtual machine.
        public let platform: String?
        /// The progress of the task.
        public let progress: String?
        /// The target hypervisor of the import task.
        public let hypervisor: String?
        /// The architecture of the virtual machine.
        public let architecture: String?
        /// The ID of the Amazon Machine Image (AMI) created by the import task.
        public let imageId: String?
        /// The task ID of the import image task.
        public let importTaskId: String?
        /// A detailed status message of the import task.
        public let statusMessage: String?
        /// Information about the snapshots.
        public let snapshotDetails: SnapshotDetailList?
        /// A description of the import task.
        public let description: String?

        public init(licenseType: String? = nil, status: String? = nil, platform: String? = nil, progress: String? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, importTaskId: String? = nil, statusMessage: String? = nil, snapshotDetails: SnapshotDetailList? = nil, description: String? = nil) {
            self.licenseType = licenseType
            self.status = status
            self.platform = platform
            self.progress = progress
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.importTaskId = importTaskId
            self.statusMessage = statusMessage
            self.snapshotDetails = snapshotDetails
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.licenseType = dictionary["LicenseType"] as? String
            self.status = dictionary["Status"] as? String
            self.platform = dictionary["Platform"] as? String
            self.progress = dictionary["Progress"] as? String
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.imageId = dictionary["ImageId"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let snapshotDetails = dictionary["SnapshotDetailSet"] as? [String: Any] { self.snapshotDetails = try Ec2.SnapshotDetailList(dictionary: snapshotDetails) } else { self.snapshotDetails = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVpcPeeringConnectionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPC peering connections.
        public let vpcPeeringConnections: VpcPeeringConnectionList?

        public init(vpcPeeringConnections: VpcPeeringConnectionList? = nil) {
            self.vpcPeeringConnections = vpcPeeringConnections
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcPeeringConnections = dictionary["VpcPeeringConnectionSet"] as? [String: Any] { self.vpcPeeringConnections = try Ec2.VpcPeeringConnectionList(dictionary: vpcPeeringConnections) } else { self.vpcPeeringConnections = nil }
        }
    }

    public struct DiskImageDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The disk image format.
        public let format: DiskImageFormat
        /// A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the Authenticating REST Requests topic in the Amazon Simple Storage Service Developer Guide. For information about the import manifest referenced by this API action, see VM Import Manifest.
        public let importManifestUrl: String
        /// The size of the disk image, in GiB.
        public let bytes: Int64

        public init(format: DiskImageFormat, importManifestUrl: String, bytes: Int64) {
            self.format = format
            self.importManifestUrl = importManifestUrl
            self.bytes = bytes
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawFormat = dictionary["Format"] as? String, let format = DiskImageFormat(rawValue: rawFormat) else { throw InitializableError.missingRequiredParam("Format") }
            self.format = format
            guard let importManifestUrl = dictionary["ImportManifestUrl"] as? String else { throw InitializableError.missingRequiredParam("ImportManifestUrl") }
            self.importManifestUrl = importManifestUrl
            guard let bytes = dictionary["Bytes"] as? Int64 else { throw InitializableError.missingRequiredParam("Bytes") }
            self.bytes = bytes
        }
    }

    public struct PrefixList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the prefix.
        public let prefixListId: String?
        /// The IP address range of the AWS service.
        public let cidrs: ValueStringList?
        /// The name of the prefix.
        public let prefixListName: String?

        public init(prefixListId: String? = nil, cidrs: ValueStringList? = nil, prefixListName: String? = nil) {
            self.prefixListId = prefixListId
            self.cidrs = cidrs
            self.prefixListName = prefixListName
        }

        public init(dictionary: [String: Any]) throws {
            self.prefixListId = dictionary["PrefixListId"] as? String
            if let cidrs = dictionary["CidrSet"] as? [String: Any] { self.cidrs = try Ec2.ValueStringList(dictionary: cidrs) } else { self.cidrs = nil }
            self.prefixListName = dictionary["PrefixListName"] as? String
        }
    }

    public struct ModifyIdFormatRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of resource: instance | reservation | snapshot | volume 
        public let resource: String
        /// Indicate whether the resource should use longer IDs (17-character IDs).
        public let useLongIds: Bool

        public init(resource: String, useLongIds: Bool) {
            self.resource = resource
            self.useLongIds = useLongIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let resource = dictionary["Resource"] as? String else { throw InitializableError.missingRequiredParam("Resource") }
            self.resource = resource
            guard let useLongIds = dictionary["UseLongIds"] as? Bool else { throw InitializableError.missingRequiredParam("UseLongIds") }
            self.useLongIds = useLongIds
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    key - The tag key.    resource-id - The resource ID.    resource-type - The resource type (customer-gateway | dhcp-options | image | instance | internet-gateway | network-acl | network-interface | reserved-instances | route-table | security-group | snapshot | spot-instances-request | subnet | volume | vpc | vpn-connection | vpn-gateway).    value - The tag value.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BundleTask: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time this task started.
        public let startTime: Date?
        /// If the task fails, a description of the error.
        public let bundleTaskError: BundleTaskError?
        /// The level of task completion, as a percent (for example, 20%).
        public let progress: String?
        /// The ID of the instance associated with this bundle task.
        public let instanceId: String?
        /// The state of the task.
        public let state: BundleTaskState?
        /// The time of the most recent update for the task.
        public let updateTime: Date?
        /// The Amazon S3 storage locations.
        public let storage: Storage?
        /// The ID of the bundle task.
        public let bundleId: String?

        public init(startTime: Date? = nil, bundleTaskError: BundleTaskError? = nil, progress: String? = nil, instanceId: String? = nil, state: BundleTaskState? = nil, updateTime: Date? = nil, storage: Storage? = nil, bundleId: String? = nil) {
            self.startTime = startTime
            self.bundleTaskError = bundleTaskError
            self.progress = progress
            self.instanceId = instanceId
            self.state = state
            self.updateTime = updateTime
            self.storage = storage
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            if let bundleTaskError = dictionary["Error"] as? [String: Any] { self.bundleTaskError = try Ec2.BundleTaskError(dictionary: bundleTaskError) } else { self.bundleTaskError = nil }
            self.progress = dictionary["Progress"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            if let state = dictionary["State"] as? String { self.state = BundleTaskState(rawValue: state) } else { self.state = nil }
            self.updateTime = dictionary["UpdateTime"] as? Date
            if let storage = dictionary["Storage"] as? [String: Any] { self.storage = try Ec2.Storage(dictionary: storage) } else { self.storage = nil }
            self.bundleId = dictionary["BundleId"] as? String
        }
    }

    public enum SubnetCidrBlockStateCode: String, CustomStringConvertible {
        case associating = "associating"
        case associated = "associated"
        case disassociating = "disassociating"
        case disassociated = "disassociated"
        case failing = "failing"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public struct DetachNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the attachment.
        public let attachmentId: String
        /// Specifies whether to force a detachment.
        public let force: Bool?

        public init(dryRun: Bool? = nil, attachmentId: String, force: Bool? = nil) {
            self.dryRun = dryRun
            self.attachmentId = attachmentId
            self.force = force
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let attachmentId = dictionary["AttachmentId"] as? String else { throw InitializableError.missingRequiredParam("AttachmentId") }
            self.attachmentId = attachmentId
            self.force = dictionary["Force"] as? Bool
        }
    }

    public struct DescribeRegionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more regions.
        public let regions: RegionList?

        public init(regions: RegionList? = nil) {
            self.regions = regions
        }

        public init(dictionary: [String: Any]) throws {
            if let regions = dictionary["RegionInfo"] as? [String: Any] { self.regions = try Ec2.RegionList(dictionary: regions) } else { self.regions = nil }
        }
    }

    public struct GetConsoleOutputRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the instance.
        public let instanceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceId: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateVolumePermissionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [CreateVolumePermission]?

        public init(item: [CreateVolumePermission]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try CreateVolumePermission(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ZoneNameStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let zoneName: [String]?

        public init(zoneName: [String]? = nil) {
            self.zoneName = zoneName
        }

        public init(dictionary: [String: Any]) throws {
            self.zoneName = dictionary["ZoneName"] as? [String]
        }
    }

    public struct PlacementGroupList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PlacementGroup]?

        public init(item: [PlacementGroup]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PlacementGroup(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CreateVpnConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the VPN connection requires static routes. If you are creating a VPN connection for a device that does not support BGP, you must specify true. Default: false 
        public let options: VpnConnectionOptionsSpecification?
        /// The ID of the customer gateway.
        public let customerGatewayId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The type of VPN connection (ipsec.1).
        public let `type`: String
        /// The ID of the virtual private gateway.
        public let vpnGatewayId: String

        public init(options: VpnConnectionOptionsSpecification? = nil, customerGatewayId: String, dryRun: Bool? = nil, type: String, vpnGatewayId: String) {
            self.options = options
            self.customerGatewayId = customerGatewayId
            self.dryRun = dryRun
            self.`type` = `type`
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            if let options = dictionary["Options"] as? [String: Any] { self.options = try Ec2.VpnConnectionOptionsSpecification(dictionary: options) } else { self.options = nil }
            guard let customerGatewayId = dictionary["CustomerGatewayId"] as? String else { throw InitializableError.missingRequiredParam("CustomerGatewayId") }
            self.customerGatewayId = customerGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let `type` = dictionary["Type"] as? String else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct DescribeSpotPriceHistoryResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The historical Spot prices.
        public let spotPriceHistory: SpotPriceHistoryList?

        public init(nextToken: String? = nil, spotPriceHistory: SpotPriceHistoryList? = nil) {
            self.nextToken = nextToken
            self.spotPriceHistory = spotPriceHistory
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let spotPriceHistory = dictionary["SpotPriceHistorySet"] as? [String: Any] { self.spotPriceHistory = try Ec2.SpotPriceHistoryList(dictionary: spotPriceHistory) } else { self.spotPriceHistory = nil }
        }
    }

    public struct CreateSecurityGroupResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the security group.
        public let groupId: String?

        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.groupId = dictionary["GroupId"] as? String
        }
    }

    public struct InstanceNetworkInterfaceSpecificationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceNetworkInterfaceSpecification]?

        public init(item: [InstanceNetworkInterfaceSpecification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceNetworkInterfaceSpecification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CancelSpotFleetRequestsSuccessSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [CancelSpotFleetRequestsSuccessItem]?

        public init(item: [CancelSpotFleetRequestsSuccessItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try CancelSpotFleetRequestsSuccessItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum AllocationStrategy: String, CustomStringConvertible {
        case lowestprice = "lowestPrice"
        case diversified = "diversified"
        public var description: String { return self.rawValue }
    }

    public struct CreateNatGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
        public let clientToken: String?
        /// Information about the NAT gateway.
        public let natGateway: NatGateway?

        public init(clientToken: String? = nil, natGateway: NatGateway? = nil) {
            self.clientToken = clientToken
            self.natGateway = natGateway
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let natGateway = dictionary["NatGateway"] as? [String: Any] { self.natGateway = try Ec2.NatGateway(dictionary: natGateway) } else { self.natGateway = nil }
        }
    }

    public struct InstanceStatusDetailsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceStatusDetails]?

        public init(item: [InstanceStatusDetails]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceStatusDetails(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SecurityGroupList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SecurityGroup]?

        public init(item: [SecurityGroup]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SecurityGroup(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum SpotInstanceState: String, CustomStringConvertible {
        case open = "open"
        case active = "active"
        case closed = "closed"
        case cancelled = "cancelled"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public struct SpotPlacement: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Availability Zone. [Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        public let availabilityZone: String?
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for Spot instances.
        public let tenancy: Tenancy?
        /// The name of the placement group (for cluster instances).
        public let groupName: String?

        public init(availabilityZone: String? = nil, tenancy: Tenancy? = nil, groupName: String? = nil) {
            self.availabilityZone = availabilityZone
            self.tenancy = tenancy
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let tenancy = dictionary["Tenancy"] as? String { self.tenancy = Tenancy(rawValue: tenancy) } else { self.tenancy = nil }
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct Instance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The idempotency token you provided when you launched the instance, if applicable.
        public let clientToken: String?
        /// The root device name (for example, /dev/sda1 or /dev/xvda).
        public let rootDeviceName: String?
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
        public let ebsOptimized: Bool?
        /// Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the instance to perform NAT. For more information, see NAT Instances in the Amazon Virtual Private Cloud User Guide.
        public let sourceDestCheck: Bool?
        /// The kernel associated with this instance, if applicable.
        public let kernelId: String?
        /// (IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the running state.  [EC2-VPC] The Amazon-provided DNS server will resolve Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.
        public let privateDnsName: String?
        /// The instance type.
        public let instanceType: InstanceType?
        /// The private IPv4 address assigned to the instance.
        public let privateIpAddress: String?
        /// The product codes attached to this instance, if applicable.
        public let productCodes: ProductCodeList?
        /// The name of the key pair, if this instance was launched with an associated key pair.
        public let keyName: String?
        /// The ID of the instance.
        public let instanceId: String?
        /// The IAM instance profile associated with the instance, if applicable.
        public let iamInstanceProfile: IamInstanceProfile?
        /// (IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the running state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.
        public let publicDnsName: String?
        /// [EC2-VPC] The ID of the VPC in which the instance is running.
        public let vpcId: String?
        /// The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.
        public let rootDeviceType: DeviceType?
        /// The RAM disk associated with this instance, if applicable.
        public let ramdiskId: String?
        /// Indicates whether this is a Spot instance or a Scheduled Instance.
        public let instanceLifecycle: InstanceLifecycleType?
        /// Any block device mapping entries for the instance.
        public let blockDeviceMappings: InstanceBlockDeviceMappingList?
        /// [EC2-VPC] The ID of the subnet in which the instance is running.
        public let subnetId: String?
        /// Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public let sriovNetSupport: String?
        /// The value is Windows for Windows instances; otherwise blank.
        public let platform: PlatformValues?
        /// If the request is a Spot instance request, the ID of the request.
        public let spotInstanceRequestId: String?
        /// Any tags assigned to the instance.
        public let tags: TagList?
        /// The time the instance was launched.
        public let launchTime: Date?
        /// The current state of the instance.
        public let state: InstanceState?
        /// The public IPv4 address assigned to the instance, if applicable.
        public let publicIpAddress: String?
        /// The monitoring for the instance.
        public let monitoring: Monitoring?
        /// The reason for the most recent state transition. This might be an empty string.
        public let stateTransitionReason: String?
        /// The reason for the most recent state transition.
        public let stateReason: StateReason?
        /// One or more security groups for the instance.
        public let securityGroups: GroupIdentifierList?
        /// The hypervisor type of the instance.
        public let hypervisor: HypervisorType?
        /// The architecture of the image.
        public let architecture: ArchitectureValues?
        /// The ID of the AMI used to launch the instance.
        public let imageId: String?
        /// Specifies whether enhanced networking with ENA is enabled.
        public let enaSupport: Bool?
        /// [EC2-VPC] One or more network interfaces for the instance.
        public let networkInterfaces: InstanceNetworkInterfaceList?
        /// The AMI launch index, which can be used to find this instance in the launch group.
        public let amiLaunchIndex: Int32?
        /// The location where the instance launched, if applicable.
        public let placement: Placement?
        /// The virtualization type of the instance.
        public let virtualizationType: VirtualizationType?

        public init(clientToken: String? = nil, rootDeviceName: String? = nil, ebsOptimized: Bool? = nil, sourceDestCheck: Bool? = nil, kernelId: String? = nil, privateDnsName: String? = nil, instanceType: InstanceType? = nil, privateIpAddress: String? = nil, productCodes: ProductCodeList? = nil, keyName: String? = nil, instanceId: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil, publicDnsName: String? = nil, vpcId: String? = nil, rootDeviceType: DeviceType? = nil, ramdiskId: String? = nil, instanceLifecycle: InstanceLifecycleType? = nil, blockDeviceMappings: InstanceBlockDeviceMappingList? = nil, subnetId: String? = nil, sriovNetSupport: String? = nil, platform: PlatformValues? = nil, spotInstanceRequestId: String? = nil, tags: TagList? = nil, launchTime: Date? = nil, state: InstanceState? = nil, publicIpAddress: String? = nil, monitoring: Monitoring? = nil, stateTransitionReason: String? = nil, stateReason: StateReason? = nil, securityGroups: GroupIdentifierList? = nil, hypervisor: HypervisorType? = nil, architecture: ArchitectureValues? = nil, imageId: String? = nil, enaSupport: Bool? = nil, networkInterfaces: InstanceNetworkInterfaceList? = nil, amiLaunchIndex: Int32? = nil, placement: Placement? = nil, virtualizationType: VirtualizationType? = nil) {
            self.clientToken = clientToken
            self.rootDeviceName = rootDeviceName
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.kernelId = kernelId
            self.privateDnsName = privateDnsName
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.productCodes = productCodes
            self.keyName = keyName
            self.instanceId = instanceId
            self.iamInstanceProfile = iamInstanceProfile
            self.publicDnsName = publicDnsName
            self.vpcId = vpcId
            self.rootDeviceType = rootDeviceType
            self.ramdiskId = ramdiskId
            self.instanceLifecycle = instanceLifecycle
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.sriovNetSupport = sriovNetSupport
            self.platform = platform
            self.spotInstanceRequestId = spotInstanceRequestId
            self.tags = tags
            self.launchTime = launchTime
            self.state = state
            self.publicIpAddress = publicIpAddress
            self.monitoring = monitoring
            self.stateTransitionReason = stateTransitionReason
            self.stateReason = stateReason
            self.securityGroups = securityGroups
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.enaSupport = enaSupport
            self.networkInterfaces = networkInterfaces
            self.amiLaunchIndex = amiLaunchIndex
            self.placement = placement
            self.virtualizationType = virtualizationType
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.rootDeviceName = dictionary["RootDeviceName"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            if let productCodes = dictionary["ProductCodes"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeList(dictionary: productCodes) } else { self.productCodes = nil }
            self.keyName = dictionary["KeyName"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfile(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
            self.publicDnsName = dictionary["DnsName"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let rootDeviceType = dictionary["RootDeviceType"] as? String { self.rootDeviceType = DeviceType(rawValue: rootDeviceType) } else { self.rootDeviceType = nil }
            self.ramdiskId = dictionary["RamdiskId"] as? String
            if let instanceLifecycle = dictionary["InstanceLifecycle"] as? String { self.instanceLifecycle = InstanceLifecycleType(rawValue: instanceLifecycle) } else { self.instanceLifecycle = nil }
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.InstanceBlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.subnetId = dictionary["SubnetId"] as? String
            self.sriovNetSupport = dictionary["SriovNetSupport"] as? String
            if let platform = dictionary["Platform"] as? String { self.platform = PlatformValues(rawValue: platform) } else { self.platform = nil }
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.launchTime = dictionary["LaunchTime"] as? Date
            if let state = dictionary["InstanceState"] as? [String: Any] { self.state = try Ec2.InstanceState(dictionary: state) } else { self.state = nil }
            self.publicIpAddress = dictionary["IpAddress"] as? String
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.Monitoring(dictionary: monitoring) } else { self.monitoring = nil }
            self.stateTransitionReason = dictionary["Reason"] as? String
            if let stateReason = dictionary["StateReason"] as? [String: Any] { self.stateReason = try Ec2.StateReason(dictionary: stateReason) } else { self.stateReason = nil }
            if let securityGroups = dictionary["GroupSet"] as? [String: Any] { self.securityGroups = try Ec2.GroupIdentifierList(dictionary: securityGroups) } else { self.securityGroups = nil }
            if let hypervisor = dictionary["Hypervisor"] as? String { self.hypervisor = HypervisorType(rawValue: hypervisor) } else { self.hypervisor = nil }
            if let architecture = dictionary["Architecture"] as? String { self.architecture = ArchitectureValues(rawValue: architecture) } else { self.architecture = nil }
            self.imageId = dictionary["ImageId"] as? String
            self.enaSupport = dictionary["EnaSupport"] as? Bool
            if let networkInterfaces = dictionary["NetworkInterfaceSet"] as? [String: Any] { self.networkInterfaces = try Ec2.InstanceNetworkInterfaceList(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
            self.amiLaunchIndex = dictionary["AmiLaunchIndex"] as? Int32
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.Placement(dictionary: placement) } else { self.placement = nil }
            if let virtualizationType = dictionary["VirtualizationType"] as? String { self.virtualizationType = VirtualizationType(rawValue: virtualizationType) } else { self.virtualizationType = nil }
        }
    }

    public enum ReportStatusType: String, CustomStringConvertible {
        case ok = "ok"
        case impaired = "impaired"
        public var description: String { return self.rawValue }
    }

    public struct AttachVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device name to expose to the instance (for example, /dev/sdh or xvdh).
        public let device: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the instance.
        public let instanceId: String
        /// The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        public let volumeId: String

        public init(device: String, dryRun: Bool? = nil, instanceId: String, volumeId: String) {
            self.device = device
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let device = dictionary["Device"] as? String else { throw InitializableError.missingRequiredParam("Device") }
            self.device = device
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public struct DisableVpcClassicLinkResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public enum TelemetryStatus: String, CustomStringConvertible {
        case up = "UP"
        case down = "DOWN"
        public var description: String { return self.rawValue }
    }

    public struct AcceptVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String?

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String? = nil) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct DescribeFlowLogsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.    deliver-log-status - The status of the logs delivery (SUCCESS | FAILED).    flow-log-id - The ID of the flow log.    log-group-name - The name of the log group.    resource-id - The ID of the VPC, subnet, or network interface.    traffic-type - The type of traffic (ACCEPT | REJECT | ALL)  
        public let filter: FilterList?
        /// One or more flow log IDs.
        public let flowLogIds: ValueStringList?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.
        public let maxResults: Int32?

        public init(filter: FilterList? = nil, flowLogIds: ValueStringList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.flowLogIds = flowLogIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [String: Any] { self.filter = try Ec2.FilterList(dictionary: filter) } else { self.filter = nil }
            if let flowLogIds = dictionary["FlowLogId"] as? [String: Any] { self.flowLogIds = try Ec2.ValueStringList(dictionary: flowLogIds) } else { self.flowLogIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct HostInstance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance type size (for example, m3.medium) of the running instance.
        public let instanceType: String?
        /// the IDs of instances that are running on the Dedicated Host.
        public let instanceId: String?

        public init(instanceType: String? = nil, instanceId: String? = nil) {
            self.instanceType = instanceType
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceType = dictionary["InstanceType"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public enum NatGatewayState: String, CustomStringConvertible {
        case pending = "pending"
        case failed = "failed"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSpotDatafeedSubscriptionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Spot instance data feed subscription.
        public let spotDatafeedSubscription: SpotDatafeedSubscription?

        public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
            self.spotDatafeedSubscription = spotDatafeedSubscription
        }

        public init(dictionary: [String: Any]) throws {
            if let spotDatafeedSubscription = dictionary["SpotDatafeedSubscription"] as? [String: Any] { self.spotDatafeedSubscription = try Ec2.SpotDatafeedSubscription(dictionary: spotDatafeedSubscription) } else { self.spotDatafeedSubscription = nil }
        }
    }

    public struct SpotFleetMonitoring: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Enables monitoring for the instance. Default: false 
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.enabled = dictionary["Enabled"] as? Bool
        }
    }

    public struct Storage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An Amazon S3 storage location.
        public let s3: S3Storage?

        public init(s3: S3Storage? = nil) {
            self.s3 = s3
        }

        public init(dictionary: [String: Any]) throws {
            if let s3 = dictionary["S3"] as? [String: Any] { self.s3 = try Ec2.S3Storage(dictionary: s3) } else { self.s3 = nil }
        }
    }

    public struct BlockDeviceMappingRequestList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let blockDeviceMapping: [BlockDeviceMapping]?

        public init(blockDeviceMapping: [BlockDeviceMapping]? = nil) {
            self.blockDeviceMapping = blockDeviceMapping
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMapping = dictionary["BlockDeviceMapping"] as? [[String: Any]] {
                self.blockDeviceMapping = try blockDeviceMapping.map({ try BlockDeviceMapping(dictionary: $0) })
            } else { 
                self.blockDeviceMapping = nil
            }
        }
    }

    public enum VirtualizationType: String, CustomStringConvertible {
        case hvm = "hvm"
        case paravirtual = "paravirtual"
        public var description: String { return self.rawValue }
    }

    public struct ImportInstanceLaunchSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-VPC] An available IP address from the IP address range of the subnet.
        public let privateIpAddress: String?
        /// [EC2-VPC] The ID of the subnet in which to launch the instance.
        public let subnetId: String?
        /// The user data to make available to the instance. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let userData: UserData?
        /// One or more security group IDs.
        public let groupIds: SecurityGroupIdStringList?
        /// The architecture of the instance.
        public let architecture: ArchitectureValues?
        /// Reserved.
        public let additionalInfo: String?
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        public let instanceInitiatedShutdownBehavior: ShutdownBehavior?
        /// The placement information for the instance.
        public let placement: Placement?
        /// Indicates whether monitoring is enabled.
        public let monitoring: Bool?
        /// The instance type. For more information about the instance types that you can import, see Instance Types in the VM Import/Export User Guide.
        public let instanceType: InstanceType?
        /// One or more security group names.
        public let groupNames: SecurityGroupStringList?

        public init(privateIpAddress: String? = nil, subnetId: String? = nil, userData: UserData? = nil, groupIds: SecurityGroupIdStringList? = nil, architecture: ArchitectureValues? = nil, additionalInfo: String? = nil, instanceInitiatedShutdownBehavior: ShutdownBehavior? = nil, placement: Placement? = nil, monitoring: Bool? = nil, instanceType: InstanceType? = nil, groupNames: SecurityGroupStringList? = nil) {
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
            self.userData = userData
            self.groupIds = groupIds
            self.architecture = architecture
            self.additionalInfo = additionalInfo
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.placement = placement
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.subnetId = dictionary["SubnetId"] as? String
            if let userData = dictionary["UserData"] as? [String: Any] { self.userData = try Ec2.UserData(dictionary: userData) } else { self.userData = nil }
            if let groupIds = dictionary["GroupId"] as? [String: Any] { self.groupIds = try Ec2.SecurityGroupIdStringList(dictionary: groupIds) } else { self.groupIds = nil }
            if let architecture = dictionary["Architecture"] as? String { self.architecture = ArchitectureValues(rawValue: architecture) } else { self.architecture = nil }
            self.additionalInfo = dictionary["AdditionalInfo"] as? String
            if let instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? String { self.instanceInitiatedShutdownBehavior = ShutdownBehavior(rawValue: instanceInitiatedShutdownBehavior) } else { self.instanceInitiatedShutdownBehavior = nil }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.Placement(dictionary: placement) } else { self.placement = nil }
            self.monitoring = dictionary["Monitoring"] as? Bool
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            if let groupNames = dictionary["GroupName"] as? [String: Any] { self.groupNames = try Ec2.SecurityGroupStringList(dictionary: groupNames) } else { self.groupNames = nil }
        }
    }

    public struct GroupIdentifierList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [GroupIdentifier]?

        public init(item: [GroupIdentifier]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try GroupIdentifier(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ReservedInstancesList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstances]?

        public init(item: [ReservedInstances]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstances(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct IpPermissionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [IpPermission]?

        public init(item: [IpPermission]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try IpPermission(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct Ipv6RangeList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Ipv6Range]?

        public init(item: [Ipv6Range]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Ipv6Range(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SpotInstanceStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description for the status code.
        public let message: String?
        /// The status code. For a list of status codes, see Spot Bid Status Codes in the Amazon Elastic Compute Cloud User Guide.
        public let code: String?
        /// The date and time of the most recent status update, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let updateTime: Date?

        public init(message: String? = nil, code: String? = nil, updateTime: Date? = nil) {
            self.message = message
            self.code = code
            self.updateTime = updateTime
        }

        public init(dictionary: [String: Any]) throws {
            self.message = dictionary["Message"] as? String
            self.code = dictionary["Code"] as? String
            self.updateTime = dictionary["UpdateTime"] as? Date
        }
    }

    public struct InstanceStatusEventList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceStatusEvent]?

        public init(item: [InstanceStatusEvent]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceStatusEvent(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SecurityGroupStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let securityGroup: [String]?

        public init(securityGroup: [String]? = nil) {
            self.securityGroup = securityGroup
        }

        public init(dictionary: [String: Any]) throws {
            self.securityGroup = dictionary["SecurityGroup"] as? [String]
        }
    }

    public struct InstanceIpv6Address: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 address.
        public let ipv6Address: String?

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6Address = dictionary["Ipv6Address"] as? String
        }
    }

    public struct ImportSnapshotTaskList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ImportSnapshotTask]?

        public init(item: [ImportSnapshotTask]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ImportSnapshotTask(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum ConversionTaskState: String, CustomStringConvertible {
        case active = "active"
        case cancelling = "cancelling"
        case cancelled = "cancelled"
        case completed = "completed"
        public var description: String { return self.rawValue }
    }

    public struct StaleIpPermission: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.
        public let prefixListIds: PrefixListIdSet?
        /// One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.
        public let userIdGroupPairs: UserIdGroupPairSet?
        /// One or more IP ranges. Not applicable for stale security group rules.
        public let ipRanges: IpRanges?
        /// The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of -1 indicates all ICMP types. 
        public let fromPort: Int32?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of -1 indicates all ICMP types. 
        public let toPort: Int32?
        /// The IP protocol name (for tcp, udp, and icmp) or number (see Protocol Numbers).
        public let ipProtocol: String?

        public init(prefixListIds: PrefixListIdSet? = nil, userIdGroupPairs: UserIdGroupPairSet? = nil, ipRanges: IpRanges? = nil, fromPort: Int32? = nil, toPort: Int32? = nil, ipProtocol: String? = nil) {
            self.prefixListIds = prefixListIds
            self.userIdGroupPairs = userIdGroupPairs
            self.ipRanges = ipRanges
            self.fromPort = fromPort
            self.toPort = toPort
            self.ipProtocol = ipProtocol
        }

        public init(dictionary: [String: Any]) throws {
            if let prefixListIds = dictionary["PrefixListIds"] as? [String: Any] { self.prefixListIds = try Ec2.PrefixListIdSet(dictionary: prefixListIds) } else { self.prefixListIds = nil }
            if let userIdGroupPairs = dictionary["Groups"] as? [String: Any] { self.userIdGroupPairs = try Ec2.UserIdGroupPairSet(dictionary: userIdGroupPairs) } else { self.userIdGroupPairs = nil }
            if let ipRanges = dictionary["IpRanges"] as? [String: Any] { self.ipRanges = try Ec2.IpRanges(dictionary: ipRanges) } else { self.ipRanges = nil }
            self.fromPort = dictionary["FromPort"] as? Int32
            self.toPort = dictionary["ToPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
        }
    }

    public struct IamInstanceProfile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String?
        /// The ID of the instance profile.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.arn = dictionary["Arn"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public struct DescribeSecurityGroupsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more security groups.
        public let securityGroups: SecurityGroupList?

        public init(securityGroups: SecurityGroupList? = nil) {
            self.securityGroups = securityGroups
        }

        public init(dictionary: [String: Any]) throws {
            if let securityGroups = dictionary["SecurityGroupInfo"] as? [String: Any] { self.securityGroups = try Ec2.SecurityGroupList(dictionary: securityGroups) } else { self.securityGroups = nil }
        }
    }

    public struct Purchase: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upfront price of the reservation.
        public let upfrontPrice: String?
        /// The IDs of the Dedicated Hosts associated with the reservation.
        public let hostIdSet: ResponseHostIdSet?
        /// The payment option for the reservation.
        public let paymentOption: PaymentOption?
        /// The hourly price of the reservation per hour.
        public let hourlyPrice: String?
        /// The currency in which the UpfrontPrice and HourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The ID of the reservation.
        public let hostReservationId: String?
        /// The duration of the reservation's term in seconds.
        public let duration: Int32?
        /// The instance family on the Dedicated Host that the reservation can be associated with.
        public let instanceFamily: String?

        public init(upfrontPrice: String? = nil, hostIdSet: ResponseHostIdSet? = nil, paymentOption: PaymentOption? = nil, hourlyPrice: String? = nil, currencyCode: CurrencyCodeValues? = nil, hostReservationId: String? = nil, duration: Int32? = nil, instanceFamily: String? = nil) {
            self.upfrontPrice = upfrontPrice
            self.hostIdSet = hostIdSet
            self.paymentOption = paymentOption
            self.hourlyPrice = hourlyPrice
            self.currencyCode = currencyCode
            self.hostReservationId = hostReservationId
            self.duration = duration
            self.instanceFamily = instanceFamily
        }

        public init(dictionary: [String: Any]) throws {
            self.upfrontPrice = dictionary["UpfrontPrice"] as? String
            if let hostIdSet = dictionary["HostIdSet"] as? [String: Any] { self.hostIdSet = try Ec2.ResponseHostIdSet(dictionary: hostIdSet) } else { self.hostIdSet = nil }
            if let paymentOption = dictionary["PaymentOption"] as? String { self.paymentOption = PaymentOption(rawValue: paymentOption) } else { self.paymentOption = nil }
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.hostReservationId = dictionary["HostReservationId"] as? String
            self.duration = dictionary["Duration"] as? Int32
            self.instanceFamily = dictionary["InstanceFamily"] as? String
        }
    }

    public struct RequestSpotFleetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The configuration for the Spot fleet request.
        public let spotFleetRequestConfig: SpotFleetRequestConfigData
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(spotFleetRequestConfig: SpotFleetRequestConfigData, dryRun: Bool? = nil) {
            self.spotFleetRequestConfig = spotFleetRequestConfig
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestConfig = dictionary["SpotFleetRequestConfig"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotFleetRequestConfig") }
            self.spotFleetRequestConfig = try Ec2.SpotFleetRequestConfigData(dictionary: spotFleetRequestConfig)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public enum VpcState: String, CustomStringConvertible {
        case pending = "pending"
        case available = "available"
        public var description: String { return self.rawValue }
    }

    public struct ReservedInstancesOffering: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The recurring charge tag assigned to the resource.
        public let recurringCharges: RecurringChargesList?
        /// The usage price of the Reserved Instance, per hour.
        public let usagePrice: Float?
        /// The tenancy of the instance.
        public let instanceTenancy: Tenancy?
        /// The pricing details of the Reserved Instance offering.
        public let pricingDetails: PricingDetailsList?
        /// The instance type on which the Reserved Instance can be used.
        public let instanceType: InstanceType?
        /// The Reserved Instance offering type.
        public let offeringType: OfferingTypeValues?
        /// The Reserved Instance product platform description.
        public let productDescription: RIProductDescription?
        /// Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is true.
        public let marketplace: Bool?
        /// The Availability Zone in which the Reserved Instance can be used.
        public let availabilityZone: String?
        /// If convertible it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If standard, it is not possible to perform an exchange.
        public let offeringClass: OfferingClassType?
        /// The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The ID of the Reserved Instance offering. This is the offering ID used in GetReservedInstancesExchangeQuote to confirm that an exchange can be made.
        public let reservedInstancesOfferingId: String?
        /// The duration of the Reserved Instance, in seconds.
        public let duration: Int64?
        /// Whether the Reserved Instance is applied to instances in a region or an Availability Zone.
        public let scope: Scope?
        /// The purchase price of the Reserved Instance.
        public let fixedPrice: Float?

        public init(recurringCharges: RecurringChargesList? = nil, usagePrice: Float? = nil, instanceTenancy: Tenancy? = nil, pricingDetails: PricingDetailsList? = nil, instanceType: InstanceType? = nil, offeringType: OfferingTypeValues? = nil, productDescription: RIProductDescription? = nil, marketplace: Bool? = nil, availabilityZone: String? = nil, offeringClass: OfferingClassType? = nil, currencyCode: CurrencyCodeValues? = nil, reservedInstancesOfferingId: String? = nil, duration: Int64? = nil, scope: Scope? = nil, fixedPrice: Float? = nil) {
            self.recurringCharges = recurringCharges
            self.usagePrice = usagePrice
            self.instanceTenancy = instanceTenancy
            self.pricingDetails = pricingDetails
            self.instanceType = instanceType
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.marketplace = marketplace
            self.availabilityZone = availabilityZone
            self.offeringClass = offeringClass
            self.currencyCode = currencyCode
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.duration = duration
            self.scope = scope
            self.fixedPrice = fixedPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let recurringCharges = dictionary["RecurringCharges"] as? [String: Any] { self.recurringCharges = try Ec2.RecurringChargesList(dictionary: recurringCharges) } else { self.recurringCharges = nil }
            self.usagePrice = dictionary["UsagePrice"] as? Float
            if let instanceTenancy = dictionary["InstanceTenancy"] as? String { self.instanceTenancy = Tenancy(rawValue: instanceTenancy) } else { self.instanceTenancy = nil }
            if let pricingDetails = dictionary["PricingDetailsSet"] as? [String: Any] { self.pricingDetails = try Ec2.PricingDetailsList(dictionary: pricingDetails) } else { self.pricingDetails = nil }
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            if let offeringType = dictionary["OfferingType"] as? String { self.offeringType = OfferingTypeValues(rawValue: offeringType) } else { self.offeringType = nil }
            if let productDescription = dictionary["ProductDescription"] as? String { self.productDescription = RIProductDescription(rawValue: productDescription) } else { self.productDescription = nil }
            self.marketplace = dictionary["Marketplace"] as? Bool
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let offeringClass = dictionary["OfferingClass"] as? String { self.offeringClass = OfferingClassType(rawValue: offeringClass) } else { self.offeringClass = nil }
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.reservedInstancesOfferingId = dictionary["ReservedInstancesOfferingId"] as? String
            self.duration = dictionary["Duration"] as? Int64
            if let scope = dictionary["Scope"] as? String { self.scope = Scope(rawValue: scope) } else { self.scope = nil }
            self.fixedPrice = dictionary["FixedPrice"] as? Float
        }
    }

    public struct InstanceCount: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The states of the listed Reserved Instances.
        public let state: ListingState?
        /// The number of listed Reserved Instances in the state specified by the state.
        public let instanceCount: Int32?

        public init(state: ListingState? = nil, instanceCount: Int32? = nil) {
            self.state = state
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            if let state = dictionary["State"] as? String { self.state = ListingState(rawValue: state) } else { self.state = nil }
            self.instanceCount = dictionary["InstanceCount"] as? Int32
        }
    }

    public struct DescribeNetworkInterfacesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more network interface IDs. Default: Describes all your network interfaces.
        public let networkInterfaceIds: NetworkInterfaceIdList?
        /// One or more filters.    addresses.private-ip-address - The private IPv4 addresses associated with the network interface.    addresses.primary - Whether the private IPv4 address is the primary IP address associated with the network interface.     addresses.association.public-ip - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).    addresses.association.owner-id - The owner ID of the addresses associated with the network interface.    association.association-id - The association ID returned when the network interface was associated with an IPv4 address.    association.allocation-id - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.    association.ip-owner-id - The owner of the Elastic IP address (IPv4) associated with the network interface.    association.public-ip - The address of the Elastic IP address (IPv4) bound to the network interface.    association.public-dns-name - The public DNS name for the network interface (IPv4).    attachment.attachment-id - The ID of the interface attachment.    attachment.attach.time - The time that the network interface was attached to an instance.    attachment.delete-on-termination - Indicates whether the attachment is deleted when an instance is terminated.    attachment.device-index - The device index to which the network interface is attached.    attachment.instance-id - The ID of the instance to which the network interface is attached.    attachment.instance-owner-id - The owner ID of the instance to which the network interface is attached.    attachment.nat-gateway-id - The ID of the NAT gateway to which the network interface is attached.    attachment.status - The status of the attachment (attaching | attached | detaching | detached).    availability-zone - The Availability Zone of the network interface.    description - The description of the network interface.    group-id - The ID of a security group associated with the network interface.    group-name - The name of a security group associated with the network interface.    ipv6-addresses.ipv6-address - An IPv6 address associated with the network interface.    mac-address - The MAC address of the network interface.    network-interface-id - The ID of the network interface.    owner-id - The AWS account ID of the network interface owner.    private-ip-address - The private IPv4 address or addresses of the network interface.    private-dns-name - The private DNS name of the network interface (IPv4).    requester-id - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).    requester-managed - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).    source-desk-check - Indicates whether the network interface performs source/destination checking. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the network interface to perform network address translation (NAT) in your VPC.     status - The status of the network interface. If the network interface is not attached to an instance, the status is available; if a network interface is attached to an instance the status is in-use.    subnet-id - The ID of the subnet for the network interface.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the network interface.  
        public let filters: FilterList?

        public init(dryRun: Bool? = nil, networkInterfaceIds: NetworkInterfaceIdList? = nil, filters: FilterList? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceIds = networkInterfaceIds
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let networkInterfaceIds = dictionary["NetworkInterfaceId"] as? [String: Any] { self.networkInterfaceIds = try Ec2.NetworkInterfaceIdList(dictionary: networkInterfaceIds) } else { self.networkInterfaceIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
        }
    }

    public enum GatewayType: String, CustomStringConvertible {
        case ipsec_1 = "ipsec.1"
        public var description: String { return self.rawValue }
    }

    public struct CreateNetworkAclResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the network ACL.
        public let networkAcl: NetworkAcl?

        public init(networkAcl: NetworkAcl? = nil) {
            self.networkAcl = networkAcl
        }

        public init(dictionary: [String: Any]) throws {
            if let networkAcl = dictionary["NetworkAcl"] as? [String: Any] { self.networkAcl = try Ec2.NetworkAcl(dictionary: networkAcl) } else { self.networkAcl = nil }
        }
    }

    public struct InstanceBlockDeviceMapping: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        public let ebs: EbsInstanceBlockDevice?
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public let deviceName: String?

        public init(ebs: EbsInstanceBlockDevice? = nil, deviceName: String? = nil) {
            self.ebs = ebs
            self.deviceName = deviceName
        }

        public init(dictionary: [String: Any]) throws {
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.EbsInstanceBlockDevice(dictionary: ebs) } else { self.ebs = nil }
            self.deviceName = dictionary["DeviceName"] as? String
        }
    }

    public struct VolumeStatusAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The code identifying the operation, for example, enable-volume-io.
        public let code: String?
        /// The event type associated with this operation.
        public let eventType: String?
        /// The ID of the event associated with this operation.
        public let eventId: String?
        /// A description of the operation.
        public let description: String?

        public init(code: String? = nil, eventType: String? = nil, eventId: String? = nil, description: String? = nil) {
            self.code = code
            self.eventType = eventType
            self.eventId = eventId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.eventType = dictionary["EventType"] as? String
            self.eventId = dictionary["EventId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct InstanceMonitoringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceMonitoring]?

        public init(item: [InstanceMonitoring]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceMonitoring(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct NetworkInterfaceList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NetworkInterface]?

        public init(item: [NetworkInterface]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NetworkInterface(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CreateReservedInstancesListingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.
        public let priceSchedules: PriceScheduleSpecificationList
        /// The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.
        public let instanceCount: Int32
        /// The ID of the active Standard Reserved Instance.
        public let reservedInstancesId: String
        /// Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see Ensuring Idempotency.
        public let clientToken: String

        public init(priceSchedules: PriceScheduleSpecificationList, instanceCount: Int32, reservedInstancesId: String, clientToken: String) {
            self.priceSchedules = priceSchedules
            self.instanceCount = instanceCount
            self.reservedInstancesId = reservedInstancesId
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let priceSchedules = dictionary["PriceSchedules"] as? [String: Any] else { throw InitializableError.missingRequiredParam("PriceSchedules") }
            self.priceSchedules = try Ec2.PriceScheduleSpecificationList(dictionary: priceSchedules)
            guard let instanceCount = dictionary["InstanceCount"] as? Int32 else { throw InitializableError.missingRequiredParam("InstanceCount") }
            self.instanceCount = instanceCount
            guard let reservedInstancesId = dictionary["ReservedInstancesId"] as? String else { throw InitializableError.missingRequiredParam("ReservedInstancesId") }
            self.reservedInstancesId = reservedInstancesId
            guard let clientToken = dictionary["ClientToken"] as? String else { throw InitializableError.missingRequiredParam("ClientToken") }
            self.clientToken = clientToken
        }
    }

    public struct GroupIds: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct DescribeRouteTablesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more route tables.
        public let routeTables: RouteTableList?

        public init(routeTables: RouteTableList? = nil) {
            self.routeTables = routeTables
        }

        public init(dictionary: [String: Any]) throws {
            if let routeTables = dictionary["RouteTableSet"] as? [String: Any] { self.routeTables = try Ec2.RouteTableList(dictionary: routeTables) } else { self.routeTables = nil }
        }
    }

    public struct AssociateIamInstanceProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the IAM instance profile association.
        public let iamInstanceProfileAssociation: IamInstanceProfileAssociation?

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

        public init(dictionary: [String: Any]) throws {
            if let iamInstanceProfileAssociation = dictionary["IamInstanceProfileAssociation"] as? [String: Any] { self.iamInstanceProfileAssociation = try Ec2.IamInstanceProfileAssociation(dictionary: iamInstanceProfileAssociation) } else { self.iamInstanceProfileAssociation = nil }
        }
    }

    public enum ExcessCapacityTerminationPolicy: String, CustomStringConvertible {
        case notermination = "noTermination"
        case `default` = "default"
        public var description: String { return self.rawValue }
    }

    public struct DhcpOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the set of DHCP options.
        public let dhcpOptionsId: String?
        /// One or more DHCP options in the set.
        public let dhcpConfigurations: DhcpConfigurationList?
        /// Any tags assigned to the DHCP options set.
        public let tags: TagList?

        public init(dhcpOptionsId: String? = nil, dhcpConfigurations: DhcpConfigurationList? = nil, tags: TagList? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
            self.dhcpConfigurations = dhcpConfigurations
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.dhcpOptionsId = dictionary["DhcpOptionsId"] as? String
            if let dhcpConfigurations = dictionary["DhcpConfigurationSet"] as? [String: Any] { self.dhcpConfigurations = try Ec2.DhcpConfigurationList(dictionary: dhcpConfigurations) } else { self.dhcpConfigurations = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
        }
    }

    public struct DescribeClassicLinkInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more linked EC2-Classic instances.
        public let instances: ClassicLinkInstanceList?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(instances: ClassicLinkInstanceList? = nil, nextToken: String? = nil) {
            self.instances = instances
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let instances = dictionary["InstancesSet"] as? [String: Any] { self.instances = try Ec2.ClassicLinkInstanceList(dictionary: instances) } else { self.instances = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct UserIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let userId: [String]?

        public init(userId: [String]? = nil) {
            self.userId = userId
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? [String]
        }
    }

    public enum InstanceAttributeName: String, CustomStringConvertible {
        case instancetype = "instanceType"
        case kernel = "kernel"
        case ramdisk = "ramdisk"
        case userdata = "userData"
        case disableapitermination = "disableApiTermination"
        case instanceinitiatedshutdownbehavior = "instanceInitiatedShutdownBehavior"
        case rootdevicename = "rootDeviceName"
        case blockdevicemapping = "blockDeviceMapping"
        case productcodes = "productCodes"
        case sourcedestcheck = "sourceDestCheck"
        case groupset = "groupSet"
        case ebsoptimized = "ebsOptimized"
        case sriovnetsupport = "sriovNetSupport"
        case enasupport = "enaSupport"
        public var description: String { return self.rawValue }
    }

    public struct CopyImageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when encrypting the snapshots of an image during a copy operation. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. The specified CMK must exist in the region that the snapshot is being copied to. If a KmsKeyId is specified, the Encrypted flag must also be set.
        public let kmsKeyId: String?
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        public let clientToken: String?
        /// The name of the region that contains the AMI to copy.
        public let sourceRegion: String
        /// The name of the new AMI in the destination region.
        public let name: String
        /// Specifies whether the destination snapshots of the copied image should be encrypted. The default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        public let encrypted: Bool?
        /// The ID of the AMI to copy.
        public let sourceImageId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A description for the new AMI in the destination region.
        public let description: String?

        public init(kmsKeyId: String? = nil, clientToken: String? = nil, sourceRegion: String, name: String, encrypted: Bool? = nil, sourceImageId: String, dryRun: Bool? = nil, description: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.clientToken = clientToken
            self.sourceRegion = sourceRegion
            self.name = name
            self.encrypted = encrypted
            self.sourceImageId = sourceImageId
            self.dryRun = dryRun
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            guard let sourceRegion = dictionary["SourceRegion"] as? String else { throw InitializableError.missingRequiredParam("SourceRegion") }
            self.sourceRegion = sourceRegion
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.encrypted = dictionary["Encrypted"] as? Bool
            guard let sourceImageId = dictionary["SourceImageId"] as? String else { throw InitializableError.missingRequiredParam("SourceImageId") }
            self.sourceImageId = sourceImageId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeNetworkAclsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more network ACL IDs. Default: Describes all your network ACLs.
        public let networkAclIds: ValueStringList?
        /// One or more filters.    association.association-id - The ID of an association ID for the ACL.    association.network-acl-id - The ID of the network ACL involved in the association.    association.subnet-id - The ID of the subnet involved in the association.    default - Indicates whether the ACL is the default network ACL for the VPC.    entry.cidr - The IPv4 CIDR range specified in the entry.    entry.egress - Indicates whether the entry applies to egress traffic.    entry.icmp.code - The ICMP code specified in the entry, if any.    entry.icmp.type - The ICMP type specified in the entry, if any.    entry.ipv6-cidr - The IPv6 CIDR range specified in the entry.    entry.port-range.from - The start of the port range specified in the entry.     entry.port-range.to - The end of the port range specified in the entry.     entry.protocol - The protocol specified in the entry (tcp | udp | icmp or a protocol number).    entry.rule-action - Allows or denies the matching traffic (allow | deny).    entry.rule-number - The number of an entry (in other words, rule) in the ACL's set of entries.    network-acl-id - The ID of the network ACL.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the network ACL.  
        public let filters: FilterList?

        public init(dryRun: Bool? = nil, networkAclIds: ValueStringList? = nil, filters: FilterList? = nil) {
            self.dryRun = dryRun
            self.networkAclIds = networkAclIds
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let networkAclIds = dictionary["NetworkAclId"] as? [String: Any] { self.networkAclIds = try Ec2.ValueStringList(dictionary: networkAclIds) } else { self.networkAclIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
        }
    }

    public enum OperationType: String, CustomStringConvertible {
        case add = "add"
        case remove = "remove"
        public var description: String { return self.rawValue }
    }

    public enum ListingStatus: String, CustomStringConvertible {
        case active = "active"
        case pending = "pending"
        case cancelled = "cancelled"
        case closed = "closed"
        public var description: String { return self.rawValue }
    }

    public struct VpcAttachmentList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpcAttachment]?

        public init(item: [VpcAttachment]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpcAttachment(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct TerminateInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more terminated instances.
        public let terminatingInstances: InstanceStateChangeList?

        public init(terminatingInstances: InstanceStateChangeList? = nil) {
            self.terminatingInstances = terminatingInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let terminatingInstances = dictionary["InstancesSet"] as? [String: Any] { self.terminatingInstances = try Ec2.InstanceStateChangeList(dictionary: terminatingInstances) } else { self.terminatingInstances = nil }
        }
    }

    public struct CreateVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes. Default: standard 
        public let volumeType: VolumeType?
        /// Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        public let encrypted: Bool?
        /// The size of the volume, in GiBs. Constraints: 1-16384 for gp2, 4-16384 for io1, 500-16384 for st1, 500-16384 for sc1, and 1-1024 for standard. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        public let size: Int32?
        /// The snapshot from which to create the volume.
        public let snapshotId: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Only valid for Provisioned IOPS SSD volumes. The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB. Constraint: Range is 100 to 20000 for Provisioned IOPS SSD volumes 
        public let iops: Int32?
        /// The Availability Zone in which to create the volume. Use DescribeAvailabilityZones to list the Availability Zones that are currently available to you.
        public let availabilityZone: String
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. If a KmsKeyId is specified, the Encrypted flag must also be set.
        public let kmsKeyId: String?

        public init(volumeType: VolumeType? = nil, encrypted: Bool? = nil, size: Int32? = nil, snapshotId: String? = nil, dryRun: Bool? = nil, iops: Int32? = nil, availabilityZone: String, kmsKeyId: String? = nil) {
            self.volumeType = volumeType
            self.encrypted = encrypted
            self.size = size
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeType = dictionary["VolumeType"] as? String { self.volumeType = VolumeType(rawValue: volumeType) } else { self.volumeType = nil }
            self.encrypted = dictionary["Encrypted"] as? Bool
            self.size = dictionary["Size"] as? Int32
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.iops = dictionary["Iops"] as? Int32
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public enum RouteState: String, CustomStringConvertible {
        case active = "active"
        case blackhole = "blackhole"
        public var description: String { return self.rawValue }
    }

    public struct DescribeImportSnapshotTasksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more filters.
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A list of import snapshot task IDs.
        public let importTaskIds: ImportTaskIdList?
        /// A token that indicates the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, importTaskIds: ImportTaskIdList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.importTaskIds = importTaskIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let importTaskIds = dictionary["ImportTaskId"] as? [String: Any] { self.importTaskIds = try Ec2.ImportTaskIdList(dictionary: importTaskIds) } else { self.importTaskIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DisassociateSubnetCidrBlockResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String?
        /// Information about the IPv6 CIDR block association.
        public let ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation?

        public init(subnetId: String? = nil, ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil) {
            self.subnetId = subnetId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.SubnetIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) } else { self.ipv6CidrBlockAssociation = nil }
        }
    }

    public struct ReservedInstanceReservationValueSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstanceReservationValue]?

        public init(item: [ReservedInstanceReservationValue]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstanceReservationValue(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AllocateAddressResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.
        public let allocationId: String?
        /// Indicates whether this Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).
        public let domain: DomainType?
        /// The Elastic IP address.
        public let publicIp: String?

        public init(allocationId: String? = nil, domain: DomainType? = nil, publicIp: String? = nil) {
            self.allocationId = allocationId
            self.domain = domain
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.allocationId = dictionary["AllocationId"] as? String
            if let domain = dictionary["Domain"] as? String { self.domain = DomainType(rawValue: domain) } else { self.domain = nil }
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct VolumeModification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Modification start time 
        public let startTime: Date?
        /// Original IOPS rate of the volume being modified.
        public let originalIops: Int32?
        /// Current state of modification. Modification state is null for unmodified volumes. 
        public let modificationState: VolumeModificationState?
        /// Original size of the volume being modified.
        public let originalSize: Int32?
        /// Modification progress from 0 to 100%.
        public let progress: Int64?
        /// ID of the volume being modified.
        public let volumeId: String?
        /// Modification completion or failure time.
        public let endTime: Date?
        /// Target EBS volume type of the volume being modified.
        public let targetVolumeType: VolumeType?
        /// Target IOPS rate of the volume being modified.
        public let targetIops: Int32?
        /// Original EBS volume type of the volume being modified.
        public let originalVolumeType: VolumeType?
        /// Target size of the volume being modified.
        public let targetSize: Int32?
        /// Generic status message on modification progress or failure.
        public let statusMessage: String?

        public init(startTime: Date? = nil, originalIops: Int32? = nil, modificationState: VolumeModificationState? = nil, originalSize: Int32? = nil, progress: Int64? = nil, volumeId: String? = nil, endTime: Date? = nil, targetVolumeType: VolumeType? = nil, targetIops: Int32? = nil, originalVolumeType: VolumeType? = nil, targetSize: Int32? = nil, statusMessage: String? = nil) {
            self.startTime = startTime
            self.originalIops = originalIops
            self.modificationState = modificationState
            self.originalSize = originalSize
            self.progress = progress
            self.volumeId = volumeId
            self.endTime = endTime
            self.targetVolumeType = targetVolumeType
            self.targetIops = targetIops
            self.originalVolumeType = originalVolumeType
            self.targetSize = targetSize
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            self.originalIops = dictionary["OriginalIops"] as? Int32
            if let modificationState = dictionary["ModificationState"] as? String { self.modificationState = VolumeModificationState(rawValue: modificationState) } else { self.modificationState = nil }
            self.originalSize = dictionary["OriginalSize"] as? Int32
            self.progress = dictionary["Progress"] as? Int64
            self.volumeId = dictionary["VolumeId"] as? String
            self.endTime = dictionary["EndTime"] as? Date
            if let targetVolumeType = dictionary["TargetVolumeType"] as? String { self.targetVolumeType = VolumeType(rawValue: targetVolumeType) } else { self.targetVolumeType = nil }
            self.targetIops = dictionary["TargetIops"] as? Int32
            if let originalVolumeType = dictionary["OriginalVolumeType"] as? String { self.originalVolumeType = VolumeType(rawValue: originalVolumeType) } else { self.originalVolumeType = nil }
            self.targetSize = dictionary["TargetSize"] as? Int32
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct UserBucket: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the S3 bucket where the disk image is located.
        public let s3Bucket: String?
        /// The file name of the disk image.
        public let s3Key: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Bucket = dictionary["S3Bucket"] as? String
            self.s3Key = dictionary["S3Key"] as? String
        }
    }

    public struct AssociateDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// The ID of the DHCP options set, or default to associate no DHCP options with the VPC.
        public let dhcpOptionsId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, dhcpOptionsId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let dhcpOptionsId = dictionary["DhcpOptionsId"] as? String else { throw InitializableError.missingRequiredParam("DhcpOptionsId") }
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateSnapshotRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the EBS volume.
        public let volumeId: String
        /// A description for the snapshot.
        public let description: String?

        public init(dryRun: Bool? = nil, volumeId: String, description: String? = nil) {
            self.dryRun = dryRun
            self.volumeId = volumeId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct HostReservationIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct DescribeIdFormatRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of resource: instance | reservation | snapshot | volume 
        public let resource: String?

        public init(resource: String? = nil) {
            self.resource = resource
        }

        public init(dictionary: [String: Any]) throws {
            self.resource = dictionary["Resource"] as? String
        }
    }

    public struct HostInstanceList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [HostInstance]?

        public init(item: [HostInstance]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try HostInstance(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeHostReservationsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more host reservation IDs.
        public let hostReservationIdSet: HostReservationIdSet?
        /// One or more filters.    instance-family - The instance family (e.g., m4).    payment-option - The payment option (NoUpfront | PartialUpfront | AllUpfront).    state - The state of the reservation (payment-pending | payment-failed | active | retired).  
        public let filter: FilterList?
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error.
        public let maxResults: Int32?

        public init(hostReservationIdSet: HostReservationIdSet? = nil, filter: FilterList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.hostReservationIdSet = hostReservationIdSet
            self.filter = filter
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let hostReservationIdSet = dictionary["HostReservationIdSet"] as? [String: Any] { self.hostReservationIdSet = try Ec2.HostReservationIdSet(dictionary: hostReservationIdSet) } else { self.hostReservationIdSet = nil }
            if let filter = dictionary["Filter"] as? [String: Any] { self.filter = try Ec2.FilterList(dictionary: filter) } else { self.filter = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct GetHostReservationPurchasePreviewRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID/s of the Dedicated Host/s that the reservation will be associated with.
        public let hostIdSet: RequestHostIdSet
        /// The offering ID of the reservation.
        public let offeringId: String

        public init(hostIdSet: RequestHostIdSet, offeringId: String) {
            self.hostIdSet = hostIdSet
            self.offeringId = offeringId
        }

        public init(dictionary: [String: Any]) throws {
            guard let hostIdSet = dictionary["HostIdSet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("HostIdSet") }
            self.hostIdSet = try Ec2.RequestHostIdSet(dictionary: hostIdSet)
            guard let offeringId = dictionary["OfferingId"] as? String else { throw InitializableError.missingRequiredParam("OfferingId") }
            self.offeringId = offeringId
        }
    }

    public struct ActiveInstance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance type.
        public let instanceType: String?
        /// The health status of the instance. If the status of both the instance status check and the system status check is impaired, the health status of the instance is unhealthy. Otherwise, the health status is healthy.
        public let instanceHealth: InstanceHealthStatus?
        /// The ID of the instance.
        public let instanceId: String?
        /// The ID of the Spot instance request.
        public let spotInstanceRequestId: String?

        public init(instanceType: String? = nil, instanceHealth: InstanceHealthStatus? = nil, instanceId: String? = nil, spotInstanceRequestId: String? = nil) {
            self.instanceType = instanceType
            self.instanceHealth = instanceHealth
            self.instanceId = instanceId
            self.spotInstanceRequestId = spotInstanceRequestId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceType = dictionary["InstanceType"] as? String
            if let instanceHealth = dictionary["InstanceHealth"] as? String { self.instanceHealth = InstanceHealthStatus(rawValue: instanceHealth) } else { self.instanceHealth = nil }
            self.instanceId = dictionary["InstanceId"] as? String
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
        }
    }

    public struct DescribeMovingAddressesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The status for each Elastic IP address.
        public let movingAddressStatuses: MovingAddressStatusSet?

        public init(nextToken: String? = nil, movingAddressStatuses: MovingAddressStatusSet? = nil) {
            self.nextToken = nextToken
            self.movingAddressStatuses = movingAddressStatuses
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let movingAddressStatuses = dictionary["MovingAddressStatusSet"] as? [String: Any] { self.movingAddressStatuses = try Ec2.MovingAddressStatusSet(dictionary: movingAddressStatuses) } else { self.movingAddressStatuses = nil }
        }
    }

    public struct ExportToS3Task: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The encryption key for your S3 bucket.
        public let s3Key: String?
        /// The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.
        public let containerFormat: ContainerFormat?
        /// The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account vm-import-export@amazon.com.
        public let s3Bucket: String?
        /// The format for the exported image.
        public let diskImageFormat: DiskImageFormat?

        public init(s3Key: String? = nil, containerFormat: ContainerFormat? = nil, s3Bucket: String? = nil, diskImageFormat: DiskImageFormat? = nil) {
            self.s3Key = s3Key
            self.containerFormat = containerFormat
            self.s3Bucket = s3Bucket
            self.diskImageFormat = diskImageFormat
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Key = dictionary["S3Key"] as? String
            if let containerFormat = dictionary["ContainerFormat"] as? String { self.containerFormat = ContainerFormat(rawValue: containerFormat) } else { self.containerFormat = nil }
            self.s3Bucket = dictionary["S3Bucket"] as? String
            if let diskImageFormat = dictionary["DiskImageFormat"] as? String { self.diskImageFormat = DiskImageFormat(rawValue: diskImageFormat) } else { self.diskImageFormat = nil }
        }
    }

    public enum VpcAttributeName: String, CustomStringConvertible {
        case enablednssupport = "enableDnsSupport"
        case enablednshostnames = "enableDnsHostnames"
        public var description: String { return self.rawValue }
    }

    public struct ValueStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct VpcAttachment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// The current state of the attachment.
        public let state: AttachmentStatus?

        public init(vpcId: String? = nil, state: AttachmentStatus? = nil) {
            self.vpcId = vpcId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let state = dictionary["State"] as? String { self.state = AttachmentStatus(rawValue: state) } else { self.state = nil }
        }
    }

    public struct Ipv6Range: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix.
        public let cidrIpv6: String?

        public init(cidrIpv6: String? = nil) {
            self.cidrIpv6 = cidrIpv6
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrIpv6 = dictionary["CidrIpv6"] as? String
        }
    }

    public struct DisableVpcClassicLinkDnsSupportResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct CreateTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more tags. The value parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. 
        public let tags: TagList
        /// The IDs of one or more resources to tag. For example, ami-1a2b3c4d.
        public let resources: [String]

        public init(dryRun: Bool? = nil, tags: TagList, resources: [String]) {
            self.dryRun = dryRun
            self.tags = tags
            self.resources = resources
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let tags = dictionary["Tag"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Tag") }
            self.tags = try Ec2.TagList(dictionary: tags)
            guard let resources = dictionary["ResourceId"] as? [String] else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resources = resources
        }
    }

    public struct PrefixListSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PrefixList]?

        public init(item: [PrefixList]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PrefixList(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeSnapshotsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more AWS accounts IDs that can create volumes from the snapshot.
        public let restorableByUserIds: [String]?
        /// One or more snapshot IDs. Default: Describes snapshots for which you have launch permissions.
        public let snapshotIds: SnapshotIdStringList?
        /// Returns the snapshots owned by the specified owner. Multiple owners can be specified.
        public let ownerIds: OwnerStringList?
        /// One or more filters.    description - A description of the snapshot.    owner-alias - Value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM consolew.    owner-id - The ID of the AWS account that owns the snapshot.    progress - The progress of the snapshot, as a percentage (for example, 80%).    snapshot-id - The snapshot ID.    start-time - The time stamp when the snapshot was initiated.    status - The status of the snapshot (pending | completed | error).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    volume-id - The ID of the volume the snapshot is for.    volume-size - The size of the volume, in GiB.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The NextToken value returned from a previous paginated DescribeSnapshots request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The maximum number of snapshot results returned by DescribeSnapshots in paginated output. When this parameter is used, DescribeSnapshots only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another DescribeSnapshots request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then DescribeSnapshots returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.
        public let maxResults: Int32?

        public init(restorableByUserIds: [String]? = nil, snapshotIds: SnapshotIdStringList? = nil, ownerIds: OwnerStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.restorableByUserIds = restorableByUserIds
            self.snapshotIds = snapshotIds
            self.ownerIds = ownerIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.restorableByUserIds = dictionary["RestorableBy"] as? [String]
            if let snapshotIds = dictionary["SnapshotId"] as? [String: Any] { self.snapshotIds = try Ec2.SnapshotIdStringList(dictionary: snapshotIds) } else { self.snapshotIds = nil }
            if let ownerIds = dictionary["Owner"] as? [String: Any] { self.ownerIds = try Ec2.OwnerStringList(dictionary: ownerIds) } else { self.ownerIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CancelReservedInstancesListingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Reserved Instance listing.
        public let reservedInstancesListingId: String

        public init(reservedInstancesListingId: String) {
            self.reservedInstancesListingId = reservedInstancesListingId
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstancesListingId = dictionary["ReservedInstancesListingId"] as? String else { throw InitializableError.missingRequiredParam("ReservedInstancesListingId") }
            self.reservedInstancesListingId = reservedInstancesListingId
        }
    }

    public struct ScheduledInstancesMonitoring: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether monitoring is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.enabled = dictionary["Enabled"] as? Bool
        }
    }

    public struct CreateNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description for the network interface.
        public let description: String?
        /// The ID of the subnet to associate with the network interface.
        public let subnetId: String
        /// The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in privateIpAddresses as primary (only one IP address can be designated as primary).
        public let privateIpAddress: String?
        /// The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using privateIpAddresses. The number of IP addresses you can assign to a network interface varies by instance type. For more information, see IP Addresses Per ENI Per Instance Type in the Amazon Virtual Private Cloud User Guide.
        public let secondaryPrivateIpAddressCount: Int32?
        /// The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the AssignIpv6AddressOnCreation attribute set to true, you can specify 0 to override this setting.
        public let ipv6AddressCount: Int32?
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        public let ipv6Addresses: InstanceIpv6AddressList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The IDs of one or more security groups.
        public let groups: SecurityGroupIdStringList?
        /// One or more private IPv4 addresses.
        public let privateIpAddresses: PrivateIpAddressSpecificationList?

        public init(description: String? = nil, subnetId: String, privateIpAddress: String? = nil, secondaryPrivateIpAddressCount: Int32? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: InstanceIpv6AddressList? = nil, dryRun: Bool? = nil, groups: SecurityGroupIdStringList? = nil, privateIpAddresses: PrivateIpAddressSpecificationList? = nil) {
            self.description = description
            self.subnetId = subnetId
            self.privateIpAddress = privateIpAddress
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.dryRun = dryRun
            self.groups = groups
            self.privateIpAddresses = privateIpAddresses
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [String: Any] { self.ipv6Addresses = try Ec2.InstanceIpv6AddressList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let groups = dictionary["SecurityGroupId"] as? [String: Any] { self.groups = try Ec2.SecurityGroupIdStringList(dictionary: groups) } else { self.groups = nil }
            if let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [String: Any] { self.privateIpAddresses = try Ec2.PrivateIpAddressSpecificationList(dictionary: privateIpAddresses) } else { self.privateIpAddresses = nil }
        }
    }

    public struct ModifyReservedInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the Reserved Instances to modify.
        public let reservedInstancesIds: ReservedInstancesIdStringList
        /// The configuration settings for the Reserved Instances to modify.
        public let targetConfigurations: ReservedInstancesConfigurationList
        /// A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see Ensuring Idempotency.
        public let clientToken: String?

        public init(reservedInstancesIds: ReservedInstancesIdStringList, targetConfigurations: ReservedInstancesConfigurationList, clientToken: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.targetConfigurations = targetConfigurations
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstancesIds = dictionary["ReservedInstancesId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ReservedInstancesId") }
            self.reservedInstancesIds = try Ec2.ReservedInstancesIdStringList(dictionary: reservedInstancesIds)
            guard let targetConfigurations = dictionary["ReservedInstancesConfigurationSetItemType"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ReservedInstancesConfigurationSetItemType") }
            self.targetConfigurations = try Ec2.ReservedInstancesConfigurationList(dictionary: targetConfigurations)
            self.clientToken = dictionary["ClientToken"] as? String
        }
    }

    public struct CancelSpotFleetRequestsErrorItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String
        /// The error.
        public let error: CancelSpotFleetRequestsError

        public init(spotFleetRequestId: String, error: CancelSpotFleetRequestsError) {
            self.spotFleetRequestId = spotFleetRequestId
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            guard let error = dictionary["Error"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Error") }
            self.error = try Ec2.CancelSpotFleetRequestsError(dictionary: error)
        }
    }

    public struct CreateInstanceExportTaskResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the instance export task.
        public let exportTask: ExportTask?

        public init(exportTask: ExportTask? = nil) {
            self.exportTask = exportTask
        }

        public init(dictionary: [String: Any]) throws {
            if let exportTask = dictionary["ExportTask"] as? [String: Any] { self.exportTask = try Ec2.ExportTask(dictionary: exportTask) } else { self.exportTask = nil }
        }
    }

    public struct DescribeVolumesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more volume IDs.
        public let volumeIds: VolumeIdStringList?
        /// One or more filters.    attachment.attach-time - The time stamp when the attachment initiated.    attachment.delete-on-termination - Whether the volume is deleted on instance termination.    attachment.device - The device name that is exposed to the instance (for example, /dev/sda1).    attachment.instance-id - The ID of the instance the volume is attached to.    attachment.status - The attachment state (attaching | attached | detaching | detached).    availability-zone - The Availability Zone in which the volume was created.    create-time - The time stamp when the volume was created.    encrypted - The encryption status of the volume.    size - The size of the volume, in GiB.    snapshot-id - The snapshot from which the volume was created.    status - The status of the volume (creating | available | in-use | deleting | deleted | error).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    volume-id - The volume ID.    volume-type - The Amazon EBS volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The NextToken value returned from a previous paginated DescribeVolumes request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The maximum number of volume results returned by DescribeVolumes in paginated output. When this parameter is used, DescribeVolumes only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another DescribeVolumes request with the returned NextToken value. This value can be between 5 and 500; if MaxResults is given a value larger than 500, only 500 results are returned. If this parameter is not used, then DescribeVolumes returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.
        public let maxResults: Int32?

        public init(volumeIds: VolumeIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeIds = dictionary["VolumeId"] as? [String: Any] { self.volumeIds = try Ec2.VolumeIdStringList(dictionary: volumeIds) } else { self.volumeIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the virtual private gateway.
        public let vpnGatewayId: String

        public init(dryRun: Bool? = nil, vpnGatewayId: String) {
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct DescribeReservedInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of Reserved Instances.
        public let reservedInstances: ReservedInstancesList?

        public init(reservedInstances: ReservedInstancesList? = nil) {
            self.reservedInstances = reservedInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstances = dictionary["ReservedInstancesSet"] as? [String: Any] { self.reservedInstances = try Ec2.ReservedInstancesList(dictionary: reservedInstances) } else { self.reservedInstances = nil }
        }
    }

    public enum VolumeStatusName: String, CustomStringConvertible {
        case io_enabled = "io-enabled"
        case io_performance = "io-performance"
        public var description: String { return self.rawValue }
    }

    public struct InstanceNetworkInterfaceList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceNetworkInterface]?

        public init(item: [InstanceNetworkInterface]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceNetworkInterface(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct EnableVpcClassicLinkDnsSupportRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?

        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
        }
    }

    public struct DescribeNetworkInterfaceAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// The attribute of the network interface.
        public let attribute: NetworkInterfaceAttribute?

        public init(dryRun: Bool? = nil, networkInterfaceId: String, attribute: NetworkInterfaceAttribute? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceId = networkInterfaceId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            if let attribute = dictionary["Attribute"] as? String { self.attribute = NetworkInterfaceAttribute(rawValue: attribute) } else { self.attribute = nil }
        }
    }

    public struct SlotDateTimeRangeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The earliest date and time, in UTC, for the Scheduled Instance to start.
        public let earliestTime: Date
        /// The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.
        public let latestTime: Date

        public init(earliestTime: Date, latestTime: Date) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

        public init(dictionary: [String: Any]) throws {
            guard let earliestTime = dictionary["EarliestTime"] as? Date else { throw InitializableError.missingRequiredParam("EarliestTime") }
            self.earliestTime = earliestTime
            guard let latestTime = dictionary["LatestTime"] as? Date else { throw InitializableError.missingRequiredParam("LatestTime") }
            self.latestTime = latestTime
        }
    }

    public struct DeleteVpcRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct InstanceBlockDeviceMappingSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// suppress the specified device included in the block device mapping.
        public let noDevice: String?
        /// The virtual device name.
        public let virtualName: String?
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public let deviceName: String?
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        public let ebs: EbsInstanceBlockDeviceSpecification?

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.EbsInstanceBlockDeviceSpecification(dictionary: ebs) } else { self.ebs = nil }
        }
    }

    public struct InstanceMonitoring: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The monitoring for the instance.
        public let monitoring: Monitoring?
        /// The ID of the instance.
        public let instanceId: String?

        public init(monitoring: Monitoring? = nil, instanceId: String? = nil) {
            self.monitoring = monitoring
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.Monitoring(dictionary: monitoring) } else { self.monitoring = nil }
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct PriceScheduleList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PriceSchedule]?

        public init(item: [PriceSchedule]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PriceSchedule(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeVpcEndpointsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more endpoint IDs.
        public let vpcEndpointIds: ValueStringList?
        /// One or more filters.    service-name: The name of the AWS service.    vpc-id: The ID of the VPC in which the endpoint resides.    vpc-endpoint-id: The ID of the endpoint.    vpc-endpoint-state: The state of the endpoint. (pending | available | deleting | deleted)  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public let nextToken: String?
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value is greater than 1000, we return only 1000 items.
        public let maxResults: Int32?

        public init(vpcEndpointIds: ValueStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.vpcEndpointIds = vpcEndpointIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcEndpointIds = dictionary["VpcEndpointId"] as? [String: Any] { self.vpcEndpointIds = try Ec2.ValueStringList(dictionary: vpcEndpointIds) } else { self.vpcEndpointIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public enum VolumeStatusInfoStatus: String, CustomStringConvertible {
        case ok = "ok"
        case impaired = "impaired"
        case insufficient_data = "insufficient-data"
        public var description: String { return self.rawValue }
    }

    public struct DescribeFlowLogsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the flow logs.
        public let flowLogs: FlowLogSet?

        public init(nextToken: String? = nil, flowLogs: FlowLogSet? = nil) {
            self.nextToken = nextToken
            self.flowLogs = flowLogs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let flowLogs = dictionary["FlowLogSet"] as? [String: Any] { self.flowLogs = try Ec2.FlowLogSet(dictionary: flowLogs) } else { self.flowLogs = nil }
        }
    }

    public struct EnableVpcClassicLinkResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct CreateVpnConnectionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPN connection.
        public let vpnConnection: VpnConnection?

        public init(vpnConnection: VpnConnection? = nil) {
            self.vpnConnection = vpnConnection
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnConnection = dictionary["VpnConnection"] as? [String: Any] { self.vpnConnection = try Ec2.VpnConnection(dictionary: vpnConnection) } else { self.vpnConnection = nil }
        }
    }

    public struct PropagatingVgw: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the virtual private gateway (VGW).
        public let gatewayId: String?

        public init(gatewayId: String? = nil) {
            self.gatewayId = gatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.gatewayId = dictionary["GatewayId"] as? String
        }
    }

    public struct StartInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more started instances.
        public let startingInstances: InstanceStateChangeList?

        public init(startingInstances: InstanceStateChangeList? = nil) {
            self.startingInstances = startingInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let startingInstances = dictionary["InstancesSet"] as? [String: Any] { self.startingInstances = try Ec2.InstanceStateChangeList(dictionary: startingInstances) } else { self.startingInstances = nil }
        }
    }

    public struct RevokeSecurityGroupEgressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account number for a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public let sourceSecurityGroupOwnerId: String?
        /// A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.
        public let ipPermissions: IpPermissionList?
        /// The CIDR IP address range. We recommend that you specify the CIDR range in a set of IP permissions instead.
        public let cidrIp: String?
        /// The name of a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public let sourceSecurityGroupName: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public let fromPort: Int32?
        /// The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.
        public let ipProtocol: String?
        /// The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public let toPort: Int32?
        /// The ID of the security group.
        public let groupId: String

        public init(sourceSecurityGroupOwnerId: String? = nil, ipPermissions: IpPermissionList? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, toPort: Int32? = nil, groupId: String) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.toPort = toPort
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [String: Any] { self.ipPermissions = try Ec2.IpPermissionList(dictionary: ipPermissions) } else { self.ipPermissions = nil }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.toPort = dictionary["ToPort"] as? Int32
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
        }
    }

    public enum ResetImageAttributeName: String, CustomStringConvertible {
        case launchpermission = "launchPermission"
        public var description: String { return self.rawValue }
    }

    public struct PublicIpStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let publicIp: [String]?

        public init(publicIp: [String]? = nil) {
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.publicIp = dictionary["PublicIp"] as? [String]
        }
    }

    public struct DescribeImportImageTasksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to get the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.
        public let importImageTasks: ImportImageTaskList?

        public init(nextToken: String? = nil, importImageTasks: ImportImageTaskList? = nil) {
            self.nextToken = nextToken
            self.importImageTasks = importImageTasks
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let importImageTasks = dictionary["ImportImageTaskSet"] as? [String: Any] { self.importImageTasks = try Ec2.ImportImageTaskList(dictionary: importImageTasks) } else { self.importImageTasks = nil }
        }
    }

    public enum PaymentOption: String, CustomStringConvertible {
        case allupfront = "AllUpfront"
        case partialupfront = "PartialUpfront"
        case noupfront = "NoUpfront"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible {
        case customer_gateway = "customer-gateway"
        case dhcp_options = "dhcp-options"
        case image = "image"
        case instance = "instance"
        case internet_gateway = "internet-gateway"
        case network_acl = "network-acl"
        case network_interface = "network-interface"
        case reserved_instances = "reserved-instances"
        case route_table = "route-table"
        case snapshot = "snapshot"
        case spot_instances_request = "spot-instances-request"
        case subnet = "subnet"
        case security_group = "security-group"
        case volume = "volume"
        case vpc = "vpc"
        case vpn_connection = "vpn-connection"
        case vpn_gateway = "vpn-gateway"
        public var description: String { return self.rawValue }
    }

    public struct InstanceStateChange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The previous state of the instance.
        public let previousState: InstanceState?
        /// The ID of the instance.
        public let instanceId: String?
        /// The current state of the instance.
        public let currentState: InstanceState?

        public init(previousState: InstanceState? = nil, instanceId: String? = nil, currentState: InstanceState? = nil) {
            self.previousState = previousState
            self.instanceId = instanceId
            self.currentState = currentState
        }

        public init(dictionary: [String: Any]) throws {
            if let previousState = dictionary["PreviousState"] as? [String: Any] { self.previousState = try Ec2.InstanceState(dictionary: previousState) } else { self.previousState = nil }
            self.instanceId = dictionary["InstanceId"] as? String
            if let currentState = dictionary["CurrentState"] as? [String: Any] { self.currentState = try Ec2.InstanceState(dictionary: currentState) } else { self.currentState = nil }
        }
    }

    public struct ClassicLinkInstanceList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ClassicLinkInstance]?

        public init(item: [ClassicLinkInstance]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ClassicLinkInstance(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct GroupIdentifier: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.groupId = dictionary["GroupId"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct CreateSubnetRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the VPC.
        public let vpcId: String
        /// The Availability Zone for the subnet. Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.
        public let availabilityZone: String?
        /// The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
        public let ipv6CidrBlock: String?
        /// The IPv4 network range for the subnet, in CIDR notation. For example, 10.0.0.0/24.
        public let cidrBlock: String

        public init(dryRun: Bool? = nil, vpcId: String, availabilityZone: String? = nil, ipv6CidrBlock: String? = nil, cidrBlock: String) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.availabilityZone = availabilityZone
            self.ipv6CidrBlock = ipv6CidrBlock
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            guard let cidrBlock = dictionary["CidrBlock"] as? String else { throw InitializableError.missingRequiredParam("CidrBlock") }
            self.cidrBlock = cidrBlock
        }
    }

    public struct ReservedInstancesId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Reserved Instance.
        public let reservedInstancesId: String?

        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
        }
    }

    public struct StaleIpPermissionSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [StaleIpPermission]?

        public init(item: [StaleIpPermission]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try StaleIpPermission(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ResetNetworkInterfaceAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// The source/destination checking attribute. Resets the value to true.
        public let sourceDestCheck: String?

        public init(dryRun: Bool? = nil, networkInterfaceId: String, sourceDestCheck: String? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceId = networkInterfaceId
            self.sourceDestCheck = sourceDestCheck
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? String
        }
    }

    public enum AccountAttributeName: String, CustomStringConvertible {
        case supported_platforms = "supported-platforms"
        case default_vpc = "default-vpc"
        public var description: String { return self.rawValue }
    }

    public struct DescribeInternetGatewaysRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Internet gateway IDs. Default: Describes all your Internet gateways.
        public let internetGatewayIds: ValueStringList?
        /// One or more filters.    attachment.state - The current state of the attachment between the gateway and the VPC (available). Present only if a VPC is attached.    attachment.vpc-id - The ID of an attached VPC.    internet-gateway-id - The ID of the Internet gateway.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(internetGatewayIds: ValueStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.internetGatewayIds = internetGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let internetGatewayIds = dictionary["InternetGatewayId"] as? [String: Any] { self.internetGatewayIds = try Ec2.ValueStringList(dictionary: internetGatewayIds) } else { self.internetGatewayIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeIdentityIdFormatRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the principal, which can be an IAM role, IAM user, or the root user.
        public let principalArn: String
        /// The type of resource: instance | reservation | snapshot | volume 
        public let resource: String?

        public init(principalArn: String, resource: String? = nil) {
            self.principalArn = principalArn
            self.resource = resource
        }

        public init(dictionary: [String: Any]) throws {
            guard let principalArn = dictionary["PrincipalArn"] as? String else { throw InitializableError.missingRequiredParam("PrincipalArn") }
            self.principalArn = principalArn
            self.resource = dictionary["Resource"] as? String
        }
    }

    public struct ResponseHostIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public enum ReportInstanceReasonCodes: String, CustomStringConvertible {
        case instance_stuck_in_state = "instance-stuck-in-state"
        case unresponsive = "unresponsive"
        case not_accepting_credentials = "not-accepting-credentials"
        case password_not_available = "password-not-available"
        case performance_network = "performance-network"
        case performance_instance_store = "performance-instance-store"
        case performance_ebs_volume = "performance-ebs-volume"
        case performance_other = "performance-other"
        case other = "other"
        public var description: String { return self.rawValue }
    }

    public struct CustomerGatewayIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let customerGatewayId: [String]?

        public init(customerGatewayId: [String]? = nil) {
            self.customerGatewayId = customerGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.customerGatewayId = dictionary["CustomerGatewayId"] as? [String]
        }
    }

    public enum StatusType: String, CustomStringConvertible {
        case passed = "passed"
        case failed = "failed"
        case insufficient_data = "insufficient-data"
        case initializing = "initializing"
        public var description: String { return self.rawValue }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Any block device mapping entries.
        public let blockDeviceMappings: BlockDeviceMappingList?
        /// The value is Windows for Windows AMIs; otherwise blank.
        public let platform: PlatformValues?
        /// The device name of the root device (for example, /dev/sda1 or /dev/xvda).
        public let rootDeviceName: String?
        /// Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public let sriovNetSupport: String?
        /// The AWS account alias (for example, amazon, self) or the AWS account ID of the AMI owner.
        public let imageOwnerAlias: String?
        /// Any tags assigned to the image.
        public let tags: TagList?
        /// The current state of the AMI. If the state is available, the image is successfully registered and can be used to launch an instance.
        public let state: ImageState?
        /// The kernel associated with the image, if any. Only applicable for machine images.
        public let kernelId: String?
        /// The location of the AMI.
        public let imageLocation: String?
        /// The date and time the image was created.
        public let creationDate: String?
        /// The reason for the state change.
        public let stateReason: StateReason?
        /// The AWS account ID of the image owner.
        public let ownerId: String?
        /// Indicates whether the image has public launch permissions. The value is true if this image has public launch permissions or false if it has only implicit and explicit launch permissions.
        public let `public`: Bool?
        /// The description of the AMI that was provided during image creation.
        public let description: String?
        /// Any product codes associated with the AMI.
        public let productCodes: ProductCodeList?
        /// The hypervisor type of the image.
        public let hypervisor: HypervisorType?
        /// Specifies whether enhanced networking with ENA is enabled.
        public let enaSupport: Bool?
        /// The name of the AMI that was provided during image creation.
        public let name: String?
        /// The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.
        public let rootDeviceType: DeviceType?
        /// The architecture of the image.
        public let architecture: ArchitectureValues?
        /// The ID of the AMI.
        public let imageId: String?
        /// The type of image.
        public let imageType: ImageTypeValues?
        /// The RAM disk associated with the image, if any. Only applicable for machine images.
        public let ramdiskId: String?
        /// The type of virtualization of the AMI.
        public let virtualizationType: VirtualizationType?

        public init(blockDeviceMappings: BlockDeviceMappingList? = nil, platform: PlatformValues? = nil, rootDeviceName: String? = nil, sriovNetSupport: String? = nil, imageOwnerAlias: String? = nil, tags: TagList? = nil, state: ImageState? = nil, kernelId: String? = nil, imageLocation: String? = nil, creationDate: String? = nil, stateReason: StateReason? = nil, ownerId: String? = nil, public: Bool? = nil, description: String? = nil, productCodes: ProductCodeList? = nil, hypervisor: HypervisorType? = nil, enaSupport: Bool? = nil, name: String? = nil, rootDeviceType: DeviceType? = nil, architecture: ArchitectureValues? = nil, imageId: String? = nil, imageType: ImageTypeValues? = nil, ramdiskId: String? = nil, virtualizationType: VirtualizationType? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.platform = platform
            self.rootDeviceName = rootDeviceName
            self.sriovNetSupport = sriovNetSupport
            self.imageOwnerAlias = imageOwnerAlias
            self.tags = tags
            self.state = state
            self.kernelId = kernelId
            self.imageLocation = imageLocation
            self.creationDate = creationDate
            self.stateReason = stateReason
            self.ownerId = ownerId
            self.`public` = `public`
            self.description = description
            self.productCodes = productCodes
            self.hypervisor = hypervisor
            self.enaSupport = enaSupport
            self.name = name
            self.rootDeviceType = rootDeviceType
            self.architecture = architecture
            self.imageId = imageId
            self.imageType = imageType
            self.ramdiskId = ramdiskId
            self.virtualizationType = virtualizationType
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            if let platform = dictionary["Platform"] as? String { self.platform = PlatformValues(rawValue: platform) } else { self.platform = nil }
            self.rootDeviceName = dictionary["RootDeviceName"] as? String
            self.sriovNetSupport = dictionary["SriovNetSupport"] as? String
            self.imageOwnerAlias = dictionary["ImageOwnerAlias"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            if let state = dictionary["ImageState"] as? String { self.state = ImageState(rawValue: state) } else { self.state = nil }
            self.kernelId = dictionary["KernelId"] as? String
            self.imageLocation = dictionary["ImageLocation"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            if let stateReason = dictionary["StateReason"] as? [String: Any] { self.stateReason = try Ec2.StateReason(dictionary: stateReason) } else { self.stateReason = nil }
            self.ownerId = dictionary["ImageOwnerId"] as? String
            self.`public` = dictionary["IsPublic"] as? Bool
            self.description = dictionary["Description"] as? String
            if let productCodes = dictionary["ProductCodes"] as? [String: Any] { self.productCodes = try Ec2.ProductCodeList(dictionary: productCodes) } else { self.productCodes = nil }
            if let hypervisor = dictionary["Hypervisor"] as? String { self.hypervisor = HypervisorType(rawValue: hypervisor) } else { self.hypervisor = nil }
            self.enaSupport = dictionary["EnaSupport"] as? Bool
            self.name = dictionary["Name"] as? String
            if let rootDeviceType = dictionary["RootDeviceType"] as? String { self.rootDeviceType = DeviceType(rawValue: rootDeviceType) } else { self.rootDeviceType = nil }
            if let architecture = dictionary["Architecture"] as? String { self.architecture = ArchitectureValues(rawValue: architecture) } else { self.architecture = nil }
            self.imageId = dictionary["ImageId"] as? String
            if let imageType = dictionary["ImageType"] as? String { self.imageType = ImageTypeValues(rawValue: imageType) } else { self.imageType = nil }
            self.ramdiskId = dictionary["RamdiskId"] as? String
            if let virtualizationType = dictionary["VirtualizationType"] as? String { self.virtualizationType = VirtualizationType(rawValue: virtualizationType) } else { self.virtualizationType = nil }
        }
    }

    public struct InternetGatewayList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InternetGateway]?

        public init(item: [InternetGateway]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InternetGateway(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VpnConnectionOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.
        public let staticRoutesOnly: Bool?

        public init(staticRoutesOnly: Bool? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
        }

        public init(dictionary: [String: Any]) throws {
            self.staticRoutesOnly = dictionary["StaticRoutesOnly"] as? Bool
        }
    }

    public struct DescribeImportImageTasksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Filter tasks using the task-state filter and one of the following values: active, completed, deleting, deleted.
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A list of import image task IDs.
        public let importTaskIds: ImportTaskIdList?
        /// A token that indicates the next page of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(filters: FilterList? = nil, dryRun: Bool? = nil, importTaskIds: ImportTaskIdList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.importTaskIds = importTaskIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let importTaskIds = dictionary["ImportTaskId"] as? [String: Any] { self.importTaskIds = try Ec2.ImportTaskIdList(dictionary: importTaskIds) } else { self.importTaskIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct NatGateway: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet in which the NAT gateway is located.
        public let subnetId: String?
        /// The ID of the NAT gateway.
        public let natGatewayId: String?
        /// The date and time the NAT gateway was deleted, if applicable.
        public let deleteTime: Date?
        /// The ID of the VPC in which the NAT gateway is located.
        public let vpcId: String?
        /// The state of the NAT gateway.    pending: The NAT gateway is being created and is not ready to process traffic.    failed: The NAT gateway could not be created. Check the failureCode and failureMessage fields for the reason.    available: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.    deleting: The NAT gateway is in the process of being terminated and may still be processing traffic.    deleted: The NAT gateway has been terminated and is no longer processing traffic.  
        public let state: NatGatewayState?
        /// If the NAT gateway could not be created, specifies the error code for the failure. (InsufficientFreeAddressesInSubnet | Gateway.NotAttached | InvalidAllocationID.NotFound | Resource.AlreadyAssociated | InternalError | InvalidSubnetID.NotFound)
        public let failureCode: String?
        /// The date and time the NAT gateway was created.
        public let createTime: Date?
        /// If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.   For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"   For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"   For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"   For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"   For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."   For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."  
        public let failureMessage: String?
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public let provisionedBandwidth: ProvisionedBandwidth?
        /// Information about the IP addresses and network interface associated with the NAT gateway.
        public let natGatewayAddresses: NatGatewayAddressList?

        public init(subnetId: String? = nil, natGatewayId: String? = nil, deleteTime: Date? = nil, vpcId: String? = nil, state: NatGatewayState? = nil, failureCode: String? = nil, createTime: Date? = nil, failureMessage: String? = nil, provisionedBandwidth: ProvisionedBandwidth? = nil, natGatewayAddresses: NatGatewayAddressList? = nil) {
            self.subnetId = subnetId
            self.natGatewayId = natGatewayId
            self.deleteTime = deleteTime
            self.vpcId = vpcId
            self.state = state
            self.failureCode = failureCode
            self.createTime = createTime
            self.failureMessage = failureMessage
            self.provisionedBandwidth = provisionedBandwidth
            self.natGatewayAddresses = natGatewayAddresses
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.deleteTime = dictionary["DeleteTime"] as? Date
            self.vpcId = dictionary["VpcId"] as? String
            if let state = dictionary["State"] as? String { self.state = NatGatewayState(rawValue: state) } else { self.state = nil }
            self.failureCode = dictionary["FailureCode"] as? String
            self.createTime = dictionary["CreateTime"] as? Date
            self.failureMessage = dictionary["FailureMessage"] as? String
            if let provisionedBandwidth = dictionary["ProvisionedBandwidth"] as? [String: Any] { self.provisionedBandwidth = try Ec2.ProvisionedBandwidth(dictionary: provisionedBandwidth) } else { self.provisionedBandwidth = nil }
            if let natGatewayAddresses = dictionary["NatGatewayAddressSet"] as? [String: Any] { self.natGatewayAddresses = try Ec2.NatGatewayAddressList(dictionary: natGatewayAddresses) } else { self.natGatewayAddresses = nil }
        }
    }

    public struct VpnStaticRouteList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpnStaticRoute]?

        public init(item: [VpnStaticRoute]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpnStaticRoute(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct InstanceCapacity: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance type size supported by the Dedicated Host.
        public let instanceType: String?
        /// The total number of instances that can be launched onto the Dedicated Host.
        public let totalCapacity: Int32?
        /// The number of instances that can still be launched onto the Dedicated Host.
        public let availableCapacity: Int32?

        public init(instanceType: String? = nil, totalCapacity: Int32? = nil, availableCapacity: Int32? = nil) {
            self.instanceType = instanceType
            self.totalCapacity = totalCapacity
            self.availableCapacity = availableCapacity
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceType = dictionary["InstanceType"] as? String
            self.totalCapacity = dictionary["TotalCapacity"] as? Int32
            self.availableCapacity = dictionary["AvailableCapacity"] as? Int32
        }
    }

    public enum PermissionGroup: String, CustomStringConvertible {
        case all = "all"
        public var description: String { return self.rawValue }
    }

    public struct UnassignIpv6AddressesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The IPv6 addresses that have been unassigned from the network interface.
        public let unassignedIpv6Addresses: Ipv6AddressList?

        public init(networkInterfaceId: String? = nil, unassignedIpv6Addresses: Ipv6AddressList? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.unassignedIpv6Addresses = unassignedIpv6Addresses
        }

        public init(dictionary: [String: Any]) throws {
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            if let unassignedIpv6Addresses = dictionary["UnassignedIpv6Addresses"] as? [String: Any] { self.unassignedIpv6Addresses = try Ec2.Ipv6AddressList(dictionary: unassignedIpv6Addresses) } else { self.unassignedIpv6Addresses = nil }
        }
    }

    public struct ClassicLinkDnsSupport: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// Indicates whether ClassicLink DNS support is enabled for the VPC.
        public let classicLinkDnsSupported: Bool?

        public init(vpcId: String? = nil, classicLinkDnsSupported: Bool? = nil) {
            self.vpcId = vpcId
            self.classicLinkDnsSupported = classicLinkDnsSupported
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            self.classicLinkDnsSupported = dictionary["ClassicLinkDnsSupported"] as? Bool
        }
    }

    public struct ClassicLinkDnsSupportList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ClassicLinkDnsSupport]?

        public init(item: [ClassicLinkDnsSupport]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ClassicLinkDnsSupport(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CancelImportTaskResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The current state of the task being canceled.
        public let previousState: String?
        /// The current state of the task being canceled.
        public let state: String?
        /// The ID of the task being canceled.
        public let importTaskId: String?

        public init(previousState: String? = nil, state: String? = nil, importTaskId: String? = nil) {
            self.previousState = previousState
            self.state = state
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.previousState = dictionary["PreviousState"] as? String
            self.state = dictionary["State"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct SnapshotDetailList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SnapshotDetail]?

        public init(item: [SnapshotDetail]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SnapshotDetail(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct PriceScheduleSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The fixed price for the term.
        public let price: Double?
        /// The currency for transacting the Reserved Instance resale. At this time, the only supported currency is USD.
        public let currencyCode: CurrencyCodeValues?
        /// The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.
        public let term: Int64?

        public init(price: Double? = nil, currencyCode: CurrencyCodeValues? = nil, term: Int64? = nil) {
            self.price = price
            self.currencyCode = currencyCode
            self.term = term
        }

        public init(dictionary: [String: Any]) throws {
            self.price = dictionary["Price"] as? Double
            if let currencyCode = dictionary["CurrencyCode"] as? String { self.currencyCode = CurrencyCodeValues(rawValue: currencyCode) } else { self.currencyCode = nil }
            self.term = dictionary["Term"] as? Int64
        }
    }

    public enum InstanceLifecycleType: String, CustomStringConvertible {
        case spot = "spot"
        case scheduled = "scheduled"
        public var description: String { return self.rawValue }
    }

    public struct ProductCodeStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let productCode: [String]?

        public init(productCode: [String]? = nil) {
            self.productCode = productCode
        }

        public init(dictionary: [String: Any]) throws {
            self.productCode = dictionary["ProductCode"] as? [String]
        }
    }

    public enum ListingState: String, CustomStringConvertible {
        case available = "available"
        case sold = "sold"
        case cancelled = "cancelled"
        case pending = "pending"
        public var description: String { return self.rawValue }
    }

    public struct DescribeIdentityIdFormatResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the ID format for the resources.
        public let statuses: IdFormatList?

        public init(statuses: IdFormatList? = nil) {
            self.statuses = statuses
        }

        public init(dictionary: [String: Any]) throws {
            if let statuses = dictionary["StatusSet"] as? [String: Any] { self.statuses = try Ec2.IdFormatList(dictionary: statuses) } else { self.statuses = nil }
        }
    }

    public struct CreateVpnConnectionRouteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPN connection.
        public let vpnConnectionId: String
        /// The CIDR block associated with the local subnet of the customer network.
        public let destinationCidrBlock: String

        public init(vpnConnectionId: String, destinationCidrBlock: String) {
            self.vpnConnectionId = vpnConnectionId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpnConnectionId = dictionary["VpnConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpnConnectionId") }
            self.vpnConnectionId = vpnConnectionId
            guard let destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String else { throw InitializableError.missingRequiredParam("DestinationCidrBlock") }
            self.destinationCidrBlock = destinationCidrBlock
        }
    }

    public struct ReservedInstancesConfigurationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstancesConfiguration]?

        public init(item: [ReservedInstancesConfiguration]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstancesConfiguration(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum VolumeAttributeName: String, CustomStringConvertible {
        case autoenableio = "autoEnableIO"
        case productcodes = "productCodes"
        public var description: String { return self.rawValue }
    }

    public struct ImportVolumeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the conversion task.
        public let conversionTask: ConversionTask?

        public init(conversionTask: ConversionTask? = nil) {
            self.conversionTask = conversionTask
        }

        public init(dictionary: [String: Any]) throws {
            if let conversionTask = dictionary["ConversionTask"] as? [String: Any] { self.conversionTask = try Ec2.ConversionTask(dictionary: conversionTask) } else { self.conversionTask = nil }
        }
    }

    public struct VpnConnection: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The VPN connection options.
        public let options: VpnConnectionOptions?
        /// The ID of the customer gateway at your end of the VPN connection.
        public let customerGatewayId: String?
        /// The static routes associated with the VPN connection.
        public let routes: VpnStaticRouteList?
        /// The ID of the VPN connection.
        public let vpnConnectionId: String?
        /// The current state of the VPN connection.
        public let state: VpnState?
        /// Any tags assigned to the VPN connection.
        public let tags: TagList?
        /// Information about the VPN tunnel.
        public let vgwTelemetry: VgwTelemetryList?
        /// The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the CreateVpnConnection response; however, it's present in the DescribeVpnConnections response only if the VPN connection is in the pending or available state.
        public let customerGatewayConfiguration: String?
        /// The type of VPN connection.
        public let `type`: GatewayType?
        /// The ID of the virtual private gateway at the AWS side of the VPN connection.
        public let vpnGatewayId: String?

        public init(options: VpnConnectionOptions? = nil, customerGatewayId: String? = nil, routes: VpnStaticRouteList? = nil, vpnConnectionId: String? = nil, state: VpnState? = nil, tags: TagList? = nil, vgwTelemetry: VgwTelemetryList? = nil, customerGatewayConfiguration: String? = nil, type: GatewayType? = nil, vpnGatewayId: String? = nil) {
            self.options = options
            self.customerGatewayId = customerGatewayId
            self.routes = routes
            self.vpnConnectionId = vpnConnectionId
            self.state = state
            self.tags = tags
            self.vgwTelemetry = vgwTelemetry
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.`type` = `type`
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            if let options = dictionary["Options"] as? [String: Any] { self.options = try Ec2.VpnConnectionOptions(dictionary: options) } else { self.options = nil }
            self.customerGatewayId = dictionary["CustomerGatewayId"] as? String
            if let routes = dictionary["Routes"] as? [String: Any] { self.routes = try Ec2.VpnStaticRouteList(dictionary: routes) } else { self.routes = nil }
            self.vpnConnectionId = dictionary["VpnConnectionId"] as? String
            if let state = dictionary["State"] as? String { self.state = VpnState(rawValue: state) } else { self.state = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            if let vgwTelemetry = dictionary["VgwTelemetry"] as? [String: Any] { self.vgwTelemetry = try Ec2.VgwTelemetryList(dictionary: vgwTelemetry) } else { self.vgwTelemetry = nil }
            self.customerGatewayConfiguration = dictionary["CustomerGatewayConfiguration"] as? String
            if let `type` = dictionary["Type"] as? String { self.`type` = GatewayType(rawValue: `type`) } else { self.`type` = nil }
            self.vpnGatewayId = dictionary["VpnGatewayId"] as? String
        }
    }

    public enum PlacementStrategy: String, CustomStringConvertible {
        case cluster = "cluster"
        public var description: String { return self.rawValue }
    }

    public struct Address: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the AWS account that owns the network interface.
        public let networkInterfaceOwnerId: String?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The ID representing the association of the address with an instance in a VPC.
        public let associationId: String?
        /// The ID of the instance that the address is associated with (if any).
        public let instanceId: String?
        /// The ID representing the allocation of the address for use with EC2-VPC.
        public let allocationId: String?
        /// The Elastic IP address.
        public let publicIp: String?
        /// Indicates whether this Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).
        public let domain: DomainType?
        /// The private IP address associated with the Elastic IP address.
        public let privateIpAddress: String?

        public init(networkInterfaceOwnerId: String? = nil, networkInterfaceId: String? = nil, associationId: String? = nil, instanceId: String? = nil, allocationId: String? = nil, publicIp: String? = nil, domain: DomainType? = nil, privateIpAddress: String? = nil) {
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.networkInterfaceId = networkInterfaceId
            self.associationId = associationId
            self.instanceId = instanceId
            self.allocationId = allocationId
            self.publicIp = publicIp
            self.domain = domain
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.networkInterfaceOwnerId = dictionary["NetworkInterfaceOwnerId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.associationId = dictionary["AssociationId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
            if let domain = dictionary["Domain"] as? String { self.domain = DomainType(rawValue: domain) } else { self.domain = nil }
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
        }
    }

    public struct DescribeVpnGatewaysRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more virtual private gateway IDs. Default: Describes all your virtual private gateways.
        public let vpnGatewayIds: VpnGatewayIdStringList?
        /// One or more filters.    attachment.state - The current state of the attachment between the gateway and the VPC (attaching | attached | detaching | detached).    attachment.vpc-id - The ID of an attached VPC.    availability-zone - The Availability Zone for the virtual private gateway (if applicable).    state - The state of the virtual private gateway (pending | available | deleting | deleted).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of virtual private gateway. Currently the only supported type is ipsec.1.    vpn-gateway-id - The ID of the virtual private gateway.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpnGatewayIds: VpnGatewayIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.vpnGatewayIds = vpnGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnGatewayIds = dictionary["VpnGatewayId"] as? [String: Any] { self.vpnGatewayIds = try Ec2.VpnGatewayIdStringList(dictionary: vpnGatewayIds) } else { self.vpnGatewayIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public enum VpnState: String, CustomStringConvertible {
        case pending = "pending"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct TerminateInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more instance IDs. Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.
        public let instanceIds: InstanceIdStringList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceIds: InstanceIdStringList, dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReasonCodesList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReportInstanceReasonCodes]?

        public init(item: [ReportInstanceReasonCodes]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [String] { self.item = item.flatMap({ ReportInstanceReasonCodes(rawValue: $0)}) } else { self.item = nil }
        }
    }

    public struct ImportImageTaskList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ImportImageTask]?

        public init(item: [ImportImageTask]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ImportImageTask(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct NetworkAclAssociationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NetworkAclAssociation]?

        public init(item: [NetworkAclAssociation]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NetworkAclAssociation(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct PurchaseReservedInstancesOfferingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the purchased Reserved Instances.
        public let reservedInstancesId: String?

        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
        }
    }

    public struct CreateNetworkAclRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVpnConnectionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more VPN connections.
        public let vpnConnections: VpnConnectionList?

        public init(vpnConnections: VpnConnectionList? = nil) {
            self.vpnConnections = vpnConnections
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnConnections = dictionary["VpnConnectionSet"] as? [String: Any] { self.vpnConnections = try Ec2.VpnConnectionList(dictionary: vpnConnections) } else { self.vpnConnections = nil }
        }
    }

    public struct ImportInstanceTaskDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The instance operating system.
        public let platform: PlatformValues?
        /// One or more volumes.
        public let volumes: ImportInstanceVolumeDetailSet
        /// The ID of the instance.
        public let instanceId: String?
        /// A description of the task.
        public let description: String?

        public init(platform: PlatformValues? = nil, volumes: ImportInstanceVolumeDetailSet, instanceId: String? = nil, description: String? = nil) {
            self.platform = platform
            self.volumes = volumes
            self.instanceId = instanceId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let platform = dictionary["Platform"] as? String { self.platform = PlatformValues(rawValue: platform) } else { self.platform = nil }
            guard let volumes = dictionary["Volumes"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volumes") }
            self.volumes = try Ec2.ImportInstanceVolumeDetailSet(dictionary: volumes)
            self.instanceId = dictionary["InstanceId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct BundleTaskError: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error code.
        public let code: String?
        /// The error message.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct AccountAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the account attribute.
        public let attributeName: String?
        /// One or more values for the account attribute.
        public let attributeValues: AccountAttributeValueList?

        public init(attributeName: String? = nil, attributeValues: AccountAttributeValueList? = nil) {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeName = dictionary["AttributeName"] as? String
            if let attributeValues = dictionary["AttributeValueSet"] as? [String: Any] { self.attributeValues = try Ec2.AccountAttributeValueList(dictionary: attributeValues) } else { self.attributeValues = nil }
        }
    }

    public struct PropagatingVgwList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PropagatingVgw]?

        public init(item: [PropagatingVgw]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PropagatingVgw(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ModifyReservedInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID for the modification.
        public let reservedInstancesModificationId: String?

        public init(reservedInstancesModificationId: String? = nil) {
            self.reservedInstancesModificationId = reservedInstancesModificationId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesModificationId = dictionary["ReservedInstancesModificationId"] as? String
        }
    }

    public struct CreateCustomerGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// For devices that support BGP, the customer gateway's BGP ASN. Default: 65000
        public let bgpAsn: Int32
        /// The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
        public let publicIp: String
        /// The type of VPN connection that this customer gateway supports (ipsec.1).
        public let `type`: GatewayType
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(bgpAsn: Int32, publicIp: String, type: GatewayType, dryRun: Bool? = nil) {
            self.bgpAsn = bgpAsn
            self.publicIp = publicIp
            self.`type` = `type`
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let bgpAsn = dictionary["BgpAsn"] as? Int32 else { throw InitializableError.missingRequiredParam("BgpAsn") }
            self.bgpAsn = bgpAsn
            guard let publicIp = dictionary["IpAddress"] as? String else { throw InitializableError.missingRequiredParam("IpAddress") }
            self.publicIp = publicIp
            guard let rawType = dictionary["Type"] as? String, let `type` = GatewayType(rawValue: rawType) else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CancelSpotInstanceRequestsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more Spot instance request IDs.
        public let spotInstanceRequestIds: SpotInstanceRequestIdList

        public init(dryRun: Bool? = nil, spotInstanceRequestIds: SpotInstanceRequestIdList) {
            self.dryRun = dryRun
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let spotInstanceRequestIds = dictionary["SpotInstanceRequestId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotInstanceRequestId") }
            self.spotInstanceRequestIds = try Ec2.SpotInstanceRequestIdList(dictionary: spotInstanceRequestIds)
        }
    }

    public enum DiskImageFormat: String, CustomStringConvertible {
        case vmdk = "VMDK"
        case raw = "RAW"
        case vhd = "VHD"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEgressOnlyInternetGatewaysResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?
        /// Information about the egress-only Internet gateways.
        public let egressOnlyInternetGateways: EgressOnlyInternetGatewayList?

        public init(nextToken: String? = nil, egressOnlyInternetGateways: EgressOnlyInternetGatewayList? = nil) {
            self.nextToken = nextToken
            self.egressOnlyInternetGateways = egressOnlyInternetGateways
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let egressOnlyInternetGateways = dictionary["EgressOnlyInternetGatewaySet"] as? [String: Any] { self.egressOnlyInternetGateways = try Ec2.EgressOnlyInternetGatewayList(dictionary: egressOnlyInternetGateways) } else { self.egressOnlyInternetGateways = nil }
        }
    }

    public struct CreateSecurityGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the security group. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*
        public let groupName: String
        /// [EC2-VPC] The ID of the VPC. Required for EC2-VPC.
        public let vpcId: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// A description for the security group. This is informational only. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*
        public let description: String

        public init(groupName: String, vpcId: String? = nil, dryRun: Bool? = nil, description: String) {
            self.groupName = groupName
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let groupName = dictionary["GroupName"] as? String else { throw InitializableError.missingRequiredParam("GroupName") }
            self.groupName = groupName
            self.vpcId = dictionary["VpcId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let description = dictionary["GroupDescription"] as? String else { throw InitializableError.missingRequiredParam("GroupDescription") }
            self.description = description
        }
    }

    public struct SubnetList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Subnet]?

        public init(item: [Subnet]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Subnet(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct MoveAddressToVpcRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The Elastic IP address.
        public let publicIp: String

        public init(dryRun: Bool? = nil, publicIp: String) {
            self.dryRun = dryRun
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let publicIp = dictionary["PublicIp"] as? String else { throw InitializableError.missingRequiredParam("PublicIp") }
            self.publicIp = publicIp
        }
    }

    public struct DescribeSpotFleetRequestHistoryResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The last date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). All records up to this time were retrieved. If nextToken indicates that there are more results, this value is not present.
        public let lastEvaluatedTime: Date
        /// The starting date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let startTime: Date
        /// Information about the events in the history of the Spot fleet request.
        public let historyRecords: HistoryRecords
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String

        public init(lastEvaluatedTime: Date, startTime: Date, historyRecords: HistoryRecords, nextToken: String? = nil, spotFleetRequestId: String) {
            self.lastEvaluatedTime = lastEvaluatedTime
            self.startTime = startTime
            self.historyRecords = historyRecords
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let lastEvaluatedTime = dictionary["LastEvaluatedTime"] as? Date else { throw InitializableError.missingRequiredParam("LastEvaluatedTime") }
            self.lastEvaluatedTime = lastEvaluatedTime
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            guard let historyRecords = dictionary["HistoryRecordSet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("HistoryRecordSet") }
            self.historyRecords = try Ec2.HistoryRecords(dictionary: historyRecords)
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct CreateInternetGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the Internet gateway.
        public let internetGateway: InternetGateway?

        public init(internetGateway: InternetGateway? = nil) {
            self.internetGateway = internetGateway
        }

        public init(dictionary: [String: Any]) throws {
            if let internetGateway = dictionary["InternetGateway"] as? [String: Any] { self.internetGateway = try Ec2.InternetGateway(dictionary: internetGateway) } else { self.internetGateway = nil }
        }
    }

    public struct DescribeImageAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AMI attribute.  Note: Depending on your account privileges, the blockDeviceMapping attribute may return a Client.AuthFailure error. If this happens, use DescribeImages to get information about the block device mapping for the AMI.
        public let attribute: ImageAttributeName
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the AMI.
        public let imageId: String

        public init(attribute: ImageAttributeName, dryRun: Bool? = nil, imageId: String) {
            self.attribute = attribute
            self.dryRun = dryRun
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = ImageAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct HostList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Host]?

        public init(item: [Host]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Host(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ReplaceNetworkAclEntryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24).
        public let cidrBlock: String?
        /// ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.
        public let icmpTypeCode: IcmpTypeCode?
        /// The rule number of the entry to replace.
        public let ruleNumber: Int32
        /// The IP protocol. You can specify all or -1 to mean all protocols. If you specify all, -1, or a protocol number other than tcp, udp, or icmp, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.
        public let `protocol`: String
        /// Indicates whether to allow or deny the traffic that matches the rule.
        public let ruleAction: RuleAction
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the ACL.
        public let networkAclId: String
        /// Indicates whether to replace the egress rule. Default: If no value is specified, we replace the ingress rule.
        public let egress: Bool
        /// The IPv6 network range to allow or deny, in CIDR notation (for example 2001:bd8:1234:1a00::/64).
        public let ipv6CidrBlock: String?
        /// TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.
        public let portRange: PortRange?

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32, protocol: String, ruleAction: RuleAction, dryRun: Bool? = nil, networkAclId: String, egress: Bool, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.dryRun = dryRun
            self.networkAclId = networkAclId
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrBlock = dictionary["CidrBlock"] as? String
            if let icmpTypeCode = dictionary["Icmp"] as? [String: Any] { self.icmpTypeCode = try Ec2.IcmpTypeCode(dictionary: icmpTypeCode) } else { self.icmpTypeCode = nil }
            guard let ruleNumber = dictionary["RuleNumber"] as? Int32 else { throw InitializableError.missingRequiredParam("RuleNumber") }
            self.ruleNumber = ruleNumber
            guard let `protocol` = dictionary["Protocol"] as? String else { throw InitializableError.missingRequiredParam("Protocol") }
            self.`protocol` = `protocol`
            guard let rawRuleAction = dictionary["RuleAction"] as? String, let ruleAction = RuleAction(rawValue: rawRuleAction) else { throw InitializableError.missingRequiredParam("RuleAction") }
            self.ruleAction = ruleAction
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
            guard let egress = dictionary["Egress"] as? Bool else { throw InitializableError.missingRequiredParam("Egress") }
            self.egress = egress
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            if let portRange = dictionary["PortRange"] as? [String: Any] { self.portRange = try Ec2.PortRange(dictionary: portRange) } else { self.portRange = nil }
        }
    }

    public struct DeleteKeyPairRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the key pair.
        public let keyName: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(keyName: String, dryRun: Bool? = nil) {
            self.keyName = keyName
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let keyName = dictionary["KeyName"] as? String else { throw InitializableError.missingRequiredParam("KeyName") }
            self.keyName = keyName
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct IamInstanceProfileAssociationSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [IamInstanceProfileAssociation]?

        public init(item: [IamInstanceProfileAssociation]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try IamInstanceProfileAssociation(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct EbsBlockDevice: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the snapshot.
        public let snapshotId: String?
        /// Indicates whether the EBS volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The volume type: gp2, io1, st1, sc1, or standard. Default: standard 
        public let volumeType: VolumeType?
        /// The size of the volume, in GiB. Constraints: 1-16384 for General Purpose SSD (gp2), 4-16384 for Provisioned IOPS SSD (io1), 500-16384 for Throughput Optimized HDD (st1), 500-16384 for Cold HDD (sc1), and 1-1024 for Magnetic (standard) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        public let volumeSize: Int32?
        /// The number of I/O operations per second (IOPS) that the volume supports. For io1, this represents the number of IOPS that are provisioned for the volume. For gp2, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        public let iops: Int32?
        /// Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.
        public let encrypted: Bool?

        public init(snapshotId: String? = nil, deleteOnTermination: Bool? = nil, volumeType: VolumeType? = nil, volumeSize: Int32? = nil, iops: Int32? = nil, encrypted: Bool? = nil) {
            self.snapshotId = snapshotId
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.volumeSize = volumeSize
            self.iops = iops
            self.encrypted = encrypted
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            if let volumeType = dictionary["VolumeType"] as? String { self.volumeType = VolumeType(rawValue: volumeType) } else { self.volumeType = nil }
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.iops = dictionary["Iops"] as? Int32
            self.encrypted = dictionary["Encrypted"] as? Bool
        }
    }

    public struct DescribeExportTasksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the export tasks.
        public let exportTasks: ExportTaskList?

        public init(exportTasks: ExportTaskList? = nil) {
            self.exportTasks = exportTasks
        }

        public init(dictionary: [String: Any]) throws {
            if let exportTasks = dictionary["ExportTaskSet"] as? [String: Any] { self.exportTasks = try Ec2.ExportTaskList(dictionary: exportTasks) } else { self.exportTasks = nil }
        }
    }

    public enum Scope: String, CustomStringConvertible {
        case availability_zone = "Availability Zone"
        case region = "Region"
        public var description: String { return self.rawValue }
    }

    public struct CreateVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPC peering connection.
        public let vpcPeeringConnection: VpcPeeringConnection?

        public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
            self.vpcPeeringConnection = vpcPeeringConnection
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcPeeringConnection = dictionary["VpcPeeringConnection"] as? [String: Any] { self.vpcPeeringConnection = try Ec2.VpcPeeringConnection(dictionary: vpcPeeringConnection) } else { self.vpcPeeringConnection = nil }
        }
    }

    public struct IpRange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix.
        public let cidrIp: String?

        public init(cidrIp: String? = nil) {
            self.cidrIp = cidrIp
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrIp = dictionary["CidrIp"] as? String
        }
    }

    public struct DhcpConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of a DHCP option.
        public let key: String?
        /// One or more values for the DHCP option.
        public let values: DhcpConfigurationValueList?

        public init(key: String? = nil, values: DhcpConfigurationValueList? = nil) {
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            if let values = dictionary["ValueSet"] as? [String: Any] { self.values = try Ec2.DhcpConfigurationValueList(dictionary: values) } else { self.values = nil }
        }
    }

    public struct CancelConversionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the conversion task.
        public let conversionTaskId: String
        /// The reason for canceling the conversion task.
        public let reasonMessage: String?

        public init(dryRun: Bool? = nil, conversionTaskId: String, reasonMessage: String? = nil) {
            self.dryRun = dryRun
            self.conversionTaskId = conversionTaskId
            self.reasonMessage = reasonMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let conversionTaskId = dictionary["ConversionTaskId"] as? String else { throw InitializableError.missingRequiredParam("ConversionTaskId") }
            self.conversionTaskId = conversionTaskId
            self.reasonMessage = dictionary["ReasonMessage"] as? String
        }
    }

    public struct GroupIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let groupId: [String]?

        public init(groupId: [String]? = nil) {
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.groupId = dictionary["GroupId"] as? [String]
        }
    }

    public struct SpotInstanceRequestIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let spotInstanceRequestId: [String]?

        public init(spotInstanceRequestId: [String]? = nil) {
            self.spotInstanceRequestId = spotInstanceRequestId
        }

        public init(dictionary: [String: Any]) throws {
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? [String]
        }
    }

    public struct ModifyInstancePlacementResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Is true if the request succeeds, and an error otherwise.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct NetworkInterfaceIpv6AddressesList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NetworkInterfaceIpv6Address]?

        public init(item: [NetworkInterfaceIpv6Address]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NetworkInterfaceIpv6Address(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum FleetType: String, CustomStringConvertible {
        case request = "request"
        case maintain = "maintain"
        public var description: String { return self.rawValue }
    }

    public struct UnsuccessfulItemSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [UnsuccessfulItem]?

        public init(item: [UnsuccessfulItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try UnsuccessfulItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeVpcAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The VPC attribute.
        public let attribute: VpcAttributeName

        public init(vpcId: String, dryRun: Bool? = nil, attribute: VpcAttributeName) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = VpcAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct ReservedInstancesModification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of one or more Reserved Instances.
        public let reservedInstancesIds: ReservedIntancesIds?
        /// The status of the Reserved Instances modification request.
        public let status: String?
        /// The time for the modification to become effective.
        public let effectiveDate: Date?
        /// A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see Ensuring Idempotency.
        public let clientToken: String?
        /// Contains target configurations along with their corresponding new Reserved Instance IDs.
        public let modificationResults: ReservedInstancesModificationResultList?
        /// The time when the modification request was last updated.
        public let updateDate: Date?
        /// A unique ID for the Reserved Instance modification.
        public let reservedInstancesModificationId: String?
        /// The time when the modification request was created.
        public let createDate: Date?
        /// The reason for the status.
        public let statusMessage: String?

        public init(reservedInstancesIds: ReservedIntancesIds? = nil, status: String? = nil, effectiveDate: Date? = nil, clientToken: String? = nil, modificationResults: ReservedInstancesModificationResultList? = nil, updateDate: Date? = nil, reservedInstancesModificationId: String? = nil, createDate: Date? = nil, statusMessage: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.status = status
            self.effectiveDate = effectiveDate
            self.clientToken = clientToken
            self.modificationResults = modificationResults
            self.updateDate = updateDate
            self.reservedInstancesModificationId = reservedInstancesModificationId
            self.createDate = createDate
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesIds = dictionary["ReservedInstancesSet"] as? [String: Any] { self.reservedInstancesIds = try Ec2.ReservedIntancesIds(dictionary: reservedInstancesIds) } else { self.reservedInstancesIds = nil }
            self.status = dictionary["Status"] as? String
            self.effectiveDate = dictionary["EffectiveDate"] as? Date
            self.clientToken = dictionary["ClientToken"] as? String
            if let modificationResults = dictionary["ModificationResultSet"] as? [String: Any] { self.modificationResults = try Ec2.ReservedInstancesModificationResultList(dictionary: modificationResults) } else { self.modificationResults = nil }
            self.updateDate = dictionary["UpdateDate"] as? Date
            self.reservedInstancesModificationId = dictionary["ReservedInstancesModificationId"] as? String
            self.createDate = dictionary["CreateDate"] as? Date
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct DescribeAvailabilityZonesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more Availability Zones.
        public let availabilityZones: AvailabilityZoneList?

        public init(availabilityZones: AvailabilityZoneList? = nil) {
            self.availabilityZones = availabilityZones
        }

        public init(dictionary: [String: Any]) throws {
            if let availabilityZones = dictionary["AvailabilityZoneInfo"] as? [String: Any] { self.availabilityZones = try Ec2.AvailabilityZoneList(dictionary: availabilityZones) } else { self.availabilityZones = nil }
        }
    }

    public struct RejectVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpcPeeringConnectionId") }
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

    public struct NetworkInterfacePrivateIpAddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NetworkInterfacePrivateIpAddress]?

        public init(item: [NetworkInterfacePrivateIpAddress]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NetworkInterfacePrivateIpAddress(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ReplaceIamInstanceProfileAssociationResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the IAM instance profile association.
        public let iamInstanceProfileAssociation: IamInstanceProfileAssociation?

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

        public init(dictionary: [String: Any]) throws {
            if let iamInstanceProfileAssociation = dictionary["IamInstanceProfileAssociation"] as? [String: Any] { self.iamInstanceProfileAssociation = try Ec2.IamInstanceProfileAssociation(dictionary: iamInstanceProfileAssociation) } else { self.iamInstanceProfileAssociation = nil }
        }
    }

    public struct CreateImageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the new AMI.
        public let imageId: String?

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct ImportVolumeTaskDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The image.
        public let image: DiskImageDescription
        /// The number of bytes converted so far.
        public let bytesConverted: Int64
        /// The volume.
        public let volume: DiskImageVolumeDescription
        /// The Availability Zone where the resulting volume will reside.
        public let availabilityZone: String
        /// The description you provided when starting the import volume task.
        public let description: String?

        public init(image: DiskImageDescription, bytesConverted: Int64, volume: DiskImageVolumeDescription, availabilityZone: String, description: String? = nil) {
            self.image = image
            self.bytesConverted = bytesConverted
            self.volume = volume
            self.availabilityZone = availabilityZone
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Ec2.DiskImageDescription(dictionary: image)
            guard let bytesConverted = dictionary["BytesConverted"] as? Int64 else { throw InitializableError.missingRequiredParam("BytesConverted") }
            self.bytesConverted = bytesConverted
            guard let volume = dictionary["Volume"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volume") }
            self.volume = try Ec2.DiskImageVolumeDescription(dictionary: volume)
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.description = dictionary["Description"] as? String
        }
    }

    public struct IpRanges: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct NetworkInterfaceAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The address of the Elastic IP address bound to the network interface.
        public let publicIp: String?
        /// The association ID.
        public let associationId: String?
        /// The ID of the Elastic IP address owner.
        public let ipOwnerId: String?
        /// The allocation ID.
        public let allocationId: String?
        /// The public DNS name.
        public let publicDnsName: String?

        public init(publicIp: String? = nil, associationId: String? = nil, ipOwnerId: String? = nil, allocationId: String? = nil, publicDnsName: String? = nil) {
            self.publicIp = publicIp
            self.associationId = associationId
            self.ipOwnerId = ipOwnerId
            self.allocationId = allocationId
            self.publicDnsName = publicDnsName
        }

        public init(dictionary: [String: Any]) throws {
            self.publicIp = dictionary["PublicIp"] as? String
            self.associationId = dictionary["AssociationId"] as? String
            self.ipOwnerId = dictionary["IpOwnerId"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
            self.publicDnsName = dictionary["PublicDnsName"] as? String
        }
    }

    public struct ScheduledInstanceRecurrenceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.
        public let occurrenceDays: OccurrenceDayRequestSet?
        /// The frequency (Daily, Weekly, or Monthly).
        public let frequency: String?
        /// The unit for OccurrenceDays (DayOfWeek or DayOfMonth). This value is required for a monthly schedule. You can't specify DayOfWeek with a weekly schedule. You can't specify this value with a daily schedule.
        public let occurrenceUnit: String?
        /// Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.
        public let occurrenceRelativeToEnd: Bool?
        /// The interval quantity. The interval unit depends on the value of Frequency. For example, every 2 weeks or every 2 months.
        public let interval: Int32?

        public init(occurrenceDays: OccurrenceDayRequestSet? = nil, frequency: String? = nil, occurrenceUnit: String? = nil, occurrenceRelativeToEnd: Bool? = nil, interval: Int32? = nil) {
            self.occurrenceDays = occurrenceDays
            self.frequency = frequency
            self.occurrenceUnit = occurrenceUnit
            self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
            self.interval = interval
        }

        public init(dictionary: [String: Any]) throws {
            if let occurrenceDays = dictionary["OccurrenceDay"] as? [String: Any] { self.occurrenceDays = try Ec2.OccurrenceDayRequestSet(dictionary: occurrenceDays) } else { self.occurrenceDays = nil }
            self.frequency = dictionary["Frequency"] as? String
            self.occurrenceUnit = dictionary["OccurrenceUnit"] as? String
            self.occurrenceRelativeToEnd = dictionary["OccurrenceRelativeToEnd"] as? Bool
            self.interval = dictionary["Interval"] as? Int32
        }
    }

    public struct Filter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the filter. Filter names are case-sensitive.
        public let name: String?
        /// One or more filter values. Filter values are case-sensitive.
        public let values: ValueStringList?

        public init(name: String? = nil, values: ValueStringList? = nil) {
            self.name = name
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            if let values = dictionary["Value"] as? [String: Any] { self.values = try Ec2.ValueStringList(dictionary: values) } else { self.values = nil }
        }
    }

    public struct MonitorInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more instance IDs.
        public let instanceIds: InstanceIdStringList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceIds: InstanceIdStringList, dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct LaunchSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.
        public let blockDeviceMappings: BlockDeviceMappingList?
        /// The ID of the subnet in which to launch the instance.
        public let subnetId: String?
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let userData: String?
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        public let ebsOptimized: Bool?
        /// The ID of the kernel.
        public let kernelId: String?
        public let monitoring: RunInstancesMonitoringEnabled?
        /// The instance type.
        public let instanceType: InstanceType?
        /// One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
        public let securityGroups: GroupIdentifierList?
        /// The name of the key pair.
        public let keyName: String?
        /// Deprecated.
        public let addressingType: String?
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfileSpecification?
        /// The ID of the AMI.
        public let imageId: String?
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        public let networkInterfaces: InstanceNetworkInterfaceSpecificationList?
        /// The placement information for the instance.
        public let placement: SpotPlacement?
        /// The ID of the RAM disk.
        public let ramdiskId: String?

        public init(blockDeviceMappings: BlockDeviceMappingList? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, instanceType: InstanceType? = nil, securityGroups: GroupIdentifierList? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.RunInstancesMonitoringEnabled(dictionary: monitoring) } else { self.monitoring = nil }
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            if let securityGroups = dictionary["GroupSet"] as? [String: Any] { self.securityGroups = try Ec2.GroupIdentifierList(dictionary: securityGroups) } else { self.securityGroups = nil }
            self.keyName = dictionary["KeyName"] as? String
            self.addressingType = dictionary["AddressingType"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
            self.imageId = dictionary["ImageId"] as? String
            if let networkInterfaces = dictionary["NetworkInterfaceSet"] as? [String: Any] { self.networkInterfaces = try Ec2.InstanceNetworkInterfaceSpecificationList(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.SpotPlacement(dictionary: placement) } else { self.placement = nil }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct RequestSpotInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Spot instance requests.
        public let spotInstanceRequests: SpotInstanceRequestList?

        public init(spotInstanceRequests: SpotInstanceRequestList? = nil) {
            self.spotInstanceRequests = spotInstanceRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let spotInstanceRequests = dictionary["SpotInstanceRequestSet"] as? [String: Any] { self.spotInstanceRequests = try Ec2.SpotInstanceRequestList(dictionary: spotInstanceRequests) } else { self.spotInstanceRequests = nil }
        }
    }

    public struct CreateNetworkAclEntryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24).
        public let cidrBlock: String?
        /// ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.
        public let icmpTypeCode: IcmpTypeCode?
        /// The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number. Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.
        public let ruleNumber: Int32
        /// The protocol. A value of -1 or all means all protocols. If you specify all, -1, or a protocol number other than tcp, udp, or icmp, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.
        public let `protocol`: String
        /// Indicates whether to allow or deny the traffic that matches the rule.
        public let ruleAction: RuleAction
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the network ACL.
        public let networkAclId: String
        /// Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).
        public let egress: Bool
        /// The IPv6 network range to allow or deny, in CIDR notation (for example 2001:db8:1234:1a00::/64).
        public let ipv6CidrBlock: String?
        /// TCP or UDP protocols: The range of ports the rule applies to.
        public let portRange: PortRange?

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32, protocol: String, ruleAction: RuleAction, dryRun: Bool? = nil, networkAclId: String, egress: Bool, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.dryRun = dryRun
            self.networkAclId = networkAclId
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrBlock = dictionary["CidrBlock"] as? String
            if let icmpTypeCode = dictionary["Icmp"] as? [String: Any] { self.icmpTypeCode = try Ec2.IcmpTypeCode(dictionary: icmpTypeCode) } else { self.icmpTypeCode = nil }
            guard let ruleNumber = dictionary["RuleNumber"] as? Int32 else { throw InitializableError.missingRequiredParam("RuleNumber") }
            self.ruleNumber = ruleNumber
            guard let `protocol` = dictionary["Protocol"] as? String else { throw InitializableError.missingRequiredParam("Protocol") }
            self.`protocol` = `protocol`
            guard let rawRuleAction = dictionary["RuleAction"] as? String, let ruleAction = RuleAction(rawValue: rawRuleAction) else { throw InitializableError.missingRequiredParam("RuleAction") }
            self.ruleAction = ruleAction
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
            guard let egress = dictionary["Egress"] as? Bool else { throw InitializableError.missingRequiredParam("Egress") }
            self.egress = egress
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            if let portRange = dictionary["PortRange"] as? [String: Any] { self.portRange = try Ec2.PortRange(dictionary: portRange) } else { self.portRange = nil }
        }
    }

    public struct CancelBundleTaskResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the bundle task.
        public let bundleTask: BundleTask?

        public init(bundleTask: BundleTask? = nil) {
            self.bundleTask = bundleTask
        }

        public init(dictionary: [String: Any]) throws {
            if let bundleTask = dictionary["BundleInstanceTask"] as? [String: Any] { self.bundleTask = try Ec2.BundleTask(dictionary: bundleTask) } else { self.bundleTask = nil }
        }
    }

    public struct VpcPeeringConnection: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the requester VPC.
        public let requesterVpcInfo: VpcPeeringConnectionVpcInfo?
        /// Information about the accepter VPC. CIDR block information is not returned when creating a VPC peering connection, or when describing a VPC peering connection that's in the initiating-request or pending-acceptance state.
        public let accepterVpcInfo: VpcPeeringConnectionVpcInfo?
        /// The status of the VPC peering connection.
        public let status: VpcPeeringConnectionStateReason?
        /// The time that an unaccepted VPC peering connection will expire.
        public let expirationTime: Date?
        /// Any tags assigned to the resource.
        public let tags: TagList?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String?

        public init(requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil, accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil, status: VpcPeeringConnectionStateReason? = nil, expirationTime: Date? = nil, tags: TagList? = nil, vpcPeeringConnectionId: String? = nil) {
            self.requesterVpcInfo = requesterVpcInfo
            self.accepterVpcInfo = accepterVpcInfo
            self.status = status
            self.expirationTime = expirationTime
            self.tags = tags
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            if let requesterVpcInfo = dictionary["RequesterVpcInfo"] as? [String: Any] { self.requesterVpcInfo = try Ec2.VpcPeeringConnectionVpcInfo(dictionary: requesterVpcInfo) } else { self.requesterVpcInfo = nil }
            if let accepterVpcInfo = dictionary["AccepterVpcInfo"] as? [String: Any] { self.accepterVpcInfo = try Ec2.VpcPeeringConnectionVpcInfo(dictionary: accepterVpcInfo) } else { self.accepterVpcInfo = nil }
            if let status = dictionary["Status"] as? [String: Any] { self.status = try Ec2.VpcPeeringConnectionStateReason(dictionary: status) } else { self.status = nil }
            self.expirationTime = dictionary["ExpirationTime"] as? Date
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public enum ShutdownBehavior: String, CustomStringConvertible {
        case stop = "stop"
        case terminate = "terminate"
        public var description: String { return self.rawValue }
    }

    public struct ScheduledInstanceAvailabilitySet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ScheduledInstanceAvailability]?

        public init(item: [ScheduledInstanceAvailability]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ScheduledInstanceAvailability(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct RegisterImageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the newly registered AMI.
        public let imageId: String?

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct PriceScheduleSpecificationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PriceScheduleSpecification]?

        public init(item: [PriceScheduleSpecification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PriceScheduleSpecification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ClientData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A user-defined comment about the disk upload.
        public let comment: String?
        /// The time that the disk upload starts.
        public let uploadStart: Date?
        /// The time that the disk upload ends.
        public let uploadEnd: Date?
        /// The size of the uploaded disk image, in GiB.
        public let uploadSize: Double?

        public init(comment: String? = nil, uploadStart: Date? = nil, uploadEnd: Date? = nil, uploadSize: Double? = nil) {
            self.comment = comment
            self.uploadStart = uploadStart
            self.uploadEnd = uploadEnd
            self.uploadSize = uploadSize
        }

        public init(dictionary: [String: Any]) throws {
            self.comment = dictionary["Comment"] as? String
            self.uploadStart = dictionary["UploadStart"] as? Date
            self.uploadEnd = dictionary["UploadEnd"] as? Date
            self.uploadSize = dictionary["UploadSize"] as? Double
        }
    }

    public struct RejectVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct DiskImageDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The disk image format.
        public let format: DiskImageFormat
        /// The checksum computed for the disk image.
        public let checksum: String?
        /// The size of the disk image, in GiB.
        public let size: Int64
        /// A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the Authenticating REST Requests topic in the Amazon Simple Storage Service Developer Guide. For information about the import manifest referenced by this API action, see VM Import Manifest.
        public let importManifestUrl: String

        public init(format: DiskImageFormat, checksum: String? = nil, size: Int64, importManifestUrl: String) {
            self.format = format
            self.checksum = checksum
            self.size = size
            self.importManifestUrl = importManifestUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawFormat = dictionary["Format"] as? String, let format = DiskImageFormat(rawValue: rawFormat) else { throw InitializableError.missingRequiredParam("Format") }
            self.format = format
            self.checksum = dictionary["Checksum"] as? String
            guard let size = dictionary["Size"] as? Int64 else { throw InitializableError.missingRequiredParam("Size") }
            self.size = size
            guard let importManifestUrl = dictionary["ImportManifestUrl"] as? String else { throw InitializableError.missingRequiredParam("ImportManifestUrl") }
            self.importManifestUrl = importManifestUrl
        }
    }

    public enum EventCode: String, CustomStringConvertible {
        case instance_reboot = "instance-reboot"
        case system_reboot = "system-reboot"
        case system_maintenance = "system-maintenance"
        case instance_retirement = "instance-retirement"
        case instance_stop = "instance-stop"
        public var description: String { return self.rawValue }
    }

    public struct CreateSubnetResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the subnet.
        public let subnet: Subnet?

        public init(subnet: Subnet? = nil) {
            self.subnet = subnet
        }

        public init(dictionary: [String: Any]) throws {
            if let subnet = dictionary["Subnet"] as? [String: Any] { self.subnet = try Ec2.Subnet(dictionary: subnet) } else { self.subnet = nil }
        }
    }

    public struct PrivateIpAddressConfigSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let privateIpAddressConfigSet: [ScheduledInstancesPrivateIpAddressConfig]?

        public init(privateIpAddressConfigSet: [ScheduledInstancesPrivateIpAddressConfig]? = nil) {
            self.privateIpAddressConfigSet = privateIpAddressConfigSet
        }

        public init(dictionary: [String: Any]) throws {
            if let privateIpAddressConfigSet = dictionary["PrivateIpAddressConfigSet"] as? [[String: Any]] {
                self.privateIpAddressConfigSet = try privateIpAddressConfigSet.map({ try ScheduledInstancesPrivateIpAddressConfig(dictionary: $0) })
            } else { 
                self.privateIpAddressConfigSet = nil
            }
        }
    }

    public struct GroupNameStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let groupName: [String]?

        public init(groupName: [String]? = nil) {
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.groupName = dictionary["GroupName"] as? [String]
        }
    }

    public struct GetConsoleOutputResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time the output was last updated.
        public let timestamp: Date?
        /// The ID of the instance.
        public let instanceId: String?
        /// The console output, Base64-encoded. If using a command line tool, the tool decodes the output for you.
        public let output: String?

        public init(timestamp: Date? = nil, instanceId: String? = nil, output: String? = nil) {
            self.timestamp = timestamp
            self.instanceId = instanceId
            self.output = output
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.instanceId = dictionary["InstanceId"] as? String
            self.output = dictionary["Output"] as? String
        }
    }

    public struct InstanceIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct DisassociateRouteTableRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The association ID representing the current association between the route table and subnet.
        public let associationId: String

        public init(dryRun: Bool? = nil, associationId: String) {
            self.dryRun = dryRun
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct AssignIpv6AddressesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        public let ipv6AddressCount: Int32?
        /// One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.
        public let ipv6Addresses: Ipv6AddressList?
        /// The ID of the network interface.
        public let networkInterfaceId: String

        public init(ipv6AddressCount: Int32? = nil, ipv6Addresses: Ipv6AddressList? = nil, networkInterfaceId: String) {
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [String: Any] { self.ipv6Addresses = try Ec2.Ipv6AddressList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
        }
    }

    public struct DescribeImportSnapshotTasksResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to get the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.
        public let importSnapshotTasks: ImportSnapshotTaskList?

        public init(nextToken: String? = nil, importSnapshotTasks: ImportSnapshotTaskList? = nil) {
            self.nextToken = nextToken
            self.importSnapshotTasks = importSnapshotTasks
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let importSnapshotTasks = dictionary["ImportSnapshotTaskSet"] as? [String: Any] { self.importSnapshotTasks = try Ec2.ImportSnapshotTaskList(dictionary: importSnapshotTasks) } else { self.importSnapshotTasks = nil }
        }
    }

    public struct VpnConnectionIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let vpnConnectionId: [String]?

        public init(vpnConnectionId: [String]? = nil) {
            self.vpnConnectionId = vpnConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpnConnectionId = dictionary["VpnConnectionId"] as? [String]
        }
    }

    public struct VolumeStatusInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The details of the volume status.
        public let details: VolumeStatusDetailsList?
        /// The status of the volume.
        public let status: VolumeStatusInfoStatus?

        public init(details: VolumeStatusDetailsList? = nil, status: VolumeStatusInfoStatus? = nil) {
            self.details = details
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let details = dictionary["Details"] as? [String: Any] { self.details = try Ec2.VolumeStatusDetailsList(dictionary: details) } else { self.details = nil }
            if let status = dictionary["Status"] as? String { self.status = VolumeStatusInfoStatus(rawValue: status) } else { self.status = nil }
        }
    }

    public struct DisableVpcClassicLinkDnsSupportRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?

        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
        }
    }

    public struct RouteTableList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [RouteTable]?

        public init(item: [RouteTable]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try RouteTable(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeSubnetsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more subnets.
        public let subnets: SubnetList?

        public init(subnets: SubnetList? = nil) {
            self.subnets = subnets
        }

        public init(dictionary: [String: Any]) throws {
            if let subnets = dictionary["SubnetSet"] as? [String: Any] { self.subnets = try Ec2.SubnetList(dictionary: subnets) } else { self.subnets = nil }
        }
    }

    public struct DeleteVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public let `return`: Bool?

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct StaleSecurityGroupSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [StaleSecurityGroup]?

        public init(item: [StaleSecurityGroup]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try StaleSecurityGroup(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct UserBucketDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The S3 bucket from which the disk image was created.
        public let s3Bucket: String?
        /// The file name of the disk image.
        public let s3Key: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Bucket = dictionary["S3Bucket"] as? String
            self.s3Key = dictionary["S3Key"] as? String
        }
    }

    public struct RequestSpotFleetResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String

        public init(spotFleetRequestId: String) {
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct DeleteVpcEndpointsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the endpoints that were not successfully deleted.
        public let unsuccessful: UnsuccessfulItemSet?

        public init(unsuccessful: UnsuccessfulItemSet? = nil) {
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let unsuccessful = dictionary["Unsuccessful"] as? [String: Any] { self.unsuccessful = try Ec2.UnsuccessfulItemSet(dictionary: unsuccessful) } else { self.unsuccessful = nil }
        }
    }

    public struct DescribeEgressOnlyInternetGatewaysRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned.
        public let maxResults: Int32?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token to retrieve the next page of results.
        public let nextToken: String?
        /// One or more egress-only Internet gateway IDs.
        public let egressOnlyInternetGatewayIds: EgressOnlyInternetGatewayIdList?

        public init(maxResults: Int32? = nil, dryRun: Bool? = nil, nextToken: String? = nil, egressOnlyInternetGatewayIds: EgressOnlyInternetGatewayIdList? = nil) {
            self.maxResults = maxResults
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.egressOnlyInternetGatewayIds = egressOnlyInternetGatewayIds
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            if let egressOnlyInternetGatewayIds = dictionary["EgressOnlyInternetGatewayId"] as? [String: Any] { self.egressOnlyInternetGatewayIds = try Ec2.EgressOnlyInternetGatewayIdList(dictionary: egressOnlyInternetGatewayIds) } else { self.egressOnlyInternetGatewayIds = nil }
        }
    }

    public struct AttachInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// The ID of the Internet gateway.
        public let internetGatewayId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, internetGatewayId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let internetGatewayId = dictionary["InternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("InternetGatewayId") }
            self.internetGatewayId = internetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CopySnapshotResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the new snapshot.
        public let snapshotId: String?

        public init(snapshotId: String? = nil) {
            self.snapshotId = snapshotId
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
        }
    }

    public struct VpcIpv6CidrBlockAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the state of the CIDR block.
        public let ipv6CidrBlockState: VpcCidrBlockState?
        /// The IPv6 CIDR block.
        public let ipv6CidrBlock: String?
        /// The association ID for the IPv6 CIDR block.
        public let associationId: String?

        public init(ipv6CidrBlockState: VpcCidrBlockState? = nil, ipv6CidrBlock: String? = nil, associationId: String? = nil) {
            self.ipv6CidrBlockState = ipv6CidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            if let ipv6CidrBlockState = dictionary["Ipv6CidrBlockState"] as? [String: Any] { self.ipv6CidrBlockState = try Ec2.VpcCidrBlockState(dictionary: ipv6CidrBlockState) } else { self.ipv6CidrBlockState = nil }
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct ScheduledInstancesIamInstanceProfile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name.
        public let name: String?
        /// The Amazon Resource Name (ARN).
        public let arn: String?

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.arn = dictionary["Arn"] as? String
        }
    }

    public struct ImportInstanceVolumeDetailSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ImportInstanceVolumeDetailItem]?

        public init(item: [ImportInstanceVolumeDetailItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ImportInstanceVolumeDetailItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AcceptVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPC peering connection.
        public let vpcPeeringConnection: VpcPeeringConnection?

        public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
            self.vpcPeeringConnection = vpcPeeringConnection
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcPeeringConnection = dictionary["VpcPeeringConnection"] as? [String: Any] { self.vpcPeeringConnection = try Ec2.VpcPeeringConnection(dictionary: vpcPeeringConnection) } else { self.vpcPeeringConnection = nil }
        }
    }

    public struct ImportSnapshotResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description of the import snapshot task.
        public let description: String?
        /// Information about the import snapshot task.
        public let snapshotTaskDetail: SnapshotTaskDetail?
        /// The ID of the import snapshot task.
        public let importTaskId: String?

        public init(description: String? = nil, snapshotTaskDetail: SnapshotTaskDetail? = nil, importTaskId: String? = nil) {
            self.description = description
            self.snapshotTaskDetail = snapshotTaskDetail
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            if let snapshotTaskDetail = dictionary["SnapshotTaskDetail"] as? [String: Any] { self.snapshotTaskDetail = try Ec2.SnapshotTaskDetail(dictionary: snapshotTaskDetail) } else { self.snapshotTaskDetail = nil }
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct SnapshotDiskContainer: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The S3 bucket for the disk image.
        public let userBucket: UserBucket?
        /// The format of the disk image being imported. Valid values: RAW | VHD | VMDK | OVA 
        public let format: String?
        /// The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).
        public let url: String?
        /// The description of the disk image being imported.
        public let description: String?

        public init(userBucket: UserBucket? = nil, format: String? = nil, url: String? = nil, description: String? = nil) {
            self.userBucket = userBucket
            self.format = format
            self.url = url
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucket(dictionary: userBucket) } else { self.userBucket = nil }
            self.format = dictionary["Format"] as? String
            self.url = dictionary["Url"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DeleteFlowLogsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the flow logs that could not be deleted successfully.
        public let unsuccessful: UnsuccessfulItemSet?

        public init(unsuccessful: UnsuccessfulItemSet? = nil) {
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let unsuccessful = dictionary["Unsuccessful"] as? [String: Any] { self.unsuccessful = try Ec2.UnsuccessfulItemSet(dictionary: unsuccessful) } else { self.unsuccessful = nil }
        }
    }

    public struct DescribeDhcpOptionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more DHCP options sets.
        public let dhcpOptions: DhcpOptionsList?

        public init(dhcpOptions: DhcpOptionsList? = nil) {
            self.dhcpOptions = dhcpOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let dhcpOptions = dictionary["DhcpOptionsSet"] as? [String: Any] { self.dhcpOptions = try Ec2.DhcpOptionsList(dictionary: dhcpOptions) } else { self.dhcpOptions = nil }
        }
    }

    public struct UserIdGroupPairSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [UserIdGroupPair]?

        public init(item: [UserIdGroupPair]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try UserIdGroupPair(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DeleteRouteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the route table.
        public let routeTableId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public let destinationCidrBlock: String?
        /// The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public let destinationIpv6CidrBlock: String?

        public init(routeTableId: String, dryRun: Bool? = nil, destinationCidrBlock: String? = nil, destinationIpv6CidrBlock: String? = nil) {
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
        }
    }

    public struct IamInstanceProfileAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The time the IAM instance profile was associated with the instance.
        public let timestamp: Date?
        /// The ID of the association.
        public let associationId: String?
        /// The ID of the instance.
        public let instanceId: String?
        /// The state of the association.
        public let state: IamInstanceProfileAssociationState?
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfile?

        public init(timestamp: Date? = nil, associationId: String? = nil, instanceId: String? = nil, state: IamInstanceProfileAssociationState? = nil, iamInstanceProfile: IamInstanceProfile? = nil) {
            self.timestamp = timestamp
            self.associationId = associationId
            self.instanceId = instanceId
            self.state = state
            self.iamInstanceProfile = iamInstanceProfile
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.associationId = dictionary["AssociationId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            if let state = dictionary["State"] as? String { self.state = IamInstanceProfileAssociationState(rawValue: state) } else { self.state = nil }
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfile(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
        }
    }

    public struct PeeringConnectionOptions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.
        public let allowEgressFromLocalVpcToRemoteClassicLink: Bool?
        /// If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        public let allowDnsResolutionFromRemoteVpc: Bool?
        /// If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.
        public let allowEgressFromLocalClassicLinkToRemoteVpc: Bool?

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

        public init(dictionary: [String: Any]) throws {
            self.allowEgressFromLocalVpcToRemoteClassicLink = dictionary["AllowEgressFromLocalVpcToRemoteClassicLink"] as? Bool
            self.allowDnsResolutionFromRemoteVpc = dictionary["AllowDnsResolutionFromRemoteVpc"] as? Bool
            self.allowEgressFromLocalClassicLinkToRemoteVpc = dictionary["AllowEgressFromLocalClassicLinkToRemoteVpc"] as? Bool
        }
    }

    public struct DetachVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the virtual private gateway.
        public let vpnGatewayId: String

        public init(vpcId: String, dryRun: Bool? = nil, vpnGatewayId: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct RouteTableAssociation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet. A subnet ID is not returned for an implicit association.
        public let subnetId: String?
        /// The ID of the route table.
        public let routeTableId: String?
        /// The ID of the association between a route table and a subnet.
        public let routeTableAssociationId: String?
        /// Indicates whether this is the main route table.
        public let main: Bool?

        public init(subnetId: String? = nil, routeTableId: String? = nil, routeTableAssociationId: String? = nil, main: Bool? = nil) {
            self.subnetId = subnetId
            self.routeTableId = routeTableId
            self.routeTableAssociationId = routeTableAssociationId
            self.main = main
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.routeTableId = dictionary["RouteTableId"] as? String
            self.routeTableAssociationId = dictionary["RouteTableAssociationId"] as? String
            self.main = dictionary["Main"] as? Bool
        }
    }

    public struct ReservedInstancesListingList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstancesListing]?

        public init(item: [ReservedInstancesListing]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstancesListing(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct UnmonitorInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more instance IDs.
        public let instanceIds: InstanceIdStringList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceIds: InstanceIdStringList, dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceIds = try Ec2.InstanceIdStringList(dictionary: instanceIds)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeExportTasksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more export task IDs.
        public let exportTaskIds: ExportTaskIdStringList?

        public init(exportTaskIds: ExportTaskIdStringList? = nil) {
            self.exportTaskIds = exportTaskIds
        }

        public init(dictionary: [String: Any]) throws {
            if let exportTaskIds = dictionary["ExportTaskId"] as? [String: Any] { self.exportTaskIds = try Ec2.ExportTaskIdStringList(dictionary: exportTaskIds) } else { self.exportTaskIds = nil }
        }
    }

    public struct PricingDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The price per instance.
        public let price: Double?
        /// The number of reservations available for the price.
        public let count: Int32?

        public init(price: Double? = nil, count: Int32? = nil) {
            self.price = price
            self.count = count
        }

        public init(dictionary: [String: Any]) throws {
            self.price = dictionary["Price"] as? Double
            self.count = dictionary["Count"] as? Int32
        }
    }

    public struct ConversionIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct VolumeList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Volume]?

        public init(item: [Volume]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Volume(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct GetConsoleScreenshotResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the instance.
        public let instanceId: String?
        /// The data that comprises the image.
        public let imageData: String?

        public init(instanceId: String? = nil, imageData: String? = nil) {
            self.instanceId = instanceId
            self.imageData = imageData
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
            self.imageData = dictionary["ImageData"] as? String
        }
    }

    public struct DescribeReservedInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Reserved Instance IDs. Default: Describes all your Reserved Instances, or only those otherwise specified.
        public let reservedInstancesIds: ReservedInstancesIdStringList?
        /// One or more filters.    availability-zone - The Availability Zone where the Reserved Instance can be used.    duration - The duration of the Reserved Instance (one year or three years), in seconds (31536000 | 94608000).    end - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).    fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).    instance-type - The instance type that is covered by the reservation.    scope - The scope of the Reserved Instance (Region or Availability Zone).    product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web | Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC)).    reserved-instances-id - The ID of the Reserved Instance.    start - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).    state - The state of the Reserved Instance (payment-pending | active | payment-failed | retired).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type.
        public let offeringType: OfferingTypeValues?
        /// Describes whether the Reserved Instance is Standard or Convertible.
        public let offeringClass: OfferingClassType?

        public init(reservedInstancesIds: ReservedInstancesIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, offeringType: OfferingTypeValues? = nil, offeringClass: OfferingClassType? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.filters = filters
            self.dryRun = dryRun
            self.offeringType = offeringType
            self.offeringClass = offeringClass
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesIds = dictionary["ReservedInstancesId"] as? [String: Any] { self.reservedInstancesIds = try Ec2.ReservedInstancesIdStringList(dictionary: reservedInstancesIds) } else { self.reservedInstancesIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let offeringType = dictionary["OfferingType"] as? String { self.offeringType = OfferingTypeValues(rawValue: offeringType) } else { self.offeringType = nil }
            if let offeringClass = dictionary["OfferingClass"] as? String { self.offeringClass = OfferingClassType(rawValue: offeringClass) } else { self.offeringClass = nil }
        }
    }

    public struct Placement: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the ImportInstance command.
        public let affinity: String?
        /// The name of the placement group the instance is in (for cluster compute instances).
        public let groupName: String?
        /// The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the ImportInstance command.
        public let hostId: String?
        /// The Availability Zone of the instance.
        public let availabilityZone: String?
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the ImportInstance command.
        public let tenancy: Tenancy?

        public init(affinity: String? = nil, groupName: String? = nil, hostId: String? = nil, availabilityZone: String? = nil, tenancy: Tenancy? = nil) {
            self.affinity = affinity
            self.groupName = groupName
            self.hostId = hostId
            self.availabilityZone = availabilityZone
            self.tenancy = tenancy
        }

        public init(dictionary: [String: Any]) throws {
            self.affinity = dictionary["Affinity"] as? String
            self.groupName = dictionary["GroupName"] as? String
            self.hostId = dictionary["HostId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let tenancy = dictionary["Tenancy"] as? String { self.tenancy = Tenancy(rawValue: tenancy) } else { self.tenancy = nil }
        }
    }

    public struct VolumeStatusList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VolumeStatusItem]?

        public init(item: [VolumeStatusItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VolumeStatusItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct RouteList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Route]?

        public init(item: [Route]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Route(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum AttachmentStatus: String, CustomStringConvertible {
        case attaching = "attaching"
        case attached = "attached"
        case detaching = "detaching"
        case detached = "detached"
        public var description: String { return self.rawValue }
    }

    public struct DescribeStaleSecurityGroupsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the stale security groups.
        public let staleSecurityGroupSet: StaleSecurityGroupSet?
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public let nextToken: String?

        public init(staleSecurityGroupSet: StaleSecurityGroupSet? = nil, nextToken: String? = nil) {
            self.staleSecurityGroupSet = staleSecurityGroupSet
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let staleSecurityGroupSet = dictionary["StaleSecurityGroupSet"] as? [String: Any] { self.staleSecurityGroupSet = try Ec2.StaleSecurityGroupSet(dictionary: staleSecurityGroupSet) } else { self.staleSecurityGroupSet = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct ScheduledInstancesNetworkInterface: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The index of the device for the network interface attachment.
        public let deviceIndex: Int32?
        /// The ID of the subnet.
        public let subnetId: String?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The IPv4 address of the network interface within the subnet.
        public let privateIpAddress: String?
        /// The private IPv4 addresses.
        public let privateIpAddressConfigs: PrivateIpAddressConfigSet?
        /// The number of secondary private IPv4 addresses.
        public let secondaryPrivateIpAddressCount: Int32?
        /// The description.
        public let description: String?
        /// The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.
        public let ipv6AddressCount: Int32?
        /// One or more specific IPv6 addresses from the subnet range.
        public let ipv6Addresses: ScheduledInstancesIpv6AddressList?
        /// Indicates whether to delete the interface when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The IDs of one or more security groups.
        public let groups: ScheduledInstancesSecurityGroupIdSet?
        /// Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
        public let associatePublicIpAddress: Bool?

        public init(deviceIndex: Int32? = nil, subnetId: String? = nil, networkInterfaceId: String? = nil, privateIpAddress: String? = nil, privateIpAddressConfigs: PrivateIpAddressConfigSet? = nil, secondaryPrivateIpAddressCount: Int32? = nil, description: String? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: ScheduledInstancesIpv6AddressList? = nil, deleteOnTermination: Bool? = nil, groups: ScheduledInstancesSecurityGroupIdSet? = nil, associatePublicIpAddress: Bool? = nil) {
            self.deviceIndex = deviceIndex
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddressConfigs = privateIpAddressConfigs
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.description = description
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.deleteOnTermination = deleteOnTermination
            self.groups = groups
            self.associatePublicIpAddress = associatePublicIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            if let privateIpAddressConfigs = dictionary["PrivateIpAddressConfig"] as? [String: Any] { self.privateIpAddressConfigs = try Ec2.PrivateIpAddressConfigSet(dictionary: privateIpAddressConfigs) } else { self.privateIpAddressConfigs = nil }
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            self.description = dictionary["Description"] as? String
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Address"] as? [String: Any] { self.ipv6Addresses = try Ec2.ScheduledInstancesIpv6AddressList(dictionary: ipv6Addresses) } else { self.ipv6Addresses = nil }
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            if let groups = dictionary["Group"] as? [String: Any] { self.groups = try Ec2.ScheduledInstancesSecurityGroupIdSet(dictionary: groups) } else { self.groups = nil }
            self.associatePublicIpAddress = dictionary["AssociatePublicIpAddress"] as? Bool
        }
    }

    public struct UserIdGroupPair: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
        public let userId: String?
        /// The status of a VPC peering connection, if applicable.
        public let peeringStatus: String?
        /// The ID of the VPC for the referenced security group, if applicable.
        public let vpcId: String?
        /// The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
        public let groupName: String?
        /// The ID of the security group.
        public let groupId: String?
        /// The ID of the VPC peering connection, if applicable.
        public let vpcPeeringConnectionId: String?

        public init(userId: String? = nil, peeringStatus: String? = nil, vpcId: String? = nil, groupName: String? = nil, groupId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.userId = userId
            self.peeringStatus = peeringStatus
            self.vpcId = vpcId
            self.groupName = groupName
            self.groupId = groupId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            self.peeringStatus = dictionary["PeeringStatus"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            self.groupName = dictionary["GroupName"] as? String
            self.groupId = dictionary["GroupId"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct DescribeConversionTasksRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more conversion task IDs.
        public let conversionTaskIds: ConversionIdStringList?

        public init(dryRun: Bool? = nil, conversionTaskIds: ConversionIdStringList? = nil) {
            self.dryRun = dryRun
            self.conversionTaskIds = conversionTaskIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let conversionTaskIds = dictionary["ConversionTaskId"] as? [String: Any] { self.conversionTaskIds = try Ec2.ConversionIdStringList(dictionary: conversionTaskIds) } else { self.conversionTaskIds = nil }
        }
    }

    public struct ModifySubnetAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specify true to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).
        public let mapPublicIpOnLaunch: AttributeBooleanValue?
        /// The ID of the subnet.
        public let subnetId: String
        /// Specify true to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address).  If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version 2016-11-15 or later of the Amazon EC2 API.
        public let assignIpv6AddressOnCreation: AttributeBooleanValue?

        public init(mapPublicIpOnLaunch: AttributeBooleanValue? = nil, subnetId: String, assignIpv6AddressOnCreation: AttributeBooleanValue? = nil) {
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.subnetId = subnetId
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        }

        public init(dictionary: [String: Any]) throws {
            if let mapPublicIpOnLaunch = dictionary["MapPublicIpOnLaunch"] as? [String: Any] { self.mapPublicIpOnLaunch = try Ec2.AttributeBooleanValue(dictionary: mapPublicIpOnLaunch) } else { self.mapPublicIpOnLaunch = nil }
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            if let assignIpv6AddressOnCreation = dictionary["AssignIpv6AddressOnCreation"] as? [String: Any] { self.assignIpv6AddressOnCreation = try Ec2.AttributeBooleanValue(dictionary: assignIpv6AddressOnCreation) } else { self.assignIpv6AddressOnCreation = nil }
        }
    }

    public struct PlacementGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state of the placement group.
        public let state: PlacementGroupState?
        /// The placement strategy.
        public let strategy: PlacementStrategy?
        /// The name of the placement group.
        public let groupName: String?

        public init(state: PlacementGroupState? = nil, strategy: PlacementStrategy? = nil, groupName: String? = nil) {
            self.state = state
            self.strategy = strategy
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            if let state = dictionary["State"] as? String { self.state = PlacementGroupState(rawValue: state) } else { self.state = nil }
            if let strategy = dictionary["Strategy"] as? String { self.strategy = PlacementStrategy(rawValue: strategy) } else { self.strategy = nil }
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct InstanceBlockDeviceMappingSpecificationList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceBlockDeviceMappingSpecification]?

        public init(item: [InstanceBlockDeviceMappingSpecification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceBlockDeviceMappingSpecification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct AssociateAddressResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.
        public let associationId: String?

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct Reservation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).
        public let requesterId: String?
        /// One or more instances.
        public let instances: InstanceList?
        /// The ID of the reservation.
        public let reservationId: String?
        /// The ID of the AWS account that owns the reservation.
        public let ownerId: String?
        /// [EC2-Classic only] One or more security groups.
        public let groups: GroupIdentifierList?

        public init(requesterId: String? = nil, instances: InstanceList? = nil, reservationId: String? = nil, ownerId: String? = nil, groups: GroupIdentifierList? = nil) {
            self.requesterId = requesterId
            self.instances = instances
            self.reservationId = reservationId
            self.ownerId = ownerId
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            self.requesterId = dictionary["RequesterId"] as? String
            if let instances = dictionary["InstancesSet"] as? [String: Any] { self.instances = try Ec2.InstanceList(dictionary: instances) } else { self.instances = nil }
            self.reservationId = dictionary["ReservationId"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let groups = dictionary["GroupSet"] as? [String: Any] { self.groups = try Ec2.GroupIdentifierList(dictionary: groups) } else { self.groups = nil }
        }
    }

    public enum ReservationState: String, CustomStringConvertible {
        case payment_pending = "payment-pending"
        case payment_failed = "payment-failed"
        case active = "active"
        case retired = "retired"
        public var description: String { return self.rawValue }
    }

    public struct SpotFleetRequestConfigData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O.
        public let targetCapacity: Int32
        /// A unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see Ensuring Idempotency.
        public let clientToken: String?
        /// Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using CancelSpotFleetRequests or when the Spot fleet request expires, if you set terminateInstancesWithExpiration.
        public let iamFleetRole: String
        /// The bid price per unit hour.
        public let spotPrice: String
        /// The end date and time of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request.
        public let validUntil: Date?
        /// Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is lowestPrice.
        public let allocationStrategy: AllocationStrategy?
        /// Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.
        public let excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy?
        /// Information about the launch specifications for the Spot fleet request.
        public let launchSpecifications: LaunchSpecsList
        /// The start date and time of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). The default is to start fulfilling the request immediately.
        public let validFrom: Date?
        /// Indicates whether running Spot instances should be terminated when the Spot fleet request expires.
        public let terminateInstancesWithExpiration: Bool?
        /// Indicates whether Spot fleet should replace unhealthy instances.
        public let replaceUnhealthyInstances: Bool?
        /// The number of units fulfilled by this request compared to the set target capacity.
        public let fulfilledCapacity: Double?
        /// The type of request. Indicates whether the fleet will only request the target capacity or also attempt to maintain it. When you request a certain target capacity, the fleet will only place the required bids. It will not attempt to replenish Spot instances if capacity is diminished, nor will it submit bids in alternative Spot pools if capacity is not available. When you want to maintain a certain target capacity, fleet will place the required bids to meet this target capacity. It will also automatically replenish any interrupted instances. Default: maintain.
        public let `type`: FleetType?

        public init(targetCapacity: Int32, clientToken: String? = nil, iamFleetRole: String, spotPrice: String, validUntil: Date? = nil, allocationStrategy: AllocationStrategy? = nil, excessCapacityTerminationPolicy: ExcessCapacityTerminationPolicy? = nil, launchSpecifications: LaunchSpecsList, validFrom: Date? = nil, terminateInstancesWithExpiration: Bool? = nil, replaceUnhealthyInstances: Bool? = nil, fulfilledCapacity: Double? = nil, type: FleetType? = nil) {
            self.targetCapacity = targetCapacity
            self.clientToken = clientToken
            self.iamFleetRole = iamFleetRole
            self.spotPrice = spotPrice
            self.validUntil = validUntil
            self.allocationStrategy = allocationStrategy
            self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
            self.launchSpecifications = launchSpecifications
            self.validFrom = validFrom
            self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
            self.replaceUnhealthyInstances = replaceUnhealthyInstances
            self.fulfilledCapacity = fulfilledCapacity
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            guard let targetCapacity = dictionary["TargetCapacity"] as? Int32 else { throw InitializableError.missingRequiredParam("TargetCapacity") }
            self.targetCapacity = targetCapacity
            self.clientToken = dictionary["ClientToken"] as? String
            guard let iamFleetRole = dictionary["IamFleetRole"] as? String else { throw InitializableError.missingRequiredParam("IamFleetRole") }
            self.iamFleetRole = iamFleetRole
            guard let spotPrice = dictionary["SpotPrice"] as? String else { throw InitializableError.missingRequiredParam("SpotPrice") }
            self.spotPrice = spotPrice
            self.validUntil = dictionary["ValidUntil"] as? Date
            if let allocationStrategy = dictionary["AllocationStrategy"] as? String { self.allocationStrategy = AllocationStrategy(rawValue: allocationStrategy) } else { self.allocationStrategy = nil }
            if let excessCapacityTerminationPolicy = dictionary["ExcessCapacityTerminationPolicy"] as? String { self.excessCapacityTerminationPolicy = ExcessCapacityTerminationPolicy(rawValue: excessCapacityTerminationPolicy) } else { self.excessCapacityTerminationPolicy = nil }
            guard let launchSpecifications = dictionary["LaunchSpecifications"] as? [String: Any] else { throw InitializableError.missingRequiredParam("LaunchSpecifications") }
            self.launchSpecifications = try Ec2.LaunchSpecsList(dictionary: launchSpecifications)
            self.validFrom = dictionary["ValidFrom"] as? Date
            self.terminateInstancesWithExpiration = dictionary["TerminateInstancesWithExpiration"] as? Bool
            self.replaceUnhealthyInstances = dictionary["ReplaceUnhealthyInstances"] as? Bool
            self.fulfilledCapacity = dictionary["FulfilledCapacity"] as? Double
            if let `type` = dictionary["Type"] as? String { self.`type` = FleetType(rawValue: `type`) } else { self.`type` = nil }
        }
    }

    public struct ImageList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Image]?

        public init(item: [Image]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Image(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum BundleTaskState: String, CustomStringConvertible {
        case pending = "pending"
        case waiting_for_shutdown = "waiting-for-shutdown"
        case bundling = "bundling"
        case storing = "storing"
        case cancelling = "cancelling"
        case complete = "complete"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public struct DeleteInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the Internet gateway.
        public let internetGatewayId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(internetGatewayId: String, dryRun: Bool? = nil) {
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let internetGatewayId = dictionary["InternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("InternetGatewayId") }
            self.internetGatewayId = internetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ScheduledInstancesBlockDeviceMapping: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Suppresses the specified device included in the block device mapping of the AMI.
        public let noDevice: String?
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for ephemeral0 and ephemeral1.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        public let virtualName: String?
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public let deviceName: String?
        /// Parameters used to set up EBS volumes automatically when the instance is launched.
        public let ebs: ScheduledInstancesEbs?

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: ScheduledInstancesEbs? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.ScheduledInstancesEbs(dictionary: ebs) } else { self.ebs = nil }
        }
    }

    public struct StateReason: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The reason code for the state change.
        public let code: String?
        /// The message for the state change.    Server.InsufficientInstanceCapacity: There was insufficient instance capacity to satisfy the launch request.    Server.InternalError: An internal error occurred during instance launch, resulting in termination.    Server.ScheduledStop: The instance was stopped due to a scheduled retirement.    Server.SpotInstanceTermination: A Spot instance was terminated due to an increase in the market price.    Client.InternalError: A client error caused the instance to terminate on launch.    Client.InstanceInitiatedShutdown: The instance was shut down using the shutdown -h command from the instance.    Client.UserInitiatedShutdown: The instance was shut down using the Amazon EC2 API.    Client.VolumeLimitExceeded: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your limits.    Client.InvalidSnapshot.NotFound: The specified snapshot was not found.  
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DeleteTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more tags to delete. If you omit the value parameter, we delete the tag regardless of its value. If you specify this parameter with an empty string as the value, we delete the key only if its value is an empty string.
        public let tags: TagList?
        /// The ID of the resource. For example, ami-1a2b3c4d. You can specify more than one resource ID.
        public let resources: [String]

        public init(dryRun: Bool? = nil, tags: TagList? = nil, resources: [String]) {
            self.dryRun = dryRun
            self.tags = tags
            self.resources = resources
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let tags = dictionary["Tag"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            guard let resources = dictionary["ResourceId"] as? [String] else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resources = resources
        }
    }

    public struct InstancePrivateIpAddressList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstancePrivateIpAddress]?

        public init(item: [InstancePrivateIpAddress]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstancePrivateIpAddress(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum VpcPeeringConnectionStateReasonCode: String, CustomStringConvertible {
        case initiating_request = "initiating-request"
        case pending_acceptance = "pending-acceptance"
        case active = "active"
        case deleted = "deleted"
        case rejected = "rejected"
        case failed = "failed"
        case expired = "expired"
        case provisioning = "provisioning"
        case deleting = "deleting"
        public var description: String { return self.rawValue }
    }

    public struct IdFormatList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [IdFormat]?

        public init(item: [IdFormat]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try IdFormat(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct InstanceBlockDeviceMappingList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [InstanceBlockDeviceMapping]?

        public init(item: [InstanceBlockDeviceMapping]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try InstanceBlockDeviceMapping(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeSpotInstanceRequestsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    availability-zone-group - The Availability Zone group.    create-time - The time stamp when the Spot instance request was created.    fault-code - The fault code related to the request.    fault-message - The fault message related to the request.    instance-id - The ID of the instance that fulfilled the request.    launch-group - The Spot instance launch group.    launch.block-device-mapping.delete-on-termination - Indicates whether the Amazon EBS volume is deleted on instance termination.    launch.block-device-mapping.device-name - The device name for the Amazon EBS volume (for example, /dev/sdh).    launch.block-device-mapping.snapshot-id - The ID of the snapshot used for the Amazon EBS volume.    launch.block-device-mapping.volume-size - The size of the Amazon EBS volume, in GiB.    launch.block-device-mapping.volume-type - The type of the Amazon EBS volume: gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1for Cold HDD, or standard for Magnetic.    launch.group-id - The security group for the instance.    launch.image-id - The ID of the AMI.    launch.instance-type - The type of instance (for example, m3.medium).    launch.kernel-id - The kernel ID.    launch.key-name - The name of the key pair the instance launched with.    launch.monitoring-enabled - Whether monitoring is enabled for the Spot instance.    launch.ramdisk-id - The RAM disk ID.    network-interface.network-interface-id - The ID of the network interface.    network-interface.device-index - The index of the device for the network interface attachment on the instance.    network-interface.subnet-id - The ID of the subnet for the instance.    network-interface.description - A description of the network interface.    network-interface.private-ip-address - The primary private IP address of the network interface.    network-interface.delete-on-termination - Indicates whether the network interface is deleted when the instance is terminated.    network-interface.group-id - The ID of the security group associated with the network interface.    network-interface.group-name - The name of the security group associated with the network interface.    network-interface.addresses.primary - Indicates whether the IP address is the primary private IP address.    product-description - The product description associated with the instance (Linux/UNIX | Windows).    spot-instance-request-id - The Spot instance request ID.    spot-price - The maximum hourly price for any Spot instance launched to fulfill the request.    state - The state of the Spot instance request (open | active | closed | cancelled | failed). Spot bid status information can help you track your Amazon EC2 Spot instance requests. For more information, see Spot Bid Status in the Amazon Elastic Compute Cloud User Guide.    status-code - The short code describing the most recent evaluation of your Spot instance request.    status-message - The message explaining the status of the Spot instance request.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of Spot instance request (one-time | persistent).    launched-availability-zone - The Availability Zone in which the bid is launched.    valid-from - The start date of the request.    valid-until - The end date of the request.  
        public let filters: FilterList?
        /// One or more Spot instance request IDs.
        public let spotInstanceRequestIds: SpotInstanceRequestIdList?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, spotInstanceRequestIds: SpotInstanceRequestIdList? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let spotInstanceRequestIds = dictionary["SpotInstanceRequestId"] as? [String: Any] { self.spotInstanceRequestIds = try Ec2.SpotInstanceRequestIdList(dictionary: spotInstanceRequestIds) } else { self.spotInstanceRequestIds = nil }
        }
    }

    public struct AttachClassicLinkVpcRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of a ClassicLink-enabled VPC.
        public let vpcId: String
        /// The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.
        public let instanceId: String
        /// The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.
        public let groups: GroupIdStringList

        public init(dryRun: Bool? = nil, vpcId: String, instanceId: String, groups: GroupIdStringList) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let groups = dictionary["SecurityGroupId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SecurityGroupId") }
            self.groups = try Ec2.GroupIdStringList(dictionary: groups)
        }
    }

    public struct ReleaseHostsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the Dedicated Hosts that were successfully released.
        public let successful: ResponseHostIdList?
        /// The IDs of the Dedicated Hosts that could not be released, including an error message.
        public let unsuccessful: UnsuccessfulItemList?

        public init(successful: ResponseHostIdList? = nil, unsuccessful: UnsuccessfulItemList? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let successful = dictionary["Successful"] as? [String: Any] { self.successful = try Ec2.ResponseHostIdList(dictionary: successful) } else { self.successful = nil }
            if let unsuccessful = dictionary["Unsuccessful"] as? [String: Any] { self.unsuccessful = try Ec2.UnsuccessfulItemList(dictionary: unsuccessful) } else { self.unsuccessful = nil }
        }
    }

    public struct ScheduledInstanceIdRequestSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let scheduledInstanceId: [String]?

        public init(scheduledInstanceId: [String]? = nil) {
            self.scheduledInstanceId = scheduledInstanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.scheduledInstanceId = dictionary["ScheduledInstanceId"] as? [String]
        }
    }

    public struct ExportToS3TaskSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.
        public let s3Prefix: String?
        /// The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.
        public let containerFormat: ContainerFormat?
        /// The format for the exported image.
        public let diskImageFormat: DiskImageFormat?
        /// The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account vm-import-export@amazon.com.
        public let s3Bucket: String?

        public init(s3Prefix: String? = nil, containerFormat: ContainerFormat? = nil, diskImageFormat: DiskImageFormat? = nil, s3Bucket: String? = nil) {
            self.s3Prefix = s3Prefix
            self.containerFormat = containerFormat
            self.diskImageFormat = diskImageFormat
            self.s3Bucket = s3Bucket
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Prefix = dictionary["S3Prefix"] as? String
            if let containerFormat = dictionary["ContainerFormat"] as? String { self.containerFormat = ContainerFormat(rawValue: containerFormat) } else { self.containerFormat = nil }
            if let diskImageFormat = dictionary["DiskImageFormat"] as? String { self.diskImageFormat = DiskImageFormat(rawValue: diskImageFormat) } else { self.diskImageFormat = nil }
            self.s3Bucket = dictionary["S3Bucket"] as? String
        }
    }

    public struct CancelSpotFleetRequestsError: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The error code.
        public let code: CancelBatchErrorCode
        /// The description for the error code.
        public let message: String

        public init(code: CancelBatchErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawCode = dictionary["Code"] as? String, let code = CancelBatchErrorCode(rawValue: rawCode) else { throw InitializableError.missingRequiredParam("Code") }
            self.code = code
            guard let message = dictionary["Message"] as? String else { throw InitializableError.missingRequiredParam("Message") }
            self.message = message
        }
    }

    public struct DescribeKeyPairsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    fingerprint - The fingerprint of the key pair.    key-name - The name of the key pair.  
        public let filters: FilterList?
        /// One or more key pair names. Default: Describes all your key pairs.
        public let keyNames: KeyNameStringList?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, keyNames: KeyNameStringList? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.keyNames = keyNames
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            if let keyNames = dictionary["KeyName"] as? [String: Any] { self.keyNames = try Ec2.KeyNameStringList(dictionary: keyNames) } else { self.keyNames = nil }
        }
    }

    public struct DescribeReservedInstancesOfferingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of Reserved Instances offerings.
        public let reservedInstancesOfferings: ReservedInstancesOfferingList?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(reservedInstancesOfferings: ReservedInstancesOfferingList? = nil, nextToken: String? = nil) {
            self.reservedInstancesOfferings = reservedInstancesOfferings
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesOfferings = dictionary["ReservedInstancesOfferingsSet"] as? [String: Any] { self.reservedInstancesOfferings = try Ec2.ReservedInstancesOfferingList(dictionary: reservedInstancesOfferings) } else { self.reservedInstancesOfferings = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public enum RecurringChargeFrequency: String, CustomStringConvertible {
        case hourly = "Hourly"
        public var description: String { return self.rawValue }
    }

    public struct VpnStaticRoute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CIDR block associated with the local subnet of the customer data center.
        public let destinationCidrBlock: String?
        /// The current state of the static route.
        public let state: VpnState?
        /// Indicates how the routes were provided.
        public let source: VpnStaticRouteSource?

        public init(destinationCidrBlock: String? = nil, state: VpnState? = nil, source: VpnStaticRouteSource? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
            self.source = source
        }

        public init(dictionary: [String: Any]) throws {
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
            if let state = dictionary["State"] as? String { self.state = VpnState(rawValue: state) } else { self.state = nil }
            if let source = dictionary["Source"] as? String { self.source = VpnStaticRouteSource(rawValue: source) } else { self.source = nil }
        }
    }

    public struct CopySnapshotRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description for the EBS snapshot.
        public let description: String?
        /// The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when creating the snapshot copy. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. The specified CMK must exist in the region that the snapshot is being copied to. If a KmsKeyId is specified, the Encrypted flag must also be set.
        public let kmsKeyId: String?
        /// The ID of the region that contains the snapshot to be copied.
        public let sourceRegion: String
        /// Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot using this flag, but you cannot use it to create an unencrypted copy from an encrypted snapshot. Your default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        public let encrypted: Bool?
        /// The destination region to use in the PresignedUrl parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a PresignedUrl parameter, where it is required.   CopySnapshot sends the snapshot copy to the regional endpoint that you send the HTTP request to, such as ec2.us-east-1.amazonaws.com (in the AWS CLI, this is specified with the --region parameter or the default region in your AWS configuration file). 
        public let destinationRegion: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The pre-signed URL that facilitates copying an encrypted snapshot. This parameter is only required when copying an encrypted snapshot with the Amazon EC2 Query API; it is available as an optional parameter in all other cases. The PresignedUrl should use the snapshot source endpoint, the CopySnapshot action, and include the SourceRegion, SourceSnapshotId, and DestinationRegion parameters. The PresignedUrl must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in Authenticating Requests by Using Query Parameters (AWS Signature Version 4) in the Amazon Simple Storage Service API Reference. An invalid or improperly signed PresignedUrl will cause the copy operation to fail asynchronously, and the snapshot will move to an error state.
        public let presignedUrl: String?
        /// The ID of the EBS snapshot to copy.
        public let sourceSnapshotId: String

        public init(description: String? = nil, kmsKeyId: String? = nil, sourceRegion: String, encrypted: Bool? = nil, destinationRegion: String? = nil, dryRun: Bool? = nil, presignedUrl: String? = nil, sourceSnapshotId: String) {
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.sourceRegion = sourceRegion
            self.encrypted = encrypted
            self.destinationRegion = destinationRegion
            self.dryRun = dryRun
            self.presignedUrl = presignedUrl
            self.sourceSnapshotId = sourceSnapshotId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
            guard let sourceRegion = dictionary["SourceRegion"] as? String else { throw InitializableError.missingRequiredParam("SourceRegion") }
            self.sourceRegion = sourceRegion
            self.encrypted = dictionary["Encrypted"] as? Bool
            self.destinationRegion = dictionary["DestinationRegion"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.presignedUrl = dictionary["PresignedUrl"] as? String
            guard let sourceSnapshotId = dictionary["SourceSnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SourceSnapshotId") }
            self.sourceSnapshotId = sourceSnapshotId
        }
    }

    public enum StatusName: String, CustomStringConvertible {
        case reachability = "reachability"
        public var description: String { return self.rawValue }
    }

    public struct IpRangeList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [IpRange]?

        public init(item: [IpRange]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try IpRange(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct VpnConnectionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpnConnection]?

        public init(item: [VpnConnection]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpnConnection(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribePlacementGroupsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more placement groups.
        public let placementGroups: PlacementGroupList?

        public init(placementGroups: PlacementGroupList? = nil) {
            self.placementGroups = placementGroups
        }

        public init(dictionary: [String: Any]) throws {
            if let placementGroups = dictionary["PlacementGroupSet"] as? [String: Any] { self.placementGroups = try Ec2.PlacementGroupList(dictionary: placementGroups) } else { self.placementGroups = nil }
        }
    }

    public struct DetachVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device name.
        public let device: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the instance.
        public let instanceId: String?
        /// The ID of the volume.
        public let volumeId: String
        /// Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.
        public let force: Bool?

        public init(device: String? = nil, dryRun: Bool? = nil, instanceId: String? = nil, volumeId: String, force: Bool? = nil) {
            self.device = device
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.volumeId = volumeId
            self.force = force
        }

        public init(dictionary: [String: Any]) throws {
            self.device = dictionary["Device"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.instanceId = dictionary["InstanceId"] as? String
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.force = dictionary["Force"] as? Bool
        }
    }

    public struct EgressOnlyInternetGateway: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the egress-only Internet gateway.
        public let egressOnlyInternetGatewayId: String?
        /// Information about the attachment of the egress-only Internet gateway.
        public let attachments: InternetGatewayAttachmentList?

        public init(egressOnlyInternetGatewayId: String? = nil, attachments: InternetGatewayAttachmentList? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.attachments = attachments
        }

        public init(dictionary: [String: Any]) throws {
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            if let attachments = dictionary["AttachmentSet"] as? [String: Any] { self.attachments = try Ec2.InternetGatewayAttachmentList(dictionary: attachments) } else { self.attachments = nil }
        }
    }

    public struct EnableVgwRoutePropagationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the virtual private gateway.
        public let gatewayId: String
        /// The ID of the route table.
        public let routeTableId: String

        public init(gatewayId: String, routeTableId: String) {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }

        public init(dictionary: [String: Any]) throws {
            guard let gatewayId = dictionary["GatewayId"] as? String else { throw InitializableError.missingRequiredParam("GatewayId") }
            self.gatewayId = gatewayId
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
        }
    }

    public struct LaunchSpecsList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SpotFleetLaunchSpecification]?

        public init(item: [SpotFleetLaunchSpecification]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SpotFleetLaunchSpecification(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct GetReservedInstancesExchangeQuoteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the Convertible Reserved Instances to exchange.
        public let reservedInstanceIds: ReservedInstanceIdSet
        /// The configuration requirements of the Convertible Reserved Instances to exchange for your current Convertible Reserved Instances.
        public let targetConfigurations: TargetConfigurationRequestSet?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(reservedInstanceIds: ReservedInstanceIdSet, targetConfigurations: TargetConfigurationRequestSet? = nil, dryRun: Bool? = nil) {
            self.reservedInstanceIds = reservedInstanceIds
            self.targetConfigurations = targetConfigurations
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstanceIds = dictionary["ReservedInstanceId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ReservedInstanceId") }
            self.reservedInstanceIds = try Ec2.ReservedInstanceIdSet(dictionary: reservedInstanceIds)
            if let targetConfigurations = dictionary["TargetConfiguration"] as? [String: Any] { self.targetConfigurations = try Ec2.TargetConfigurationRequestSet(dictionary: targetConfigurations) } else { self.targetConfigurations = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct SpotFleetLaunchSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more block device mapping entries.
        public let blockDeviceMappings: BlockDeviceMappingList?
        /// The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".
        public let subnetId: String?
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let userData: String?
        /// Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        public let ebsOptimized: Bool?
        /// The ID of the kernel.
        public let kernelId: String?
        /// The bid price per unit hour for the specified instance type. If this value is not specified, the default is the Spot bid price specified for the fleet. To determine the bid price per unit hour, divide the Spot bid price by the value of WeightedCapacity.
        public let spotPrice: String?
        /// Enable or disable monitoring for the instances.
        public let monitoring: SpotFleetMonitoring?
        /// The instance type. Note that T2 and HS1 instance types are not supported.
        public let instanceType: InstanceType?
        /// The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O). If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.
        public let weightedCapacity: Double?
        /// One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
        public let securityGroups: GroupIdentifierList?
        /// The name of the key pair.
        public let keyName: String?
        /// Deprecated.
        public let addressingType: String?
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfileSpecification?
        /// The ID of the AMI.
        public let imageId: String?
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        public let networkInterfaces: InstanceNetworkInterfaceSpecificationList?
        /// The placement information.
        public let placement: SpotPlacement?
        /// The ID of the RAM disk.
        public let ramdiskId: String?

        public init(blockDeviceMappings: BlockDeviceMappingList? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, spotPrice: String? = nil, monitoring: SpotFleetMonitoring? = nil, instanceType: InstanceType? = nil, weightedCapacity: Double? = nil, securityGroups: GroupIdentifierList? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: InstanceNetworkInterfaceSpecificationList? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.spotPrice = spotPrice
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            self.spotPrice = dictionary["SpotPrice"] as? String
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.SpotFleetMonitoring(dictionary: monitoring) } else { self.monitoring = nil }
            if let instanceType = dictionary["InstanceType"] as? String { self.instanceType = InstanceType(rawValue: instanceType) } else { self.instanceType = nil }
            self.weightedCapacity = dictionary["WeightedCapacity"] as? Double
            if let securityGroups = dictionary["GroupSet"] as? [String: Any] { self.securityGroups = try Ec2.GroupIdentifierList(dictionary: securityGroups) } else { self.securityGroups = nil }
            self.keyName = dictionary["KeyName"] as? String
            self.addressingType = dictionary["AddressingType"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) } else { self.iamInstanceProfile = nil }
            self.imageId = dictionary["ImageId"] as? String
            if let networkInterfaces = dictionary["NetworkInterfaceSet"] as? [String: Any] { self.networkInterfaces = try Ec2.InstanceNetworkInterfaceSpecificationList(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.SpotPlacement(dictionary: placement) } else { self.placement = nil }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct Region: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The region service endpoint.
        public let endpoint: String?
        /// The name of the region.
        public let regionName: String?

        public init(endpoint: String? = nil, regionName: String? = nil) {
            self.endpoint = endpoint
            self.regionName = regionName
        }

        public init(dictionary: [String: Any]) throws {
            self.endpoint = dictionary["RegionEndpoint"] as? String
            self.regionName = dictionary["RegionName"] as? String
        }
    }

    public struct PurchaseRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The purchase token.
        public let purchaseToken: String
        /// The number of instances.
        public let instanceCount: Int32

        public init(purchaseToken: String, instanceCount: Int32) {
            self.purchaseToken = purchaseToken
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let purchaseToken = dictionary["PurchaseToken"] as? String else { throw InitializableError.missingRequiredParam("PurchaseToken") }
            self.purchaseToken = purchaseToken
            guard let instanceCount = dictionary["InstanceCount"] as? Int32 else { throw InitializableError.missingRequiredParam("InstanceCount") }
            self.instanceCount = instanceCount
        }
    }

    public struct ImportTaskIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let importTaskId: [String]?

        public init(importTaskId: [String]? = nil) {
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.importTaskId = dictionary["ImportTaskId"] as? [String]
        }
    }

    public struct DetachInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// The ID of the Internet gateway.
        public let internetGatewayId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcId: String, internetGatewayId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let internetGatewayId = dictionary["InternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("InternetGatewayId") }
            self.internetGatewayId = internetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVpcClassicLinkDnsSupportResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the ClassicLink DNS support status of the VPCs.
        public let vpcs: ClassicLinkDnsSupportList?
        /// The token to use when requesting the next set of items.
        public let nextToken: String?

        public init(vpcs: ClassicLinkDnsSupportList? = nil, nextToken: String? = nil) {
            self.vpcs = vpcs
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcs = dictionary["Vpcs"] as? [String: Any] { self.vpcs = try Ec2.ClassicLinkDnsSupportList(dictionary: vpcs) } else { self.vpcs = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CreateInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct VpnConnectionOptionsSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.
        public let staticRoutesOnly: Bool?

        public init(staticRoutesOnly: Bool? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
        }

        public init(dictionary: [String: Any]) throws {
            self.staticRoutesOnly = dictionary["StaticRoutesOnly"] as? Bool
        }
    }

    public enum ImageState: String, CustomStringConvertible {
        case pending = "pending"
        case available = "available"
        case invalid = "invalid"
        case deregistered = "deregistered"
        case transient = "transient"
        case failed = "failed"
        case error = "error"
        public var description: String { return self.rawValue }
    }

    public enum DeviceType: String, CustomStringConvertible {
        case ebs = "ebs"
        case instance_store = "instance-store"
        public var description: String { return self.rawValue }
    }

    public struct HistoryRecord: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The event type.    error - Indicates an error with the Spot fleet request.    fleetRequestChange - Indicates a change in the status or configuration of the Spot fleet request.    instanceChange - Indicates that an instance was launched or terminated.  
        public let eventType: EventType
        /// The date and time of the event, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let timestamp: Date
        /// Information about the event.
        public let eventInformation: EventInformation

        public init(eventType: EventType, timestamp: Date, eventInformation: EventInformation) {
            self.eventType = eventType
            self.timestamp = timestamp
            self.eventInformation = eventInformation
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawEventType = dictionary["EventType"] as? String, let eventType = EventType(rawValue: rawEventType) else { throw InitializableError.missingRequiredParam("EventType") }
            self.eventType = eventType
            guard let timestamp = dictionary["Timestamp"] as? Date else { throw InitializableError.missingRequiredParam("Timestamp") }
            self.timestamp = timestamp
            guard let eventInformation = dictionary["EventInformation"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EventInformation") }
            self.eventInformation = try Ec2.EventInformation(dictionary: eventInformation)
        }
    }

    public struct DescribeSpotFleetRequestsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the configuration of your Spot fleet.
        public let spotFleetRequestConfigs: SpotFleetRequestConfigSet

        public init(nextToken: String? = nil, spotFleetRequestConfigs: SpotFleetRequestConfigSet) {
            self.nextToken = nextToken
            self.spotFleetRequestConfigs = spotFleetRequestConfigs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestConfigs = dictionary["SpotFleetRequestConfigSet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotFleetRequestConfigSet") }
            self.spotFleetRequestConfigs = try Ec2.SpotFleetRequestConfigSet(dictionary: spotFleetRequestConfigs)
        }
    }

    public struct VpcPeeringConnectionOptionsDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        public let allowEgressFromLocalVpcToRemoteClassicLink: Bool?
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        public let allowDnsResolutionFromRemoteVpc: Bool?
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        public let allowEgressFromLocalClassicLinkToRemoteVpc: Bool?

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

        public init(dictionary: [String: Any]) throws {
            self.allowEgressFromLocalVpcToRemoteClassicLink = dictionary["AllowEgressFromLocalVpcToRemoteClassicLink"] as? Bool
            self.allowDnsResolutionFromRemoteVpc = dictionary["AllowDnsResolutionFromRemoteVpc"] as? Bool
            self.allowEgressFromLocalClassicLinkToRemoteVpc = dictionary["AllowEgressFromLocalClassicLinkToRemoteVpc"] as? Bool
        }
    }

    public struct VpcEndpointSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpcEndpoint]?

        public init(item: [VpcEndpoint]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpcEndpoint(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct InstanceStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The intended state of the instance. DescribeInstanceStatus requires that an instance be in the running state.
        public let instanceState: InstanceState?
        /// Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.
        public let systemStatus: InstanceStatusSummary?
        /// Any scheduled events associated with the instance.
        public let events: InstanceStatusEventList?
        /// Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.
        public let instanceStatus: InstanceStatusSummary?
        /// The ID of the instance.
        public let instanceId: String?
        /// The Availability Zone of the instance.
        public let availabilityZone: String?

        public init(instanceState: InstanceState? = nil, systemStatus: InstanceStatusSummary? = nil, events: InstanceStatusEventList? = nil, instanceStatus: InstanceStatusSummary? = nil, instanceId: String? = nil, availabilityZone: String? = nil) {
            self.instanceState = instanceState
            self.systemStatus = systemStatus
            self.events = events
            self.instanceStatus = instanceStatus
            self.instanceId = instanceId
            self.availabilityZone = availabilityZone
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceState = dictionary["InstanceState"] as? [String: Any] { self.instanceState = try Ec2.InstanceState(dictionary: instanceState) } else { self.instanceState = nil }
            if let systemStatus = dictionary["SystemStatus"] as? [String: Any] { self.systemStatus = try Ec2.InstanceStatusSummary(dictionary: systemStatus) } else { self.systemStatus = nil }
            if let events = dictionary["EventsSet"] as? [String: Any] { self.events = try Ec2.InstanceStatusEventList(dictionary: events) } else { self.events = nil }
            if let instanceStatus = dictionary["InstanceStatus"] as? [String: Any] { self.instanceStatus = try Ec2.InstanceStatusSummary(dictionary: instanceStatus) } else { self.instanceStatus = nil }
            self.instanceId = dictionary["InstanceId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
        }
    }

    public struct ReservedInstancesOfferingList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ReservedInstancesOffering]?

        public init(item: [ReservedInstancesOffering]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ReservedInstancesOffering(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public enum VpcCidrBlockStateCode: String, CustomStringConvertible {
        case associating = "associating"
        case associated = "associated"
        case disassociating = "disassociating"
        case disassociated = "disassociated"
        case failing = "failing"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public struct VpcPeeringConnectionVpcInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        public let peeringOptions: VpcPeeringConnectionOptionsDescription?
        /// The IPv6 CIDR block for the VPC.
        public let ipv6CidrBlockSet: Ipv6CidrBlockSet?
        /// The ID of the VPC.
        public let vpcId: String?
        /// The AWS account ID of the VPC owner.
        public let ownerId: String?
        /// The IPv4 CIDR block for the VPC.
        public let cidrBlock: String?

        public init(peeringOptions: VpcPeeringConnectionOptionsDescription? = nil, ipv6CidrBlockSet: Ipv6CidrBlockSet? = nil, vpcId: String? = nil, ownerId: String? = nil, cidrBlock: String? = nil) {
            self.peeringOptions = peeringOptions
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.vpcId = vpcId
            self.ownerId = ownerId
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            if let peeringOptions = dictionary["PeeringOptions"] as? [String: Any] { self.peeringOptions = try Ec2.VpcPeeringConnectionOptionsDescription(dictionary: peeringOptions) } else { self.peeringOptions = nil }
            if let ipv6CidrBlockSet = dictionary["Ipv6CidrBlockSet"] as? [String: Any] { self.ipv6CidrBlockSet = try Ec2.Ipv6CidrBlockSet(dictionary: ipv6CidrBlockSet) } else { self.ipv6CidrBlockSet = nil }
            self.vpcId = dictionary["VpcId"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            self.cidrBlock = dictionary["CidrBlock"] as? String
        }
    }

    public struct SnapshotTaskDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A brief status for the import snapshot task.
        public let status: String?
        /// The percentage of completion for the import snapshot task.
        public let progress: String?
        /// The URL of the disk image from which the snapshot is created.
        public let url: String?
        /// The size of the disk in the snapshot, in GiB.
        public let diskImageSize: Double?
        /// The format of the disk image from which the snapshot is created.
        public let format: String?
        /// The snapshot ID of the disk being imported.
        public let snapshotId: String?
        /// The S3 bucket for the disk image.
        public let userBucket: UserBucketDetails?
        /// A detailed status message for the import snapshot task.
        public let statusMessage: String?
        /// The description of the snapshot.
        public let description: String?

        public init(status: String? = nil, progress: String? = nil, url: String? = nil, diskImageSize: Double? = nil, format: String? = nil, snapshotId: String? = nil, userBucket: UserBucketDetails? = nil, statusMessage: String? = nil, description: String? = nil) {
            self.status = status
            self.progress = progress
            self.url = url
            self.diskImageSize = diskImageSize
            self.format = format
            self.snapshotId = snapshotId
            self.userBucket = userBucket
            self.statusMessage = statusMessage
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.progress = dictionary["Progress"] as? String
            self.url = dictionary["Url"] as? String
            self.diskImageSize = dictionary["DiskImageSize"] as? Double
            self.format = dictionary["Format"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucketDetails(dictionary: userBucket) } else { self.userBucket = nil }
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct SubnetIpv6CidrBlockAssociationSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [SubnetIpv6CidrBlockAssociation]?

        public init(item: [SubnetIpv6CidrBlockAssociation]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SubnetIpv6CidrBlockAssociation(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct TargetReservationValueSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [TargetReservationValue]?

        public init(item: [TargetReservationValue]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try TargetReservationValue(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CreateSpotDatafeedSubscriptionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Spot instance data feed subscription.
        public let spotDatafeedSubscription: SpotDatafeedSubscription?

        public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
            self.spotDatafeedSubscription = spotDatafeedSubscription
        }

        public init(dictionary: [String: Any]) throws {
            if let spotDatafeedSubscription = dictionary["SpotDatafeedSubscription"] as? [String: Any] { self.spotDatafeedSubscription = try Ec2.SpotDatafeedSubscription(dictionary: spotDatafeedSubscription) } else { self.spotDatafeedSubscription = nil }
        }
    }

    public enum SummaryStatus: String, CustomStringConvertible {
        case ok = "ok"
        case impaired = "impaired"
        case insufficient_data = "insufficient-data"
        case not_applicable = "not-applicable"
        case initializing = "initializing"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSpotInstanceRequestsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more Spot instance requests.
        public let spotInstanceRequests: SpotInstanceRequestList?

        public init(spotInstanceRequests: SpotInstanceRequestList? = nil) {
            self.spotInstanceRequests = spotInstanceRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let spotInstanceRequests = dictionary["SpotInstanceRequestSet"] as? [String: Any] { self.spotInstanceRequests = try Ec2.SpotInstanceRequestList(dictionary: spotInstanceRequests) } else { self.spotInstanceRequests = nil }
        }
    }

    public enum ReservedInstanceState: String, CustomStringConvertible {
        case payment_pending = "payment-pending"
        case active = "active"
        case payment_failed = "payment-failed"
        case retired = "retired"
        public var description: String { return self.rawValue }
    }

    public struct ModifyVpcPeeringConnectionOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The VPC peering connection options for the accepter VPC.
        public let accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest?
        /// The VPC peering connection options for the requester VPC.
        public let requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest?
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String

        public init(accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil, requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil, dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
            self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            if let accepterPeeringConnectionOptions = dictionary["AccepterPeeringConnectionOptions"] as? [String: Any] { self.accepterPeeringConnectionOptions = try Ec2.PeeringConnectionOptionsRequest(dictionary: accepterPeeringConnectionOptions) } else { self.accepterPeeringConnectionOptions = nil }
            if let requesterPeeringConnectionOptions = dictionary["RequesterPeeringConnectionOptions"] as? [String: Any] { self.requesterPeeringConnectionOptions = try Ec2.PeeringConnectionOptionsRequest(dictionary: requesterPeeringConnectionOptions) } else { self.requesterPeeringConnectionOptions = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpcPeeringConnectionId") }
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

    public enum AutoPlacement: String, CustomStringConvertible {
        case on = "on"
        case off = "off"
        public var description: String { return self.rawValue }
    }

    public struct IamInstanceProfileSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the instance profile.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String?

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.arn = dictionary["Arn"] as? String
        }
    }

    public enum HostTenancy: String, CustomStringConvertible {
        case dedicated = "dedicated"
        case host = "host"
        public var description: String { return self.rawValue }
    }

    public struct TagList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Tag]?

        public init(item: [Tag]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Tag(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ConfirmProductInstanceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the instance.
        public let instanceId: String
        /// The product code. This must be a product code that you own.
        public let productCode: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(instanceId: String, productCode: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.productCode = productCode
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let productCode = dictionary["ProductCode"] as? String else { throw InitializableError.missingRequiredParam("ProductCode") }
            self.productCode = productCode
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DisableVgwRoutePropagationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the virtual private gateway.
        public let gatewayId: String
        /// The ID of the route table.
        public let routeTableId: String

        public init(gatewayId: String, routeTableId: String) {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }

        public init(dictionary: [String: Any]) throws {
            guard let gatewayId = dictionary["GatewayId"] as? String else { throw InitializableError.missingRequiredParam("GatewayId") }
            self.gatewayId = gatewayId
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
        }
    }

    public struct DescribeSpotPriceHistoryRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let startTime: Date?
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?
        /// Filters the results by the specified basic product descriptions.
        public let productDescriptions: [String]?
        /// The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public let endTime: Date?
        /// One or more filters.    availability-zone - The Availability Zone for which prices should be returned.    instance-type - The type of instance (for example, m3.medium).    product-description - The product description for the Spot price (Linux/UNIX | SUSE Linux | Windows | Linux/UNIX (Amazon VPC) | SUSE Linux (Amazon VPC) | Windows (Amazon VPC)).    spot-price - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).    timestamp - The timestamp of the Spot price history, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). You can use wildcards (* and ?). Greater than or less than comparison is not supported.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Filters the results by the specified Availability Zone.
        public let availabilityZone: String?
        /// The token for the next set of results.
        public let nextToken: String?
        /// Filters the results by the specified instance types. Note that T2 and HS1 instance types are not supported.
        public let instanceTypes: [InstanceType]?

        public init(startTime: Date? = nil, maxResults: Int32? = nil, productDescriptions: [String]? = nil, endTime: Date? = nil, filters: FilterList? = nil, dryRun: Bool? = nil, availabilityZone: String? = nil, nextToken: String? = nil, instanceTypes: [InstanceType]? = nil) {
            self.startTime = startTime
            self.maxResults = maxResults
            self.productDescriptions = productDescriptions
            self.endTime = endTime
            self.filters = filters
            self.dryRun = dryRun
            self.availabilityZone = availabilityZone
            self.nextToken = nextToken
            self.instanceTypes = instanceTypes
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.productDescriptions = dictionary["ProductDescription"] as? [String]
            self.endTime = dictionary["EndTime"] as? Date
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            if let instanceTypes = dictionary["InstanceType"] as? [String] { self.instanceTypes = instanceTypes.flatMap({ InstanceType(rawValue: $0)}) } else { self.instanceTypes = nil }
        }
    }

    public struct ExportTaskIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let exportTaskId: [String]?

        public init(exportTaskId: [String]? = nil) {
            self.exportTaskId = exportTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.exportTaskId = dictionary["ExportTaskId"] as? [String]
        }
    }

    public struct ConversionTask: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the task is for importing an instance, this contains information about the import instance task.
        public let importInstance: ImportInstanceTaskDetails?
        /// The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.
        public let expirationTime: String?
        /// Any tags assigned to the task.
        public let tags: TagList?
        /// The state of the conversion task.
        public let state: ConversionTaskState
        /// The ID of the conversion task.
        public let conversionTaskId: String
        /// The status message related to the conversion task.
        public let statusMessage: String?
        /// If the task is for importing a volume, this contains information about the import volume task.
        public let importVolume: ImportVolumeTaskDetails?

        public init(importInstance: ImportInstanceTaskDetails? = nil, expirationTime: String? = nil, tags: TagList? = nil, state: ConversionTaskState, conversionTaskId: String, statusMessage: String? = nil, importVolume: ImportVolumeTaskDetails? = nil) {
            self.importInstance = importInstance
            self.expirationTime = expirationTime
            self.tags = tags
            self.state = state
            self.conversionTaskId = conversionTaskId
            self.statusMessage = statusMessage
            self.importVolume = importVolume
        }

        public init(dictionary: [String: Any]) throws {
            if let importInstance = dictionary["ImportInstance"] as? [String: Any] { self.importInstance = try Ec2.ImportInstanceTaskDetails(dictionary: importInstance) } else { self.importInstance = nil }
            self.expirationTime = dictionary["ExpirationTime"] as? String
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            guard let rawState = dictionary["State"] as? String, let state = ConversionTaskState(rawValue: rawState) else { throw InitializableError.missingRequiredParam("State") }
            self.state = state
            guard let conversionTaskId = dictionary["ConversionTaskId"] as? String else { throw InitializableError.missingRequiredParam("ConversionTaskId") }
            self.conversionTaskId = conversionTaskId
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let importVolume = dictionary["ImportVolume"] as? [String: Any] { self.importVolume = try Ec2.ImportVolumeTaskDetails(dictionary: importVolume) } else { self.importVolume = nil }
        }
    }

    public struct ReplaceRouteTableAssociationResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the new association.
        public let newAssociationId: String?

        public init(newAssociationId: String? = nil) {
            self.newAssociationId = newAssociationId
        }

        public init(dictionary: [String: Any]) throws {
            self.newAssociationId = dictionary["NewAssociationId"] as? String
        }
    }

    public struct PrefixListIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct ModifyVolumeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A VolumeModification object.
        public let volumeModification: VolumeModification?

        public init(volumeModification: VolumeModification? = nil) {
            self.volumeModification = volumeModification
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeModification = dictionary["VolumeModification"] as? [String: Any] { self.volumeModification = try Ec2.VolumeModification(dictionary: volumeModification) } else { self.volumeModification = nil }
        }
    }

    public struct KeyPair: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the key pair.
        public let keyName: String?
        /// The SHA-1 digest of the DER encoded private key.
        public let keyFingerprint: String?
        /// An unencrypted PEM encoded RSA private key.
        public let keyMaterial: String?

        public init(keyName: String? = nil, keyFingerprint: String? = nil, keyMaterial: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
            self.keyMaterial = keyMaterial
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? String
            self.keyFingerprint = dictionary["KeyFingerprint"] as? String
            self.keyMaterial = dictionary["KeyMaterial"] as? String
        }
    }

    public struct DescribeVpnGatewaysResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more virtual private gateways.
        public let vpnGateways: VpnGatewayList?

        public init(vpnGateways: VpnGatewayList? = nil) {
            self.vpnGateways = vpnGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnGateways = dictionary["VpnGatewaySet"] as? [String: Any] { self.vpnGateways = try Ec2.VpnGatewayList(dictionary: vpnGateways) } else { self.vpnGateways = nil }
        }
    }

    public struct DescribeSpotFleetInstancesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(dryRun: Bool? = nil, nextToken: String? = nil, spotFleetRequestId: String, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteVpcEndpointsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more endpoint IDs.
        public let vpcEndpointIds: ValueStringList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(vpcEndpointIds: ValueStringList, dryRun: Bool? = nil) {
            self.vpcEndpointIds = vpcEndpointIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcEndpointIds = dictionary["VpcEndpointId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("VpcEndpointId") }
            self.vpcEndpointIds = try Ec2.ValueStringList(dictionary: vpcEndpointIds)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeReservedInstancesModificationsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The Reserved Instance modification information.
        public let reservedInstancesModifications: ReservedInstancesModificationList?

        public init(nextToken: String? = nil, reservedInstancesModifications: ReservedInstancesModificationList? = nil) {
            self.nextToken = nextToken
            self.reservedInstancesModifications = reservedInstancesModifications
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let reservedInstancesModifications = dictionary["ReservedInstancesModificationsSet"] as? [String: Any] { self.reservedInstancesModifications = try Ec2.ReservedInstancesModificationList(dictionary: reservedInstancesModifications) } else { self.reservedInstancesModifications = nil }
        }
    }

    public struct AssociateSubnetCidrBlockRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.
        public let ipv6CidrBlock: String
        /// The ID of your subnet.
        public let subnetId: String

        public init(ipv6CidrBlock: String, subnetId: String) {
            self.ipv6CidrBlock = ipv6CidrBlock
            self.subnetId = subnetId
        }

        public init(dictionary: [String: Any]) throws {
            guard let ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String else { throw InitializableError.missingRequiredParam("Ipv6CidrBlock") }
            self.ipv6CidrBlock = ipv6CidrBlock
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
        }
    }

    public struct DescribeDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of one or more DHCP options sets. Default: Describes all your DHCP options sets.
        public let dhcpOptionsIds: DhcpOptionsIdStringList?
        /// One or more filters.    dhcp-options-id - The ID of a set of DHCP options.    key - The key for one of the options (for example, domain-name).    value - The value for one of the options.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public let filters: FilterList?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(dhcpOptionsIds: DhcpOptionsIdStringList? = nil, filters: FilterList? = nil, dryRun: Bool? = nil) {
            self.dhcpOptionsIds = dhcpOptionsIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let dhcpOptionsIds = dictionary["DhcpOptionsId"] as? [String: Any] { self.dhcpOptionsIds = try Ec2.DhcpOptionsIdStringList(dictionary: dhcpOptionsIds) } else { self.dhcpOptionsIds = nil }
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct LaunchPermissionModifications: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account ID to remove from the list of launch permissions for the AMI.
        public let remove: LaunchPermissionList?
        /// The AWS account ID to add to the list of launch permissions for the AMI.
        public let add: LaunchPermissionList?

        public init(remove: LaunchPermissionList? = nil, add: LaunchPermissionList? = nil) {
            self.remove = remove
            self.add = add
        }

        public init(dictionary: [String: Any]) throws {
            if let remove = dictionary["Remove"] as? [String: Any] { self.remove = try Ec2.LaunchPermissionList(dictionary: remove) } else { self.remove = nil }
            if let add = dictionary["Add"] as? [String: Any] { self.add = try Ec2.LaunchPermissionList(dictionary: add) } else { self.add = nil }
        }
    }

    public enum AllocationState: String, CustomStringConvertible {
        case available = "available"
        case under_assessment = "under-assessment"
        case permanent_failure = "permanent-failure"
        case released = "released"
        case released_permanent_failure = "released-permanent-failure"
        public var description: String { return self.rawValue }
    }

    public struct ModifyHostsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The host IDs of the Dedicated Hosts you want to modify.
        public let hostIds: RequestHostIdList
        /// Specify whether to enable or disable auto-placement.
        public let autoPlacement: AutoPlacement

        public init(hostIds: RequestHostIdList, autoPlacement: AutoPlacement) {
            self.hostIds = hostIds
            self.autoPlacement = autoPlacement
        }

        public init(dictionary: [String: Any]) throws {
            guard let hostIds = dictionary["HostId"] as? [String: Any] else { throw InitializableError.missingRequiredParam("HostId") }
            self.hostIds = try Ec2.RequestHostIdList(dictionary: hostIds)
            guard let rawAutoPlacement = dictionary["AutoPlacement"] as? String, let autoPlacement = AutoPlacement(rawValue: rawAutoPlacement) else { throw InitializableError.missingRequiredParam("AutoPlacement") }
            self.autoPlacement = autoPlacement
        }
    }

    public enum NetworkInterfaceAttribute: String, CustomStringConvertible {
        case description = "description"
        case groupset = "groupSet"
        case sourcedestcheck = "sourceDestCheck"
        case attachment = "attachment"
        public var description: String { return self.rawValue }
    }

    public struct ReleaseAddressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// [EC2-VPC] The allocation ID. Required for EC2-VPC.
        public let allocationId: String?
        /// [EC2-Classic] The Elastic IP address. Required for EC2-Classic.
        public let publicIp: String?

        public init(dryRun: Bool? = nil, allocationId: String? = nil, publicIp: String? = nil) {
            self.dryRun = dryRun
            self.allocationId = allocationId
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.allocationId = dictionary["AllocationId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct VpcEndpoint: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time the VPC endpoint was created.
        public let creationTimestamp: Date?
        /// The ID of the VPC to which the endpoint is associated.
        public let vpcId: String?
        /// The state of the VPC endpoint.
        public let state: State?
        /// The name of the AWS service to which the endpoint is associated.
        public let serviceName: String?
        /// The ID of the VPC endpoint.
        public let vpcEndpointId: String?
        /// The policy document associated with the endpoint.
        public let policyDocument: String?
        /// One or more route tables associated with the endpoint.
        public let routeTableIds: ValueStringList?

        public init(creationTimestamp: Date? = nil, vpcId: String? = nil, state: State? = nil, serviceName: String? = nil, vpcEndpointId: String? = nil, policyDocument: String? = nil, routeTableIds: ValueStringList? = nil) {
            self.creationTimestamp = creationTimestamp
            self.vpcId = vpcId
            self.state = state
            self.serviceName = serviceName
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = policyDocument
            self.routeTableIds = routeTableIds
        }

        public init(dictionary: [String: Any]) throws {
            self.creationTimestamp = dictionary["CreationTimestamp"] as? Date
            self.vpcId = dictionary["VpcId"] as? String
            if let state = dictionary["State"] as? String { self.state = State(rawValue: state) } else { self.state = nil }
            self.serviceName = dictionary["ServiceName"] as? String
            self.vpcEndpointId = dictionary["VpcEndpointId"] as? String
            self.policyDocument = dictionary["PolicyDocument"] as? String
            if let routeTableIds = dictionary["RouteTableIdSet"] as? [String: Any] { self.routeTableIds = try Ec2.ValueStringList(dictionary: routeTableIds) } else { self.routeTableIds = nil }
        }
    }

    public struct AssociateIamInstanceProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the instance.
        public let instanceId: String
        /// The IAM instance profile.
        public let iamInstanceProfile: IamInstanceProfileSpecification

        public init(instanceId: String, iamInstanceProfile: IamInstanceProfileSpecification) {
            self.instanceId = instanceId
            self.iamInstanceProfile = iamInstanceProfile
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IamInstanceProfile") }
            self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile)
        }
    }

    public enum OfferingTypeValues: String, CustomStringConvertible {
        case heavy_utilization = "Heavy Utilization"
        case medium_utilization = "Medium Utilization"
        case light_utilization = "Light Utilization"
        case no_upfront = "No Upfront"
        case partial_upfront = "Partial Upfront"
        case all_upfront = "All Upfront"
        public var description: String { return self.rawValue }
    }

    public struct DisassociateVpcCidrBlockResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// Information about the IPv6 CIDR block association.
        public let ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation?

        public init(vpcId: String? = nil, ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil) {
            self.vpcId = vpcId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.VpcIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) } else { self.ipv6CidrBlockAssociation = nil }
        }
    }

    public struct InstanceList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Instance]?

        public init(item: [Instance]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Instance(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DeleteDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the DHCP options set.
        public let dhcpOptionsId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(dhcpOptionsId: String, dryRun: Bool? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let dhcpOptionsId = dictionary["DhcpOptionsId"] as? String else { throw InitializableError.missingRequiredParam("DhcpOptionsId") }
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public enum CurrencyCodeValues: String, CustomStringConvertible {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public struct DescribeHostReservationsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Details about the reservation's configuration.
        public let hostReservationSet: [HostReservation]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(hostReservationSet: [HostReservation]? = nil, nextToken: String? = nil) {
            self.hostReservationSet = hostReservationSet
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let hostReservationSet = dictionary["HostReservationSet"] as? [[String: Any]] {
                self.hostReservationSet = try hostReservationSet.map({ try HostReservation(dictionary: $0) })
            } else { 
                self.hostReservationSet = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public enum RouteOrigin: String, CustomStringConvertible {
        case createroutetable = "CreateRouteTable"
        case createroute = "CreateRoute"
        case enablevgwroutepropagation = "EnableVgwRoutePropagation"
        public var description: String { return self.rawValue }
    }

    public struct ModifyNetworkInterfaceAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description for the network interface.
        public let description: AttributeValue?
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.
        public let attachment: NetworkInterfaceAttachmentChanges?
        /// Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.
        public let groups: SecurityGroupIdStringList?
        /// Indicates whether source/destination checking is enabled. A value of true means checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT. For more information, see NAT Instances in the Amazon Virtual Private Cloud User Guide.
        public let sourceDestCheck: AttributeBooleanValue?

        public init(description: AttributeValue? = nil, networkInterfaceId: String, dryRun: Bool? = nil, attachment: NetworkInterfaceAttachmentChanges? = nil, groups: SecurityGroupIdStringList? = nil, sourceDestCheck: AttributeBooleanValue? = nil) {
            self.description = description
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
            self.attachment = attachment
            self.groups = groups
            self.sourceDestCheck = sourceDestCheck
        }

        public init(dictionary: [String: Any]) throws {
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) } else { self.description = nil }
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dictionary["DryRun"] as? Bool
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.NetworkInterfaceAttachmentChanges(dictionary: attachment) } else { self.attachment = nil }
            if let groups = dictionary["SecurityGroupId"] as? [String: Any] { self.groups = try Ec2.SecurityGroupIdStringList(dictionary: groups) } else { self.groups = nil }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) } else { self.sourceDestCheck = nil }
        }
    }

    public struct ReservedInstancesIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let reservedInstancesId: [String]?

        public init(reservedInstancesId: [String]? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? [String]
        }
    }

    public struct AttributeBooleanValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The attribute value. The valid values are true or false.
        public let value: Bool?

        public init(value: Bool? = nil) {
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct AttachVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the virtual private gateway.
        public let vpnGatewayId: String

        public init(vpcId: String, dryRun: Bool? = nil, vpnGatewayId: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct ActiveInstanceSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [ActiveInstance]?

        public init(item: [ActiveInstance]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ActiveInstance(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct CreateEgressOnlyInternetGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// Information about the egress-only Internet gateway.
        public let egressOnlyInternetGateway: EgressOnlyInternetGateway?

        public init(clientToken: String? = nil, egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil) {
            self.clientToken = clientToken
            self.egressOnlyInternetGateway = egressOnlyInternetGateway
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let egressOnlyInternetGateway = dictionary["EgressOnlyInternetGateway"] as? [String: Any] { self.egressOnlyInternetGateway = try Ec2.EgressOnlyInternetGateway(dictionary: egressOnlyInternetGateway) } else { self.egressOnlyInternetGateway = nil }
        }
    }

    public enum Status: String, CustomStringConvertible {
        case moveinprogress = "MoveInProgress"
        case invpc = "InVpc"
        case inclassic = "InClassic"
        public var description: String { return self.rawValue }
    }

    public struct NetworkInterfaceAttachmentChanges: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The ID of the network interface attachment.
        public let attachmentId: String?

        public init(deleteOnTermination: Bool? = nil, attachmentId: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.attachmentId = attachmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.attachmentId = dictionary["AttachmentId"] as? String
        }
    }

    public struct CancelExportTaskRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the export task. This is the ID returned by CreateInstanceExportTask.
        public let exportTaskId: String

        public init(exportTaskId: String) {
            self.exportTaskId = exportTaskId
        }

        public init(dictionary: [String: Any]) throws {
            guard let exportTaskId = dictionary["ExportTaskId"] as? String else { throw InitializableError.missingRequiredParam("ExportTaskId") }
            self.exportTaskId = exportTaskId
        }
    }

    public struct ResetImageAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The attribute to reset (currently you can only reset the launch permission attribute).
        public let attribute: ResetImageAttributeName
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the AMI.
        public let imageId: String

        public init(attribute: ResetImageAttributeName, dryRun: Bool? = nil, imageId: String) {
            self.attribute = attribute
            self.dryRun = dryRun
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawAttribute = dictionary["Attribute"] as? String, let attribute = ResetImageAttributeName(rawValue: rawAttribute) else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct RequestHostIdSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [String]?

        public init(item: [String]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            self.item = dictionary["Item"] as? [String]
        }
    }

    public struct AssociateRouteTableRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the subnet.
        public let subnetId: String
        /// The ID of the route table.
        public let routeTableId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(subnetId: String, routeTableId: String, dryRun: Bool? = nil) {
            self.subnetId = subnetId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct PrivateIpAddressSpecification: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        public let primary: Bool?
        /// The private IPv4 addresses.
        public let privateIpAddress: String

        public init(primary: Bool? = nil, privateIpAddress: String) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.primary = dictionary["Primary"] as? Bool
            guard let privateIpAddress = dictionary["PrivateIpAddress"] as? String else { throw InitializableError.missingRequiredParam("PrivateIpAddress") }
            self.privateIpAddress = privateIpAddress
        }
    }

    public struct ClassicLinkInstance: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// The ID of the instance.
        public let instanceId: String?
        /// A list of security groups.
        public let groups: GroupIdentifierList?
        /// Any tags assigned to the instance.
        public let tags: TagList?

        public init(vpcId: String? = nil, instanceId: String? = nil, groups: GroupIdentifierList? = nil, tags: TagList? = nil) {
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.groups = groups
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            if let groups = dictionary["GroupSet"] as? [String: Any] { self.groups = try Ec2.GroupIdentifierList(dictionary: groups) } else { self.groups = nil }
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
        }
    }

    public struct DescribePlacementGroupsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// One or more filters.    group-name - The name of the placement group.    state - The state of the placement group (pending | available | deleting | deleted).    strategy - The strategy of the placement group (cluster).  
        public let filters: FilterList?
        /// One or more placement group names. Default: Describes all your placement groups, or only those otherwise specified.
        public let groupNames: [String]?

        public init(dryRun: Bool? = nil, filters: FilterList? = nil, groupNames: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filter"] as? [String: Any] { self.filters = try Ec2.FilterList(dictionary: filters) } else { self.filters = nil }
            self.groupNames = dictionary["GroupName"] as? [String]
        }
    }

    public struct ReplaceNetworkAclAssociationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the current association between the original network ACL and the subnet.
        public let associationId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the new network ACL to associate with the subnet.
        public let networkAclId: String

        public init(associationId: String, dryRun: Bool? = nil, networkAclId: String) {
            self.associationId = associationId
            self.dryRun = dryRun
            self.networkAclId = networkAclId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
        }
    }

    public struct CreateImageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more block device mappings.
        public let blockDeviceMappings: BlockDeviceMappingRequestList?
        /// A description for the new image.
        public let description: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.
        public let noReboot: Bool?
        /// A name for the new image. Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)
        public let name: String
        /// The ID of the instance.
        public let instanceId: String

        public init(blockDeviceMappings: BlockDeviceMappingRequestList? = nil, description: String? = nil, dryRun: Bool? = nil, noReboot: Bool? = nil, name: String, instanceId: String) {
            self.blockDeviceMappings = blockDeviceMappings
            self.description = description
            self.dryRun = dryRun
            self.noReboot = noReboot
            self.name = name
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.BlockDeviceMappingRequestList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            self.description = dictionary["Description"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.noReboot = dictionary["NoReboot"] as? Bool
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct VpcIpv6CidrBlockAssociationSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [VpcIpv6CidrBlockAssociation]?

        public init(item: [VpcIpv6CidrBlockAssociation]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try VpcIpv6CidrBlockAssociation(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ModifyVpcPeeringConnectionOptionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the VPC peering connection options for the accepter VPC.
        public let accepterPeeringConnectionOptions: PeeringConnectionOptions?
        /// Information about the VPC peering connection options for the requester VPC.
        public let requesterPeeringConnectionOptions: PeeringConnectionOptions?

        public init(accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil, requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil) {
            self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
            self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let accepterPeeringConnectionOptions = dictionary["AccepterPeeringConnectionOptions"] as? [String: Any] { self.accepterPeeringConnectionOptions = try Ec2.PeeringConnectionOptions(dictionary: accepterPeeringConnectionOptions) } else { self.accepterPeeringConnectionOptions = nil }
            if let requesterPeeringConnectionOptions = dictionary["RequesterPeeringConnectionOptions"] as? [String: Any] { self.requesterPeeringConnectionOptions = try Ec2.PeeringConnectionOptions(dictionary: requesterPeeringConnectionOptions) } else { self.requesterPeeringConnectionOptions = nil }
        }
    }

    public enum BatchState: String, CustomStringConvertible {
        case submitted = "submitted"
        case active = "active"
        case cancelled = "cancelled"
        case failed = "failed"
        case cancelled_running = "cancelled_running"
        case cancelled_terminating = "cancelled_terminating"
        case modifying = "modifying"
        public var description: String { return self.rawValue }
    }

    public struct DescribeVpcAttributeResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the VPC.
        public let vpcId: String?
        /// Indicates whether DNS resolution is enabled for the VPC. If this attribute is true, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.
        public let enableDnsSupport: AttributeBooleanValue?
        /// Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is true, instances in the VPC get DNS hostnames; otherwise, they do not.
        public let enableDnsHostnames: AttributeBooleanValue?

        public init(vpcId: String? = nil, enableDnsSupport: AttributeBooleanValue? = nil, enableDnsHostnames: AttributeBooleanValue? = nil) {
            self.vpcId = vpcId
            self.enableDnsSupport = enableDnsSupport
            self.enableDnsHostnames = enableDnsHostnames
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let enableDnsSupport = dictionary["EnableDnsSupport"] as? [String: Any] { self.enableDnsSupport = try Ec2.AttributeBooleanValue(dictionary: enableDnsSupport) } else { self.enableDnsSupport = nil }
            if let enableDnsHostnames = dictionary["EnableDnsHostnames"] as? [String: Any] { self.enableDnsHostnames = try Ec2.AttributeBooleanValue(dictionary: enableDnsHostnames) } else { self.enableDnsHostnames = nil }
        }
    }

    public struct TagDescriptionList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [TagDescription]?

        public init(item: [TagDescription]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try TagDescription(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct SubnetIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let subnetId: [String]?

        public init(subnetId: [String]? = nil) {
            self.subnetId = subnetId
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? [String]
        }
    }

    public struct ModifyVolumeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Target EBS volume type of the volume to be modified  The API does not support modifications for volume type standard. You also cannot change the type of a volume to standard.  Default: If no type is specified, the existing type is retained. 
        public let volumeType: VolumeType?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Target IOPS rate of the volume to be modified. Only valid for Provisioned IOPS SSD (io1) volumes. For more information about io1 IOPS configuration, see http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops. Default: If no IOPS value is specified, the existing value is retained. 
        public let iops: Int32?
        public let volumeId: String
        /// Target size in GiB of the volume to be modified. Target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html. Default: If no size is specified, the existing size is retained. 
        public let size: Int32?

        public init(volumeType: VolumeType? = nil, dryRun: Bool? = nil, iops: Int32? = nil, volumeId: String, size: Int32? = nil) {
            self.volumeType = volumeType
            self.dryRun = dryRun
            self.iops = iops
            self.volumeId = volumeId
            self.size = size
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeType = dictionary["VolumeType"] as? String { self.volumeType = VolumeType(rawValue: volumeType) } else { self.volumeType = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.iops = dictionary["Iops"] as? Int32
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.size = dictionary["Size"] as? Int32
        }
    }

    public struct DhcpConfigurationValueList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [AttributeValue]?

        public init(item: [AttributeValue]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try AttributeValue(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DescribeCustomerGatewaysResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more customer gateways.
        public let customerGateways: CustomerGatewayList?

        public init(customerGateways: CustomerGatewayList? = nil) {
            self.customerGateways = customerGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let customerGateways = dictionary["CustomerGatewaySet"] as? [String: Any] { self.customerGateways = try Ec2.CustomerGatewayList(dictionary: customerGateways) } else { self.customerGateways = nil }
        }
    }

    public struct ModifyInstanceAttributeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Modifies the DeleteOnTermination attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for DeleteOnTermination, the default is true and the volume is deleted when the instance is terminated. To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see Updating the Block Device Mapping when Launching an Instance in the Amazon Elastic Compute Cloud User Guide.
        public let blockDeviceMappings: InstanceBlockDeviceMappingSpecificationList?
        /// If the value is true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.
        public let disableApiTermination: AttributeBooleanValue?
        /// Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public let userData: BlobAttributeValue?
        /// Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance. There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.
        public let sriovNetSupport: AttributeValue?
        /// Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
        public let ebsOptimized: AttributeBooleanValue?
        /// Specifies whether source/destination checking is enabled. A value of true means that checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.
        public let sourceDestCheck: AttributeBooleanValue?
        /// The name of the attribute.
        public let attribute: InstanceAttributeName?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// Changes the instance type to the specified value. For more information, see Instance Types. If the instance type is not valid, the error returned is InvalidInstanceAttributeValue.
        public let instanceType: AttributeValue?
        /// Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB.
        public let ramdisk: AttributeValue?
        /// A new value for the attribute. Use only with the kernel, ramdisk, userData, disableApiTermination, or instanceInitiatedShutdownBehavior attribute.
        public let value: String?
        /// Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB.
        public let kernel: AttributeValue?
        /// The ID of the instance.
        public let instanceId: String
        /// Set to true to enable enhanced networking with ENA for the instance. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.
        public let enaSupport: AttributeBooleanValue?
        /// Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        public let instanceInitiatedShutdownBehavior: AttributeValue?
        /// [EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.
        public let groups: GroupIdStringList?

        public init(blockDeviceMappings: InstanceBlockDeviceMappingSpecificationList? = nil, disableApiTermination: AttributeBooleanValue? = nil, userData: BlobAttributeValue? = nil, sriovNetSupport: AttributeValue? = nil, ebsOptimized: AttributeBooleanValue? = nil, sourceDestCheck: AttributeBooleanValue? = nil, attribute: InstanceAttributeName? = nil, dryRun: Bool? = nil, instanceType: AttributeValue? = nil, ramdisk: AttributeValue? = nil, value: String? = nil, kernel: AttributeValue? = nil, instanceId: String, enaSupport: AttributeBooleanValue? = nil, instanceInitiatedShutdownBehavior: AttributeValue? = nil, groups: GroupIdStringList? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.disableApiTermination = disableApiTermination
            self.userData = userData
            self.sriovNetSupport = sriovNetSupport
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.attribute = attribute
            self.dryRun = dryRun
            self.instanceType = instanceType
            self.ramdisk = ramdisk
            self.value = value
            self.kernel = kernel
            self.instanceId = instanceId
            self.enaSupport = enaSupport
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMapping"] as? [String: Any] { self.blockDeviceMappings = try Ec2.InstanceBlockDeviceMappingSpecificationList(dictionary: blockDeviceMappings) } else { self.blockDeviceMappings = nil }
            if let disableApiTermination = dictionary["DisableApiTermination"] as? [String: Any] { self.disableApiTermination = try Ec2.AttributeBooleanValue(dictionary: disableApiTermination) } else { self.disableApiTermination = nil }
            if let userData = dictionary["UserData"] as? [String: Any] { self.userData = try Ec2.BlobAttributeValue(dictionary: userData) } else { self.userData = nil }
            if let sriovNetSupport = dictionary["SriovNetSupport"] as? [String: Any] { self.sriovNetSupport = try Ec2.AttributeValue(dictionary: sriovNetSupport) } else { self.sriovNetSupport = nil }
            if let ebsOptimized = dictionary["EbsOptimized"] as? [String: Any] { self.ebsOptimized = try Ec2.AttributeBooleanValue(dictionary: ebsOptimized) } else { self.ebsOptimized = nil }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) } else { self.sourceDestCheck = nil }
            if let attribute = dictionary["Attribute"] as? String { self.attribute = InstanceAttributeName(rawValue: attribute) } else { self.attribute = nil }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceType = dictionary["InstanceType"] as? [String: Any] { self.instanceType = try Ec2.AttributeValue(dictionary: instanceType) } else { self.instanceType = nil }
            if let ramdisk = dictionary["Ramdisk"] as? [String: Any] { self.ramdisk = try Ec2.AttributeValue(dictionary: ramdisk) } else { self.ramdisk = nil }
            self.value = dictionary["Value"] as? String
            if let kernel = dictionary["Kernel"] as? [String: Any] { self.kernel = try Ec2.AttributeValue(dictionary: kernel) } else { self.kernel = nil }
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            if let enaSupport = dictionary["EnaSupport"] as? [String: Any] { self.enaSupport = try Ec2.AttributeBooleanValue(dictionary: enaSupport) } else { self.enaSupport = nil }
            if let instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? [String: Any] { self.instanceInitiatedShutdownBehavior = try Ec2.AttributeValue(dictionary: instanceInitiatedShutdownBehavior) } else { self.instanceInitiatedShutdownBehavior = nil }
            if let groups = dictionary["GroupId"] as? [String: Any] { self.groups = try Ec2.GroupIdStringList(dictionary: groups) } else { self.groups = nil }
        }
    }

    public struct ScheduledInstanceRecurrence: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The frequency (Daily, Weekly, or Monthly).
        public let frequency: String?
        /// The unit for occurrenceDaySet (DayOfWeek or DayOfMonth).
        public let occurrenceUnit: String?
        /// Indicates whether the occurrence is relative to the end of the specified week or month.
        public let occurrenceRelativeToEnd: Bool?
        /// The interval quantity. The interval unit depends on the value of frequency. For example, every 2 weeks or every 2 months.
        public let interval: Int32?
        /// The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).
        public let occurrenceDaySet: OccurrenceDaySet?

        public init(frequency: String? = nil, occurrenceUnit: String? = nil, occurrenceRelativeToEnd: Bool? = nil, interval: Int32? = nil, occurrenceDaySet: OccurrenceDaySet? = nil) {
            self.frequency = frequency
            self.occurrenceUnit = occurrenceUnit
            self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
            self.interval = interval
            self.occurrenceDaySet = occurrenceDaySet
        }

        public init(dictionary: [String: Any]) throws {
            self.frequency = dictionary["Frequency"] as? String
            self.occurrenceUnit = dictionary["OccurrenceUnit"] as? String
            self.occurrenceRelativeToEnd = dictionary["OccurrenceRelativeToEnd"] as? Bool
            self.interval = dictionary["Interval"] as? Int32
            if let occurrenceDaySet = dictionary["OccurrenceDaySet"] as? [String: Any] { self.occurrenceDaySet = try Ec2.OccurrenceDaySet(dictionary: occurrenceDaySet) } else { self.occurrenceDaySet = nil }
        }
    }

    public struct CreateVpnGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the virtual private gateway.
        public let vpnGateway: VpnGateway?

        public init(vpnGateway: VpnGateway? = nil) {
            self.vpnGateway = vpnGateway
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnGateway = dictionary["VpnGateway"] as? [String: Any] { self.vpnGateway = try Ec2.VpnGateway(dictionary: vpnGateway) } else { self.vpnGateway = nil }
        }
    }

    public struct SnapshotDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A brief status of the snapshot creation.
        public let status: String?
        /// The percentage of progress for the task.
        public let progress: String?
        /// The URL used to access the disk image.
        public let url: String?
        /// The size of the disk in the snapshot, in GiB.
        public let diskImageSize: Double?
        /// The format of the disk image from which the snapshot is created.
        public let format: String?
        /// The snapshot ID of the disk being imported.
        public let snapshotId: String?
        /// The S3 bucket for the disk image.
        public let userBucket: UserBucketDetails?
        /// A detailed status message for the snapshot creation.
        public let statusMessage: String?
        /// The block device mapping for the snapshot.
        public let deviceName: String?
        /// A description for the snapshot.
        public let description: String?

        public init(status: String? = nil, progress: String? = nil, url: String? = nil, diskImageSize: Double? = nil, format: String? = nil, snapshotId: String? = nil, userBucket: UserBucketDetails? = nil, statusMessage: String? = nil, deviceName: String? = nil, description: String? = nil) {
            self.status = status
            self.progress = progress
            self.url = url
            self.diskImageSize = diskImageSize
            self.format = format
            self.snapshotId = snapshotId
            self.userBucket = userBucket
            self.statusMessage = statusMessage
            self.deviceName = deviceName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.progress = dictionary["Progress"] as? String
            self.url = dictionary["Url"] as? String
            self.diskImageSize = dictionary["DiskImageSize"] as? Double
            self.format = dictionary["Format"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucketDetails(dictionary: userBucket) } else { self.userBucket = nil }
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVpcClassicLinkDnsSupportRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more VPC IDs.
        public let vpcIds: VpcClassicLinkIdList?
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public let nextToken: String?
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int32?

        public init(vpcIds: VpcClassicLinkIdList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.vpcIds = vpcIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcIds = dictionary["VpcIds"] as? [String: Any] { self.vpcIds = try Ec2.VpcClassicLinkIdList(dictionary: vpcIds) } else { self.vpcIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteNatGatewayResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the NAT gateway.
        public let natGatewayId: String?

        public init(natGatewayId: String? = nil) {
            self.natGatewayId = natGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.natGatewayId = dictionary["NatGatewayId"] as? String
        }
    }

    public struct AttachNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The index of the device for the network interface attachment.
        public let deviceIndex: Int32
        /// The ID of the network interface.
        public let networkInterfaceId: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The ID of the instance.
        public let instanceId: String

        public init(deviceIndex: Int32, networkInterfaceId: String, dryRun: Bool? = nil, instanceId: String) {
            self.deviceIndex = deviceIndex
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let deviceIndex = dictionary["DeviceIndex"] as? Int32 else { throw InitializableError.missingRequiredParam("DeviceIndex") }
            self.deviceIndex = deviceIndex
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct PrivateIpAddressStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let privateIpAddress: [String]?

        public init(privateIpAddress: [String]? = nil) {
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? [String]
        }
    }

    public struct IpPermission: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more security group and AWS account ID pairs.
        public let userIdGroupPairs: UserIdGroupPairList?
        /// One or more IPv4 ranges.
        public let ipRanges: IpRangeList?
        /// [EC2-VPC only] One or more IPv6 ranges.
        public let ipv6Ranges: Ipv6RangeList?
        /// (Valid for AuthorizeSecurityGroupEgress, RevokeSecurityGroupEgress and DescribeSecurityGroups only) One or more prefix list IDs for an AWS service. In an AuthorizeSecurityGroupEgress request, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
        public let prefixListIds: PrefixListIdList?
        /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes for the specified ICMP type.
        public let toPort: Int32?
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers).  [EC2-VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. 
        public let ipProtocol: String?
        /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.
        public let fromPort: Int32?

        public init(userIdGroupPairs: UserIdGroupPairList? = nil, ipRanges: IpRangeList? = nil, ipv6Ranges: Ipv6RangeList? = nil, prefixListIds: PrefixListIdList? = nil, toPort: Int32? = nil, ipProtocol: String? = nil, fromPort: Int32? = nil) {
            self.userIdGroupPairs = userIdGroupPairs
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.ipProtocol = ipProtocol
            self.fromPort = fromPort
        }

        public init(dictionary: [String: Any]) throws {
            if let userIdGroupPairs = dictionary["Groups"] as? [String: Any] { self.userIdGroupPairs = try Ec2.UserIdGroupPairList(dictionary: userIdGroupPairs) } else { self.userIdGroupPairs = nil }
            if let ipRanges = dictionary["IpRanges"] as? [String: Any] { self.ipRanges = try Ec2.IpRangeList(dictionary: ipRanges) } else { self.ipRanges = nil }
            if let ipv6Ranges = dictionary["Ipv6Ranges"] as? [String: Any] { self.ipv6Ranges = try Ec2.Ipv6RangeList(dictionary: ipv6Ranges) } else { self.ipv6Ranges = nil }
            if let prefixListIds = dictionary["PrefixListIds"] as? [String: Any] { self.prefixListIds = try Ec2.PrefixListIdList(dictionary: prefixListIds) } else { self.prefixListIds = nil }
            self.toPort = dictionary["ToPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.fromPort = dictionary["FromPort"] as? Int32
        }
    }

    public struct VgwTelemetry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the VPN tunnel.
        public let status: TelemetryStatus?
        /// The date and time of the last change in status.
        public let lastStatusChange: Date?
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        public let outsideIpAddress: String?
        /// If an error occurs, a description of the error.
        public let statusMessage: String?
        /// The number of accepted routes.
        public let acceptedRouteCount: Int32?

        public init(status: TelemetryStatus? = nil, lastStatusChange: Date? = nil, outsideIpAddress: String? = nil, statusMessage: String? = nil, acceptedRouteCount: Int32? = nil) {
            self.status = status
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.statusMessage = statusMessage
            self.acceptedRouteCount = acceptedRouteCount
        }

        public init(dictionary: [String: Any]) throws {
            if let status = dictionary["Status"] as? String { self.status = TelemetryStatus(rawValue: status) } else { self.status = nil }
            self.lastStatusChange = dictionary["LastStatusChange"] as? Date
            self.outsideIpAddress = dictionary["OutsideIpAddress"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.acceptedRouteCount = dictionary["AcceptedRouteCount"] as? Int32
        }
    }

    public struct PrefixListIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [PrefixListId]?

        public init(item: [PrefixListId]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try PrefixListId(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct ReplaceNetworkAclAssociationResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the new association.
        public let newAssociationId: String?

        public init(newAssociationId: String? = nil) {
            self.newAssociationId = newAssociationId
        }

        public init(dictionary: [String: Any]) throws {
            self.newAssociationId = dictionary["NewAssociationId"] as? String
        }
    }

    public struct NetworkAclEntryList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [NetworkAclEntry]?

        public init(item: [NetworkAclEntry]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try NetworkAclEntry(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct Ipv6CidrBlockSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let item: [Ipv6CidrBlock]?

        public init(item: [Ipv6CidrBlock]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try Ipv6CidrBlock(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct DiskImageVolumeDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The size of the volume, in GiB.
        public let size: Int64?
        /// The volume identifier.
        public let id: String

        public init(size: Int64? = nil, id: String) {
            self.size = size
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.size = dictionary["Size"] as? Int64
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public enum VolumeState: String, CustomStringConvertible {
        case creating = "creating"
        case available = "available"
        case in_use = "in-use"
        case deleting = "deleting"
        case deleted = "deleted"
        case error = "error"
        public var description: String { return self.rawValue }
    }

    public struct AttributeValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The attribute value. Note that the value is case-sensitive.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
        }
    }

    public struct BundleIdStringList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let bundleId: [String]?

        public init(bundleId: [String]? = nil) {
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.bundleId = dictionary["BundleId"] as? [String]
        }
    }

    public struct ImportInstanceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the conversion task.
        public let conversionTask: ConversionTask?

        public init(conversionTask: ConversionTask? = nil) {
            self.conversionTask = conversionTask
        }

        public init(dictionary: [String: Any]) throws {
            if let conversionTask = dictionary["ConversionTask"] as? [String: Any] { self.conversionTask = try Ec2.ConversionTask(dictionary: conversionTask) } else { self.conversionTask = nil }
        }
    }

    public struct CreateDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A DHCP configuration option.
        public let dhcpConfigurations: NewDhcpConfigurationList
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?

        public init(dhcpConfigurations: NewDhcpConfigurationList, dryRun: Bool? = nil) {
            self.dhcpConfigurations = dhcpConfigurations
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let dhcpConfigurations = dictionary["DhcpConfiguration"] as? [String: Any] else { throw InitializableError.missingRequiredParam("DhcpConfiguration") }
            self.dhcpConfigurations = try Ec2.NewDhcpConfigurationList(dictionary: dhcpConfigurations)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ModifyIdentityIdFormatRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify all to modify the ID format for all IAM users, IAM roles, and the root user of the account.
        public let principalArn: String
        /// The type of resource: instance | reservation | snapshot | volume 
        public let resource: String
        /// Indicates whether the resource should use longer IDs (17-character IDs)
        public let useLongIds: Bool

        public init(principalArn: String, resource: String, useLongIds: Bool) {
            self.principalArn = principalArn
            self.resource = resource
            self.useLongIds = useLongIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let principalArn = dictionary["PrincipalArn"] as? String else { throw InitializableError.missingRequiredParam("PrincipalArn") }
            self.principalArn = principalArn
            guard let resource = dictionary["Resource"] as? String else { throw InitializableError.missingRequiredParam("Resource") }
            self.resource = resource
            guard let useLongIds = dictionary["UseLongIds"] as? Bool else { throw InitializableError.missingRequiredParam("UseLongIds") }
            self.useLongIds = useLongIds
        }
    }

    public struct SpotFleetRequestConfig: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The state of the Spot fleet request.
        public let spotFleetRequestState: BatchState
        /// The creation date and time of the request.
        public let createTime: Date
        /// The progress of the Spot fleet request. If there is an error, the status is error. After all bids are placed, the status is pending_fulfillment. If the size of the fleet is equal to or greater than its target capacity, the status is fulfilled. If the size of the fleet is decreased, the status is pending_termination while Spot instances are terminating.
        public let activityStatus: ActivityStatus?
        /// Information about the configuration of the Spot fleet request.
        public let spotFleetRequestConfig: SpotFleetRequestConfigData
        /// The ID of the Spot fleet request.
        public let spotFleetRequestId: String

        public init(spotFleetRequestState: BatchState, createTime: Date, activityStatus: ActivityStatus? = nil, spotFleetRequestConfig: SpotFleetRequestConfigData, spotFleetRequestId: String) {
            self.spotFleetRequestState = spotFleetRequestState
            self.createTime = createTime
            self.activityStatus = activityStatus
            self.spotFleetRequestConfig = spotFleetRequestConfig
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawSpotFleetRequestState = dictionary["SpotFleetRequestState"] as? String, let spotFleetRequestState = BatchState(rawValue: rawSpotFleetRequestState) else { throw InitializableError.missingRequiredParam("SpotFleetRequestState") }
            self.spotFleetRequestState = spotFleetRequestState
            guard let createTime = dictionary["CreateTime"] as? Date else { throw InitializableError.missingRequiredParam("CreateTime") }
            self.createTime = createTime
            if let activityStatus = dictionary["ActivityStatus"] as? String { self.activityStatus = ActivityStatus(rawValue: activityStatus) } else { self.activityStatus = nil }
            guard let spotFleetRequestConfig = dictionary["SpotFleetRequestConfig"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotFleetRequestConfig") }
            self.spotFleetRequestConfig = try Ec2.SpotFleetRequestConfigData(dictionary: spotFleetRequestConfig)
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct ModifyHostsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IDs of the Dedicated Hosts that were successfully modified.
        public let successful: ResponseHostIdList?
        /// The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.
        public let unsuccessful: UnsuccessfulItemList?

        public init(successful: ResponseHostIdList? = nil, unsuccessful: UnsuccessfulItemList? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let successful = dictionary["Successful"] as? [String: Any] { self.successful = try Ec2.ResponseHostIdList(dictionary: successful) } else { self.successful = nil }
            if let unsuccessful = dictionary["Unsuccessful"] as? [String: Any] { self.unsuccessful = try Ec2.UnsuccessfulItemList(dictionary: unsuccessful) } else { self.unsuccessful = nil }
        }
    }

    public struct DisassociateAddressRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// [EC2-Classic] The Elastic IP address. Required for EC2-Classic.
        public let publicIp: String?
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// [EC2-VPC] The association ID. Required for EC2-VPC.
        public let associationId: String?

        public init(publicIp: String? = nil, dryRun: Bool? = nil, associationId: String? = nil) {
            self.publicIp = publicIp
            self.dryRun = dryRun
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.publicIp = dictionary["PublicIp"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct ScheduledInstancesEbs: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the snapshot.
        public let snapshotId: String?
        /// Indicates whether the volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        /// The volume type. gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, Throughput Optimized HDD for st1, Cold HDD for sc1, or standard for Magnetic. Default: standard 
        public let volumeType: String?
        /// The size of the volume, in GiB. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        public let volumeSize: Int32?
        /// The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about gp2 baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        public let iops: Int32?
        /// Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.
        public let encrypted: Bool?

        public init(snapshotId: String? = nil, deleteOnTermination: Bool? = nil, volumeType: String? = nil, volumeSize: Int32? = nil, iops: Int32? = nil, encrypted: Bool? = nil) {
            self.snapshotId = snapshotId
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.volumeSize = volumeSize
            self.iops = iops
            self.encrypted = encrypted
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.volumeType = dictionary["VolumeType"] as? String
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.iops = dictionary["Iops"] as? Int32
            self.encrypted = dictionary["Encrypted"] as? Bool
        }
    }

    public struct UnmonitorInstancesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The monitoring information.
        public let instanceMonitorings: InstanceMonitoringList?

        public init(instanceMonitorings: InstanceMonitoringList? = nil) {
            self.instanceMonitorings = instanceMonitorings
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceMonitorings = dictionary["InstancesSet"] as? [String: Any] { self.instanceMonitorings = try Ec2.InstanceMonitoringList(dictionary: instanceMonitorings) } else { self.instanceMonitorings = nil }
        }
    }

    public struct InternetGateway: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Any tags assigned to the Internet gateway.
        public let tags: TagList?
        /// The ID of the Internet gateway.
        public let internetGatewayId: String?
        /// Any VPCs attached to the Internet gateway.
        public let attachments: InternetGatewayAttachmentList?

        public init(tags: TagList? = nil, internetGatewayId: String? = nil, attachments: InternetGatewayAttachmentList? = nil) {
            self.tags = tags
            self.internetGatewayId = internetGatewayId
            self.attachments = attachments
        }

        public init(dictionary: [String: Any]) throws {
            if let tags = dictionary["TagSet"] as? [String: Any] { self.tags = try Ec2.TagList(dictionary: tags) } else { self.tags = nil }
            self.internetGatewayId = dictionary["InternetGatewayId"] as? String
            if let attachments = dictionary["AttachmentSet"] as? [String: Any] { self.attachments = try Ec2.InternetGatewayAttachmentList(dictionary: attachments) } else { self.attachments = nil }
        }
    }

    public struct CreateVolumePermissionModifications: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Removes a specific AWS account ID or group from a volume's list of create volume permissions.
        public let remove: CreateVolumePermissionList?
        /// Adds a specific AWS account ID or group to a volume's list of create volume permissions.
        public let add: CreateVolumePermissionList?

        public init(remove: CreateVolumePermissionList? = nil, add: CreateVolumePermissionList? = nil) {
            self.remove = remove
            self.add = add
        }

        public init(dictionary: [String: Any]) throws {
            if let remove = dictionary["Remove"] as? [String: Any] { self.remove = try Ec2.CreateVolumePermissionList(dictionary: remove) } else { self.remove = nil }
            if let add = dictionary["Add"] as? [String: Any] { self.add = try Ec2.CreateVolumePermissionList(dictionary: add) } else { self.add = nil }
        }
    }

    public struct DescribeSpotFleetRequestsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The IDs of the Spot fleet requests.
        public let spotFleetRequestIds: ValueStringList?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?

        public init(dryRun: Bool? = nil, spotFleetRequestIds: ValueStringList? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.spotFleetRequestIds = spotFleetRequestIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let spotFleetRequestIds = dictionary["SpotFleetRequestId"] as? [String: Any] { self.spotFleetRequestIds = try Ec2.ValueStringList(dictionary: spotFleetRequestIds) } else { self.spotFleetRequestIds = nil }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeNetworkInterfacesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about one or more network interfaces.
        public let networkInterfaces: NetworkInterfaceList?

        public init(networkInterfaces: NetworkInterfaceList? = nil) {
            self.networkInterfaces = networkInterfaces
        }

        public init(dictionary: [String: Any]) throws {
            if let networkInterfaces = dictionary["NetworkInterfaceSet"] as? [String: Any] { self.networkInterfaces = try Ec2.NetworkInterfaceList(dictionary: networkInterfaces) } else { self.networkInterfaces = nil }
        }
    }

    public struct AssociationIdList: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public let associationId: [String]?

        public init(associationId: [String]? = nil) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.associationId = dictionary["AssociationId"] as? [String]
        }
    }

    public struct TargetConfigurationRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Convertible Reserved Instance offering ID.
        public let offeringId: String
        /// The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request
        public let instanceCount: Int32?

        public init(offeringId: String, instanceCount: Int32? = nil) {
            self.offeringId = offeringId
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let offeringId = dictionary["OfferingId"] as? String else { throw InitializableError.missingRequiredParam("OfferingId") }
            self.offeringId = offeringId
            self.instanceCount = dictionary["InstanceCount"] as? Int32
        }
    }

    public struct DescribeInstanceStatusResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more instance status descriptions.
        public let instanceStatuses: InstanceStatusList?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(instanceStatuses: InstanceStatusList? = nil, nextToken: String? = nil) {
            self.instanceStatuses = instanceStatuses
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceStatuses = dictionary["InstanceStatusSet"] as? [String: Any] { self.instanceStatuses = try Ec2.InstanceStatusList(dictionary: instanceStatuses) } else { self.instanceStatuses = nil }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public enum NetworkInterfaceStatus: String, CustomStringConvertible {
        case available = "available"
        case attaching = "attaching"
        case in_use = "in-use"
        case detaching = "detaching"
        public var description: String { return self.rawValue }
    }

}