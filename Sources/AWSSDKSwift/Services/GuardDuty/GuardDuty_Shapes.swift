// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension GuardDuty {

    public struct AcceptInvitationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "InvitationId", location: .body(locationName: "invitationId"), required: true, type: .string), 
            AWSShapeMember(label: "MasterId", location: .body(locationName: "masterId"), required: true, type: .string)
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String
        /// This value is used to validate the master account to the member account.
        public let invitationId: String
        /// The account ID of the master GuardDuty account whose invitation you're accepting.
        public let masterId: String

        public init(detectorId: String, invitationId: String, masterId: String) {
            self.detectorId = detectorId
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case invitationId = "invitationId"
            case masterId = "masterId"
        }
    }

    public struct AcceptInvitationResponse: AWSShape {


        public init() {
        }

    }

    public struct AccessKeyDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessKeyId", location: .body(locationName: "accessKeyId"), required: false, type: .string), 
            AWSShapeMember(label: "PrincipalId", location: .body(locationName: "principalId"), required: false, type: .string), 
            AWSShapeMember(label: "UserName", location: .body(locationName: "userName"), required: false, type: .string), 
            AWSShapeMember(label: "UserType", location: .body(locationName: "userType"), required: false, type: .string)
        ]

        /// Access key ID of the user.
        public let accessKeyId: String?
        /// The principal ID of the user.
        public let principalId: String?
        /// The name of the user.
        public let userName: String?
        /// The type of the user.
        public let userType: String?

        public init(accessKeyId: String? = nil, principalId: String? = nil, userName: String? = nil, userType: String? = nil) {
            self.accessKeyId = accessKeyId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case principalId = "principalId"
            case userName = "userName"
            case userType = "userType"
        }
    }

    public struct AccountDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", location: .body(locationName: "accountId"), required: true, type: .string), 
            AWSShapeMember(label: "Email", location: .body(locationName: "email"), required: true, type: .string)
        ]

        /// Member account ID.
        public let accountId: String
        /// Member account's email address.
        public let email: String

        public init(accountId: String, email: String) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name:"accountId", parent: name, max: 12)
            try validate(self.accountId, name:"accountId", parent: name, min: 12)
            try validate(self.email, name:"email", parent: name, max: 64)
            try validate(self.email, name:"email", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case email = "email"
        }
    }

    public struct Action: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionType", location: .body(locationName: "actionType"), required: false, type: .string), 
            AWSShapeMember(label: "AwsApiCallAction", location: .body(locationName: "awsApiCallAction"), required: false, type: .structure), 
            AWSShapeMember(label: "DnsRequestAction", location: .body(locationName: "dnsRequestAction"), required: false, type: .structure), 
            AWSShapeMember(label: "NetworkConnectionAction", location: .body(locationName: "networkConnectionAction"), required: false, type: .structure), 
            AWSShapeMember(label: "PortProbeAction", location: .body(locationName: "portProbeAction"), required: false, type: .structure)
        ]

        /// GuardDuty Finding activity type.
        public let actionType: String?
        /// Information about the AWS_API_CALL action described in this finding.
        public let awsApiCallAction: AwsApiCallAction?
        /// Information about the DNS_REQUEST action described in this finding.
        public let dnsRequestAction: DnsRequestAction?
        /// Information about the NETWORK_CONNECTION action described in this finding.
        public let networkConnectionAction: NetworkConnectionAction?
        /// Information about the PORT_PROBE action described in this finding.
        public let portProbeAction: PortProbeAction?

        public init(actionType: String? = nil, awsApiCallAction: AwsApiCallAction? = nil, dnsRequestAction: DnsRequestAction? = nil, networkConnectionAction: NetworkConnectionAction? = nil, portProbeAction: PortProbeAction? = nil) {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case awsApiCallAction = "awsApiCallAction"
            case dnsRequestAction = "dnsRequestAction"
            case networkConnectionAction = "networkConnectionAction"
            case portProbeAction = "portProbeAction"
        }
    }

    public struct ArchiveFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingIds", location: .body(locationName: "findingIds"), required: true, type: .list)
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to archive.
        public let detectorId: String
        /// IDs of the findings that you want to archive.
        public let findingIds: [String]

        public init(detectorId: String, findingIds: [String]) {
            self.detectorId = detectorId
            self.findingIds = findingIds
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try validate(self.findingIds, name:"findingIds", parent: name, max: 50)
            try validate(self.findingIds, name:"findingIds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case findingIds = "findingIds"
        }
    }

    public struct ArchiveFindingsResponse: AWSShape {


        public init() {
        }

    }

    public struct AwsApiCallAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Api", location: .body(locationName: "api"), required: false, type: .string), 
            AWSShapeMember(label: "CallerType", location: .body(locationName: "callerType"), required: false, type: .string), 
            AWSShapeMember(label: "DomainDetails", location: .body(locationName: "domainDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "RemoteIpDetails", location: .body(locationName: "remoteIpDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "ServiceName", location: .body(locationName: "serviceName"), required: false, type: .string)
        ]

        /// AWS API name.
        public let api: String?
        /// AWS API caller type.
        public let callerType: String?
        /// Domain information for the AWS API call.
        public let domainDetails: DomainDetails?
        /// Remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?
        /// AWS service name whose API was invoked.
        public let serviceName: String?

        public init(api: String? = nil, callerType: String? = nil, domainDetails: DomainDetails? = nil, remoteIpDetails: RemoteIpDetails? = nil, serviceName: String? = nil) {
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case api = "api"
            case callerType = "callerType"
            case domainDetails = "domainDetails"
            case remoteIpDetails = "remoteIpDetails"
            case serviceName = "serviceName"
        }
    }

    public struct City: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CityName", location: .body(locationName: "cityName"), required: false, type: .string)
        ]

        /// City name of the remote IP address.
        public let cityName: String?

        public init(cityName: String? = nil) {
            self.cityName = cityName
        }

        private enum CodingKeys: String, CodingKey {
            case cityName = "cityName"
        }
    }

    public struct Condition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Equals", location: .body(locationName: "equals"), required: false, type: .list), 
            AWSShapeMember(label: "GreaterThan", location: .body(locationName: "greaterThan"), required: false, type: .long), 
            AWSShapeMember(label: "GreaterThanOrEqual", location: .body(locationName: "greaterThanOrEqual"), required: false, type: .long), 
            AWSShapeMember(label: "LessThan", location: .body(locationName: "lessThan"), required: false, type: .long), 
            AWSShapeMember(label: "LessThanOrEqual", location: .body(locationName: "lessThanOrEqual"), required: false, type: .long), 
            AWSShapeMember(label: "NotEquals", location: .body(locationName: "notEquals"), required: false, type: .list)
        ]

        /// Represents an equal condition to be applied to a single field when querying for findings.
        public let equals: [String]?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public let greaterThan: Int64?
        /// Represents a greater than equal condition to be applied to a single field when querying for findings.
        public let greaterThanOrEqual: Int64?
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public let lessThan: Int64?
        /// Represents a less than equal condition to be applied to a single field when querying for findings.
        public let lessThanOrEqual: Int64?
        /// Represents an not equal condition to be applied to a single field when querying for findings.
        public let notEquals: [String]?

        public init(equals: [String]? = nil, greaterThan: Int64? = nil, greaterThanOrEqual: Int64? = nil, lessThan: Int64? = nil, lessThanOrEqual: Int64? = nil, notEquals: [String]? = nil) {
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.notEquals = notEquals
        }

        private enum CodingKeys: String, CodingKey {
            case equals = "equals"
            case greaterThan = "greaterThan"
            case greaterThanOrEqual = "greaterThanOrEqual"
            case lessThan = "lessThan"
            case lessThanOrEqual = "lessThanOrEqual"
            case notEquals = "notEquals"
        }
    }

    public struct Country: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CountryCode", location: .body(locationName: "countryCode"), required: false, type: .string), 
            AWSShapeMember(label: "CountryName", location: .body(locationName: "countryName"), required: false, type: .string)
        ]

        /// Country code of the remote IP address.
        public let countryCode: String?
        /// Country name of the remote IP address.
        public let countryName: String?

        public init(countryCode: String? = nil, countryName: String? = nil) {
            self.countryCode = countryCode
            self.countryName = countryName
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode = "countryCode"
            case countryName = "countryName"
        }
    }

    public struct CreateDetectorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientToken", location: .body(locationName: "clientToken"), required: false, type: .string), 
            AWSShapeMember(label: "Enable", location: .body(locationName: "enable"), required: true, type: .boolean), 
            AWSShapeMember(label: "FindingPublishingFrequency", location: .body(locationName: "findingPublishingFrequency"), required: false, type: .enum), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The idempotency token for the create request.
        public let clientToken: String?
        /// A boolean value that specifies whether the detector is to be enabled.
        public let enable: Bool
        /// A enum value that specifies how frequently customer got Finding updates published.
        public let findingPublishingFrequency: FindingPublishingFrequency?
        /// The tags to be added to a new detector resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDetectorRequest.idempotencyToken(), enable: Bool, findingPublishingFrequency: FindingPublishingFrequency? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.enable = enable
            self.findingPublishingFrequency = findingPublishingFrequency
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name:"clientToken", parent: name, max: 64)
            try validate(self.clientToken, name:"clientToken", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case enable = "enable"
            case findingPublishingFrequency = "findingPublishingFrequency"
            case tags = "tags"
        }
    }

    public struct CreateDetectorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .body(locationName: "detectorId"), required: false, type: .string)
        ]

        /// The unique ID of the created detector.
        public let detectorId: String?

        public init(detectorId: String? = nil) {
            self.detectorId = detectorId
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
        }
    }

    public struct CreateFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", location: .body(locationName: "action"), required: false, type: .enum), 
            AWSShapeMember(label: "ClientToken", location: .body(locationName: "clientToken"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingCriteria", location: .body(locationName: "findingCriteria"), required: true, type: .structure), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Rank", location: .body(locationName: "rank"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The description of the filter.
        public let description: String?
        /// The unique ID of the detector of the GuardDuty account for which you want to create a filter.
        public let detectorId: String
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria
        /// The name of the filter.
        public let name: String
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?
        /// The tags to be added to a new filter resource.
        public let tags: [String: String]?

        public init(action: FilterAction? = nil, clientToken: String? = CreateFilterRequest.idempotencyToken(), description: String? = nil, detectorId: String, findingCriteria: FindingCriteria, name: String, rank: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.name = name
            self.rank = rank
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name:"clientToken", parent: name, max: 64)
            try validate(self.clientToken, name:"clientToken", parent: name, min: 0)
            try validate(self.description, name:"description", parent: name, max: 512)
            try validate(self.description, name:"description", parent: name, min: 0)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 64)
            try validate(self.name, name:"name", parent: name, min: 3)
            try validate(self.rank, name:"rank", parent: name, max: 100)
            try validate(self.rank, name:"rank", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case description = "description"
            case detectorId = "detectorId"
            case findingCriteria = "findingCriteria"
            case name = "name"
            case rank = "rank"
            case tags = "tags"
        }
    }

    public struct CreateFilterResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string)
        ]

        /// The name of the successfully created filter.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct CreateIPSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Activate", location: .body(locationName: "activate"), required: true, type: .boolean), 
            AWSShapeMember(label: "ClientToken", location: .body(locationName: "clientToken"), required: false, type: .string), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "Format", location: .body(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "Location", location: .body(locationName: "location"), required: true, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// A boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.
        public let activate: Bool
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The unique ID of the detector of the GuardDuty account for which you want to create an IPSet.
        public let detectorId: String
        /// The format of the file that contains the IPSet.
        public let format: IpSetFormat
        /// The URI of the file that contains the IPSet. For example (https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key)
        public let location: String
        /// The user friendly name to identify the IPSet. This name is displayed in all findings that are triggered by activity that involves IP addresses included in this IPSet.
        public let name: String
        /// The tags to be added to a new IP set resource.
        public let tags: [String: String]?

        public init(activate: Bool, clientToken: String? = CreateIPSetRequest.idempotencyToken(), detectorId: String, format: IpSetFormat, location: String, name: String, tags: [String: String]? = nil) {
            self.activate = activate
            self.clientToken = clientToken
            self.detectorId = detectorId
            self.format = format
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name:"clientToken", parent: name, max: 64)
            try validate(self.clientToken, name:"clientToken", parent: name, min: 0)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.location, name:"location", parent: name, max: 300)
            try validate(self.location, name:"location", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 300)
            try validate(self.name, name:"name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case clientToken = "clientToken"
            case detectorId = "detectorId"
            case format = "format"
            case location = "location"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateIPSetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IpSetId", location: .body(locationName: "ipSetId"), required: true, type: .string)
        ]

        /// The ID of the IPSet resource.
        public let ipSetId: String

        public init(ipSetId: String) {
            self.ipSetId = ipSetId
        }

        private enum CodingKeys: String, CodingKey {
            case ipSetId = "ipSetId"
        }
    }

    public struct CreateMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountDetails", location: .body(locationName: "accountDetails"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// A list of account ID and email address pairs of the accounts that you want to associate with the master GuardDuty account.
        public let accountDetails: [AccountDetail]
        /// The unique ID of the detector of the GuardDuty account with which you want to associate member accounts.
        public let detectorId: String

        public init(accountDetails: [AccountDetail], detectorId: String) {
            self.accountDetails = accountDetails
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountDetails.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
            try validate(self.accountDetails, name:"accountDetails", parent: name, max: 50)
            try validate(self.accountDetails, name:"accountDetails", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails = "accountDetails"
            case detectorId = "detectorId"
        }
    }

    public struct CreateMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct CreateSampleFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingTypes", location: .body(locationName: "findingTypes"), required: false, type: .list)
        ]

        /// The ID of the detector to create sample findings for.
        public let detectorId: String
        /// Types of sample findings that you want to generate.
        public let findingTypes: [String]?

        public init(detectorId: String, findingTypes: [String]? = nil) {
            self.detectorId = detectorId
            self.findingTypes = findingTypes
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try self.findingTypes?.forEach {
                try validate($0, name: "findingTypes[]", parent: name, max: 50)
                try validate($0, name: "findingTypes[]", parent: name, min: 1)
            }
            try validate(self.findingTypes, name:"findingTypes", parent: name, max: 50)
            try validate(self.findingTypes, name:"findingTypes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case findingTypes = "findingTypes"
        }
    }

    public struct CreateSampleFindingsResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateThreatIntelSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Activate", location: .body(locationName: "activate"), required: true, type: .boolean), 
            AWSShapeMember(label: "ClientToken", location: .body(locationName: "clientToken"), required: false, type: .string), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "Format", location: .body(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "Location", location: .body(locationName: "location"), required: true, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// A boolean value that indicates whether GuardDuty is to start using the uploaded ThreatIntelSet.
        public let activate: Bool
        /// The idempotency token for the create request.
        public let clientToken: String?
        /// The unique ID of the detector of the GuardDuty account for which you want to create a threatIntelSet.
        public let detectorId: String
        /// The format of the file that contains the ThreatIntelSet.
        public let format: ThreatIntelSetFormat
        /// The URI of the file that contains the ThreatIntelSet. For example (https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key).
        public let location: String
        /// A user-friendly ThreatIntelSet name that is displayed in all finding generated by activity that involves IP addresses included in this ThreatIntelSet.
        public let name: String
        /// The tags to be added to a new Threat List resource.
        public let tags: [String: String]?

        public init(activate: Bool, clientToken: String? = CreateThreatIntelSetRequest.idempotencyToken(), detectorId: String, format: ThreatIntelSetFormat, location: String, name: String, tags: [String: String]? = nil) {
            self.activate = activate
            self.clientToken = clientToken
            self.detectorId = detectorId
            self.format = format
            self.location = location
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.clientToken, name:"clientToken", parent: name, max: 64)
            try validate(self.clientToken, name:"clientToken", parent: name, min: 0)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.location, name:"location", parent: name, max: 300)
            try validate(self.location, name:"location", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 300)
            try validate(self.name, name:"name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case clientToken = "clientToken"
            case detectorId = "detectorId"
            case format = "format"
            case location = "location"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateThreatIntelSetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ThreatIntelSetId", location: .body(locationName: "threatIntelSetId"), required: true, type: .string)
        ]

        /// The ID of the ThreatIntelSet resource.
        public let threatIntelSetId: String

        public init(threatIntelSetId: String) {
            self.threatIntelSetId = threatIntelSetId
        }

        private enum CodingKeys: String, CodingKey {
            case threatIntelSetId = "threatIntelSetId"
        }
    }

    public struct DeclineInvitationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list)
        ]

        /// A list of account IDs of the AWS accounts that sent invitations to the current member account that you want to decline invitations from.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DeleteDetectorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// The unique ID of the detector that you want to delete.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
        }
    }

    public struct DeleteDetectorResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FilterName", location: .uri(locationName: "filterName"), required: true, type: .string)
        ]

        /// The unique ID of the detector the filter is associated with.
        public let detectorId: String
        /// The name of the filter you want to delete.
        public let filterName: String

        public init(detectorId: String, filterName: String) {
            self.detectorId = detectorId
            self.filterName = filterName
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case filterName = "filterName"
        }
    }

    public struct DeleteFilterResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteIPSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "IpSetId", location: .uri(locationName: "ipSetId"), required: true, type: .string)
        ]

        /// The unique ID of the detector the ipSet is associated with.
        public let detectorId: String
        /// The unique ID of the ipSet you want to delete.
        public let ipSetId: String

        public init(detectorId: String, ipSetId: String) {
            self.detectorId = detectorId
            self.ipSetId = ipSetId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case ipSetId = "ipSetId"
        }
    }

    public struct DeleteIPSetResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteInvitationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list)
        ]

        /// A list of account IDs of the AWS accounts that sent invitations to the current member account that you want to delete invitations from.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DeleteMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// A list of account IDs of the GuardDuty member accounts that you want to delete.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whose members you want to delete.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case detectorId = "detectorId"
        }
    }

    public struct DeleteMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// The accounts that could not be processed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DeleteThreatIntelSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "ThreatIntelSetId", location: .uri(locationName: "threatIntelSetId"), required: true, type: .string)
        ]

        /// The unique ID of the detector the threatIntelSet is associated with.
        public let detectorId: String
        /// The unique ID of the threatIntelSet you want to delete.
        public let threatIntelSetId: String

        public init(detectorId: String, threatIntelSetId: String) {
            self.detectorId = detectorId
            self.threatIntelSetId = threatIntelSetId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case threatIntelSetId = "threatIntelSetId"
        }
    }

    public struct DeleteThreatIntelSetResponse: AWSShape {


        public init() {
        }

    }

    public enum DetectorStatus: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct DisassociateFromMasterAccountRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
        }
    }

    public struct DisassociateFromMasterAccountResponse: AWSShape {


        public init() {
        }

    }

    public struct DisassociateMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// A list of account IDs of the GuardDuty member accounts that you want to disassociate from master.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whose members you want to disassociate from master.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case detectorId = "detectorId"
        }
    }

    public struct DisassociateMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct DnsRequestAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Domain", location: .body(locationName: "domain"), required: false, type: .string)
        ]

        /// Domain information for the DNS request.
        public let domain: String?

        public init(domain: String? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct DomainDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Domain", location: .body(locationName: "domain"), required: false, type: .string)
        ]

        /// Domain information for the AWS API call.
        public let domain: String?

        public init(domain: String? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct Evidence: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ThreatIntelligenceDetails", location: .body(locationName: "threatIntelligenceDetails"), required: false, type: .list)
        ]

        /// A list of threat intelligence details related to the evidence.
        public let threatIntelligenceDetails: [ThreatIntelligenceDetail]?

        public init(threatIntelligenceDetails: [ThreatIntelligenceDetail]? = nil) {
            self.threatIntelligenceDetails = threatIntelligenceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case threatIntelligenceDetails = "threatIntelligenceDetails"
        }
    }

    public enum Feedback: String, CustomStringConvertible, Codable {
        case useful = "USEFUL"
        case notUseful = "NOT_USEFUL"
        public var description: String { return self.rawValue }
    }

    public enum FilterAction: String, CustomStringConvertible, Codable {
        case noop = "NOOP"
        case archive = "ARCHIVE"
        public var description: String { return self.rawValue }
    }

    public struct Finding: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", location: .body(locationName: "accountId"), required: true, type: .string), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: true, type: .string), 
            AWSShapeMember(label: "Confidence", location: .body(locationName: "confidence"), required: false, type: .double), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "Partition", location: .body(locationName: "partition"), required: false, type: .string), 
            AWSShapeMember(label: "Region", location: .body(locationName: "region"), required: true, type: .string), 
            AWSShapeMember(label: "Resource", location: .body(locationName: "resource"), required: true, type: .structure), 
            AWSShapeMember(label: "SchemaVersion", location: .body(locationName: "schemaVersion"), required: true, type: .string), 
            AWSShapeMember(label: "Service", location: .body(locationName: "service"), required: false, type: .structure), 
            AWSShapeMember(label: "Severity", location: .body(locationName: "severity"), required: true, type: .double), 
            AWSShapeMember(label: "Title", location: .body(locationName: "title"), required: false, type: .string), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: true, type: .string), 
            AWSShapeMember(label: "UpdatedAt", location: .body(locationName: "updatedAt"), required: true, type: .string)
        ]

        /// The ID of the account in which the finding was generated.
        public let accountId: String
        /// The ARN for the finding.
        public let arn: String
        /// The confidence score for the finding.
        public let confidence: Double?
        /// The time and date at which the finding was created.
        public let createdAt: String
        /// The description of the finding.
        public let description: String?
        /// The ID of the finding.
        public let id: String
        /// The partition associated with the finding.
        public let partition: String?
        /// The Region in which the finding was generated.
        public let region: String
        public let resource: Resource
        /// The version of the schema used for the finding.
        public let schemaVersion: String
        public let service: Service?
        /// The severity of the finding.
        public let severity: Double
        /// The title for the finding.
        public let title: String?
        /// The type of the finding.
        public let `type`: String
        /// The time and date at which the finding was laste updated.
        public let updatedAt: String

        public init(accountId: String, arn: String, confidence: Double? = nil, createdAt: String, description: String? = nil, id: String, partition: String? = nil, region: String, resource: Resource, schemaVersion: String, service: Service? = nil, severity: Double, title: String? = nil, type: String, updatedAt: String) {
            self.accountId = accountId
            self.arn = arn
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.region = region
            self.resource = resource
            self.schemaVersion = schemaVersion
            self.service = service
            self.severity = severity
            self.title = title
            self.`type` = `type`
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case arn = "arn"
            case confidence = "confidence"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case partition = "partition"
            case region = "region"
            case resource = "resource"
            case schemaVersion = "schemaVersion"
            case service = "service"
            case severity = "severity"
            case title = "title"
            case `type` = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct FindingCriteria: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Criterion", location: .body(locationName: "criterion"), required: false, type: .map)
        ]

        /// Represents a map of finding properties that match specified conditions and values when querying findings.
        public let criterion: [String: Condition]?

        public init(criterion: [String: Condition]? = nil) {
            self.criterion = criterion
        }

        private enum CodingKeys: String, CodingKey {
            case criterion = "criterion"
        }
    }

    public enum FindingPublishingFrequency: String, CustomStringConvertible, Codable {
        case fifteenMinutes = "FIFTEEN_MINUTES"
        case oneHour = "ONE_HOUR"
        case sixHours = "SIX_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatisticType: String, CustomStringConvertible, Codable {
        case countBySeverity = "COUNT_BY_SEVERITY"
        public var description: String { return self.rawValue }
    }

    public struct FindingStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CountBySeverity", location: .body(locationName: "countBySeverity"), required: false, type: .map)
        ]

        /// Represents a map of severity to count statistic for a set of findings
        public let countBySeverity: [String: Int]?

        public init(countBySeverity: [String: Int]? = nil) {
            self.countBySeverity = countBySeverity
        }

        private enum CodingKeys: String, CodingKey {
            case countBySeverity = "countBySeverity"
        }
    }

    public struct GeoLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Lat", location: .body(locationName: "lat"), required: false, type: .double), 
            AWSShapeMember(label: "Lon", location: .body(locationName: "lon"), required: false, type: .double)
        ]

        /// Latitude information of remote IP address.
        public let lat: Double?
        /// Longitude information of remote IP address.
        public let lon: Double?

        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat = "lat"
            case lon = "lon"
        }
    }

    public struct GetDetectorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// The unique ID of the detector that you want to get.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
        }
    }

    public struct GetDetectorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .string), 
            AWSShapeMember(label: "FindingPublishingFrequency", location: .body(locationName: "findingPublishingFrequency"), required: false, type: .enum), 
            AWSShapeMember(label: "ServiceRole", location: .body(locationName: "serviceRole"), required: true, type: .string), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: true, type: .enum), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "UpdatedAt", location: .body(locationName: "updatedAt"), required: false, type: .string)
        ]

        /// Detector creation timestamp.
        public let createdAt: String?
        /// Finding publishing frequency.
        public let findingPublishingFrequency: FindingPublishingFrequency?
        /// The GuardDuty service role.
        public let serviceRole: String
        /// The detector status.
        public let status: DetectorStatus
        /// The tags of the detector resource.
        public let tags: [String: String]?
        /// Detector last update timestamp.
        public let updatedAt: String?

        public init(createdAt: String? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, serviceRole: String, status: DetectorStatus, tags: [String: String]? = nil, updatedAt: String? = nil) {
            self.createdAt = createdAt
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case findingPublishingFrequency = "findingPublishingFrequency"
            case serviceRole = "serviceRole"
            case status = "status"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FilterName", location: .uri(locationName: "filterName"), required: true, type: .string)
        ]

        /// The unique ID of the detector the filter is associated with.
        public let detectorId: String
        /// The name of the filter you want to get.
        public let filterName: String

        public init(detectorId: String, filterName: String) {
            self.detectorId = detectorId
            self.filterName = filterName
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case filterName = "filterName"
        }
    }

    public struct GetFilterResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", location: .body(locationName: "action"), required: true, type: .enum), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "FindingCriteria", location: .body(locationName: "findingCriteria"), required: true, type: .structure), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Rank", location: .body(locationName: "rank"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction
        /// The description of the filter.
        public let description: String?
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria
        /// The name of the filter.
        public let name: String
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?
        /// The tags of the filter resource.
        public let tags: [String: String]?

        public init(action: FilterAction, description: String? = nil, findingCriteria: FindingCriteria, name: String, rank: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.description = description
            self.findingCriteria = findingCriteria
            self.name = name
            self.rank = rank
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case findingCriteria = "findingCriteria"
            case name = "name"
            case rank = "rank"
            case tags = "tags"
        }
    }

    public struct GetFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingIds", location: .body(locationName: "findingIds"), required: true, type: .list), 
            AWSShapeMember(label: "SortCriteria", location: .body(locationName: "sortCriteria"), required: false, type: .structure)
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to retrieve.
        public let detectorId: String
        /// IDs of the findings that you want to retrieve.
        public let findingIds: [String]
        /// Represents the criteria used for sorting findings.
        public let sortCriteria: SortCriteria?

        public init(detectorId: String, findingIds: [String], sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.findingIds = findingIds
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try validate(self.findingIds, name:"findingIds", parent: name, max: 50)
            try validate(self.findingIds, name:"findingIds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case findingIds = "findingIds"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Findings", location: .body(locationName: "findings"), required: true, type: .list)
        ]

        /// A list of findings.
        public let findings: [Finding]

        public init(findings: [Finding]) {
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
        }
    }

    public struct GetFindingsStatisticsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingCriteria", location: .body(locationName: "findingCriteria"), required: false, type: .structure), 
            AWSShapeMember(label: "FindingStatisticTypes", location: .body(locationName: "findingStatisticTypes"), required: true, type: .list)
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings' statistics you want to retrieve.
        public let detectorId: String
        /// Represents the criteria used for querying findings.
        public let findingCriteria: FindingCriteria?
        /// Types of finding statistics to retrieve.
        public let findingStatisticTypes: [FindingStatisticType]

        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, findingStatisticTypes: [FindingStatisticType]) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.findingStatisticTypes = findingStatisticTypes
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.findingStatisticTypes, name:"findingStatisticTypes", parent: name, max: 10)
            try validate(self.findingStatisticTypes, name:"findingStatisticTypes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case findingCriteria = "findingCriteria"
            case findingStatisticTypes = "findingStatisticTypes"
        }
    }

    public struct GetFindingsStatisticsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FindingStatistics", location: .body(locationName: "findingStatistics"), required: true, type: .structure)
        ]

        /// Finding statistics object.
        public let findingStatistics: FindingStatistics

        public init(findingStatistics: FindingStatistics) {
            self.findingStatistics = findingStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case findingStatistics = "findingStatistics"
        }
    }

    public struct GetIPSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "IpSetId", location: .uri(locationName: "ipSetId"), required: true, type: .string)
        ]

        /// The unique ID of the detector the ipSet is associated with.
        public let detectorId: String
        /// The unique ID of the ipSet you want to get.
        public let ipSetId: String

        public init(detectorId: String, ipSetId: String) {
            self.detectorId = detectorId
            self.ipSetId = ipSetId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case ipSetId = "ipSetId"
        }
    }

    public struct GetIPSetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Format", location: .body(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "Location", location: .body(locationName: "location"), required: true, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: true, type: .enum), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The format of the file that contains the IPSet.
        public let format: IpSetFormat
        /// The URI of the file that contains the IPSet. For example (https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key)
        public let location: String
        /// The user friendly name to identify the IPSet. This name is displayed in all findings that are triggered by activity that involves IP addresses included in this IPSet.
        public let name: String
        /// The status of ipSet file uploaded.
        public let status: IpSetStatus
        /// The tags of the IP set resource.
        public let tags: [String: String]?

        public init(format: IpSetFormat, location: String, name: String, status: IpSetStatus, tags: [String: String]? = nil) {
            self.format = format
            self.location = location
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case location = "location"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetInvitationsCountRequest: AWSShape {


        public init() {
        }

    }

    public struct GetInvitationsCountResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InvitationsCount", location: .body(locationName: "invitationsCount"), required: false, type: .integer)
        ]

        /// The number of received invitations.
        public let invitationsCount: Int?

        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "invitationsCount"
        }
    }

    public struct GetMasterAccountRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// The unique ID of the detector of the GuardDuty member account.
        public let detectorId: String

        public init(detectorId: String) {
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
        }
    }

    public struct GetMasterAccountResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Master", location: .body(locationName: "master"), required: true, type: .structure)
        ]

        /// Master account details.
        public let master: Master

        public init(master: Master) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "master"
        }
    }

    public struct GetMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// A list of account IDs of the GuardDuty member accounts that you want to describe.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whose members you want to retrieve.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case detectorId = "detectorId"
        }
    }

    public struct GetMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Members", location: .body(locationName: "members"), required: true, type: .list), 
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of members.
        public let members: [Member]
        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(members: [Member], unprocessedAccounts: [UnprocessedAccount]) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct GetThreatIntelSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "ThreatIntelSetId", location: .uri(locationName: "threatIntelSetId"), required: true, type: .string)
        ]

        /// The unique ID of the detector the threatIntelSet is associated with.
        public let detectorId: String
        /// The unique ID of the threatIntelSet you want to get.
        public let threatIntelSetId: String

        public init(detectorId: String, threatIntelSetId: String) {
            self.detectorId = detectorId
            self.threatIntelSetId = threatIntelSetId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case threatIntelSetId = "threatIntelSetId"
        }
    }

    public struct GetThreatIntelSetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Format", location: .body(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "Location", location: .body(locationName: "location"), required: true, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: true, type: .enum), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The format of the threatIntelSet.
        public let format: ThreatIntelSetFormat
        /// The URI of the file that contains the ThreatIntelSet. For example (https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key).
        public let location: String
        /// A user-friendly ThreatIntelSet name that is displayed in all finding generated by activity that involves IP addresses included in this ThreatIntelSet.
        public let name: String
        /// The status of threatIntelSet file uploaded.
        public let status: ThreatIntelSetStatus
        /// The tags of the Threat List resource.
        public let tags: [String: String]?

        public init(format: ThreatIntelSetFormat, location: String, name: String, status: ThreatIntelSetStatus, tags: [String: String]? = nil) {
            self.format = format
            self.location = location
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case location = "location"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct IamInstanceProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string)
        ]

        /// AWS EC2 instance profile ARN.
        public let arn: String?
        /// AWS EC2 instance profile ID.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct InstanceDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZone", location: .body(locationName: "availabilityZone"), required: false, type: .string), 
            AWSShapeMember(label: "IamInstanceProfile", location: .body(locationName: "iamInstanceProfile"), required: false, type: .structure), 
            AWSShapeMember(label: "ImageDescription", location: .body(locationName: "imageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "ImageId", location: .body(locationName: "imageId"), required: false, type: .string), 
            AWSShapeMember(label: "InstanceId", location: .body(locationName: "instanceId"), required: false, type: .string), 
            AWSShapeMember(label: "InstanceState", location: .body(locationName: "instanceState"), required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", location: .body(locationName: "instanceType"), required: false, type: .string), 
            AWSShapeMember(label: "LaunchTime", location: .body(locationName: "launchTime"), required: false, type: .string), 
            AWSShapeMember(label: "NetworkInterfaces", location: .body(locationName: "networkInterfaces"), required: false, type: .list), 
            AWSShapeMember(label: "Platform", location: .body(locationName: "platform"), required: false, type: .string), 
            AWSShapeMember(label: "ProductCodes", location: .body(locationName: "productCodes"), required: false, type: .list), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .list)
        ]

        /// The availability zone of the EC2 instance.
        public let availabilityZone: String?
        /// The profile information of the EC2 instance.
        public let iamInstanceProfile: IamInstanceProfile?
        /// The image description of the EC2 instance.
        public let imageDescription: String?
        /// The image ID of the EC2 instance.
        public let imageId: String?
        /// The ID of the EC2 instance.
        public let instanceId: String?
        /// The state of the EC2 instance.
        public let instanceState: String?
        /// The type of the EC2 instance.
        public let instanceType: String?
        /// The launch time of the EC2 instance.
        public let launchTime: String?
        /// The network interface information of the EC2 instance.
        public let networkInterfaces: [NetworkInterface]?
        /// The platform of the EC2 instance.
        public let platform: String?
        /// The product code of the EC2 instance.
        public let productCodes: [ProductCode]?
        /// The tags of the EC2 instance.
        public let tags: [Tag]?

        public init(availabilityZone: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil, imageDescription: String? = nil, imageId: String? = nil, instanceId: String? = nil, instanceState: String? = nil, instanceType: String? = nil, launchTime: String? = nil, networkInterfaces: [NetworkInterface]? = nil, platform: String? = nil, productCodes: [ProductCode]? = nil, tags: [Tag]? = nil) {
            self.availabilityZone = availabilityZone
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.launchTime = launchTime
            self.networkInterfaces = networkInterfaces
            self.platform = platform
            self.productCodes = productCodes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case iamInstanceProfile = "iamInstanceProfile"
            case imageDescription = "imageDescription"
            case imageId = "imageId"
            case instanceId = "instanceId"
            case instanceState = "instanceState"
            case instanceType = "instanceType"
            case launchTime = "launchTime"
            case networkInterfaces = "networkInterfaces"
            case platform = "platform"
            case productCodes = "productCodes"
            case tags = "tags"
        }
    }

    public struct Invitation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", location: .body(locationName: "accountId"), required: false, type: .string), 
            AWSShapeMember(label: "InvitationId", location: .body(locationName: "invitationId"), required: false, type: .string), 
            AWSShapeMember(label: "InvitedAt", location: .body(locationName: "invitedAt"), required: false, type: .string), 
            AWSShapeMember(label: "RelationshipStatus", location: .body(locationName: "relationshipStatus"), required: false, type: .string)
        ]

        /// Inviter account ID
        public let accountId: String?
        /// This value is used to validate the inviter account to the member account.
        public let invitationId: String?
        /// Timestamp at which the invitation was sent
        public let invitedAt: String?
        /// The status of the relationship between the inviter and invitee accounts.
        public let relationshipStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case invitationId = "invitationId"
            case invitedAt = "invitedAt"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct InviteMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "DisableEmailNotification", location: .body(locationName: "disableEmailNotification"), required: false, type: .boolean), 
            AWSShapeMember(label: "Message", location: .body(locationName: "message"), required: false, type: .string)
        ]

        /// A list of account IDs of the accounts that you want to invite to GuardDuty as members.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account with which you want to invite members.
        public let detectorId: String
        /// A boolean value that specifies whether you want to disable email notification to the accounts that youre inviting to GuardDuty as members.
        public let disableEmailNotification: Bool?
        /// The invitation message that you want to send to the accounts that youre inviting to GuardDuty as members.
        public let message: String?

        public init(accountIds: [String], detectorId: String, disableEmailNotification: Bool? = nil, message: String? = nil) {
            self.accountIds = accountIds
            self.detectorId = detectorId
            self.disableEmailNotification = disableEmailNotification
            self.message = message
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case detectorId = "detectorId"
            case disableEmailNotification = "disableEmailNotification"
            case message = "message"
        }
    }

    public struct InviteMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public enum IpSetFormat: String, CustomStringConvertible, Codable {
        case txt = "TXT"
        case stix = "STIX"
        case otxCsv = "OTX_CSV"
        case alienVault = "ALIEN_VAULT"
        case proofPoint = "PROOF_POINT"
        case fireEye = "FIRE_EYE"
        public var description: String { return self.rawValue }
    }

    public enum IpSetStatus: String, CustomStringConvertible, Codable {
        case inactive = "INACTIVE"
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deactivating = "DEACTIVATING"
        case error = "ERROR"
        case deletePending = "DELETE_PENDING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct ListDetectorsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDetectorsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorIds", location: .body(locationName: "detectorIds"), required: true, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        /// A list of detector Ids.
        public let detectorIds: [String]
        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(detectorIds: [String], nextToken: String? = nil) {
            self.detectorIds = detectorIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case detectorIds = "detectorIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The unique ID of the detector the filter is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterNames", location: .body(locationName: "filterNames"), required: true, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        /// A list of filter names
        public let filterNames: [String]
        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(filterNames: [String], nextToken: String? = nil) {
            self.filterNames = filterNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filterNames = "filterNames"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingCriteria", location: .body(locationName: "findingCriteria"), required: false, type: .structure), 
            AWSShapeMember(label: "MaxResults", location: .body(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "SortCriteria", location: .body(locationName: "sortCriteria"), required: false, type: .structure)
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to list.
        public let detectorId: String
        /// Represents the criteria used for querying findings.
        public let findingCriteria: FindingCriteria?
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Represents the criteria used for sorting findings.
        public let sortCriteria: SortCriteria?

        public init(detectorId: String, findingCriteria: FindingCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.detectorId = detectorId
            self.findingCriteria = findingCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case findingCriteria = "findingCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct ListFindingsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FindingIds", location: .body(locationName: "findingIds"), required: true, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The IDs of the findings you are listing.
        public let findingIds: [String]
        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(findingIds: [String], nextToken: String? = nil) {
            self.findingIds = findingIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListIPSetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The unique ID of the detector the ipSet is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListIPSetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IpSetIds", location: .body(locationName: "ipSetIds"), required: true, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The IDs of the IPSet resources.
        public let ipSetIds: [String]
        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(ipSetIds: [String], nextToken: String? = nil) {
            self.ipSetIds = ipSetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ipSetIds = "ipSetIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListInvitationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListInvitationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Invitations", location: .body(locationName: "invitations"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        /// A list of invitation descriptions.
        public let invitations: [Invitation]?
        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "invitations"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "OnlyAssociated", location: .querystring(locationName: "onlyAssociated"), required: false, type: .string)
        ]

        /// The unique ID of the detector the member is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Specifies whether to only return associated members or to return all members (including members which haven't been invited yet or have been disassociated).
        public let onlyAssociated: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case onlyAssociated = "onlyAssociated"
        }
    }

    public struct ListMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Members", location: .body(locationName: "members"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        /// A list of members.
        public let members: [Member]?
        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) for the given GuardDuty resource 
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The tags associated with the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListThreatIntelSetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The unique ID of the detector the threatIntelSet is associated with.
        public let detectorId: String
        /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
        public let maxResults: Int?
        /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(detectorId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.detectorId = detectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListThreatIntelSetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "ThreatIntelSetIds", location: .body(locationName: "threatIntelSetIds"), required: true, type: .list)
        ]

        /// Pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// The IDs of the ThreatIntelSet resources.
        public let threatIntelSetIds: [String]

        public init(nextToken: String? = nil, threatIntelSetIds: [String]) {
            self.nextToken = nextToken
            self.threatIntelSetIds = threatIntelSetIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case threatIntelSetIds = "threatIntelSetIds"
        }
    }

    public struct LocalPortDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Port", location: .body(locationName: "port"), required: false, type: .integer), 
            AWSShapeMember(label: "PortName", location: .body(locationName: "portName"), required: false, type: .string)
        ]

        /// Port number of the local connection.
        public let port: Int?
        /// Port name of the local connection.
        public let portName: String?

        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case portName = "portName"
        }
    }

    public struct Master: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", location: .body(locationName: "accountId"), required: false, type: .string), 
            AWSShapeMember(label: "InvitationId", location: .body(locationName: "invitationId"), required: false, type: .string), 
            AWSShapeMember(label: "InvitedAt", location: .body(locationName: "invitedAt"), required: false, type: .string), 
            AWSShapeMember(label: "RelationshipStatus", location: .body(locationName: "relationshipStatus"), required: false, type: .string)
        ]

        /// The ID of the account used as the Master account.
        public let accountId: String?
        /// This value is used to validate the master account to the member account.
        public let invitationId: String?
        /// Timestamp at which the invitation was sent.
        public let invitedAt: String?
        /// The status of the relationship between the master and member accounts.
        public let relationshipStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: String? = nil, relationshipStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case invitationId = "invitationId"
            case invitedAt = "invitedAt"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct Member: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", location: .body(locationName: "accountId"), required: true, type: .string), 
            AWSShapeMember(label: "DetectorId", location: .body(locationName: "detectorId"), required: false, type: .string), 
            AWSShapeMember(label: "Email", location: .body(locationName: "email"), required: true, type: .string), 
            AWSShapeMember(label: "InvitedAt", location: .body(locationName: "invitedAt"), required: false, type: .string), 
            AWSShapeMember(label: "MasterId", location: .body(locationName: "masterId"), required: true, type: .string), 
            AWSShapeMember(label: "RelationshipStatus", location: .body(locationName: "relationshipStatus"), required: true, type: .string), 
            AWSShapeMember(label: "UpdatedAt", location: .body(locationName: "updatedAt"), required: true, type: .string)
        ]

        /// Member account ID.
        public let accountId: String
        /// Member account's detector ID.
        public let detectorId: String?
        /// Member account's email address.
        public let email: String
        /// Timestamp at which the invitation was sent
        public let invitedAt: String?
        /// Master account ID.
        public let masterId: String
        /// The status of the relationship between the member and the master.
        public let relationshipStatus: String
        /// Member last updated timestamp.
        public let updatedAt: String

        public init(accountId: String, detectorId: String? = nil, email: String, invitedAt: String? = nil, masterId: String, relationshipStatus: String, updatedAt: String) {
            self.accountId = accountId
            self.detectorId = detectorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case detectorId = "detectorId"
            case email = "email"
            case invitedAt = "invitedAt"
            case masterId = "masterId"
            case relationshipStatus = "relationshipStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct NetworkConnectionAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Blocked", location: .body(locationName: "blocked"), required: false, type: .boolean), 
            AWSShapeMember(label: "ConnectionDirection", location: .body(locationName: "connectionDirection"), required: false, type: .string), 
            AWSShapeMember(label: "LocalPortDetails", location: .body(locationName: "localPortDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "Protocol", location: .body(locationName: "protocol"), required: false, type: .string), 
            AWSShapeMember(label: "RemoteIpDetails", location: .body(locationName: "remoteIpDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "RemotePortDetails", location: .body(locationName: "remotePortDetails"), required: false, type: .structure)
        ]

        /// Network connection blocked information.
        public let blocked: Bool?
        /// Network connection direction.
        public let connectionDirection: String?
        /// Local port information of the connection.
        public let localPortDetails: LocalPortDetails?
        /// Network connection protocol.
        public let `protocol`: String?
        /// Remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?
        /// Remote port information of the connection.
        public let remotePortDetails: RemotePortDetails?

        public init(blocked: Bool? = nil, connectionDirection: String? = nil, localPortDetails: LocalPortDetails? = nil, protocol: String? = nil, remoteIpDetails: RemoteIpDetails? = nil, remotePortDetails: RemotePortDetails? = nil) {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "blocked"
            case connectionDirection = "connectionDirection"
            case localPortDetails = "localPortDetails"
            case `protocol` = "protocol"
            case remoteIpDetails = "remoteIpDetails"
            case remotePortDetails = "remotePortDetails"
        }
    }

    public struct NetworkInterface: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Ipv6Addresses", location: .body(locationName: "ipv6Addresses"), required: false, type: .list), 
            AWSShapeMember(label: "NetworkInterfaceId", location: .body(locationName: "networkInterfaceId"), required: false, type: .string), 
            AWSShapeMember(label: "PrivateDnsName", location: .body(locationName: "privateDnsName"), required: false, type: .string), 
            AWSShapeMember(label: "PrivateIpAddress", location: .body(locationName: "privateIpAddress"), required: false, type: .string), 
            AWSShapeMember(label: "PrivateIpAddresses", location: .body(locationName: "privateIpAddresses"), required: false, type: .list), 
            AWSShapeMember(label: "PublicDnsName", location: .body(locationName: "publicDnsName"), required: false, type: .string), 
            AWSShapeMember(label: "PublicIp", location: .body(locationName: "publicIp"), required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroups", location: .body(locationName: "securityGroups"), required: false, type: .list), 
            AWSShapeMember(label: "SubnetId", location: .body(locationName: "subnetId"), required: false, type: .string), 
            AWSShapeMember(label: "VpcId", location: .body(locationName: "vpcId"), required: false, type: .string)
        ]

        /// A list of EC2 instance IPv6 address information.
        public let ipv6Addresses: [String]?
        /// The ID of the network interface
        public let networkInterfaceId: String?
        /// Private DNS name of the EC2 instance.
        public let privateDnsName: String?
        /// Private IP address of the EC2 instance.
        public let privateIpAddress: String?
        /// Other private IP address information of the EC2 instance.
        public let privateIpAddresses: [PrivateIpAddressDetails]?
        /// Public DNS name of the EC2 instance.
        public let publicDnsName: String?
        /// Public IP address of the EC2 instance.
        public let publicIp: String?
        /// Security groups associated with the EC2 instance.
        public let securityGroups: [SecurityGroup]?
        /// The subnet ID of the EC2 instance.
        public let subnetId: String?
        /// The VPC ID of the EC2 instance.
        public let vpcId: String?

        public init(ipv6Addresses: [String]? = nil, networkInterfaceId: String? = nil, privateDnsName: String? = nil, privateIpAddress: String? = nil, privateIpAddresses: [PrivateIpAddressDetails]? = nil, publicDnsName: String? = nil, publicIp: String? = nil, securityGroups: [SecurityGroup]? = nil, subnetId: String? = nil, vpcId: String? = nil) {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Addresses = "ipv6Addresses"
            case networkInterfaceId = "networkInterfaceId"
            case privateDnsName = "privateDnsName"
            case privateIpAddress = "privateIpAddress"
            case privateIpAddresses = "privateIpAddresses"
            case publicDnsName = "publicDnsName"
            case publicIp = "publicIp"
            case securityGroups = "securityGroups"
            case subnetId = "subnetId"
            case vpcId = "vpcId"
        }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public struct Organization: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Asn", location: .body(locationName: "asn"), required: false, type: .string), 
            AWSShapeMember(label: "AsnOrg", location: .body(locationName: "asnOrg"), required: false, type: .string), 
            AWSShapeMember(label: "Isp", location: .body(locationName: "isp"), required: false, type: .string), 
            AWSShapeMember(label: "Org", location: .body(locationName: "org"), required: false, type: .string)
        ]

        /// Autonomous system number of the internet provider of the remote IP address.
        public let asn: String?
        /// Organization that registered this ASN.
        public let asnOrg: String?
        /// ISP information for the internet provider.
        public let isp: String?
        /// Name of the internet provider.
        public let org: String?

        public init(asn: String? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "asn"
            case asnOrg = "asnOrg"
            case isp = "isp"
            case org = "org"
        }
    }

    public struct PortProbeAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Blocked", location: .body(locationName: "blocked"), required: false, type: .boolean), 
            AWSShapeMember(label: "PortProbeDetails", location: .body(locationName: "portProbeDetails"), required: false, type: .list)
        ]

        /// Port probe blocked information.
        public let blocked: Bool?
        /// A list of port probe details objects.
        public let portProbeDetails: [PortProbeDetail]?

        public init(blocked: Bool? = nil, portProbeDetails: [PortProbeDetail]? = nil) {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "blocked"
            case portProbeDetails = "portProbeDetails"
        }
    }

    public struct PortProbeDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LocalPortDetails", location: .body(locationName: "localPortDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "RemoteIpDetails", location: .body(locationName: "remoteIpDetails"), required: false, type: .structure)
        ]

        /// Local port information of the connection.
        public let localPortDetails: LocalPortDetails?
        /// Remote IP information of the connection.
        public let remoteIpDetails: RemoteIpDetails?

        public init(localPortDetails: LocalPortDetails? = nil, remoteIpDetails: RemoteIpDetails? = nil) {
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }

        private enum CodingKeys: String, CodingKey {
            case localPortDetails = "localPortDetails"
            case remoteIpDetails = "remoteIpDetails"
        }
    }

    public struct PrivateIpAddressDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PrivateDnsName", location: .body(locationName: "privateDnsName"), required: false, type: .string), 
            AWSShapeMember(label: "PrivateIpAddress", location: .body(locationName: "privateIpAddress"), required: false, type: .string)
        ]

        /// Private DNS name of the EC2 instance.
        public let privateDnsName: String?
        /// Private IP address of the EC2 instance.
        public let privateIpAddress: String?

        public init(privateDnsName: String? = nil, privateIpAddress: String? = nil) {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }

        private enum CodingKeys: String, CodingKey {
            case privateDnsName = "privateDnsName"
            case privateIpAddress = "privateIpAddress"
        }
    }

    public struct ProductCode: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", location: .body(locationName: "code"), required: false, type: .string), 
            AWSShapeMember(label: "ProductType", location: .body(locationName: "productType"), required: false, type: .string)
        ]

        /// Product code information.
        public let code: String?
        /// Product code type.
        public let productType: String?

        public init(code: String? = nil, productType: String? = nil) {
            self.code = code
            self.productType = productType
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case productType = "productType"
        }
    }

    public struct RemoteIpDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "City", location: .body(locationName: "city"), required: false, type: .structure), 
            AWSShapeMember(label: "Country", location: .body(locationName: "country"), required: false, type: .structure), 
            AWSShapeMember(label: "GeoLocation", location: .body(locationName: "geoLocation"), required: false, type: .structure), 
            AWSShapeMember(label: "IpAddressV4", location: .body(locationName: "ipAddressV4"), required: false, type: .string), 
            AWSShapeMember(label: "Organization", location: .body(locationName: "organization"), required: false, type: .structure)
        ]

        /// City information of the remote IP address.
        public let city: City?
        /// Country code of the remote IP address.
        public let country: Country?
        /// Location information of the remote IP address.
        public let geoLocation: GeoLocation?
        /// IPV4 remote address of the connection.
        public let ipAddressV4: String?
        /// ISP Organization information of the remote IP address.
        public let organization: Organization?

        public init(city: City? = nil, country: Country? = nil, geoLocation: GeoLocation? = nil, ipAddressV4: String? = nil, organization: Organization? = nil) {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }

        private enum CodingKeys: String, CodingKey {
            case city = "city"
            case country = "country"
            case geoLocation = "geoLocation"
            case ipAddressV4 = "ipAddressV4"
            case organization = "organization"
        }
    }

    public struct RemotePortDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Port", location: .body(locationName: "port"), required: false, type: .integer), 
            AWSShapeMember(label: "PortName", location: .body(locationName: "portName"), required: false, type: .string)
        ]

        /// Port number of the remote connection.
        public let port: Int?
        /// Port name of the remote connection.
        public let portName: String?

        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case portName = "portName"
        }
    }

    public struct Resource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessKeyDetails", location: .body(locationName: "accessKeyDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "InstanceDetails", location: .body(locationName: "instanceDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "ResourceType", location: .body(locationName: "resourceType"), required: false, type: .string)
        ]

        /// The IAM access key details (IAM user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding.
        public let accessKeyDetails: AccessKeyDetails?
        /// The information about the EC2 instance associated with the activity that prompted GuardDuty to generate a finding.
        public let instanceDetails: InstanceDetails?
        /// The type of the AWS resource.
        public let resourceType: String?

        public init(accessKeyDetails: AccessKeyDetails? = nil, instanceDetails: InstanceDetails? = nil, resourceType: String? = nil) {
            self.accessKeyDetails = accessKeyDetails
            self.instanceDetails = instanceDetails
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyDetails = "accessKeyDetails"
            case instanceDetails = "instanceDetails"
            case resourceType = "resourceType"
        }
    }

    public struct SecurityGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupId", location: .body(locationName: "groupId"), required: false, type: .string), 
            AWSShapeMember(label: "GroupName", location: .body(locationName: "groupName"), required: false, type: .string)
        ]

        /// EC2 instance's security group ID.
        public let groupId: String?
        /// EC2 instance's security group name.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
            case groupName = "groupName"
        }
    }

    public struct Service: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", location: .body(locationName: "action"), required: false, type: .structure), 
            AWSShapeMember(label: "Archived", location: .body(locationName: "archived"), required: false, type: .boolean), 
            AWSShapeMember(label: "Count", location: .body(locationName: "count"), required: false, type: .integer), 
            AWSShapeMember(label: "DetectorId", location: .body(locationName: "detectorId"), required: false, type: .string), 
            AWSShapeMember(label: "EventFirstSeen", location: .body(locationName: "eventFirstSeen"), required: false, type: .string), 
            AWSShapeMember(label: "EventLastSeen", location: .body(locationName: "eventLastSeen"), required: false, type: .string), 
            AWSShapeMember(label: "Evidence", location: .body(locationName: "evidence"), required: false, type: .structure), 
            AWSShapeMember(label: "ResourceRole", location: .body(locationName: "resourceRole"), required: false, type: .string), 
            AWSShapeMember(label: "ServiceName", location: .body(locationName: "serviceName"), required: false, type: .string), 
            AWSShapeMember(label: "UserFeedback", location: .body(locationName: "userFeedback"), required: false, type: .string)
        ]

        /// Information about the activity described in a finding.
        public let action: Action?
        /// Indicates whether this finding is archived.
        public let archived: Bool?
        /// Total count of the occurrences of this finding type.
        public let count: Int?
        /// Detector ID for the GuardDuty service.
        public let detectorId: String?
        /// First seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public let eventFirstSeen: String?
        /// Last seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public let eventLastSeen: String?
        /// An evidence object associated with the service.
        public let evidence: Evidence?
        /// Resource role information for this finding.
        public let resourceRole: String?
        /// The name of the AWS service (GuardDuty) that generated a finding.
        public let serviceName: String?
        /// Feedback left about the finding.
        public let userFeedback: String?

        public init(action: Action? = nil, archived: Bool? = nil, count: Int? = nil, detectorId: String? = nil, eventFirstSeen: String? = nil, eventLastSeen: String? = nil, evidence: Evidence? = nil, resourceRole: String? = nil, serviceName: String? = nil, userFeedback: String? = nil) {
            self.action = action
            self.archived = archived
            self.count = count
            self.detectorId = detectorId
            self.eventFirstSeen = eventFirstSeen
            self.eventLastSeen = eventLastSeen
            self.evidence = evidence
            self.resourceRole = resourceRole
            self.serviceName = serviceName
            self.userFeedback = userFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case archived = "archived"
            case count = "count"
            case detectorId = "detectorId"
            case eventFirstSeen = "eventFirstSeen"
            case eventLastSeen = "eventLastSeen"
            case evidence = "evidence"
            case resourceRole = "resourceRole"
            case serviceName = "serviceName"
            case userFeedback = "userFeedback"
        }
    }

    public struct SortCriteria: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributeName", location: .body(locationName: "attributeName"), required: false, type: .string), 
            AWSShapeMember(label: "OrderBy", location: .body(locationName: "orderBy"), required: false, type: .enum)
        ]

        /// Represents the finding attribute (for example, accountId) by which to sort findings.
        public let attributeName: String?
        /// Order by which the sorted findings are to be displayed.
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "attributeName"
            case orderBy = "orderBy"
        }
    }

    public struct StartMonitoringMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// A list of account IDs of the GuardDuty member accounts whose findings you want the master account to monitor.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account whom you want to re-enable to monitor members' findings.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case detectorId = "detectorId"
        }
    }

    public struct StartMonitoringMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct StopMonitoringMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", location: .body(locationName: "accountIds"), required: true, type: .list), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string)
        ]

        /// A list of account IDs of the GuardDuty member accounts whose findings you want the master account to stop monitoring.
        public let accountIds: [String]
        /// The unique ID of the detector of the GuardDuty account that you want to stop from monitor members' findings.
        public let detectorId: String

        public init(accountIds: [String], detectorId: String) {
            self.accountIds = accountIds
            self.detectorId = detectorId
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
            }
            try validate(self.accountIds, name:"accountIds", parent: name, max: 50)
            try validate(self.accountIds, name:"accountIds", parent: name, min: 1)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case detectorId = "detectorId"
        }
    }

    public struct StopMonitoringMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", location: .body(locationName: "unprocessedAccounts"), required: true, type: .list)
        ]

        /// A list of objects containing the unprocessed account and a result string explaining why it was unprocessed.
        public let unprocessedAccounts: [UnprocessedAccount]

        public init(unprocessedAccounts: [UnprocessedAccount]) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "unprocessedAccounts"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", location: .body(locationName: "key"), required: false, type: .string), 
            AWSShapeMember(label: "Value", location: .body(locationName: "value"), required: false, type: .string)
        ]

        /// EC2 instance tag key.
        public let key: String?
        /// EC2 instance tag value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: true, type: .map)
        ]

        /// The Amazon Resource Name (ARN) for the given GuardDuty resource 
        public let resourceArn: String
        /// The tags to be added to a resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
            try self.tags.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSShape {


        public init() {
        }

    }

    public enum ThreatIntelSetFormat: String, CustomStringConvertible, Codable {
        case txt = "TXT"
        case stix = "STIX"
        case otxCsv = "OTX_CSV"
        case alienVault = "ALIEN_VAULT"
        case proofPoint = "PROOF_POINT"
        case fireEye = "FIRE_EYE"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelSetStatus: String, CustomStringConvertible, Codable {
        case inactive = "INACTIVE"
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case deactivating = "DEACTIVATING"
        case error = "ERROR"
        case deletePending = "DELETE_PENDING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct ThreatIntelligenceDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ThreatListName", location: .body(locationName: "threatListName"), required: false, type: .string), 
            AWSShapeMember(label: "ThreatNames", location: .body(locationName: "threatNames"), required: false, type: .list)
        ]

        /// The name of the threat intelligence list that triggered the finding.
        public let threatListName: String?
        /// A list of names of the threats in the threat intelligence list that triggered the finding.
        public let threatNames: [String]?

        public init(threatListName: String? = nil, threatNames: [String]? = nil) {
            self.threatListName = threatListName
            self.threatNames = threatNames
        }

        private enum CodingKeys: String, CodingKey {
            case threatListName = "threatListName"
            case threatNames = "threatNames"
        }
    }

    public struct UnarchiveFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FindingIds", location: .body(locationName: "findingIds"), required: true, type: .list)
        ]

        /// The ID of the detector that specifies the GuardDuty service whose findings you want to unarchive.
        public let detectorId: String
        /// IDs of the findings that you want to unarchive.
        public let findingIds: [String]

        public init(detectorId: String, findingIds: [String]) {
            self.detectorId = detectorId
            self.findingIds = findingIds
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try validate(self.findingIds, name:"findingIds", parent: name, max: 50)
            try validate(self.findingIds, name:"findingIds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case findingIds = "findingIds"
        }
    }

    public struct UnarchiveFindingsResponse: AWSShape {


        public init() {
        }

    }

    public struct UnprocessedAccount: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", location: .body(locationName: "accountId"), required: true, type: .string), 
            AWSShapeMember(label: "Result", location: .body(locationName: "result"), required: true, type: .string)
        ]

        /// AWS Account ID.
        public let accountId: String
        /// A reason why the account hasn't been processed.
        public let result: String

        public init(accountId: String, result: String) {
            self.accountId = accountId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case result = "result"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) for the given GuardDuty resource 
        public let resourceArn: String
        /// The tag keys to remove from a resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:[A-Za-z_.-]{1,20}:guardduty:[A-Za-z0-9_/.-]{0,63}:\\d+:detector/[A-Za-z0-9_/.-]{32,264}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 200)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateDetectorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "Enable", location: .body(locationName: "enable"), required: false, type: .boolean), 
            AWSShapeMember(label: "FindingPublishingFrequency", location: .body(locationName: "findingPublishingFrequency"), required: false, type: .enum)
        ]

        /// The unique ID of the detector that you want to update.
        public let detectorId: String
        /// Updated boolean value for the detector that specifies whether the detector is enabled.
        public let enable: Bool?
        /// A enum value that specifies how frequently customer got Finding updates published.
        public let findingPublishingFrequency: FindingPublishingFrequency?

        public init(detectorId: String, enable: Bool? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil) {
            self.detectorId = detectorId
            self.enable = enable
            self.findingPublishingFrequency = findingPublishingFrequency
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case detectorId = "detectorId"
            case enable = "enable"
            case findingPublishingFrequency = "findingPublishingFrequency"
        }
    }

    public struct UpdateDetectorResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", location: .body(locationName: "action"), required: false, type: .enum), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "FilterName", location: .uri(locationName: "filterName"), required: true, type: .string), 
            AWSShapeMember(label: "FindingCriteria", location: .body(locationName: "findingCriteria"), required: false, type: .structure), 
            AWSShapeMember(label: "Rank", location: .body(locationName: "rank"), required: false, type: .integer)
        ]

        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// The description of the filter.
        public let description: String?
        /// The unique ID of the detector that specifies the GuardDuty service where you want to update a filter.
        public let detectorId: String
        /// The name of the filter.
        public let filterName: String
        /// Represents the criteria to be used in the filter for querying findings.
        public let findingCriteria: FindingCriteria?
        /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
        public let rank: Int?

        public init(action: FilterAction? = nil, description: String? = nil, detectorId: String, filterName: String, findingCriteria: FindingCriteria? = nil, rank: Int? = nil) {
            self.action = action
            self.description = description
            self.detectorId = detectorId
            self.filterName = filterName
            self.findingCriteria = findingCriteria
            self.rank = rank
        }

        public func validate(name: String) throws {
            try validate(self.description, name:"description", parent: name, max: 512)
            try validate(self.description, name:"description", parent: name, min: 0)
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.rank, name:"rank", parent: name, max: 100)
            try validate(self.rank, name:"rank", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case detectorId = "detectorId"
            case filterName = "filterName"
            case findingCriteria = "findingCriteria"
            case rank = "rank"
        }
    }

    public struct UpdateFilterResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string)
        ]

        /// The name of the filter.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UpdateFindingsFeedbackRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Comments", location: .body(locationName: "comments"), required: false, type: .string), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "Feedback", location: .body(locationName: "feedback"), required: true, type: .enum), 
            AWSShapeMember(label: "FindingIds", location: .body(locationName: "findingIds"), required: true, type: .list)
        ]

        /// Additional feedback about the GuardDuty findings.
        public let comments: String?
        /// The ID of the detector that specifies the GuardDuty service whose findings you want to mark as useful or not useful.
        public let detectorId: String
        /// Valid values: USEFUL | NOT_USEFUL
        public let feedback: Feedback
        /// IDs of the findings that you want to mark as useful or not useful.
        public let findingIds: [String]

        public init(comments: String? = nil, detectorId: String, feedback: Feedback, findingIds: [String]) {
            self.comments = comments
            self.detectorId = detectorId
            self.feedback = feedback
            self.findingIds = findingIds
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 300)
                try validate($0, name: "findingIds[]", parent: name, min: 1)
            }
            try validate(self.findingIds, name:"findingIds", parent: name, max: 50)
            try validate(self.findingIds, name:"findingIds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case comments = "comments"
            case detectorId = "detectorId"
            case feedback = "feedback"
            case findingIds = "findingIds"
        }
    }

    public struct UpdateFindingsFeedbackResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateIPSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Activate", location: .body(locationName: "activate"), required: false, type: .boolean), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "IpSetId", location: .uri(locationName: "ipSetId"), required: true, type: .string), 
            AWSShapeMember(label: "Location", location: .body(locationName: "location"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string)
        ]

        /// The updated boolean value that specifies whether the IPSet is active or not.
        public let activate: Bool?
        /// The detectorID that specifies the GuardDuty service whose IPSet you want to update.
        public let detectorId: String
        /// The unique ID that specifies the IPSet that you want to update.
        public let ipSetId: String
        /// The updated URI of the file that contains the IPSet. For example (https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key).
        public let location: String?
        /// The unique ID that specifies the IPSet that you want to update.
        public let name: String?

        public init(activate: Bool? = nil, detectorId: String, ipSetId: String, location: String? = nil, name: String? = nil) {
            self.activate = activate
            self.detectorId = detectorId
            self.ipSetId = ipSetId
            self.location = location
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.location, name:"location", parent: name, max: 300)
            try validate(self.location, name:"location", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 300)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case detectorId = "detectorId"
            case ipSetId = "ipSetId"
            case location = "location"
            case name = "name"
        }
    }

    public struct UpdateIPSetResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateThreatIntelSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Activate", location: .body(locationName: "activate"), required: false, type: .boolean), 
            AWSShapeMember(label: "DetectorId", location: .uri(locationName: "detectorId"), required: true, type: .string), 
            AWSShapeMember(label: "Location", location: .body(locationName: "location"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ThreatIntelSetId", location: .uri(locationName: "threatIntelSetId"), required: true, type: .string)
        ]

        /// The updated boolean value that specifies whether the ThreateIntelSet is active or not.
        public let activate: Bool?
        /// The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to update.
        public let detectorId: String
        /// The updated URI of the file that contains the ThreateIntelSet. For example (https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key)
        public let location: String?
        /// The unique ID that specifies the ThreatIntelSet that you want to update.
        public let name: String?
        /// The unique ID that specifies the ThreatIntelSet that you want to update.
        public let threatIntelSetId: String

        public init(activate: Bool? = nil, detectorId: String, location: String? = nil, name: String? = nil, threatIntelSetId: String) {
            self.activate = activate
            self.detectorId = detectorId
            self.location = location
            self.name = name
            self.threatIntelSetId = threatIntelSetId
        }

        public func validate(name: String) throws {
            try validate(self.detectorId, name:"detectorId", parent: name, max: 300)
            try validate(self.detectorId, name:"detectorId", parent: name, min: 1)
            try validate(self.location, name:"location", parent: name, max: 300)
            try validate(self.location, name:"location", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 300)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activate = "activate"
            case detectorId = "detectorId"
            case location = "location"
            case name = "name"
            case threatIntelSetId = "threatIntelSetId"
        }
    }

    public struct UpdateThreatIntelSetResponse: AWSShape {


        public init() {
        }

    }
}
