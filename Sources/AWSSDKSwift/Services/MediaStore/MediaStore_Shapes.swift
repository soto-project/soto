// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaStore {

    public struct Container: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessLoggingEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "ARN", required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Endpoint", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// The state of access logging on the container. This value is false by default, indicating that AWS Elemental MediaStore does not send access logs to Amazon CloudWatch Logs. When you enable access logging on the container, MediaStore changes this value to true, indicating that the service delivers access logs for objects stored in that container to CloudWatch Logs.
        public let accessLoggingEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the container. The ARN has the following format: arn:aws:&lt;region&gt;:&lt;account that owns this container&gt;:container/&lt;name of container&gt;  For example: arn:aws:mediastore:us-west-2:111122223333:container/movies 
        public let arn: String?
        /// Unix timestamp.
        public let creationTime: TimeStamp?
        /// The DNS endpoint of the container. Use the endpoint to identify the specific container when sending requests to the data plane. The service assigns this value when the container is created. Once the value has been assigned, it does not change.
        public let endpoint: String?
        /// The name of the container.
        public let name: String?
        /// The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When the endpoint is available, the status changes to ACTIVE.
        public let status: ContainerStatus?

        public init(accessLoggingEnabled: Bool? = nil, arn: String? = nil, creationTime: TimeStamp? = nil, endpoint: String? = nil, name: String? = nil, status: ContainerStatus? = nil) {
            self.accessLoggingEnabled = accessLoggingEnabled
            self.arn = arn
            self.creationTime = creationTime
            self.endpoint = endpoint
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accessLoggingEnabled = "AccessLoggingEnabled"
            case arn = "ARN"
            case creationTime = "CreationTime"
            case endpoint = "Endpoint"
            case name = "Name"
            case status = "Status"
        }
    }

    public enum ContainerStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public struct CorsRule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllowedHeaders", required: true, type: .list), 
            AWSShapeMember(label: "AllowedMethods", required: false, type: .list), 
            AWSShapeMember(label: "AllowedOrigins", required: true, type: .list), 
            AWSShapeMember(label: "ExposeHeaders", required: false, type: .list), 
            AWSShapeMember(label: "MaxAgeSeconds", required: false, type: .integer)
        ]

        /// Specifies which headers are allowed in a preflight OPTIONS request through the Access-Control-Request-Headers header. Each header name that is specified in Access-Control-Request-Headers must have a corresponding entry in the rule. Only the headers that were requested are sent back.  This element can contain only one wildcard character (*).
        public let allowedHeaders: [String]
        /// Identifies an HTTP method that the origin that is specified in the rule is allowed to execute. Each CORS rule must contain at least one AllowedMethods and one AllowedOrigins element.
        public let allowedMethods: [MethodName]?
        /// One or more response headers that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). Each CORS rule must have at least one AllowedOrigins element. The string value can include only one wildcard character (*), for example, http://*.example.com. Additionally, you can specify only one wildcard character to allow cross-origin access for all origins.
        public let allowedOrigins: [String]
        /// One or more headers in the response that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). This element is optional for each rule.
        public let exposeHeaders: [String]?
        /// The time in seconds that your browser caches the preflight response for the specified resource. A CORS rule can have only one MaxAgeSeconds element.
        public let maxAgeSeconds: Int?

        public init(allowedHeaders: [String], allowedMethods: [MethodName]? = nil, allowedOrigins: [String], exposeHeaders: [String]? = nil, maxAgeSeconds: Int? = nil) {
            self.allowedHeaders = allowedHeaders
            self.allowedMethods = allowedMethods
            self.allowedOrigins = allowedOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAgeSeconds = maxAgeSeconds
        }

        public func validate(name: String) throws {
            try self.allowedHeaders.forEach {
                try validate($0, name: "allowedHeaders[]", parent: name, max: 8192)
                try validate($0, name: "allowedHeaders[]", parent: name, min: 1)
                try validate($0, name: "allowedHeaders[]", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u00FF]+")
            }
            try validate(self.allowedHeaders, name:"allowedHeaders", parent: name, max: 100)
            try validate(self.allowedHeaders, name:"allowedHeaders", parent: name, min: 0)
            try validate(self.allowedMethods, name:"allowedMethods", parent: name, max: 4)
            try validate(self.allowedMethods, name:"allowedMethods", parent: name, min: 1)
            try self.allowedOrigins.forEach {
                try validate($0, name: "allowedOrigins[]", parent: name, max: 2048)
                try validate($0, name: "allowedOrigins[]", parent: name, min: 1)
                try validate($0, name: "allowedOrigins[]", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u00FF]+")
            }
            try validate(self.allowedOrigins, name:"allowedOrigins", parent: name, max: 100)
            try validate(self.allowedOrigins, name:"allowedOrigins", parent: name, min: 1)
            try self.exposeHeaders?.forEach {
                try validate($0, name: "exposeHeaders[]", parent: name, max: 8192)
                try validate($0, name: "exposeHeaders[]", parent: name, min: 1)
                try validate($0, name: "exposeHeaders[]", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u00FF]+")
            }
            try validate(self.exposeHeaders, name:"exposeHeaders", parent: name, max: 100)
            try validate(self.exposeHeaders, name:"exposeHeaders", parent: name, min: 0)
            try validate(self.maxAgeSeconds, name:"maxAgeSeconds", parent: name, max: 2147483647)
            try validate(self.maxAgeSeconds, name:"maxAgeSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedHeaders = "AllowedHeaders"
            case allowedMethods = "AllowedMethods"
            case allowedOrigins = "AllowedOrigins"
            case exposeHeaders = "ExposeHeaders"
            case maxAgeSeconds = "MaxAgeSeconds"
        }
    }

    public struct CreateContainerInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// The name for the container. The name must be from 1 to 255 characters. Container names must be unique to your AWS account within a specific region. As an example, you could create a container named movies in every region, as long as you donâ€™t have an existing container with that name.
        public let containerName: String
        /// An array of key:value pairs that you define. These values can be anything that you want. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see Tagging Resources in MediaStore.
        public let tags: [Tag]?

        public init(containerName: String, tags: [Tag]? = nil) {
            self.containerName = containerName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case tags = "Tags"
        }
    }

    public struct CreateContainerOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Container", required: true, type: .structure)
        ]

        /// ContainerARN: The Amazon Resource Name (ARN) of the newly created container. The ARN has the following format: arn:aws:&lt;region&gt;:&lt;account that owns this container&gt;:container/&lt;name of container&gt;. For example: arn:aws:mediastore:us-west-2:111122223333:container/movies  ContainerName: The container name as specified in the request. CreationTime: Unix time stamp. Status: The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When an endpoint is available, the status changes to ACTIVE. The return value does not include the container's endpoint. To make downstream requests, you must obtain this value by using DescribeContainer or ListContainers.
        public let container: Container

        public init(container: Container) {
            self.container = container
        }

        private enum CodingKeys: String, CodingKey {
            case container = "Container"
        }
    }

    public struct DeleteContainerInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container to delete. 
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct DeleteContainerOutput: AWSShape {


        public init() {
        }

    }

    public struct DeleteContainerPolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container that holds the policy.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct DeleteContainerPolicyOutput: AWSShape {


        public init() {
        }

    }

    public struct DeleteCorsPolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container to remove the policy from.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct DeleteCorsPolicyOutput: AWSShape {


        public init() {
        }

    }

    public struct DeleteLifecyclePolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container that holds the object lifecycle policy.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct DeleteLifecyclePolicyOutput: AWSShape {


        public init() {
        }

    }

    public struct DescribeContainerInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: false, type: .string)
        ]

        /// The name of the container to query.
        public let containerName: String?

        public init(containerName: String? = nil) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct DescribeContainerOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Container", required: false, type: .structure)
        ]

        /// The name of the queried container.
        public let container: Container?

        public init(container: Container? = nil) {
            self.container = container
        }

        private enum CodingKeys: String, CodingKey {
            case container = "Container"
        }
    }

    public struct GetContainerPolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container. 
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct GetContainerPolicyOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Policy", required: true, type: .string)
        ]

        /// The contents of the access policy.
        public let policy: String

        public init(policy: String) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetCorsPolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container that the policy is assigned to.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct GetCorsPolicyOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CorsPolicy", required: true, type: .list)
        ]

        /// The CORS policy assigned to the container.
        public let corsPolicy: [CorsRule]

        public init(corsPolicy: [CorsRule]) {
            self.corsPolicy = corsPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case corsPolicy = "CorsPolicy"
        }
    }

    public struct GetLifecyclePolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container that the object lifecycle policy is assigned to.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct GetLifecyclePolicyOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LifecyclePolicy", required: true, type: .string)
        ]

        /// The object lifecycle policy that is assigned to the container.
        public let lifecyclePolicy: String

        public init(lifecyclePolicy: String) {
            self.lifecyclePolicy = lifecyclePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicy = "LifecyclePolicy"
        }
    }

    public struct ListContainersInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Enter the maximum number of containers in the response. Use from 1 to 255 characters. 
        public let maxResults: Int?
        /// Only if you used MaxResults in the first command, enter the token (which was included in the previous response) to obtain the next set of containers. This token is included in a response only if there actually are more containers to list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "[0-9A-Za-z=/+]+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListContainersOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Containers", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The names of the containers.
        public let containers: [Container]
        ///  NextToken is the token to use in the next call to ListContainers. This token is returned only if you included the MaxResults tag in the original command, and only if there are still containers to return. 
        public let nextToken: String?

        public init(containers: [Container], nextToken: String? = nil) {
            self.containers = containers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case containers = "Containers"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Resource", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) for the container.
        public let resource: String

        public init(resource: String) {
            self.resource = resource
        }

        public func validate(name: String) throws {
            try validate(self.resource, name:"resource", parent: name, max: 1024)
            try validate(self.resource, name:"resource", parent: name, min: 1)
            try validate(self.resource, name:"resource", parent: name, pattern: "arn:aws:mediastore:[a-z]+-[a-z]+-\\d:\\d{12}:container/[\\w-]{1,255}")
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "Resource"
        }
    }

    public struct ListTagsForResourceOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// An array of key:value pairs that are assigned to the container.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public enum MethodName: String, CustomStringConvertible, Codable {
        case put = "PUT"
        case get = "GET"
        case delete = "DELETE"
        case head = "HEAD"
        public var description: String { return self.rawValue }
    }

    public struct PutContainerPolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string), 
            AWSShapeMember(label: "Policy", required: true, type: .string)
        ]

        /// The name of the container.
        public let containerName: String
        /// The contents of the policy, which includes the following:    One Version tag   One Statement tag that contains the standard tags for the policy.  
        public let policy: String

        public init(containerName: String, policy: String) {
            self.containerName = containerName
            self.policy = policy
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
            try validate(self.policy, name:"policy", parent: name, max: 8192)
            try validate(self.policy, name:"policy", parent: name, min: 1)
            try validate(self.policy, name:"policy", parent: name, pattern: "[\\x00-\\x7F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case policy = "Policy"
        }
    }

    public struct PutContainerPolicyOutput: AWSShape {


        public init() {
        }

    }

    public struct PutCorsPolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string), 
            AWSShapeMember(label: "CorsPolicy", required: true, type: .list)
        ]

        /// The name of the container that you want to assign the CORS policy to.
        public let containerName: String
        /// The CORS policy to apply to the container. 
        public let corsPolicy: [CorsRule]

        public init(containerName: String, corsPolicy: [CorsRule]) {
            self.containerName = containerName
            self.corsPolicy = corsPolicy
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
            try self.corsPolicy.forEach {
                try $0.validate(name: "\(name).corsPolicy[]")
            }
            try validate(self.corsPolicy, name:"corsPolicy", parent: name, max: 100)
            try validate(self.corsPolicy, name:"corsPolicy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case corsPolicy = "CorsPolicy"
        }
    }

    public struct PutCorsPolicyOutput: AWSShape {


        public init() {
        }

    }

    public struct PutLifecyclePolicyInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string), 
            AWSShapeMember(label: "LifecyclePolicy", required: true, type: .string)
        ]

        /// The name of the container that you want to assign the object lifecycle policy to.
        public let containerName: String
        /// The object lifecycle policy to apply to the container.
        public let lifecyclePolicy: String

        public init(containerName: String, lifecyclePolicy: String) {
            self.containerName = containerName
            self.lifecyclePolicy = lifecyclePolicy
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
            try validate(self.lifecyclePolicy, name:"lifecyclePolicy", parent: name, max: 8192)
            try validate(self.lifecyclePolicy, name:"lifecyclePolicy", parent: name, min: 0)
            try validate(self.lifecyclePolicy, name:"lifecyclePolicy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case lifecyclePolicy = "LifecyclePolicy"
        }
    }

    public struct PutLifecyclePolicyOutput: AWSShape {


        public init() {
        }

    }

    public struct StartAccessLoggingInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container that you want to start access logging on.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct StartAccessLoggingOutput: AWSShape {


        public init() {
        }

    }

    public struct StopAccessLoggingInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerName", required: true, type: .string)
        ]

        /// The name of the container that you want to stop access logging on.
        public let containerName: String

        public init(containerName: String) {
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try validate(self.containerName, name:"containerName", parent: name, max: 255)
            try validate(self.containerName, name:"containerName", parent: name, min: 1)
            try validate(self.containerName, name:"containerName", parent: name, pattern: "[\\w-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
        }
    }

    public struct StopAccessLoggingOutput: AWSShape {


        public init() {
        }

    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        public let key: String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 128)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Resource", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) for the container. 
        public let resource: String
        /// An array of key:value pairs that you want to add to the container. You need to specify only the tags that you want to add or update. For example, suppose a container already has two tags (customer:CompanyA and priority:High). You want to change the priority tag and also add a third tag (type:Contract). For TagResource, you specify the following tags: priority:Medium, type:Contract. The result is that your container has three tags: customer:CompanyA, priority:Medium, and type:Contract.
        public let tags: [Tag]

        public init(resource: String, tags: [Tag]) {
            self.resource = resource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resource, name:"resource", parent: name, max: 1024)
            try validate(self.resource, name:"resource", parent: name, min: 1)
            try validate(self.resource, name:"resource", parent: name, pattern: "arn:aws:mediastore:[a-z]+-[a-z]+-\\d:\\d{12}:container/[\\w-]{1,255}")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "Resource"
            case tags = "Tags"
        }
    }

    public struct TagResourceOutput: AWSShape {


        public init() {
        }

    }

    public struct UntagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Resource", required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) for the container.
        public let resource: String
        /// A comma-separated list of keys for tags that you want to remove from the container. For example, if your container has two tags (customer:CompanyA and priority:High) and you want to remove one of the tags (priority:High), you specify the key for the tag that you want to remove (priority).
        public let tagKeys: [String]

        public init(resource: String, tagKeys: [String]) {
            self.resource = resource
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resource, name:"resource", parent: name, max: 1024)
            try validate(self.resource, name:"resource", parent: name, min: 1)
            try validate(self.resource, name:"resource", parent: name, pattern: "arn:aws:mediastore:[a-z]+-[a-z]+-\\d:\\d{12}:container/[\\w-]{1,255}")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "Resource"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceOutput: AWSShape {


        public init() {
        }

    }
}
