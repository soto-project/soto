//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

@_exported import AWSSDKSwiftCore
import NIO

/**
Client object for interacting with AWS CodeGuruProfiler service.

This section provides documentation for the Amazon CodeGuru Profiler API operations.
*/
public struct CodeGuruProfiler {

    //MARK: Member variables

    public let client: AWSClient
    public let serviceConfig: AWSServiceConfig

    //MARK: Initialization

    /// Initialize the CodeGuruProfiler client
    /// - parameters:
    ///     - credentialProvider: Object providing credential to sign requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - retryPolicy: Object returning whether retries should be attempted. Possible options are NoRetry(), ExponentialRetry() or JitterRetry()
    ///     - middlewares: Array of middlewares to apply to requests and responses
    ///     - httpClientProvider: HTTPClient to use. Use `createNew` if the client should manage its own HTTPClient.
    public init(
        credentialProvider: CredentialProviderFactory? = nil,
        region: AWSSDKSwiftCore.Region? = nil,
        partition: AWSSDKSwiftCore.Partition = .aws,
        endpoint: String? = nil,
        retryPolicy: RetryPolicy = JitterRetry(),
        middlewares: [AWSServiceMiddleware] = [],
        httpClientProvider: AWSClient.HTTPClientProvider = .createNew
    ) {
        self.serviceConfig = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "codeguru-profiler",
            serviceProtocol: .restjson,
            apiVersion: "2019-07-18",
            endpoint: endpoint,
            possibleErrorTypes: [CodeGuruProfilerErrorType.self]
        )
        self.client = AWSClient(
            credentialProviderFactory: credentialProvider ?? .runtime,
            retryPolicy: retryPolicy,
            middlewares: middlewares,
            httpClientProvider: httpClientProvider
        )
    }
    
    public func syncShutdown() throws {
        try client.syncShutdown()
    }
    
    //MARK: API Calls

    public func configureAgent(_ input: ConfigureAgentRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ConfigureAgentResponse> {
        return client.execute(operation: "ConfigureAgent", path: "/profilingGroups/{profilingGroupName}/configureAgent", httpMethod: "POST", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Creates a profiling group.
    public func createProfilingGroup(_ input: CreateProfilingGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateProfilingGroupResponse> {
        return client.execute(operation: "CreateProfilingGroup", path: "/profilingGroups", httpMethod: "POST", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Deletes a profiling group.
    public func deleteProfilingGroup(_ input: DeleteProfilingGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteProfilingGroupResponse> {
        return client.execute(operation: "DeleteProfilingGroup", path: "/profilingGroups/{profilingGroupName}", httpMethod: "DELETE", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Describes a profiling group.
    public func describeProfilingGroup(_ input: DescribeProfilingGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeProfilingGroupResponse> {
        return client.execute(operation: "DescribeProfilingGroup", path: "/profilingGroups/{profilingGroupName}", httpMethod: "GET", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Gets the profiling group policy.
    public func getPolicy(_ input: GetPolicyRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPolicyResponse> {
        return client.execute(operation: "GetPolicy", path: "/profilingGroups/{profilingGroupName}/policy", httpMethod: "GET", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Gets the aggregated profile of a profiling group for the specified time range. If the requested time range does not align with the available aggregated profiles, it is expanded to attain alignment. If aggregated profiles are available only for part of the period requested, the profile is returned from the earliest available to the latest within the requested time range.  For example, if the requested time range is from 00:00 to 00:20 and the available profiles are from 00:15 to 00:25, the returned profile will be from 00:15 to 00:20.  You must specify exactly two of the following parameters: startTime, period, and endTime. 
    public func getProfile(_ input: GetProfileRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetProfileResponse> {
        return client.execute(operation: "GetProfile", path: "/profilingGroups/{profilingGroupName}/profile", httpMethod: "GET", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  List the start times of the available aggregated profiles of a profiling group for an aggregation period within the specified time range.
    public func listProfileTimes(_ input: ListProfileTimesRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProfileTimesResponse> {
        return client.execute(operation: "ListProfileTimes", path: "/profilingGroups/{profilingGroupName}/profileTimes", httpMethod: "GET", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Lists profiling groups.
    public func listProfilingGroups(_ input: ListProfilingGroupsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProfilingGroupsResponse> {
        return client.execute(operation: "ListProfilingGroups", path: "/profilingGroups", httpMethod: "GET", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    public func postAgentProfile(_ input: PostAgentProfileRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PostAgentProfileResponse> {
        return client.execute(operation: "PostAgentProfile", path: "/profilingGroups/{profilingGroupName}/agentProfile", httpMethod: "POST", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Provides permission to the principals. This overwrites the existing permissions, and is not additive.
    public func putPermission(_ input: PutPermissionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutPermissionResponse> {
        return client.execute(operation: "PutPermission", path: "/profilingGroups/{profilingGroupName}/policy/{actionGroup}", httpMethod: "PUT", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Removes statement for the provided action group from the policy.
    public func removePermission(_ input: RemovePermissionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RemovePermissionResponse> {
        return client.execute(operation: "RemovePermission", path: "/profilingGroups/{profilingGroupName}/policy/{actionGroup}", httpMethod: "DELETE", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }

    ///  Updates a profiling group.
    public func updateProfilingGroup(_ input: UpdateProfilingGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateProfilingGroupResponse> {
        return client.execute(operation: "UpdateProfilingGroup", path: "/profilingGroups/{profilingGroupName}", httpMethod: "PUT", serviceConfig: serviceConfig, input: input, on: eventLoop)
    }
}
