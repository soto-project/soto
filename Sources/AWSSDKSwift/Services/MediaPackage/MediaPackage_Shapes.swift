// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaPackage {
    //MARK: Enums

    public enum AdMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case scte35Enhanced = "SCTE35_ENHANCED"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum AdsOnDeliveryRestrictions: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case restricted = "RESTRICTED"
        case unrestricted = "UNRESTRICTED"
        case both = "BOTH"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum ManifestLayout: String, CustomStringConvertible, Codable {
        case full = "FULL"
        case compact = "COMPACT"
        public var description: String { return self.rawValue }
    }

    public enum Origination: String, CustomStringConvertible, Codable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum PlaylistType: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case event = "EVENT"
        case vod = "VOD"
        public var description: String { return self.rawValue }
    }

    public enum Profile: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case hbbtv15 = "HBBTV_1_5"
        public var description: String { return self.rawValue }
    }

    public enum SegmentTemplateFormat: String, CustomStringConvertible, Codable {
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        case timeWithTimeline = "TIME_WITH_TIMELINE"
        case numberWithDuration = "NUMBER_WITH_DURATION"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable {
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum Adtriggerselement: String, CustomStringConvertible, Codable {
        case spliceInsert = "SPLICE_INSERT"
        case `break` = "BREAK"
        case providerAdvertisement = "PROVIDER_ADVERTISEMENT"
        case distributorAdvertisement = "DISTRIBUTOR_ADVERTISEMENT"
        case providerPlacementOpportunity = "PROVIDER_PLACEMENT_OPPORTUNITY"
        case distributorPlacementOpportunity = "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case providerOverlayPlacementOpportunity = "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case distributorOverlayPlacementOpportunity = "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        public var description: String { return self.rawValue }
    }

    public enum Periodtriggerselement: String, CustomStringConvertible, Codable {
        case ads = "ADS"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct Authorization: AWSShape {

        /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
        public let cdnIdentifierSecret: String
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        public let secretsRoleArn: String

        public init(cdnIdentifierSecret: String, secretsRoleArn: String) {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case cdnIdentifierSecret = "cdnIdentifierSecret"
            case secretsRoleArn = "secretsRoleArn"
        }
    }

    public struct Channel: AWSShape {

        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CmafEncryption: AWSShape {

        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct CmafPackage: AWSShape {

        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest]? = nil, segmentDurationSeconds: Int? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentPrefix = "segmentPrefix"
            case streamSelection = "streamSelection"
        }
    }

    public struct CmafPackageCreateOrUpdateParameters: AWSShape {

        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifestCreateOrUpdateParameters]? = nil, segmentDurationSeconds: Int? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentPrefix = "segmentPrefix"
            case streamSelection = "streamSelection"
        }
    }

    public struct CreateChannelRequest: AWSShape {

        public let description: String?
        public let id: String
        public let tags: [String: String]?

        public init(description: String? = nil, id: String, tags: [String: String]? = nil) {
            self.description = description
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateChannelResponse: AWSShape {

        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateHarvestJobRequest: AWSShape {

        public let endTime: String
        public let id: String
        public let originEndpointId: String
        public let s3Destination: S3Destination
        public let startTime: String

        public init(endTime: String, id: String, originEndpointId: String, s3Destination: S3Destination, startTime: String) {
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
        }
    }

    public struct CreateHarvestJobResponse: AWSShape {

        public let arn: String?
        public let channelId: String?
        public let createdAt: String?
        public let endTime: String?
        public let id: String?
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        public let startTime: String?
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case createdAt = "createdAt"
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct CreateOriginEndpointRequest: AWSShape {

        public let authorization: Authorization?
        public let channelId: String
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let origination: Origination?
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int?
        public let whitelist: [String]?

        public init(authorization: Authorization? = nil, channelId: String, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, whitelist: [String]? = nil) {
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct CreateOriginEndpointResponse: AWSShape {

        public let arn: String?
        public let authorization: Authorization?
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let origination: Origination?
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int?
        public let url: String?
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct DashEncryption: AWSShape {

        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(keyRotationIntervalSeconds: Int? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct DashPackage: AWSShape {

        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [Adtriggerselement]?
        public let encryption: DashEncryption?
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public let manifestLayout: ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public let minUpdatePeriodSeconds: Int?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Channel source contains SCTE-35 ad markers.
        public let periodTriggers: [Periodtriggerselement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public let profile: Profile?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public let segmentTemplateFormat: SegmentTemplateFormat?
        public let streamSelection: StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public let suggestedPresentationDelaySeconds: Int?

        public init(adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [Adtriggerselement]? = nil, encryption: DashEncryption? = nil, manifestLayout: ManifestLayout? = nil, manifestWindowSeconds: Int? = nil, minBufferTimeSeconds: Int? = nil, minUpdatePeriodSeconds: Int? = nil, periodTriggers: [Periodtriggerselement]? = nil, profile: Profile? = nil, segmentDurationSeconds: Int? = nil, segmentTemplateFormat: SegmentTemplateFormat? = nil, streamSelection: StreamSelection? = nil, suggestedPresentationDelaySeconds: Int? = nil) {
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.encryption = encryption
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case encryption = "encryption"
            case manifestLayout = "manifestLayout"
            case manifestWindowSeconds = "manifestWindowSeconds"
            case minBufferTimeSeconds = "minBufferTimeSeconds"
            case minUpdatePeriodSeconds = "minUpdatePeriodSeconds"
            case periodTriggers = "periodTriggers"
            case profile = "profile"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentTemplateFormat = "segmentTemplateFormat"
            case streamSelection = "streamSelection"
            case suggestedPresentationDelaySeconds = "suggestedPresentationDelaySeconds"
        }
    }

    public struct DeleteChannelRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteChannelResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteOriginEndpointRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteOriginEndpointResponse: AWSShape {


        public init() {
        }

    }

    public struct DescribeChannelRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribeChannelResponse: AWSShape {

        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct DescribeHarvestJobRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribeHarvestJobResponse: AWSShape {

        public let arn: String?
        public let channelId: String?
        public let createdAt: String?
        public let endTime: String?
        public let id: String?
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        public let startTime: String?
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case createdAt = "createdAt"
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct DescribeOriginEndpointRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribeOriginEndpointResponse: AWSShape {

        public let arn: String?
        public let authorization: Authorization?
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let origination: Origination?
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int?
        public let url: String?
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct HarvestJob: AWSShape {

        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public let arn: String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public let channelId: String?
        /// The time the HarvestJob was submitted
        public let createdAt: String?
        /// The end of the time-window which will be harvested.
        public let endTime: String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public let id: String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public let originEndpointId: String?
        public let s3Destination: S3Destination?
        /// The start of the time-window which will be harvested.
        public let startTime: String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public let status: Status?

        public init(arn: String? = nil, channelId: String? = nil, createdAt: String? = nil, endTime: String? = nil, id: String? = nil, originEndpointId: String? = nil, s3Destination: S3Destination? = nil, startTime: String? = nil, status: Status? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case createdAt = "createdAt"
            case endTime = "endTime"
            case id = "id"
            case originEndpointId = "originEndpointId"
            case s3Destination = "s3Destination"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct HlsEncryption: AWSShape {

        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod? = nil, keyRotationIntervalSeconds: Int? = nil, repeatExtXKey: Bool? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case repeatExtXKey = "repeatExtXKey"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct HlsIngest: AWSShape {

        /// A list of endpoints to which the source stream should be sent.
        public let ingestEndpoints: [IngestEndpoint]?

        public init(ingestEndpoints: [IngestEndpoint]? = nil) {
            self.ingestEndpoints = ingestEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case ingestEndpoints = "ingestEndpoints"
        }
    }

    public struct HlsManifest: AWSShape {

        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?

        public init(adMarkers: AdMarkers? = nil, id: String, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, url: String? = nil) {
            self.adMarkers = adMarkers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case id = "id"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case url = "url"
        }
    }

    public struct HlsManifestCreateOrUpdateParameters: AWSShape {

        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [Adtriggerselement]?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [Adtriggerselement]? = nil, id: String, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case id = "id"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        }
    }

    public struct HlsPackage: AWSShape {

        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let adTriggers: [Adtriggerselement]?
        public let encryption: HlsEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?
        public let streamSelection: StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        public init(adMarkers: AdMarkers? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, adTriggers: [Adtriggerselement]? = nil, encryption: HlsEncryption? = nil, includeIframeOnlyStream: Bool? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int? = nil, programDateTimeIntervalSeconds: Int? = nil, segmentDurationSeconds: Int? = nil, streamSelection: StreamSelection? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.adMarkers = adMarkers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.adTriggers = adTriggers
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case adTriggers = "adTriggers"
            case encryption = "encryption"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case streamSelection = "streamSelection"
            case useAudioRenditionGroup = "useAudioRenditionGroup"
        }
    }

    public struct IngestEndpoint: AWSShape {

        /// The system generated unique identifier for the IngestEndpoint
        public let id: String?
        /// The system generated password for ingest authentication.
        public let password: String?
        /// The ingest URL to which the source stream should be sent.
        public let url: String?
        /// The system generated username for ingest authentication.
        public let username: String?

        public init(id: String? = nil, password: String? = nil, url: String? = nil, username: String? = nil) {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case password = "password"
            case url = "url"
            case username = "username"
        }
    }

    public struct ListChannelsRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "MaxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "NextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListChannelsResponse: AWSShape {

        public let channels: [Channel]?
        public let nextToken: String?

        public init(channels: [Channel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ListHarvestJobsRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "IncludeChannelId", location: .querystring(locationName: "includeChannelId")), 
            AWSMemberEncoding(label: "IncludeStatus", location: .querystring(locationName: "includeStatus")), 
            AWSMemberEncoding(label: "MaxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "NextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let includeChannelId: String?
        public let includeStatus: String?
        public let maxResults: Int?
        public let nextToken: String?

        public init(includeChannelId: String? = nil, includeStatus: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeChannelId = includeChannelId
            self.includeStatus = includeStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeChannelId = "includeChannelId"
            case includeStatus = "includeStatus"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListHarvestJobsResponse: AWSShape {

        public let harvestJobs: [HarvestJob]?
        public let nextToken: String?

        public init(harvestJobs: [HarvestJob]? = nil, nextToken: String? = nil) {
            self.harvestJobs = harvestJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case harvestJobs = "harvestJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListOriginEndpointsRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ChannelId", location: .querystring(locationName: "channelId")), 
            AWSMemberEncoding(label: "MaxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "NextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let channelId: String?
        public let maxResults: Int?
        public let nextToken: String?

        public init(channelId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelId = channelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channelId = "channelId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListOriginEndpointsResponse: AWSShape {

        public let nextToken: String?
        public let originEndpoints: [OriginEndpoint]?

        public init(nextToken: String? = nil, originEndpoints: [OriginEndpoint]? = nil) {
            self.nextToken = nextToken
            self.originEndpoints = originEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case originEndpoints = "originEndpoints"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ResourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {

        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MssEncryption: AWSShape {

        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct MssPackage: AWSShape {

        public let encryption: MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int?
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int?
        public let streamSelection: StreamSelection?

        public init(encryption: MssEncryption? = nil, manifestWindowSeconds: Int? = nil, segmentDurationSeconds: Int? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case manifestWindowSeconds = "manifestWindowSeconds"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case streamSelection = "streamSelection"
        }
    }

    public struct OriginEndpoint: AWSShape {

        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        public let authorization: Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public let origination: Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct RotateChannelCredentialsRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct RotateChannelCredentialsResponse: AWSShape {

        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct RotateIngestEndpointCredentialsRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id")), 
            AWSMemberEncoding(label: "IngestEndpointId", location: .uri(locationName: "ingest_endpoint_id"))
        ]

        public let id: String
        public let ingestEndpointId: String

        public init(id: String, ingestEndpointId: String) {
            self.id = id
            self.ingestEndpointId = ingestEndpointId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case ingestEndpointId = "ingest_endpoint_id"
        }
    }

    public struct RotateIngestEndpointCredentialsResponse: AWSShape {

        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct S3Destination: AWSShape {

        /// The name of an S3 bucket within which harvested content will be exported
        public let bucketName: String
        /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
        public let manifestKey: String
        /// The IAM role used to write to the specified S3 bucket
        public let roleArn: String

        public init(bucketName: String, manifestKey: String, roleArn: String) {
            self.bucketName = bucketName
            self.manifestKey = manifestKey
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case manifestKey = "manifestKey"
            case roleArn = "roleArn"
        }
    }

    public struct SpekeKeyProvider: AWSShape {

        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate
        /// that MediaPackage will use for enforcing secure end-to-end data
        /// transfer with the key provider service.
        public let certificateArn: String?
        /// The resource ID to include in key requests.
        public let resourceId: String
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String
        /// The system IDs to include in key requests.
        public let systemIds: [String]
        /// The URL of the external key provider service.
        public let url: String

        public init(certificateArn: String? = nil, resourceId: String, roleArn: String, systemIds: [String], url: String) {
            self.certificateArn = certificateArn
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
            case resourceId = "resourceId"
            case roleArn = "roleArn"
            case systemIds = "systemIds"
            case url = "url"
        }
    }

    public struct StreamSelection: AWSShape {

        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        public init(maxVideoBitsPerSecond: Int? = nil, minVideoBitsPerSecond: Int? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
            case minVideoBitsPerSecond = "minVideoBitsPerSecond"
            case streamOrder = "streamOrder"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ResourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ResourceArn", location: .uri(locationName: "resource-arn")), 
            AWSMemberEncoding(label: "TagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UpdateChannelRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let description: String?
        public let id: String

        public init(description: String? = nil, id: String) {
            self.description = description
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
        }
    }

    public struct UpdateChannelResponse: AWSShape {

        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct UpdateOriginEndpointRequest: AWSShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "Id", location: .uri(locationName: "id"))
        ]

        public let authorization: Authorization?
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let origination: Origination?
        public let startoverWindowSeconds: Int?
        public let timeDelaySeconds: Int?
        public let whitelist: [String]?

        public init(authorization: Authorization? = nil, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, timeDelaySeconds: Int? = nil, whitelist: [String]? = nil) {
            self.authorization = authorization
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case authorization = "authorization"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct UpdateOriginEndpointResponse: AWSShape {

        public let arn: String?
        public let authorization: Authorization?
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let origination: Origination?
        public let startoverWindowSeconds: Int?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int?
        public let url: String?
        public let whitelist: [String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, origination: Origination? = nil, startoverWindowSeconds: Int? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case origination = "origination"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }
}
