//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore
import Foundation

extension S3Control {
    //MARK: Enums

    public enum JobManifestFieldName: String, CustomStringConvertible, Codable {
        case ignore = "Ignore"
        case bucket = "Bucket"
        case key = "Key"
        case versionid = "VersionId"
        public var description: String { return self.rawValue }
    }

    public enum JobManifestFormat: String, CustomStringConvertible, Codable {
        case s3batchoperationsCsv20180820 = "S3BatchOperations_CSV_20180820"
        case s3inventoryreportCsv20161130 = "S3InventoryReport_CSV_20161130"
        public var description: String { return self.rawValue }
    }

    public enum JobReportFormat: String, CustomStringConvertible, Codable {
        case reportCsv20180820 = "Report_CSV_20180820"
        public var description: String { return self.rawValue }
    }

    public enum JobReportScope: String, CustomStringConvertible, Codable {
        case alltasks = "AllTasks"
        case failedtasksonly = "FailedTasksOnly"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case cancelled = "Cancelled"
        case cancelling = "Cancelling"
        case complete = "Complete"
        case completing = "Completing"
        case failed = "Failed"
        case failing = "Failing"
        case new = "New"
        case paused = "Paused"
        case pausing = "Pausing"
        case preparing = "Preparing"
        case ready = "Ready"
        case suspended = "Suspended"
        public var description: String { return self.rawValue }
    }

    public enum NetworkOrigin: String, CustomStringConvertible, Codable {
        case internet = "Internet"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum OperationName: String, CustomStringConvertible, Codable {
        case lambdainvoke = "LambdaInvoke"
        case s3putobjectcopy = "S3PutObjectCopy"
        case s3putobjectacl = "S3PutObjectAcl"
        case s3putobjecttagging = "S3PutObjectTagging"
        case s3initiaterestoreobject = "S3InitiateRestoreObject"
        case s3putobjectlegalhold = "S3PutObjectLegalHold"
        case s3putobjectretention = "S3PutObjectRetention"
        public var description: String { return self.rawValue }
    }

    public enum RequestedJobStatus: String, CustomStringConvertible, Codable {
        case cancelled = "Cancelled"
        case ready = "Ready"
        public var description: String { return self.rawValue }
    }

    public enum S3CannedAccessControlList: String, CustomStringConvertible, Codable {
        case `private` = "private"
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        case awsExecRead = "aws-exec-read"
        case authenticatedRead = "authenticated-read"
        case bucketOwnerRead = "bucket-owner-read"
        case bucketOwnerFullControl = "bucket-owner-full-control"
        public var description: String { return self.rawValue }
    }

    public enum S3GlacierJobTier: String, CustomStringConvertible, Codable {
        case bulk = "BULK"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum S3GranteeTypeIdentifier: String, CustomStringConvertible, Codable {
        case id = "id"
        case emailaddress = "emailAddress"
        case uri = "uri"
        public var description: String { return self.rawValue }
    }

    public enum S3MetadataDirective: String, CustomStringConvertible, Codable {
        case copy = "COPY"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum S3ObjectLockLegalHoldStatus: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case on = "ON"
        public var description: String { return self.rawValue }
    }

    public enum S3ObjectLockMode: String, CustomStringConvertible, Codable {
        case compliance = "COMPLIANCE"
        case governance = "GOVERNANCE"
        public var description: String { return self.rawValue }
    }

    public enum S3ObjectLockRetentionMode: String, CustomStringConvertible, Codable {
        case compliance = "COMPLIANCE"
        case governance = "GOVERNANCE"
        public var description: String { return self.rawValue }
    }

    public enum S3Permission: String, CustomStringConvertible, Codable {
        case fullControl = "FULL_CONTROL"
        case read = "READ"
        case write = "WRITE"
        case readAcp = "READ_ACP"
        case writeAcp = "WRITE_ACP"
        public var description: String { return self.rawValue }
    }

    public enum S3SSEAlgorithm: String, CustomStringConvertible, Codable {
        case aes256 = "AES256"
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum S3StorageClass: String, CustomStringConvertible, Codable {
        case standard = "STANDARD"
        case standardIa = "STANDARD_IA"
        case onezoneIa = "ONEZONE_IA"
        case glacier = "GLACIER"
        case intelligentTiering = "INTELLIGENT_TIERING"
        case deepArchive = "DEEP_ARCHIVE"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AccessPoint: AWSDecodableShape {

        /// The name of the bucket associated with this access point.
        public let bucket: String
        /// The name of this access point.
        public let name: String
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies.
        public let networkOrigin: NetworkOrigin
        /// The virtual private cloud (VPC) configuration for this access point, if one exists.
        public let vpcConfiguration: VpcConfiguration?

        public init(bucket: String, name: String, networkOrigin: NetworkOrigin, vpcConfiguration: VpcConfiguration? = nil) {
            self.bucket = bucket
            self.name = name
            self.networkOrigin = networkOrigin
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case name = "Name"
            case networkOrigin = "NetworkOrigin"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct CreateAccessPointRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The AWS account ID for the owner of the bucket for which you want to create an access point.
        public let accountId: String
        /// The name of the bucket that you want to associate this access point with.
        public let bucket: String
        /// The name you want to assign to this access point.
        public let name: String
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
        /// If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC).
        public let vpcConfiguration: VpcConfiguration?

        public init(accountId: String, bucket: String, name: String, publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.accountId = accountId
            self.bucket = bucket
            self.name = name
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.bucket, name: "bucket", parent: name, max: 255)
            try validate(self.bucket, name: "bucket", parent: name, min: 3)
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id"))
        ]

        public let accountId: String
        /// An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.
        public let clientRequestToken: String
        /// Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.
        public let confirmationRequired: Bool?
        /// A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.
        public let description: String?
        /// Configuration parameters for the manifest.
        public let manifest: JobManifest
        /// The operation that you want this job to perform on each object listed in the manifest. For more information about the available operations, see Available Operations in the Amazon Simple Storage Service Developer Guide.
        public let operation: JobOperation
        /// The numerical priority for this job. Higher numbers indicate higher priority.
        public let priority: Int
        /// Configuration parameters for the optional job-completion report.
        public let report: JobReport
        /// The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role that Batch Operations will use to execute this job's operation on each object in the manifest.
        public let roleArn: String
        /// A set of tags to associate with the Amazon S3 Batch Operations job. This is an optional parameter. 
        @OptionalCoding<DefaultArrayCoder>
        public var tags: [S3Tag]?

        public init(accountId: String, clientRequestToken: String = CreateJobRequest.idempotencyToken(), confirmationRequired: Bool? = nil, description: String? = nil, manifest: JobManifest, operation: JobOperation, priority: Int, report: JobReport, roleArn: String, tags: [S3Tag]? = nil) {
            self.accountId = accountId
            self.clientRequestToken = clientRequestToken
            self.confirmationRequired = confirmationRequired
            self.description = description
            self.manifest = manifest
            self.operation = operation
            self.priority = priority
            self.report = report
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try validate(self.description, name: "description", parent: name, max: 256)
            try validate(self.description, name: "description", parent: name, min: 1)
            try self.manifest.validate(name: "\(name).manifest")
            try self.operation.validate(name: "\(name).operation")
            try validate(self.priority, name: "priority", parent: name, max: 2147483647)
            try validate(self.priority, name: "priority", parent: name, min: 0)
            try self.report.validate(name: "\(name).report")
            try validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:[^:]+:iam::\\d{12}:role/.*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case confirmationRequired = "ConfirmationRequired"
            case description = "Description"
            case manifest = "Manifest"
            case operation = "Operation"
            case priority = "Priority"
            case report = "Report"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateJobResult: AWSDecodableShape {

        /// The ID for this job. Amazon S3 generates this ID automatically and returns it after a successful Create Job request.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DeleteAccessPointPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose policy you want to delete.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point you want to delete.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The AWS account ID associated with the Amazon S3 Batch Operations job.
        public let accountId: String
        /// The ID for the Amazon S3 Batch Operations job whose tags you want to delete.
        public let jobId: String

        public init(accountId: String, jobId: String) {
            self.accountId = accountId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.jobId, name: "jobId", parent: name, max: 36)
            try validate(self.jobId, name: "jobId", parent: name, min: 5)
            try validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobTaggingResult: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeletePublicAccessBlockRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id"))
        ]

        /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to remove.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        public let accountId: String
        /// The ID for the job whose information you want to retrieve.
        public let jobId: String

        public init(accountId: String, jobId: String) {
            self.accountId = accountId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.jobId, name: "jobId", parent: name, max: 36)
            try validate(self.jobId, name: "jobId", parent: name, min: 5)
            try validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobResult: AWSDecodableShape {

        /// Contains the configuration parameters and status for the job specified in the Describe Job request.
        public let job: JobDescriptor?

        public init(job: JobDescriptor? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "Job"
        }
    }

    public struct GetAccessPointPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose policy you want to retrieve.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointPolicyResult: AWSDecodableShape {

        /// The access point policy associated with the specified access point.
        public let policy: String?

        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetAccessPointPolicyStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose policy status you want to retrieve.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointPolicyStatusResult: AWSDecodableShape {

        /// Indicates the current policy status of the specified access point.
        public let policyStatus: PolicyStatus?

        public init(policyStatus: PolicyStatus? = nil) {
            self.policyStatus = policyStatus
        }

        private enum CodingKeys: String, CodingKey {
            case policyStatus = "PolicyStatus"
        }
    }

    public struct GetAccessPointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose configuration information you want to retrieve.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointResult: AWSDecodableShape {

        /// The name of the bucket associated with the specified access point.
        public let bucket: String?
        /// The date and time when the specified access point was created.
        public let creationDate: TimeStamp?
        /// The name of the specified access point.
        public let name: String?
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies.
        public let networkOrigin: NetworkOrigin?
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
        /// Contains the virtual private cloud (VPC) configuration for the specified access point.
        public let vpcConfiguration: VpcConfiguration?

        public init(bucket: String? = nil, creationDate: TimeStamp? = nil, name: String? = nil, networkOrigin: NetworkOrigin? = nil, publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.bucket = bucket
            self.creationDate = creationDate
            self.name = name
            self.networkOrigin = networkOrigin
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case creationDate = "CreationDate"
            case name = "Name"
            case networkOrigin = "NetworkOrigin"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct GetJobTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The AWS account ID associated with the Amazon S3 Batch Operations job.
        public let accountId: String
        /// The ID for the Amazon S3 Batch Operations job whose tags you want to retrieve.
        public let jobId: String

        public init(accountId: String, jobId: String) {
            self.accountId = accountId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.jobId, name: "jobId", parent: name, max: 36)
            try validate(self.jobId, name: "jobId", parent: name, min: 5)
            try validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobTaggingResult: AWSDecodableShape {

        /// The set of tags associated with the Amazon S3 Batch Operations job.
        @OptionalCoding<DefaultArrayCoder>
        public var tags: [S3Tag]?

        public init(tags: [S3Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct GetPublicAccessBlockOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "publicAccessBlockConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "publicAccessBlockConfiguration", location: .body(locationName: "PublicAccessBlockConfiguration"))
        ]

        /// The PublicAccessBlock configuration currently in effect for this Amazon Web Services account.
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

        public init(publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil) {
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        }
    }

    public struct GetPublicAccessBlockRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id"))
        ]

        /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to retrieve.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct JobDescriptor: AWSDecodableShape {

        /// Indicates whether confirmation is required before Amazon S3 begins running the specified job. Confirmation is required only for jobs created through the Amazon S3 console.
        public let confirmationRequired: Bool?
        /// A timestamp indicating when this job was created.
        public let creationTime: TimeStamp?
        /// The description for this job, if one was provided in this job's Create Job request.
        public let description: String?
        /// If the specified job failed, this field contains information describing the failure.
        @OptionalCoding<DefaultArrayCoder>
        public var failureReasons: [JobFailure]?
        /// The Amazon Resource Name (ARN) for this job.
        public let jobArn: String?
        /// The ID for the specified job.
        public let jobId: String?
        /// The configuration information for the specified job's manifest object.
        public let manifest: JobManifest?
        /// The operation that the specified job is configured to execute on the objects listed in the manifest.
        public let operation: JobOperation?
        /// The priority of the specified job.
        public let priority: Int?
        /// Describes the total number of tasks that the specified job has executed, the number of tasks that succeeded, and the number of tasks that failed.
        public let progressSummary: JobProgressSummary?
        /// Contains the configuration information for the job-completion report if you requested one in the Create Job request.
        public let report: JobReport?
        /// The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role assigned to execute the tasks for this job.
        public let roleArn: String?
        /// The current status of the specified job.
        public let status: JobStatus?
        public let statusUpdateReason: String?
        /// The reason why the specified job was suspended. A job is only suspended if you create it through the Amazon S3 console. When you create the job, it enters the Suspended state to await confirmation before running. After you confirm the job, it automatically exits the Suspended state.
        public let suspendedCause: String?
        /// The timestamp when this job was suspended, if it has been suspended.
        public let suspendedDate: TimeStamp?
        /// A timestamp indicating when this job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public let terminationDate: TimeStamp?

        public init(confirmationRequired: Bool? = nil, creationTime: TimeStamp? = nil, description: String? = nil, failureReasons: [JobFailure]? = nil, jobArn: String? = nil, jobId: String? = nil, manifest: JobManifest? = nil, operation: JobOperation? = nil, priority: Int? = nil, progressSummary: JobProgressSummary? = nil, report: JobReport? = nil, roleArn: String? = nil, status: JobStatus? = nil, statusUpdateReason: String? = nil, suspendedCause: String? = nil, suspendedDate: TimeStamp? = nil, terminationDate: TimeStamp? = nil) {
            self.confirmationRequired = confirmationRequired
            self.creationTime = creationTime
            self.description = description
            self.failureReasons = failureReasons
            self.jobArn = jobArn
            self.jobId = jobId
            self.manifest = manifest
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.report = report
            self.roleArn = roleArn
            self.status = status
            self.statusUpdateReason = statusUpdateReason
            self.suspendedCause = suspendedCause
            self.suspendedDate = suspendedDate
            self.terminationDate = terminationDate
        }

        private enum CodingKeys: String, CodingKey {
            case confirmationRequired = "ConfirmationRequired"
            case creationTime = "CreationTime"
            case description = "Description"
            case failureReasons = "FailureReasons"
            case jobArn = "JobArn"
            case jobId = "JobId"
            case manifest = "Manifest"
            case operation = "Operation"
            case priority = "Priority"
            case progressSummary = "ProgressSummary"
            case report = "Report"
            case roleArn = "RoleArn"
            case status = "Status"
            case statusUpdateReason = "StatusUpdateReason"
            case suspendedCause = "SuspendedCause"
            case suspendedDate = "SuspendedDate"
            case terminationDate = "TerminationDate"
        }
    }

    public struct JobFailure: AWSDecodableShape {

        /// The failure code, if any, for the specified job.
        public let failureCode: String?
        /// The failure reason, if any, for the specified job.
        public let failureReason: String?

        public init(failureCode: String? = nil, failureReason: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "FailureCode"
            case failureReason = "FailureReason"
        }
    }

    public struct JobListDescriptor: AWSDecodableShape {

        /// A timestamp indicating when the specified job was created.
        public let creationTime: TimeStamp?
        /// The user-specified description that was included in the specified job's Create Job request.
        public let description: String?
        /// The ID for the specified job.
        public let jobId: String?
        /// The operation that the specified job is configured to run on each object listed in the manifest.
        public let operation: OperationName?
        /// The current priority for the specified job.
        public let priority: Int?
        /// Describes the total number of tasks that the specified job has executed, the number of tasks that succeeded, and the number of tasks that failed.
        public let progressSummary: JobProgressSummary?
        /// The specified job's current status.
        public let status: JobStatus?
        /// A timestamp indicating when the specified job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public let terminationDate: TimeStamp?

        public init(creationTime: TimeStamp? = nil, description: String? = nil, jobId: String? = nil, operation: OperationName? = nil, priority: Int? = nil, progressSummary: JobProgressSummary? = nil, status: JobStatus? = nil, terminationDate: TimeStamp? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.jobId = jobId
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.status = status
            self.terminationDate = terminationDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case jobId = "JobId"
            case operation = "Operation"
            case priority = "Priority"
            case progressSummary = "ProgressSummary"
            case status = "Status"
            case terminationDate = "TerminationDate"
        }
    }

    public struct JobManifest: AWSEncodableShape & AWSDecodableShape {

        /// Contains the information required to locate the specified job's manifest.
        public let location: JobManifestLocation
        /// Describes the format of the specified job's manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
        public let spec: JobManifestSpec

        public init(location: JobManifestLocation, spec: JobManifestSpec) {
            self.location = location
            self.spec = spec
        }

        public func validate(name: String) throws {
            try self.location.validate(name: "\(name).location")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case spec = "Spec"
        }
    }

    public struct JobManifestLocation: AWSEncodableShape & AWSDecodableShape {

        /// The ETag for the specified manifest object.
        public let eTag: String
        /// The Amazon Resource Name (ARN) for a manifest object.
        public let objectArn: String
        /// The optional version ID to identify a specific version of the manifest object.
        public let objectVersionId: String?

        public init(eTag: String, objectArn: String, objectVersionId: String? = nil) {
            self.eTag = eTag
            self.objectArn = objectArn
            self.objectVersionId = objectVersionId
        }

        public func validate(name: String) throws {
            try validate(self.eTag, name: "eTag", parent: name, max: 1024)
            try validate(self.eTag, name: "eTag", parent: name, min: 1)
            try validate(self.objectArn, name: "objectArn", parent: name, max: 2000)
            try validate(self.objectArn, name: "objectArn", parent: name, min: 1)
            try validate(self.objectArn, name: "objectArn", parent: name, pattern: "arn:[^:]+:s3:.*")
            try validate(self.objectVersionId, name: "objectVersionId", parent: name, max: 2000)
            try validate(self.objectVersionId, name: "objectVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eTag = "ETag"
            case objectArn = "ObjectArn"
            case objectVersionId = "ObjectVersionId"
        }
    }

    public struct JobManifestSpec: AWSEncodableShape & AWSDecodableShape {

        /// If the specified manifest object is in the S3BatchOperations_CSV_20180820 format, this element describes which columns contain the required data.
        @OptionalCoding<DefaultArrayCoder>
        public var fields: [JobManifestFieldName]?
        /// Indicates which of the available formats the specified manifest uses.
        public let format: JobManifestFormat

        public init(fields: [JobManifestFieldName]? = nil, format: JobManifestFormat) {
            self.fields = fields
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case format = "Format"
        }
    }

    public struct JobOperation: AWSEncodableShape & AWSDecodableShape {

        /// Directs the specified job to invoke an AWS Lambda function on each object in the manifest.
        public let lambdaInvoke: LambdaInvokeOperation?
        /// Directs the specified job to execute an Initiate Glacier Restore call on each object in the manifest.
        public let s3InitiateRestoreObject: S3InitiateRestoreObjectOperation?
        /// Directs the specified job to execute a PUT Object acl call on each object in the manifest.
        public let s3PutObjectAcl: S3SetObjectAclOperation?
        /// Directs the specified job to execute a PUT Copy object call on each object in the manifest.
        public let s3PutObjectCopy: S3CopyObjectOperation?
        public let s3PutObjectLegalHold: S3SetObjectLegalHoldOperation?
        public let s3PutObjectRetention: S3SetObjectRetentionOperation?
        /// Directs the specified job to execute a PUT Object tagging call on each object in the manifest.
        public let s3PutObjectTagging: S3SetObjectTaggingOperation?

        public init(lambdaInvoke: LambdaInvokeOperation? = nil, s3InitiateRestoreObject: S3InitiateRestoreObjectOperation? = nil, s3PutObjectAcl: S3SetObjectAclOperation? = nil, s3PutObjectCopy: S3CopyObjectOperation? = nil, s3PutObjectLegalHold: S3SetObjectLegalHoldOperation? = nil, s3PutObjectRetention: S3SetObjectRetentionOperation? = nil, s3PutObjectTagging: S3SetObjectTaggingOperation? = nil) {
            self.lambdaInvoke = lambdaInvoke
            self.s3InitiateRestoreObject = s3InitiateRestoreObject
            self.s3PutObjectAcl = s3PutObjectAcl
            self.s3PutObjectCopy = s3PutObjectCopy
            self.s3PutObjectLegalHold = s3PutObjectLegalHold
            self.s3PutObjectRetention = s3PutObjectRetention
            self.s3PutObjectTagging = s3PutObjectTagging
        }

        public func validate(name: String) throws {
            try self.lambdaInvoke?.validate(name: "\(name).lambdaInvoke")
            try self.s3InitiateRestoreObject?.validate(name: "\(name).s3InitiateRestoreObject")
            try self.s3PutObjectAcl?.validate(name: "\(name).s3PutObjectAcl")
            try self.s3PutObjectCopy?.validate(name: "\(name).s3PutObjectCopy")
            try self.s3PutObjectTagging?.validate(name: "\(name).s3PutObjectTagging")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaInvoke = "LambdaInvoke"
            case s3InitiateRestoreObject = "S3InitiateRestoreObject"
            case s3PutObjectAcl = "S3PutObjectAcl"
            case s3PutObjectCopy = "S3PutObjectCopy"
            case s3PutObjectLegalHold = "S3PutObjectLegalHold"
            case s3PutObjectRetention = "S3PutObjectRetention"
            case s3PutObjectTagging = "S3PutObjectTagging"
        }
    }

    public struct JobProgressSummary: AWSDecodableShape {

        public let numberOfTasksFailed: Int64?
        public let numberOfTasksSucceeded: Int64?
        public let totalNumberOfTasks: Int64?

        public init(numberOfTasksFailed: Int64? = nil, numberOfTasksSucceeded: Int64? = nil, totalNumberOfTasks: Int64? = nil) {
            self.numberOfTasksFailed = numberOfTasksFailed
            self.numberOfTasksSucceeded = numberOfTasksSucceeded
            self.totalNumberOfTasks = totalNumberOfTasks
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfTasksFailed = "NumberOfTasksFailed"
            case numberOfTasksSucceeded = "NumberOfTasksSucceeded"
            case totalNumberOfTasks = "TotalNumberOfTasks"
        }
    }

    public struct JobReport: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) for the bucket where specified job-completion report will be stored.
        public let bucket: String?
        /// Indicates whether the specified job will generate a job-completion report.
        public let enabled: Bool
        /// The format of the specified job-completion report.
        public let format: JobReportFormat?
        /// An optional prefix to describe where in the specified bucket the job-completion report will be stored. Amazon S3 will store the job-completion report at &lt;prefix&gt;/job-&lt;job-id&gt;/report.json.
        public let prefix: String?
        /// Indicates whether the job-completion report will include details of all tasks or only failed tasks.
        public let reportScope: JobReportScope?

        public init(bucket: String? = nil, enabled: Bool, format: JobReportFormat? = nil, prefix: String? = nil, reportScope: JobReportScope? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.format = format
            self.prefix = prefix
            self.reportScope = reportScope
        }

        public func validate(name: String) throws {
            try validate(self.bucket, name: "bucket", parent: name, max: 128)
            try validate(self.bucket, name: "bucket", parent: name, min: 1)
            try validate(self.bucket, name: "bucket", parent: name, pattern: "arn:[^:]+:s3:.*")
            try validate(self.prefix, name: "prefix", parent: name, max: 512)
            try validate(self.prefix, name: "prefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case enabled = "Enabled"
            case format = "Format"
            case prefix = "Prefix"
            case reportScope = "ReportScope"
        }
    }

    public struct LambdaInvokeOperation: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) for the AWS Lambda function that the specified job will invoke for each object in the manifest.
        public let functionArn: String?

        public init(functionArn: String? = nil) {
            self.functionArn = functionArn
        }

        public func validate(name: String) throws {
            try validate(self.functionArn, name: "functionArn", parent: name, max: 1024)
            try validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try validate(self.functionArn, name: "functionArn", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
        }
    }

    public struct ListAccessPointsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "bucket", location: .querystring(locationName: "bucket")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The AWS account ID for owner of the bucket whose access points you want to list.
        public let accountId: String
        /// The name of the bucket whose associated access points you want to list.
        public let bucket: String?
        /// The maximum number of access points that you want to include in the list. If the specified bucket has more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
        public let maxResults: Int?
        /// A continuation token. If a previous call to ListAccessPoints returned a continuation token in the NextToken field, then providing that value here causes Amazon S3 to retrieve the next page of results.
        public let nextToken: String?

        public init(accountId: String, bucket: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.bucket = bucket
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.bucket, name: "bucket", parent: name, max: 255)
            try validate(self.bucket, name: "bucket", parent: name, min: 3)
            try validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPointsResult: AWSDecodableShape {
        public struct _AccessPointListEncoding: ArrayCoderProperties { static public let member = "AccessPoint" }

        /// Contains identification and configuration information for one or more access points associated with the specified bucket.
        @OptionalCoding<ArrayCoder<_AccessPointListEncoding, AccessPoint>>
        public var accessPointList: [AccessPoint]?
        /// If the specified bucket has more access points than can be returned in one call to this API, then this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
        public let nextToken: String?

        public init(accessPointList: [AccessPoint]? = nil, nextToken: String? = nil) {
            self.accessPointList = accessPointList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointList = "AccessPointList"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobStatuses", location: .querystring(locationName: "jobStatuses")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let accountId: String
        /// The List Jobs request returns jobs that match the statuses listed in this element.
        public let jobStatuses: [JobStatus]?
        /// The maximum number of jobs that Amazon S3 will include in the List Jobs response. If there are more jobs than this number, the response will include a pagination token in the NextToken field to enable you to retrieve the next page of results.
        public let maxResults: Int?
        /// A pagination token to request the next page of results. Use the token that Amazon S3 returned in the NextToken element of the ListJobsResult from the previous List Jobs request.
        public let nextToken: String?

        public init(accountId: String, jobStatuses: [JobStatus]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.jobStatuses = jobStatuses
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9\\+\\:\\/\\=\\?\\#-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResult: AWSDecodableShape {

        /// The list of current jobs and jobs that have ended within the last 30 days.
        @OptionalCoding<DefaultArrayCoder>
        public var jobs: [JobListDescriptor]?
        /// If the List Jobs request produced more than the maximum number of results, you can pass this value into a subsequent List Jobs request in order to retrieve the next page of results.
        public let nextToken: String?

        public init(jobs: [JobListDescriptor]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct PolicyStatus: AWSDecodableShape {

        public let isPublic: Bool?

        public init(isPublic: Bool? = nil) {
            self.isPublic = isPublic
        }

        private enum CodingKeys: String, CodingKey {
            case isPublic = "IsPublic"
        }
    }

    public struct PublicAccessBlockConfiguration: AWSEncodableShape & AWSDecodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"

        /// Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:   PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.   PUT Object calls fail if the request includes a public ACL.   PUT Bucket calls fail if the request includes a public ACL.   Enabling this setting doesn't affect existing policies or ACLs.
        public let blockPublicAcls: Bool?
        /// Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.  Enabling this setting doesn't affect existing bucket policies.
        public let blockPublicPolicy: Bool?
        /// Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain.  Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        public let ignorePublicAcls: Bool?
        /// Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only AWS services and authorized users within this account. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        public let restrictPublicBuckets: Bool?

        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls = "BlockPublicAcls"
            case blockPublicPolicy = "BlockPublicPolicy"
            case ignorePublicAcls = "IgnorePublicAcls"
            case restrictPublicBuckets = "RestrictPublicBuckets"
        }
    }

    public struct PutAccessPointPolicyRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The AWS account ID for owner of the bucket associated with the specified access point.
        public let accountId: String
        /// The name of the access point that you want to associate with the specified policy.
        public let name: String
        /// The policy that you want to apply to the specified access point. For more information about access point policies, see Managing Data Access with Amazon S3 Access Points in the Amazon Simple Storage Service Developer Guide.
        public let policy: String

        public init(accountId: String, name: String, policy: String) {
            self.accountId = accountId
            self.name = name
            self.policy = policy
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.name, name: "name", parent: name, max: 50)
            try validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutJobTaggingRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The AWS account ID associated with the Amazon S3 Batch Operations job.
        public let accountId: String
        /// The ID for the Amazon S3 Batch Operations job whose tags you want to replace.
        public let jobId: String
        /// The set of tags to associate with the Amazon S3 Batch Operations job.
        @Coding<DefaultArrayCoder>
        public var tags: [S3Tag]

        public init(accountId: String, jobId: String, tags: [S3Tag]) {
            self.accountId = accountId
            self.jobId = jobId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.jobId, name: "jobId", parent: name, max: 36)
            try validate(self.jobId, name: "jobId", parent: name, min: 5)
            try validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct PutJobTaggingResult: AWSDecodableShape {


        public init() {
        }

    }

    public struct PutPublicAccessBlockRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "publicAccessBlockConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "publicAccessBlockConfiguration", location: .body(locationName: "PublicAccessBlockConfiguration"))
        ]

        /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to set.
        public let accountId: String
        /// The PublicAccessBlock configuration that you want to apply to the specified Amazon Web Services account.
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration

        public init(accountId: String, publicAccessBlockConfiguration: PublicAccessBlockConfiguration) {
            self.accountId = accountId
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        }
    }

    public struct S3AccessControlList: AWSEncodableShape & AWSDecodableShape {

        @OptionalCoding<DefaultArrayCoder>
        public var grants: [S3Grant]?
        public let owner: S3ObjectOwner

        public init(grants: [S3Grant]? = nil, owner: S3ObjectOwner) {
            self.grants = grants
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.grants?.forEach {
                try $0.validate(name: "\(name).grants[]")
            }
            try self.owner.validate(name: "\(name).owner")
        }

        private enum CodingKeys: String, CodingKey {
            case grants = "Grants"
            case owner = "Owner"
        }
    }

    public struct S3AccessControlPolicy: AWSEncodableShape & AWSDecodableShape {

        public let accessControlList: S3AccessControlList?
        public let cannedAccessControlList: S3CannedAccessControlList?

        public init(accessControlList: S3AccessControlList? = nil, cannedAccessControlList: S3CannedAccessControlList? = nil) {
            self.accessControlList = accessControlList
            self.cannedAccessControlList = cannedAccessControlList
        }

        public func validate(name: String) throws {
            try self.accessControlList?.validate(name: "\(name).accessControlList")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "AccessControlList"
            case cannedAccessControlList = "CannedAccessControlList"
        }
    }

    public struct S3CopyObjectOperation: AWSEncodableShape & AWSDecodableShape {

        @OptionalCoding<DefaultArrayCoder>
        public var accessControlGrants: [S3Grant]?
        public let cannedAccessControlList: S3CannedAccessControlList?
        public let metadataDirective: S3MetadataDirective?
        public let modifiedSinceConstraint: TimeStamp?
        public let newObjectMetadata: S3ObjectMetadata?
        @OptionalCoding<DefaultArrayCoder>
        public var newObjectTagging: [S3Tag]?
        /// The Legal Hold status to be applied to all objects in the Batch Operations job.
        public let objectLockLegalHoldStatus: S3ObjectLockLegalHoldStatus?
        /// The Retention mode to be applied to all objects in the Batch Operations job.
        public let objectLockMode: S3ObjectLockMode?
        /// The date when the applied Object Retention configuration will expire on all objects in the Batch Operations job.
        public let objectLockRetainUntilDate: TimeStamp?
        public let redirectLocation: String?
        public let requesterPays: Bool?
        public let sSEAwsKmsKeyId: String?
        public let storageClass: S3StorageClass?
        public let targetKeyPrefix: String?
        public let targetResource: String?
        public let unModifiedSinceConstraint: TimeStamp?

        public init(accessControlGrants: [S3Grant]? = nil, cannedAccessControlList: S3CannedAccessControlList? = nil, metadataDirective: S3MetadataDirective? = nil, modifiedSinceConstraint: TimeStamp? = nil, newObjectMetadata: S3ObjectMetadata? = nil, newObjectTagging: [S3Tag]? = nil, objectLockLegalHoldStatus: S3ObjectLockLegalHoldStatus? = nil, objectLockMode: S3ObjectLockMode? = nil, objectLockRetainUntilDate: TimeStamp? = nil, redirectLocation: String? = nil, requesterPays: Bool? = nil, sSEAwsKmsKeyId: String? = nil, storageClass: S3StorageClass? = nil, targetKeyPrefix: String? = nil, targetResource: String? = nil, unModifiedSinceConstraint: TimeStamp? = nil) {
            self.accessControlGrants = accessControlGrants
            self.cannedAccessControlList = cannedAccessControlList
            self.metadataDirective = metadataDirective
            self.modifiedSinceConstraint = modifiedSinceConstraint
            self.newObjectMetadata = newObjectMetadata
            self.newObjectTagging = newObjectTagging
            self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
            self.objectLockMode = objectLockMode
            self.objectLockRetainUntilDate = objectLockRetainUntilDate
            self.redirectLocation = redirectLocation
            self.requesterPays = requesterPays
            self.sSEAwsKmsKeyId = sSEAwsKmsKeyId
            self.storageClass = storageClass
            self.targetKeyPrefix = targetKeyPrefix
            self.targetResource = targetResource
            self.unModifiedSinceConstraint = unModifiedSinceConstraint
        }

        public func validate(name: String) throws {
            try self.accessControlGrants?.forEach {
                try $0.validate(name: "\(name).accessControlGrants[]")
            }
            try self.newObjectMetadata?.validate(name: "\(name).newObjectMetadata")
            try self.newObjectTagging?.forEach {
                try $0.validate(name: "\(name).newObjectTagging[]")
            }
            try validate(self.redirectLocation, name: "redirectLocation", parent: name, max: 2048)
            try validate(self.redirectLocation, name: "redirectLocation", parent: name, min: 1)
            try validate(self.sSEAwsKmsKeyId, name: "sSEAwsKmsKeyId", parent: name, max: 2000)
            try validate(self.sSEAwsKmsKeyId, name: "sSEAwsKmsKeyId", parent: name, min: 1)
            try validate(self.targetKeyPrefix, name: "targetKeyPrefix", parent: name, max: 1024)
            try validate(self.targetKeyPrefix, name: "targetKeyPrefix", parent: name, min: 1)
            try validate(self.targetResource, name: "targetResource", parent: name, max: 128)
            try validate(self.targetResource, name: "targetResource", parent: name, min: 1)
            try validate(self.targetResource, name: "targetResource", parent: name, pattern: "arn:[^:]+:s3:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlGrants = "AccessControlGrants"
            case cannedAccessControlList = "CannedAccessControlList"
            case metadataDirective = "MetadataDirective"
            case modifiedSinceConstraint = "ModifiedSinceConstraint"
            case newObjectMetadata = "NewObjectMetadata"
            case newObjectTagging = "NewObjectTagging"
            case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
            case objectLockMode = "ObjectLockMode"
            case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
            case redirectLocation = "RedirectLocation"
            case requesterPays = "RequesterPays"
            case sSEAwsKmsKeyId = "SSEAwsKmsKeyId"
            case storageClass = "StorageClass"
            case targetKeyPrefix = "TargetKeyPrefix"
            case targetResource = "TargetResource"
            case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
        }
    }

    public struct S3Grant: AWSEncodableShape & AWSDecodableShape {

        public let grantee: S3Grantee?
        public let permission: S3Permission?

        public init(grantee: S3Grantee? = nil, permission: S3Permission? = nil) {
            self.grantee = grantee
            self.permission = permission
        }

        public func validate(name: String) throws {
            try self.grantee?.validate(name: "\(name).grantee")
        }

        private enum CodingKeys: String, CodingKey {
            case grantee = "Grantee"
            case permission = "Permission"
        }
    }

    public struct S3Grantee: AWSEncodableShape & AWSDecodableShape {

        public let displayName: String?
        public let identifier: String?
        public let typeIdentifier: S3GranteeTypeIdentifier?

        public init(displayName: String? = nil, identifier: String? = nil, typeIdentifier: S3GranteeTypeIdentifier? = nil) {
            self.displayName = displayName
            self.identifier = identifier
            self.typeIdentifier = typeIdentifier
        }

        public func validate(name: String) throws {
            try validate(self.displayName, name: "displayName", parent: name, max: 1024)
            try validate(self.displayName, name: "displayName", parent: name, min: 1)
            try validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case identifier = "Identifier"
            case typeIdentifier = "TypeIdentifier"
        }
    }

    public struct S3InitiateRestoreObjectOperation: AWSEncodableShape & AWSDecodableShape {

        public let expirationInDays: Int?
        public let glacierJobTier: S3GlacierJobTier?

        public init(expirationInDays: Int? = nil, glacierJobTier: S3GlacierJobTier? = nil) {
            self.expirationInDays = expirationInDays
            self.glacierJobTier = glacierJobTier
        }

        public func validate(name: String) throws {
            try validate(self.expirationInDays, name: "expirationInDays", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationInDays = "ExpirationInDays"
            case glacierJobTier = "GlacierJobTier"
        }
    }

    public struct S3ObjectLockLegalHold: AWSEncodableShape & AWSDecodableShape {

        /// The Legal Hold status to be applied to all objects in the Batch Operations job.
        public let status: S3ObjectLockLegalHoldStatus

        public init(status: S3ObjectLockLegalHoldStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct S3ObjectMetadata: AWSEncodableShape & AWSDecodableShape {

        public let cacheControl: String?
        public let contentDisposition: String?
        public let contentEncoding: String?
        public let contentLanguage: String?
        public let contentLength: Int64?
        public let contentMD5: String?
        public let contentType: String?
        public let httpExpiresDate: TimeStamp?
        public let requesterCharged: Bool?
        public let sSEAlgorithm: S3SSEAlgorithm?
        @OptionalCoding<DefaultDictionaryCoder>
        public var userMetadata: [String: String]?

        public init(cacheControl: String? = nil, contentDisposition: String? = nil, contentEncoding: String? = nil, contentLanguage: String? = nil, contentLength: Int64? = nil, contentMD5: String? = nil, contentType: String? = nil, httpExpiresDate: TimeStamp? = nil, requesterCharged: Bool? = nil, sSEAlgorithm: S3SSEAlgorithm? = nil, userMetadata: [String: String]? = nil) {
            self.cacheControl = cacheControl
            self.contentDisposition = contentDisposition
            self.contentEncoding = contentEncoding
            self.contentLanguage = contentLanguage
            self.contentLength = contentLength
            self.contentMD5 = contentMD5
            self.contentType = contentType
            self.httpExpiresDate = httpExpiresDate
            self.requesterCharged = requesterCharged
            self.sSEAlgorithm = sSEAlgorithm
            self.userMetadata = userMetadata
        }

        public func validate(name: String) throws {
            try validate(self.cacheControl, name: "cacheControl", parent: name, max: 1024)
            try validate(self.cacheControl, name: "cacheControl", parent: name, min: 1)
            try validate(self.contentDisposition, name: "contentDisposition", parent: name, max: 1024)
            try validate(self.contentDisposition, name: "contentDisposition", parent: name, min: 1)
            try validate(self.contentEncoding, name: "contentEncoding", parent: name, max: 1024)
            try validate(self.contentEncoding, name: "contentEncoding", parent: name, min: 1)
            try validate(self.contentLanguage, name: "contentLanguage", parent: name, max: 1024)
            try validate(self.contentLanguage, name: "contentLanguage", parent: name, min: 1)
            try validate(self.contentLength, name: "contentLength", parent: name, min: 0)
            try validate(self.contentMD5, name: "contentMD5", parent: name, max: 1024)
            try validate(self.contentMD5, name: "contentMD5", parent: name, min: 1)
            try validate(self.contentType, name: "contentType", parent: name, max: 1024)
            try validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.userMetadata?.forEach {
                try validate($0.key, name: "userMetadata.key", parent: name, max: 1024)
                try validate($0.key, name: "userMetadata.key", parent: name, min: 1)
                try validate($0.value, name: "userMetadata[\"\($0.key)\"]", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cacheControl = "CacheControl"
            case contentDisposition = "ContentDisposition"
            case contentEncoding = "ContentEncoding"
            case contentLanguage = "ContentLanguage"
            case contentLength = "ContentLength"
            case contentMD5 = "ContentMD5"
            case contentType = "ContentType"
            case httpExpiresDate = "HttpExpiresDate"
            case requesterCharged = "RequesterCharged"
            case sSEAlgorithm = "SSEAlgorithm"
            case userMetadata = "UserMetadata"
        }
    }

    public struct S3ObjectOwner: AWSEncodableShape & AWSDecodableShape {

        public let displayName: String?
        public let id: String?

        public init(displayName: String? = nil, id: String? = nil) {
            self.displayName = displayName
            self.id = id
        }

        public func validate(name: String) throws {
            try validate(self.displayName, name: "displayName", parent: name, max: 1024)
            try validate(self.displayName, name: "displayName", parent: name, min: 1)
            try validate(self.id, name: "id", parent: name, max: 1024)
            try validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case id = "ID"
        }
    }

    public struct S3Retention: AWSEncodableShape & AWSDecodableShape {

        /// The Retention mode to be applied to all objects in the Batch Operations job.
        public let mode: S3ObjectLockRetentionMode?
        /// The date when the applied Object Retention will expire on all objects in the Batch Operations job.
        public let retainUntilDate: TimeStamp?

        public init(mode: S3ObjectLockRetentionMode? = nil, retainUntilDate: TimeStamp? = nil) {
            self.mode = mode
            self.retainUntilDate = retainUntilDate
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
            case retainUntilDate = "RetainUntilDate"
        }
    }

    public struct S3SetObjectAclOperation: AWSEncodableShape & AWSDecodableShape {

        public let accessControlPolicy: S3AccessControlPolicy?

        public init(accessControlPolicy: S3AccessControlPolicy? = nil) {
            self.accessControlPolicy = accessControlPolicy
        }

        public func validate(name: String) throws {
            try self.accessControlPolicy?.validate(name: "\(name).accessControlPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlPolicy = "AccessControlPolicy"
        }
    }

    public struct S3SetObjectLegalHoldOperation: AWSEncodableShape & AWSDecodableShape {

        /// The Legal Hold contains the status to be applied to all objects in the Batch Operations job.
        public let legalHold: S3ObjectLockLegalHold

        public init(legalHold: S3ObjectLockLegalHold) {
            self.legalHold = legalHold
        }

        private enum CodingKeys: String, CodingKey {
            case legalHold = "LegalHold"
        }
    }

    public struct S3SetObjectRetentionOperation: AWSEncodableShape & AWSDecodableShape {

        /// Indicates if the operation should be applied to objects in the Batch Operations job even if they have Governance-type Object Lock in place.
        public let bypassGovernanceRetention: Bool?
        /// Amazon S3 object lock Retention contains the retention mode to be applied to all objects in the Batch Operations job.
        public let retention: S3Retention

        public init(bypassGovernanceRetention: Bool? = nil, retention: S3Retention) {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.retention = retention
        }

        private enum CodingKeys: String, CodingKey {
            case bypassGovernanceRetention = "BypassGovernanceRetention"
            case retention = "Retention"
        }
    }

    public struct S3SetObjectTaggingOperation: AWSEncodableShape & AWSDecodableShape {

        @OptionalCoding<DefaultArrayCoder>
        public var tagSet: [S3Tag]?

        public init(tagSet: [S3Tag]? = nil) {
            self.tagSet = tagSet
        }

        public func validate(name: String) throws {
            try self.tagSet?.forEach {
                try $0.validate(name: "\(name).tagSet[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tagSet = "TagSet"
        }
    }

    public struct S3Tag: AWSEncodableShape & AWSDecodableShape {

        public let key: String
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name: "key", parent: name, max: 1024)
            try validate(self.key, name: "key", parent: name, min: 1)
            try validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:=+\\-@%]*)$")
            try validate(self.value, name: "value", parent: name, max: 1024)
            try validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:=+\\-@%]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct UpdateJobPriorityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id")), 
            AWSMemberEncoding(label: "priority", location: .querystring(locationName: "priority"))
        ]

        public let accountId: String
        /// The ID for the job whose priority you want to update.
        public let jobId: String
        /// The priority you want to assign to this job.
        public let priority: Int

        public init(accountId: String, jobId: String, priority: Int) {
            self.accountId = accountId
            self.jobId = jobId
            self.priority = priority
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.jobId, name: "jobId", parent: name, max: 36)
            try validate(self.jobId, name: "jobId", parent: name, min: 5)
            try validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
            try validate(self.priority, name: "priority", parent: name, max: 2147483647)
            try validate(self.priority, name: "priority", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateJobPriorityResult: AWSDecodableShape {

        /// The ID for the job whose priority Amazon S3 updated.
        public let jobId: String
        /// The new priority assigned to the specified job.
        public let priority: Int

        public init(jobId: String, priority: Int) {
            self.jobId = jobId
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case priority = "Priority"
        }
    }

    public struct UpdateJobStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")), 
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id")), 
            AWSMemberEncoding(label: "requestedJobStatus", location: .querystring(locationName: "requestedJobStatus")), 
            AWSMemberEncoding(label: "statusUpdateReason", location: .querystring(locationName: "statusUpdateReason"))
        ]

        public let accountId: String
        /// The ID of the job whose status you want to update.
        public let jobId: String
        /// The status that you want to move the specified job to.
        public let requestedJobStatus: RequestedJobStatus
        /// A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.
        public let statusUpdateReason: String?

        public init(accountId: String, jobId: String, requestedJobStatus: RequestedJobStatus, statusUpdateReason: String? = nil) {
            self.accountId = accountId
            self.jobId = jobId
            self.requestedJobStatus = requestedJobStatus
            self.statusUpdateReason = statusUpdateReason
        }

        public func validate(name: String) throws {
            try validate(self.accountId, name: "accountId", parent: name, max: 64)
            try validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try validate(self.jobId, name: "jobId", parent: name, max: 36)
            try validate(self.jobId, name: "jobId", parent: name, min: 5)
            try validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
            try validate(self.statusUpdateReason, name: "statusUpdateReason", parent: name, max: 256)
            try validate(self.statusUpdateReason, name: "statusUpdateReason", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateJobStatusResult: AWSDecodableShape {

        /// The ID for the job whose status was updated.
        public let jobId: String?
        /// The current status for the specified job.
        public let status: JobStatus?
        /// The reason that the specified job's status was updated.
        public let statusUpdateReason: String?

        public init(jobId: String? = nil, status: JobStatus? = nil, statusUpdateReason: String? = nil) {
            self.jobId = jobId
            self.status = status
            self.statusUpdateReason = statusUpdateReason
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case status = "Status"
            case statusUpdateReason = "StatusUpdateReason"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        public let vpcId: String

        public init(vpcId: String) {
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try validate(self.vpcId, name: "vpcId", parent: name, max: 1024)
            try validate(self.vpcId, name: "vpcId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vpcId = "VpcId"
        }
    }
}
