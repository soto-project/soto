// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension SecurityHub {

    public struct AcceptInvitationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InvitationId", required: true, type: .string), 
            AWSShapeMember(label: "MasterId", required: true, type: .string)
        ]

        /// The ID of the invitation sent from the Security Hub master account.
        public let invitationId: String
        /// The account ID of the Security Hub master account that sent the invitation.
        public let masterId: String

        public init(invitationId: String, masterId: String) {
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func validate(name: String) throws {
            try validate(self.invitationId, name:"invitationId", parent: name, pattern: ".*\\S.*")
            try validate(self.masterId, name:"masterId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "InvitationId"
            case masterId = "MasterId"
        }
    }

    public struct AcceptInvitationResponse: AWSShape {


        public init() {
        }

    }

    public struct AccountDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Email", required: false, type: .string)
        ]

        /// The ID of an AWS account.
        public let accountId: String?
        /// The email of an AWS account.
        public let email: String?

        public init(accountId: String? = nil, email: String? = nil) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try validate(self.email, name:"email", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case email = "Email"
        }
    }

    public struct ActionTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargetArn", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ARN for the target action.
        public let actionTargetArn: String
        /// The description of the target action.
        public let description: String
        /// The name of the action target.
        public let name: String

        public init(actionTargetArn: String, description: String, name: String) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct AvailabilityZone: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "ZoneName", required: false, type: .string)
        ]

        /// The ID of the subnet. You can specify one subnet per Availability Zone.
        public let subnetId: String?
        /// The name of the Availability Zone.
        public let zoneName: String?

        public init(subnetId: String? = nil, zoneName: String? = nil) {
            self.subnetId = subnetId
            self.zoneName = zoneName
        }

        public func validate(name: String) throws {
            try validate(self.subnetId, name:"subnetId", parent: name, pattern: ".*\\S.*")
            try validate(self.zoneName, name:"zoneName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case zoneName = "ZoneName"
        }
    }

    public struct AwsCloudFrontDistributionDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: false, type: .string), 
            AWSShapeMember(label: "ETag", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .string), 
            AWSShapeMember(label: "Logging", required: false, type: .structure), 
            AWSShapeMember(label: "Origins", required: false, type: .structure), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "WebAclId", required: false, type: .string)
        ]

        /// The domain name corresponding to the distribution.
        public let domainName: String?
        /// The entity tag is a hash of the object.
        public let eTag: String?
        /// The date and time that the distribution was last modified.
        public let lastModifiedTime: String?
        /// A complex type that controls whether access logs are written for the distribution.
        public let logging: AwsCloudFrontDistributionLogging?
        /// A complex type that contains information about origins for this distribution.
        public let origins: AwsCloudFrontDistributionOrigins?
        /// Indicates the current status of the distribution.
        public let status: String?
        /// A unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution.
        public let webAclId: String?

        public init(domainName: String? = nil, eTag: String? = nil, lastModifiedTime: String? = nil, logging: AwsCloudFrontDistributionLogging? = nil, origins: AwsCloudFrontDistributionOrigins? = nil, status: String? = nil, webAclId: String? = nil) {
            self.domainName = domainName
            self.eTag = eTag
            self.lastModifiedTime = lastModifiedTime
            self.logging = logging
            self.origins = origins
            self.status = status
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try validate(self.domainName, name:"domainName", parent: name, pattern: ".*\\S.*")
            try validate(self.eTag, name:"eTag", parent: name, pattern: ".*\\S.*")
            try validate(self.lastModifiedTime, name:"lastModifiedTime", parent: name, pattern: ".*\\S.*")
            try self.logging?.validate(name: "\(name).logging")
            try self.origins?.validate(name: "\(name).origins")
            try validate(self.status, name:"status", parent: name, pattern: ".*\\S.*")
            try validate(self.webAclId, name:"webAclId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case eTag = "ETag"
            case lastModifiedTime = "LastModifiedTime"
            case logging = "Logging"
            case origins = "Origins"
            case status = "Status"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsCloudFrontDistributionLogging: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bucket", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeCookies", required: false, type: .boolean), 
            AWSShapeMember(label: "Prefix", required: false, type: .string)
        ]

        /// The Amazon S3 bucket to store the access logs in.
        public let bucket: String?
        /// With this field, you can enable or disable the selected distribution.
        public let enabled: Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs.
        public let includeCookies: Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this distribution.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool? = nil, includeCookies: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try validate(self.bucket, name:"bucket", parent: name, pattern: ".*\\S.*")
            try validate(self.prefix, name:"prefix", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case enabled = "Enabled"
            case includeCookies = "IncludeCookies"
            case prefix = "Prefix"
        }
    }

    public struct AwsCloudFrontDistributionOriginItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "OriginPath", required: false, type: .string)
        ]

        /// Amazon S3 origins: The DNS name of the Amazon S3 bucket from which you want CloudFront to get objects for this origin.
        public let domainName: String?
        /// A unique identifier for the origin or origin group.
        public let id: String?
        /// An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
        public let originPath: String?

        public init(domainName: String? = nil, id: String? = nil, originPath: String? = nil) {
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
        }

        public func validate(name: String) throws {
            try validate(self.domainName, name:"domainName", parent: name, pattern: ".*\\S.*")
            try validate(self.id, name:"id", parent: name, pattern: ".*\\S.*")
            try validate(self.originPath, name:"originPath", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case id = "Id"
            case originPath = "OriginPath"
        }
    }

    public struct AwsCloudFrontDistributionOrigins: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Items", required: false, type: .list)
        ]

        /// A complex type that contains origins or origin groups for this distribution.
        public let items: [AwsCloudFrontDistributionOriginItem]?

        public init(items: [AwsCloudFrontDistributionOriginItem]? = nil) {
            self.items = items
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsEc2InstanceDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IamInstanceProfileArn", required: false, type: .string), 
            AWSShapeMember(label: "ImageId", required: false, type: .string), 
            AWSShapeMember(label: "IpV4Addresses", required: false, type: .list), 
            AWSShapeMember(label: "IpV6Addresses", required: false, type: .list), 
            AWSShapeMember(label: "KeyName", required: false, type: .string), 
            AWSShapeMember(label: "LaunchedAt", required: false, type: .string), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string)
        ]

        /// The IAM profile ARN of the instance.
        public let iamInstanceProfileArn: String?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let imageId: String?
        /// The IPv4 addresses associated with the instance.
        public let ipV4Addresses: [String]?
        /// The IPv6 addresses associated with the instance.
        public let ipV6Addresses: [String]?
        /// The key name associated with the instance.
        public let keyName: String?
        /// The date/time the instance was launched.
        public let launchedAt: String?
        /// The identifier of the subnet that the instance was launched in.
        public let subnetId: String?
        /// The instance type of the instance. 
        public let `type`: String?
        /// The identifier of the VPC that the instance was launched in.
        public let vpcId: String?

        public init(iamInstanceProfileArn: String? = nil, imageId: String? = nil, ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil, keyName: String? = nil, launchedAt: String? = nil, subnetId: String? = nil, type: String? = nil, vpcId: String? = nil) {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.subnetId = subnetId
            self.`type` = `type`
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try validate(self.iamInstanceProfileArn, name:"iamInstanceProfileArn", parent: name, pattern: ".*\\S.*")
            try validate(self.imageId, name:"imageId", parent: name, pattern: ".*\\S.*")
            try self.ipV4Addresses?.forEach {
                try validate($0, name: "ipV4Addresses[]", parent: name, pattern: ".*\\S.*")
            }
            try self.ipV6Addresses?.forEach {
                try validate($0, name: "ipV6Addresses[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.keyName, name:"keyName", parent: name, pattern: ".*\\S.*")
            try validate(self.launchedAt, name:"launchedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.subnetId, name:"subnetId", parent: name, pattern: ".*\\S.*")
            try validate(self.`type`, name:"`type`", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcId, name:"vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case iamInstanceProfileArn = "IamInstanceProfileArn"
            case imageId = "ImageId"
            case ipV4Addresses = "IpV4Addresses"
            case ipV6Addresses = "IpV6Addresses"
            case keyName = "KeyName"
            case launchedAt = "LaunchedAt"
            case subnetId = "SubnetId"
            case `type` = "Type"
            case vpcId = "VpcId"
        }
    }

    public struct AwsElbv2LoadBalancerDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeMember(label: "CanonicalHostedZoneId", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .string), 
            AWSShapeMember(label: "DNSName", required: false, type: .string), 
            AWSShapeMember(label: "IpAddressType", required: false, type: .string), 
            AWSShapeMember(label: "Scheme", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroups", required: false, type: .list), 
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string)
        ]

        /// The Availability Zones for the load balancer.
        public let availabilityZones: [AvailabilityZone]?
        /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
        public let canonicalHostedZoneId: String?
        /// The date and time the load balancer was created.
        public let createdTime: String?
        /// The public DNS name of the load balancer.
        public let dNSName: String?
        /// The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
        public let ipAddressType: String?
        /// The nodes of an Internet-facing load balancer have public IP addresses.
        public let scheme: String?
        /// The IDs of the security groups for the load balancer.
        public let securityGroups: [String]?
        /// The state of the load balancer.
        public let state: LoadBalancerState?
        /// The type of load balancer.
        public let `type`: String?
        /// The ID of the VPC for the load balancer.
        public let vpcId: String?

        public init(availabilityZones: [AvailabilityZone]? = nil, canonicalHostedZoneId: String? = nil, createdTime: String? = nil, dNSName: String? = nil, ipAddressType: String? = nil, scheme: String? = nil, securityGroups: [String]? = nil, state: LoadBalancerState? = nil, type: String? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.dNSName = dNSName
            self.ipAddressType = ipAddressType
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.`type` = `type`
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try $0.validate(name: "\(name).availabilityZones[]")
            }
            try validate(self.canonicalHostedZoneId, name:"canonicalHostedZoneId", parent: name, pattern: ".*\\S.*")
            try validate(self.createdTime, name:"createdTime", parent: name, pattern: ".*\\S.*")
            try validate(self.dNSName, name:"dNSName", parent: name, pattern: ".*\\S.*")
            try validate(self.ipAddressType, name:"ipAddressType", parent: name, pattern: ".*\\S.*")
            try validate(self.scheme, name:"scheme", parent: name, pattern: ".*\\S.*")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: ".*\\S.*")
            }
            try self.state?.validate(name: "\(name).state")
            try validate(self.`type`, name:"`type`", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcId, name:"vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case canonicalHostedZoneId = "CanonicalHostedZoneId"
            case createdTime = "CreatedTime"
            case dNSName = "DNSName"
            case ipAddressType = "IpAddressType"
            case scheme = "Scheme"
            case securityGroups = "SecurityGroups"
            case state = "State"
            case `type` = "Type"
            case vpcId = "VpcId"
        }
    }

    public struct AwsIamAccessKeyDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedAt", required: false, type: .string), 
            AWSShapeMember(label: "PrincipalId", required: false, type: .string), 
            AWSShapeMember(label: "PrincipalName", required: false, type: .string), 
            AWSShapeMember(label: "PrincipalType", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// The creation date/time of the IAM access key related to a finding.
        public let createdAt: String?
        /// The ID of the principal associated with an access key.
        public let principalId: String?
        /// The name of the principal.
        public let principalName: String?
        /// The type of principal associated with an access key.
        public let principalType: String?
        /// The status of the IAM access key related to a finding.
        public let status: AwsIamAccessKeyStatus?

        public init(createdAt: String? = nil, principalId: String? = nil, principalName: String? = nil, principalType: String? = nil, status: AwsIamAccessKeyStatus? = nil) {
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.createdAt, name:"createdAt", parent: name, pattern: ".*\\S.*")
            try validate(self.principalId, name:"principalId", parent: name, pattern: ".*\\S.*")
            try validate(self.principalName, name:"principalName", parent: name, pattern: ".*\\S.*")
            try validate(self.principalType, name:"principalType", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case principalId = "PrincipalId"
            case principalName = "PrincipalName"
            case principalType = "PrincipalType"
            case status = "Status"
        }
    }

    public enum AwsIamAccessKeyStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public struct AwsIamRoleDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AssumeRolePolicyDocument", required: false, type: .string), 
            AWSShapeMember(label: "CreateDate", required: false, type: .string), 
            AWSShapeMember(label: "MaxSessionDuration", required: false, type: .integer), 
            AWSShapeMember(label: "Path", required: false, type: .string), 
            AWSShapeMember(label: "RoleId", required: false, type: .string), 
            AWSShapeMember(label: "RoleName", required: false, type: .string)
        ]

        /// The trust policy that grants permission to assume the role.
        public let assumeRolePolicyDocument: String?
        /// The date and time, in ISO 8601 date-time format, when the role was created.
        public let createDate: String?
        /// The maximum session duration (in seconds) that you want to set for the specified role.
        public let maxSessionDuration: Int?
        /// The path to the role.
        public let path: String?
        /// The stable and unique string identifying the role.
        public let roleId: String?
        /// The friendly name that identifies the role.
        public let roleName: String?

        public init(assumeRolePolicyDocument: String? = nil, createDate: String? = nil, maxSessionDuration: Int? = nil, path: String? = nil, roleId: String? = nil, roleName: String? = nil) {
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.roleId = roleId
            self.roleName = roleName
        }

        public func validate(name: String) throws {
            try validate(self.assumeRolePolicyDocument, name:"assumeRolePolicyDocument", parent: name, max: 131072)
            try validate(self.assumeRolePolicyDocument, name:"assumeRolePolicyDocument", parent: name, min: 1)
            try validate(self.assumeRolePolicyDocument, name:"assumeRolePolicyDocument", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try validate(self.createDate, name:"createDate", parent: name, pattern: ".*\\S.*")
            try validate(self.path, name:"path", parent: name, pattern: ".*\\S.*")
            try validate(self.roleId, name:"roleId", parent: name, pattern: ".*\\S.*")
            try validate(self.roleName, name:"roleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
            case createDate = "CreateDate"
            case maxSessionDuration = "MaxSessionDuration"
            case path = "Path"
            case roleId = "RoleId"
            case roleName = "RoleName"
        }
    }

    public struct AwsKmsKeyDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AWSAccountId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .double), 
            AWSShapeMember(label: "KeyId", required: false, type: .string), 
            AWSShapeMember(label: "KeyManager", required: false, type: .string), 
            AWSShapeMember(label: "KeyState", required: false, type: .string), 
            AWSShapeMember(label: "Origin", required: false, type: .string)
        ]

        /// The twelve-digit account ID of the AWS account that owns the CMK.
        public let aWSAccountId: String?
        /// The date and time when the CMK was created.
        public let creationDate: Double?
        /// The globally unique identifier for the CMK.
        public let keyId: String?
        /// The manager of the CMK. CMKs in your AWS account are either customer managed or AWS managed.
        public let keyManager: String?
        /// The state of the CMK.
        public let keyState: String?
        /// The source of the CMK's key material. When this value is AWS_KMS, AWS KMS created the key material. When this value is EXTERNAL, the key material was imported from your existing key management infrastructure or the CMK lacks key material. When this value is AWS_CLOUDHSM, the key material was created in the AWS CloudHSM cluster associated with a custom key store.
        public let origin: String?

        public init(aWSAccountId: String? = nil, creationDate: Double? = nil, keyId: String? = nil, keyManager: String? = nil, keyState: String? = nil, origin: String? = nil) {
            self.aWSAccountId = aWSAccountId
            self.creationDate = creationDate
            self.keyId = keyId
            self.keyManager = keyManager
            self.keyState = keyState
            self.origin = origin
        }

        public func validate(name: String) throws {
            try validate(self.aWSAccountId, name:"aWSAccountId", parent: name, pattern: ".*\\S.*")
            try validate(self.keyId, name:"keyId", parent: name, pattern: ".*\\S.*")
            try validate(self.keyManager, name:"keyManager", parent: name, pattern: ".*\\S.*")
            try validate(self.keyState, name:"keyState", parent: name, pattern: ".*\\S.*")
            try validate(self.origin, name:"origin", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case aWSAccountId = "AWSAccountId"
            case creationDate = "CreationDate"
            case keyId = "KeyId"
            case keyManager = "KeyManager"
            case keyState = "KeyState"
            case origin = "Origin"
        }
    }

    public struct AwsLambdaFunctionCode: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3Bucket", required: false, type: .string), 
            AWSShapeMember(label: "S3Key", required: false, type: .string), 
            AWSShapeMember(label: "S3ObjectVersion", required: false, type: .string), 
            AWSShapeMember(label: "ZipFile", required: false, type: .string)
        ]

        /// An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for you.
        public let zipFile: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try validate(self.s3Bucket, name:"s3Bucket", parent: name, pattern: ".*\\S.*")
            try validate(self.s3Key, name:"s3Key", parent: name, pattern: ".*\\S.*")
            try validate(self.s3ObjectVersion, name:"s3ObjectVersion", parent: name, pattern: ".*\\S.*")
            try validate(self.zipFile, name:"zipFile", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct AwsLambdaFunctionDeadLetterConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public let targetArn: String?

        public init(targetArn: String? = nil) {
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try validate(self.targetArn, name:"targetArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case targetArn = "TargetArn"
        }
    }

    public struct AwsLambdaFunctionDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", required: false, type: .structure), 
            AWSShapeMember(label: "CodeSha256", required: false, type: .string), 
            AWSShapeMember(label: "DeadLetterConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Environment", required: false, type: .structure), 
            AWSShapeMember(label: "FunctionName", required: false, type: .string), 
            AWSShapeMember(label: "Handler", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "LastModified", required: false, type: .string), 
            AWSShapeMember(label: "Layers", required: false, type: .list), 
            AWSShapeMember(label: "MasterArn", required: false, type: .string), 
            AWSShapeMember(label: "MemorySize", required: false, type: .integer), 
            AWSShapeMember(label: "RevisionId", required: false, type: .string), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "Runtime", required: false, type: .string), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer), 
            AWSShapeMember(label: "TracingConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Version", required: false, type: .string), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure)
        ]

        /// An AwsLambdaFunctionCode object.
        public let code: AwsLambdaFunctionCode?
        /// The SHA256 hash of the function's deployment package.
        public let codeSha256: String?
        /// The function's dead letter queue.
        public let deadLetterConfig: AwsLambdaFunctionDeadLetterConfig?
        /// The function's environment variables.
        public let environment: AwsLambdaFunctionEnvironment?
        /// The name of the function.
        public let functionName: String?
        /// The function that Lambda calls to begin executing your function.
        public let handler: String?
        /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed CMK.
        public let kmsKeyArn: String?
        /// The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModified: String?
        /// The function's layers.
        public let layers: [AwsLambdaFunctionLayer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public let masterArn: String?
        /// The memory that's allocated to the function.
        public let memorySize: Int?
        /// The latest updated revision of the function or alias.
        public let revisionId: String?
        /// The function's execution role.
        public let role: String?
        /// The runtime environment for the Lambda function.
        public let runtime: String?
        /// The amount of time that Lambda allows a function to run before stopping it.
        public let timeout: Int?
        /// The function's AWS X-Ray tracing configuration.
        public let tracingConfig: AwsLambdaFunctionTracingConfig?
        /// The version of the Lambda function.
        public let version: String?
        /// The function's networking configuration.
        public let vpcConfig: AwsLambdaFunctionVpcConfig?

        public init(code: AwsLambdaFunctionCode? = nil, codeSha256: String? = nil, deadLetterConfig: AwsLambdaFunctionDeadLetterConfig? = nil, environment: AwsLambdaFunctionEnvironment? = nil, functionName: String? = nil, handler: String? = nil, kmsKeyArn: String? = nil, lastModified: String? = nil, layers: [AwsLambdaFunctionLayer]? = nil, masterArn: String? = nil, memorySize: Int? = nil, revisionId: String? = nil, role: String? = nil, runtime: String? = nil, timeout: Int? = nil, tracingConfig: AwsLambdaFunctionTracingConfig? = nil, version: String? = nil, vpcConfig: AwsLambdaFunctionVpcConfig? = nil) {
            self.code = code
            self.codeSha256 = codeSha256
            self.deadLetterConfig = deadLetterConfig
            self.environment = environment
            self.functionName = functionName
            self.handler = handler
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.code?.validate(name: "\(name).code")
            try validate(self.codeSha256, name:"codeSha256", parent: name, pattern: ".*\\S.*")
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.environment?.validate(name: "\(name).environment")
            try validate(self.functionName, name:"functionName", parent: name, pattern: ".*\\S.*")
            try validate(self.handler, name:"handler", parent: name, pattern: ".*\\S.*")
            try validate(self.kmsKeyArn, name:"kmsKeyArn", parent: name, pattern: ".*\\S.*")
            try validate(self.lastModified, name:"lastModified", parent: name, pattern: ".*\\S.*")
            try self.layers?.forEach {
                try $0.validate(name: "\(name).layers[]")
            }
            try validate(self.masterArn, name:"masterArn", parent: name, pattern: ".*\\S.*")
            try validate(self.revisionId, name:"revisionId", parent: name, pattern: ".*\\S.*")
            try validate(self.role, name:"role", parent: name, pattern: ".*\\S.*")
            try validate(self.runtime, name:"runtime", parent: name, pattern: ".*\\S.*")
            try self.tracingConfig?.validate(name: "\(name).tracingConfig")
            try validate(self.version, name:"version", parent: name, pattern: ".*\\S.*")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case codeSha256 = "CodeSha256"
            case deadLetterConfig = "DeadLetterConfig"
            case environment = "Environment"
            case functionName = "FunctionName"
            case handler = "Handler"
            case kmsKeyArn = "KmsKeyArn"
            case lastModified = "LastModified"
            case layers = "Layers"
            case masterArn = "MasterArn"
            case memorySize = "MemorySize"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case version = "Version"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsLambdaFunctionEnvironment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Error", required: false, type: .structure), 
            AWSShapeMember(label: "Variables", required: false, type: .map)
        ]

        /// An AwsLambdaFunctionEnvironmentError object.
        public let error: AwsLambdaFunctionEnvironmentError?
        /// Environment variable key-value pairs.
        public let variables: [String: String]?

        public init(error: AwsLambdaFunctionEnvironmentError? = nil, variables: [String: String]? = nil) {
            self.error = error
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.error?.validate(name: "\(name).error")
            try self.variables?.forEach {
                try validate($0.key, name:"variables.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name:"variables[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case variables = "Variables"
        }
    }

    public struct AwsLambdaFunctionEnvironmentError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]

        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        public func validate(name: String) throws {
            try validate(self.errorCode, name:"errorCode", parent: name, pattern: ".*\\S.*")
            try validate(self.message, name:"message", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AwsLambdaFunctionLayer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "CodeSize", required: false, type: .integer)
        ]

        /// The Amazon Resource Name (ARN) of the function layer.
        public let arn: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int?

        public init(arn: String? = nil, codeSize: Int? = nil) {
            self.arn = arn
            self.codeSize = codeSize
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case codeSize = "CodeSize"
        }
    }

    public struct AwsLambdaFunctionTracingConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Mode", required: false, type: .string)
        ]

        /// The tracing mode.
        public let mode: String?

        public init(mode: String? = nil) {
            self.mode = mode
        }

        public func validate(name: String) throws {
            try validate(self.mode, name:"mode", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct AwsLambdaFunctionVpcConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "SubnetIds", required: false, type: .list), 
            AWSShapeMember(label: "VpcId", required: false, type: .string)
        ]

        /// A list of VPC security groups IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: ".*\\S.*")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.vpcId, name:"vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VpcId"
        }
    }

    public struct AwsS3BucketDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OwnerId", required: false, type: .string), 
            AWSShapeMember(label: "OwnerName", required: false, type: .string)
        ]

        /// The canonical user ID of the owner of the S3 bucket.
        public let ownerId: String?
        /// The display name of the owner of the S3 bucket.
        public let ownerName: String?

        public init(ownerId: String? = nil, ownerName: String? = nil) {
            self.ownerId = ownerId
            self.ownerName = ownerName
        }

        public func validate(name: String) throws {
            try validate(self.ownerId, name:"ownerId", parent: name, pattern: ".*\\S.*")
            try validate(self.ownerName, name:"ownerName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case ownerId = "OwnerId"
            case ownerName = "OwnerName"
        }
    }

    public struct AwsSecurityFinding: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AwsAccountId", required: true, type: .string), 
            AWSShapeMember(label: "Compliance", required: false, type: .structure), 
            AWSShapeMember(label: "Confidence", required: false, type: .integer), 
            AWSShapeMember(label: "CreatedAt", required: true, type: .string), 
            AWSShapeMember(label: "Criticality", required: false, type: .integer), 
            AWSShapeMember(label: "Description", required: true, type: .string), 
            AWSShapeMember(label: "FirstObservedAt", required: false, type: .string), 
            AWSShapeMember(label: "GeneratorId", required: true, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "LastObservedAt", required: false, type: .string), 
            AWSShapeMember(label: "Malware", required: false, type: .list), 
            AWSShapeMember(label: "Network", required: false, type: .structure), 
            AWSShapeMember(label: "Note", required: false, type: .structure), 
            AWSShapeMember(label: "Process", required: false, type: .structure), 
            AWSShapeMember(label: "ProductArn", required: true, type: .string), 
            AWSShapeMember(label: "ProductFields", required: false, type: .map), 
            AWSShapeMember(label: "RecordState", required: false, type: .enum), 
            AWSShapeMember(label: "RelatedFindings", required: false, type: .list), 
            AWSShapeMember(label: "Remediation", required: false, type: .structure), 
            AWSShapeMember(label: "Resources", required: true, type: .list), 
            AWSShapeMember(label: "SchemaVersion", required: true, type: .string), 
            AWSShapeMember(label: "Severity", required: true, type: .structure), 
            AWSShapeMember(label: "SourceUrl", required: false, type: .string), 
            AWSShapeMember(label: "ThreatIntelIndicators", required: false, type: .list), 
            AWSShapeMember(label: "Title", required: true, type: .string), 
            AWSShapeMember(label: "Types", required: true, type: .list), 
            AWSShapeMember(label: "UpdatedAt", required: true, type: .string), 
            AWSShapeMember(label: "UserDefinedFields", required: false, type: .map), 
            AWSShapeMember(label: "VerificationState", required: false, type: .enum), 
            AWSShapeMember(label: "WorkflowState", required: false, type: .enum)
        ]

        /// The AWS account ID that a finding is generated in.
        public let awsAccountId: String
        /// This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard (for example, CIS AWS Foundations). Contains compliance-related finding details.
        public let compliance: Compliance?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider created the potential security issue that a finding captured.
        public let createdAt: String
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// A finding's description.  In this release, Description is a required property. 
        public let description: String
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.
        public let firstObservedAt: String?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plug-in, etc. 
        public let generatorId: String
        /// The security findings provider-specific identifier for a finding.
        public let id: String
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.
        public let lastObservedAt: String?
        /// A list of malware related to a finding.
        public let malware: [Malware]?
        /// The details of network-related information about a finding.
        public let network: Network?
        /// A user-defined note added to a finding.
        public let note: Note?
        /// The details of process-related information about a finding.
        public let process: ProcessDetails?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security-findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. 
        public let productArn: String
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public let productFields: [String: String]?
        /// The record state of a finding.
        public let recordState: RecordState?
        /// A list of related findings.
        public let relatedFindings: [RelatedFinding]?
        /// A data type that describes the remediation options for a finding.
        public let remediation: Remediation?
        /// A set of resource data types that describe the resources that the finding refers to.
        public let resources: [Resource]
        /// The schema version that a finding is formatted for.
        public let schemaVersion: String
        /// A finding's severity.
        public let severity: Severity
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public let sourceUrl: String?
        /// Threat intel details related to a finding.
        public let threatIntelIndicators: [ThreatIntelIndicator]?
        /// A finding's title.  In this release, Title is a required property. 
        public let title: String
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let types: [String]
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. 
        public let updatedAt: String
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. 
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding. 
        public let verificationState: VerificationState?
        /// The workflow state of a finding. 
        public let workflowState: WorkflowState?

        public init(awsAccountId: String, compliance: Compliance? = nil, confidence: Int? = nil, createdAt: String, criticality: Int? = nil, description: String, firstObservedAt: String? = nil, generatorId: String, id: String, lastObservedAt: String? = nil, malware: [Malware]? = nil, network: Network? = nil, note: Note? = nil, process: ProcessDetails? = nil, productArn: String, productFields: [String: String]? = nil, recordState: RecordState? = nil, relatedFindings: [RelatedFinding]? = nil, remediation: Remediation? = nil, resources: [Resource], schemaVersion: String, severity: Severity, sourceUrl: String? = nil, threatIntelIndicators: [ThreatIntelIndicator]? = nil, title: String, types: [String], updatedAt: String, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, workflowState: WorkflowState? = nil) {
            self.awsAccountId = awsAccountId
            self.compliance = compliance
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.malware = malware
            self.network = network
            self.note = note
            self.process = process
            self.productArn = productArn
            self.productFields = productFields
            self.recordState = recordState
            self.relatedFindings = relatedFindings
            self.remediation = remediation
            self.resources = resources
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.sourceUrl = sourceUrl
            self.threatIntelIndicators = threatIntelIndicators
            self.title = title
            self.types = types
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowState = workflowState
        }

        public func validate(name: String) throws {
            try validate(self.awsAccountId, name:"awsAccountId", parent: name, pattern: ".*\\S.*")
            try validate(self.createdAt, name:"createdAt", parent: name, pattern: ".*\\S.*")
            try validate(self.description, name:"description", parent: name, pattern: ".*\\S.*")
            try validate(self.firstObservedAt, name:"firstObservedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.generatorId, name:"generatorId", parent: name, pattern: ".*\\S.*")
            try validate(self.id, name:"id", parent: name, pattern: ".*\\S.*")
            try validate(self.lastObservedAt, name:"lastObservedAt", parent: name, pattern: ".*\\S.*")
            try self.malware?.forEach {
                try $0.validate(name: "\(name).malware[]")
            }
            try self.network?.validate(name: "\(name).network")
            try self.note?.validate(name: "\(name).note")
            try self.process?.validate(name: "\(name).process")
            try validate(self.productArn, name:"productArn", parent: name, pattern: ".*\\S.*")
            try self.productFields?.forEach {
                try validate($0.key, name:"productFields.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name:"productFields[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.remediation?.validate(name: "\(name).remediation")
            try self.resources.forEach {
                try $0.validate(name: "\(name).resources[]")
            }
            try validate(self.schemaVersion, name:"schemaVersion", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceUrl, name:"sourceUrl", parent: name, pattern: ".*\\S.*")
            try self.threatIntelIndicators?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicators[]")
            }
            try validate(self.title, name:"title", parent: name, pattern: ".*\\S.*")
            try self.types.forEach {
                try validate($0, name: "types[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.updatedAt, name:"updatedAt", parent: name, pattern: ".*\\S.*")
            try self.userDefinedFields?.forEach {
                try validate($0.key, name:"userDefinedFields.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name:"userDefinedFields[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case compliance = "Compliance"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case lastObservedAt = "LastObservedAt"
            case malware = "Malware"
            case network = "Network"
            case note = "Note"
            case process = "Process"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case recordState = "RecordState"
            case relatedFindings = "RelatedFindings"
            case remediation = "Remediation"
            case resources = "Resources"
            case schemaVersion = "SchemaVersion"
            case severity = "Severity"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicators = "ThreatIntelIndicators"
            case title = "Title"
            case types = "Types"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflowState = "WorkflowState"
        }
    }

    public struct AwsSecurityFindingFilters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AwsAccountId", required: false, type: .list), 
            AWSShapeMember(label: "CompanyName", required: false, type: .list), 
            AWSShapeMember(label: "ComplianceStatus", required: false, type: .list), 
            AWSShapeMember(label: "Confidence", required: false, type: .list), 
            AWSShapeMember(label: "CreatedAt", required: false, type: .list), 
            AWSShapeMember(label: "Criticality", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .list), 
            AWSShapeMember(label: "FirstObservedAt", required: false, type: .list), 
            AWSShapeMember(label: "GeneratorId", required: false, type: .list), 
            AWSShapeMember(label: "Id", required: false, type: .list), 
            AWSShapeMember(label: "Keyword", required: false, type: .list), 
            AWSShapeMember(label: "LastObservedAt", required: false, type: .list), 
            AWSShapeMember(label: "MalwareName", required: false, type: .list), 
            AWSShapeMember(label: "MalwarePath", required: false, type: .list), 
            AWSShapeMember(label: "MalwareState", required: false, type: .list), 
            AWSShapeMember(label: "MalwareType", required: false, type: .list), 
            AWSShapeMember(label: "NetworkDestinationDomain", required: false, type: .list), 
            AWSShapeMember(label: "NetworkDestinationIpV4", required: false, type: .list), 
            AWSShapeMember(label: "NetworkDestinationIpV6", required: false, type: .list), 
            AWSShapeMember(label: "NetworkDestinationPort", required: false, type: .list), 
            AWSShapeMember(label: "NetworkDirection", required: false, type: .list), 
            AWSShapeMember(label: "NetworkProtocol", required: false, type: .list), 
            AWSShapeMember(label: "NetworkSourceDomain", required: false, type: .list), 
            AWSShapeMember(label: "NetworkSourceIpV4", required: false, type: .list), 
            AWSShapeMember(label: "NetworkSourceIpV6", required: false, type: .list), 
            AWSShapeMember(label: "NetworkSourceMac", required: false, type: .list), 
            AWSShapeMember(label: "NetworkSourcePort", required: false, type: .list), 
            AWSShapeMember(label: "NoteText", required: false, type: .list), 
            AWSShapeMember(label: "NoteUpdatedAt", required: false, type: .list), 
            AWSShapeMember(label: "NoteUpdatedBy", required: false, type: .list), 
            AWSShapeMember(label: "ProcessLaunchedAt", required: false, type: .list), 
            AWSShapeMember(label: "ProcessName", required: false, type: .list), 
            AWSShapeMember(label: "ProcessParentPid", required: false, type: .list), 
            AWSShapeMember(label: "ProcessPath", required: false, type: .list), 
            AWSShapeMember(label: "ProcessPid", required: false, type: .list), 
            AWSShapeMember(label: "ProcessTerminatedAt", required: false, type: .list), 
            AWSShapeMember(label: "ProductArn", required: false, type: .list), 
            AWSShapeMember(label: "ProductFields", required: false, type: .list), 
            AWSShapeMember(label: "ProductName", required: false, type: .list), 
            AWSShapeMember(label: "RecommendationText", required: false, type: .list), 
            AWSShapeMember(label: "RecordState", required: false, type: .list), 
            AWSShapeMember(label: "RelatedFindingsId", required: false, type: .list), 
            AWSShapeMember(label: "RelatedFindingsProductArn", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceIamInstanceProfileArn", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceImageId", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceIpV4Addresses", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceIpV6Addresses", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceKeyName", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceLaunchedAt", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceSubnetId", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceType", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsEc2InstanceVpcId", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsIamAccessKeyCreatedAt", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsIamAccessKeyStatus", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsIamAccessKeyUserName", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsS3BucketOwnerId", required: false, type: .list), 
            AWSShapeMember(label: "ResourceAwsS3BucketOwnerName", required: false, type: .list), 
            AWSShapeMember(label: "ResourceContainerImageId", required: false, type: .list), 
            AWSShapeMember(label: "ResourceContainerImageName", required: false, type: .list), 
            AWSShapeMember(label: "ResourceContainerLaunchedAt", required: false, type: .list), 
            AWSShapeMember(label: "ResourceContainerName", required: false, type: .list), 
            AWSShapeMember(label: "ResourceDetailsOther", required: false, type: .list), 
            AWSShapeMember(label: "ResourceId", required: false, type: .list), 
            AWSShapeMember(label: "ResourcePartition", required: false, type: .list), 
            AWSShapeMember(label: "ResourceRegion", required: false, type: .list), 
            AWSShapeMember(label: "ResourceTags", required: false, type: .list), 
            AWSShapeMember(label: "ResourceType", required: false, type: .list), 
            AWSShapeMember(label: "SeverityLabel", required: false, type: .list), 
            AWSShapeMember(label: "SeverityNormalized", required: false, type: .list), 
            AWSShapeMember(label: "SeverityProduct", required: false, type: .list), 
            AWSShapeMember(label: "SourceUrl", required: false, type: .list), 
            AWSShapeMember(label: "ThreatIntelIndicatorCategory", required: false, type: .list), 
            AWSShapeMember(label: "ThreatIntelIndicatorLastObservedAt", required: false, type: .list), 
            AWSShapeMember(label: "ThreatIntelIndicatorSource", required: false, type: .list), 
            AWSShapeMember(label: "ThreatIntelIndicatorSourceUrl", required: false, type: .list), 
            AWSShapeMember(label: "ThreatIntelIndicatorType", required: false, type: .list), 
            AWSShapeMember(label: "ThreatIntelIndicatorValue", required: false, type: .list), 
            AWSShapeMember(label: "Title", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .list), 
            AWSShapeMember(label: "UpdatedAt", required: false, type: .list), 
            AWSShapeMember(label: "UserDefinedFields", required: false, type: .list), 
            AWSShapeMember(label: "VerificationState", required: false, type: .list), 
            AWSShapeMember(label: "WorkflowState", required: false, type: .list)
        ]

        /// The AWS account ID that a finding is generated in.
        public let awsAccountId: [StringFilter]?
        /// The name of the findings provider (company) that owns the solution (product) that generates findings.
        public let companyName: [StringFilter]?
        /// Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard (for example, CIS AWS Foundations). Contains compliance-related finding details.
        public let complianceStatus: [StringFilter]?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: [NumberFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.
        public let createdAt: [DateFilter]?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: [NumberFilter]?
        /// A finding's description.
        public let description: [StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.
        public let firstObservedAt: [DateFilter]?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plug-in, etc.
        public let generatorId: [StringFilter]?
        /// The security findings provider-specific identifier for a finding.
        public let id: [StringFilter]?
        /// A keyword for a finding.
        public let keyword: [KeywordFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.
        public let lastObservedAt: [DateFilter]?
        /// The name of the malware that was observed.
        public let malwareName: [StringFilter]?
        /// The filesystem path of the malware that was observed.
        public let malwarePath: [StringFilter]?
        /// The state of the malware that was observed.
        public let malwareState: [StringFilter]?
        /// The type of the malware that was observed.
        public let malwareType: [StringFilter]?
        /// The destination domain of network-related information about a finding.
        public let networkDestinationDomain: [StringFilter]?
        /// The destination IPv4 address of network-related information about a finding.
        public let networkDestinationIpV4: [IpFilter]?
        /// The destination IPv6 address of network-related information about a finding.
        public let networkDestinationIpV6: [IpFilter]?
        /// The destination port of network-related information about a finding.
        public let networkDestinationPort: [NumberFilter]?
        /// Indicates the direction of network traffic associated with a finding.
        public let networkDirection: [StringFilter]?
        /// The protocol of network-related information about a finding.
        public let networkProtocol: [StringFilter]?
        /// The source domain of network-related information about a finding.
        public let networkSourceDomain: [StringFilter]?
        /// The source IPv4 address of network-related information about a finding.
        public let networkSourceIpV4: [IpFilter]?
        /// The source IPv6 address of network-related information about a finding.
        public let networkSourceIpV6: [IpFilter]?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let networkSourceMac: [StringFilter]?
        /// The source port of network-related information about a finding.
        public let networkSourcePort: [NumberFilter]?
        /// The text of a note.
        public let noteText: [StringFilter]?
        /// The timestamp of when the note was updated.
        public let noteUpdatedAt: [DateFilter]?
        /// The principal that created a note.
        public let noteUpdatedBy: [StringFilter]?
        /// The date/time that the process was launched.
        public let processLaunchedAt: [DateFilter]?
        /// The name of the process.
        public let processName: [StringFilter]?
        /// The parent process ID.
        public let processParentPid: [NumberFilter]?
        /// The path to the process executable.
        public let processPath: [StringFilter]?
        /// The process ID.
        public let processPid: [NumberFilter]?
        /// The date/time that the process was terminated.
        public let processTerminatedAt: [DateFilter]?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.
        public let productArn: [StringFilter]?
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public let productFields: [MapFilter]?
        /// The name of the solution (product) that generates findings.
        public let productName: [StringFilter]?
        /// The recommendation of what to do about the issue described in a finding.
        public let recommendationText: [StringFilter]?
        /// The updated record state for the finding.
        public let recordState: [StringFilter]?
        /// The solution-generated identifier for a related finding.
        public let relatedFindingsId: [StringFilter]?
        /// The ARN of the solution that generated a related finding.
        public let relatedFindingsProductArn: [StringFilter]?
        /// The IAM profile ARN of the instance.
        public let resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let resourceAwsEc2InstanceImageId: [StringFilter]?
        /// The IPv4 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV4Addresses: [IpFilter]?
        /// The IPv6 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV6Addresses: [IpFilter]?
        /// The key name associated with the instance.
        public let resourceAwsEc2InstanceKeyName: [StringFilter]?
        /// The date/time the instance was launched.
        public let resourceAwsEc2InstanceLaunchedAt: [DateFilter]?
        /// The identifier of the subnet that the instance was launched in.
        public let resourceAwsEc2InstanceSubnetId: [StringFilter]?
        /// The instance type of the instance.
        public let resourceAwsEc2InstanceType: [StringFilter]?
        /// The identifier of the VPC that the instance was launched in.
        public let resourceAwsEc2InstanceVpcId: [StringFilter]?
        /// The creation date/time of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyCreatedAt: [DateFilter]?
        /// The status of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyStatus: [StringFilter]?
        /// The user associated with the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyUserName: [StringFilter]?
        /// The canonical user ID of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerId: [StringFilter]?
        /// The display name of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerName: [StringFilter]?
        /// The identifier of the image related to a finding.
        public let resourceContainerImageId: [StringFilter]?
        /// The name of the image related to a finding.
        public let resourceContainerImageName: [StringFilter]?
        /// The date/time that the container was started.
        public let resourceContainerLaunchedAt: [DateFilter]?
        /// The name of the container related to a finding.
        public let resourceContainerName: [StringFilter]?
        /// The details of a resource that doesn't have a specific subfield for the resource type defined.
        public let resourceDetailsOther: [MapFilter]?
        /// The canonical identifier for the given resource type.
        public let resourceId: [StringFilter]?
        /// The canonical AWS partition name that the Region is assigned to.
        public let resourcePartition: [StringFilter]?
        /// The canonical AWS external Region name where this resource is located.
        public let resourceRegion: [StringFilter]?
        /// A list of AWS tags associated with a resource at the time the finding was processed.
        public let resourceTags: [MapFilter]?
        /// Specifies the type of the resource that details are provided for.
        public let resourceType: [StringFilter]?
        /// The label of a finding's severity.
        public let severityLabel: [StringFilter]?
        /// The normalized severity of a finding.
        public let severityNormalized: [NumberFilter]?
        /// The native severity as defined by the security-findings provider's solution that generated the finding.
        public let severityProduct: [NumberFilter]?
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public let sourceUrl: [StringFilter]?
        /// The category of a threat intel indicator.
        public let threatIntelIndicatorCategory: [StringFilter]?
        /// The date/time of the last observation of a threat intel indicator.
        public let threatIntelIndicatorLastObservedAt: [DateFilter]?
        /// The source of the threat intel.
        public let threatIntelIndicatorSource: [StringFilter]?
        /// The URL for more details from the source of the threat intel.
        public let threatIntelIndicatorSourceUrl: [StringFilter]?
        /// The type of a threat intel indicator.
        public let threatIntelIndicatorType: [StringFilter]?
        /// The value of a threat intel indicator.
        public let threatIntelIndicatorValue: [StringFilter]?
        /// A finding's title.
        public let title: [StringFilter]?
        /// A finding type in the format of namespace/category/classifier that classifies a finding.
        public let `type`: [StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. 
        public let updatedAt: [DateFilter]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. 
        public let userDefinedFields: [MapFilter]?
        /// The veracity of a finding.
        public let verificationState: [StringFilter]?
        /// The workflow state of a finding.
        public let workflowState: [StringFilter]?

        public init(awsAccountId: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, keyword: [KeywordFilter]? = nil, lastObservedAt: [DateFilter]? = nil, malwareName: [StringFilter]? = nil, malwarePath: [StringFilter]? = nil, malwareState: [StringFilter]? = nil, malwareType: [StringFilter]? = nil, networkDestinationDomain: [StringFilter]? = nil, networkDestinationIpV4: [IpFilter]? = nil, networkDestinationIpV6: [IpFilter]? = nil, networkDestinationPort: [NumberFilter]? = nil, networkDirection: [StringFilter]? = nil, networkProtocol: [StringFilter]? = nil, networkSourceDomain: [StringFilter]? = nil, networkSourceIpV4: [IpFilter]? = nil, networkSourceIpV6: [IpFilter]? = nil, networkSourceMac: [StringFilter]? = nil, networkSourcePort: [NumberFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, processLaunchedAt: [DateFilter]? = nil, processName: [StringFilter]? = nil, processParentPid: [NumberFilter]? = nil, processPath: [StringFilter]? = nil, processPid: [NumberFilter]? = nil, processTerminatedAt: [DateFilter]? = nil, productArn: [StringFilter]? = nil, productFields: [MapFilter]? = nil, productName: [StringFilter]? = nil, recommendationText: [StringFilter]? = nil, recordState: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil, resourceAwsEc2InstanceImageId: [StringFilter]? = nil, resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceKeyName: [StringFilter]? = nil, resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil, resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil, resourceAwsEc2InstanceType: [StringFilter]? = nil, resourceAwsEc2InstanceVpcId: [StringFilter]? = nil, resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil, resourceAwsIamAccessKeyStatus: [StringFilter]? = nil, resourceAwsIamAccessKeyUserName: [StringFilter]? = nil, resourceAwsS3BucketOwnerId: [StringFilter]? = nil, resourceAwsS3BucketOwnerName: [StringFilter]? = nil, resourceContainerImageId: [StringFilter]? = nil, resourceContainerImageName: [StringFilter]? = nil, resourceContainerLaunchedAt: [DateFilter]? = nil, resourceContainerName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, severityLabel: [StringFilter]? = nil, severityNormalized: [NumberFilter]? = nil, severityProduct: [NumberFilter]? = nil, sourceUrl: [StringFilter]? = nil, threatIntelIndicatorCategory: [StringFilter]? = nil, threatIntelIndicatorLastObservedAt: [DateFilter]? = nil, threatIntelIndicatorSource: [StringFilter]? = nil, threatIntelIndicatorSourceUrl: [StringFilter]? = nil, threatIntelIndicatorType: [StringFilter]? = nil, threatIntelIndicatorValue: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, workflowState: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = keyword
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severityLabel = severityLabel
            self.severityNormalized = severityNormalized
            self.severityProduct = severityProduct
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.`type` = `type`
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowState = workflowState
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.companyName?.forEach {
                try $0.validate(name: "\(name).companyName[]")
            }
            try self.complianceStatus?.forEach {
                try $0.validate(name: "\(name).complianceStatus[]")
            }
            try self.createdAt?.forEach {
                try $0.validate(name: "\(name).createdAt[]")
            }
            try self.description?.forEach {
                try $0.validate(name: "\(name).description[]")
            }
            try self.firstObservedAt?.forEach {
                try $0.validate(name: "\(name).firstObservedAt[]")
            }
            try self.generatorId?.forEach {
                try $0.validate(name: "\(name).generatorId[]")
            }
            try self.id?.forEach {
                try $0.validate(name: "\(name).id[]")
            }
            try self.keyword?.forEach {
                try $0.validate(name: "\(name).keyword[]")
            }
            try self.lastObservedAt?.forEach {
                try $0.validate(name: "\(name).lastObservedAt[]")
            }
            try self.malwareName?.forEach {
                try $0.validate(name: "\(name).malwareName[]")
            }
            try self.malwarePath?.forEach {
                try $0.validate(name: "\(name).malwarePath[]")
            }
            try self.malwareState?.forEach {
                try $0.validate(name: "\(name).malwareState[]")
            }
            try self.malwareType?.forEach {
                try $0.validate(name: "\(name).malwareType[]")
            }
            try self.networkDestinationDomain?.forEach {
                try $0.validate(name: "\(name).networkDestinationDomain[]")
            }
            try self.networkDestinationIpV4?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV4[]")
            }
            try self.networkDestinationIpV6?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV6[]")
            }
            try self.networkDirection?.forEach {
                try $0.validate(name: "\(name).networkDirection[]")
            }
            try self.networkProtocol?.forEach {
                try $0.validate(name: "\(name).networkProtocol[]")
            }
            try self.networkSourceDomain?.forEach {
                try $0.validate(name: "\(name).networkSourceDomain[]")
            }
            try self.networkSourceIpV4?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV4[]")
            }
            try self.networkSourceIpV6?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV6[]")
            }
            try self.networkSourceMac?.forEach {
                try $0.validate(name: "\(name).networkSourceMac[]")
            }
            try self.noteText?.forEach {
                try $0.validate(name: "\(name).noteText[]")
            }
            try self.noteUpdatedAt?.forEach {
                try $0.validate(name: "\(name).noteUpdatedAt[]")
            }
            try self.noteUpdatedBy?.forEach {
                try $0.validate(name: "\(name).noteUpdatedBy[]")
            }
            try self.processLaunchedAt?.forEach {
                try $0.validate(name: "\(name).processLaunchedAt[]")
            }
            try self.processName?.forEach {
                try $0.validate(name: "\(name).processName[]")
            }
            try self.processPath?.forEach {
                try $0.validate(name: "\(name).processPath[]")
            }
            try self.processTerminatedAt?.forEach {
                try $0.validate(name: "\(name).processTerminatedAt[]")
            }
            try self.productArn?.forEach {
                try $0.validate(name: "\(name).productArn[]")
            }
            try self.productFields?.forEach {
                try $0.validate(name: "\(name).productFields[]")
            }
            try self.productName?.forEach {
                try $0.validate(name: "\(name).productName[]")
            }
            try self.recommendationText?.forEach {
                try $0.validate(name: "\(name).recommendationText[]")
            }
            try self.recordState?.forEach {
                try $0.validate(name: "\(name).recordState[]")
            }
            try self.relatedFindingsId?.forEach {
                try $0.validate(name: "\(name).relatedFindingsId[]")
            }
            try self.relatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).relatedFindingsProductArn[]")
            }
            try self.resourceAwsEc2InstanceIamInstanceProfileArn?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIamInstanceProfileArn[]")
            }
            try self.resourceAwsEc2InstanceImageId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceImageId[]")
            }
            try self.resourceAwsEc2InstanceIpV4Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV4Addresses[]")
            }
            try self.resourceAwsEc2InstanceIpV6Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV6Addresses[]")
            }
            try self.resourceAwsEc2InstanceKeyName?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceKeyName[]")
            }
            try self.resourceAwsEc2InstanceLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceLaunchedAt[]")
            }
            try self.resourceAwsEc2InstanceSubnetId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceSubnetId[]")
            }
            try self.resourceAwsEc2InstanceType?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceType[]")
            }
            try self.resourceAwsEc2InstanceVpcId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceVpcId[]")
            }
            try self.resourceAwsIamAccessKeyCreatedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyCreatedAt[]")
            }
            try self.resourceAwsIamAccessKeyStatus?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyStatus[]")
            }
            try self.resourceAwsIamAccessKeyUserName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyUserName[]")
            }
            try self.resourceAwsS3BucketOwnerId?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerId[]")
            }
            try self.resourceAwsS3BucketOwnerName?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerName[]")
            }
            try self.resourceContainerImageId?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageId[]")
            }
            try self.resourceContainerImageName?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageName[]")
            }
            try self.resourceContainerLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceContainerLaunchedAt[]")
            }
            try self.resourceContainerName?.forEach {
                try $0.validate(name: "\(name).resourceContainerName[]")
            }
            try self.resourceDetailsOther?.forEach {
                try $0.validate(name: "\(name).resourceDetailsOther[]")
            }
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.resourcePartition?.forEach {
                try $0.validate(name: "\(name).resourcePartition[]")
            }
            try self.resourceRegion?.forEach {
                try $0.validate(name: "\(name).resourceRegion[]")
            }
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.severityLabel?.forEach {
                try $0.validate(name: "\(name).severityLabel[]")
            }
            try self.sourceUrl?.forEach {
                try $0.validate(name: "\(name).sourceUrl[]")
            }
            try self.threatIntelIndicatorCategory?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorCategory[]")
            }
            try self.threatIntelIndicatorLastObservedAt?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorLastObservedAt[]")
            }
            try self.threatIntelIndicatorSource?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSource[]")
            }
            try self.threatIntelIndicatorSourceUrl?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSourceUrl[]")
            }
            try self.threatIntelIndicatorType?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorType[]")
            }
            try self.threatIntelIndicatorValue?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorValue[]")
            }
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.`type`?.forEach {
                try $0.validate(name: "\(name).`type`[]")
            }
            try self.updatedAt?.forEach {
                try $0.validate(name: "\(name).updatedAt[]")
            }
            try self.userDefinedFields?.forEach {
                try $0.validate(name: "\(name).userDefinedFields[]")
            }
            try self.verificationState?.forEach {
                try $0.validate(name: "\(name).verificationState[]")
            }
            try self.workflowState?.forEach {
                try $0.validate(name: "\(name).workflowState[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case companyName = "CompanyName"
            case complianceStatus = "ComplianceStatus"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case keyword = "Keyword"
            case lastObservedAt = "LastObservedAt"
            case malwareName = "MalwareName"
            case malwarePath = "MalwarePath"
            case malwareState = "MalwareState"
            case malwareType = "MalwareType"
            case networkDestinationDomain = "NetworkDestinationDomain"
            case networkDestinationIpV4 = "NetworkDestinationIpV4"
            case networkDestinationIpV6 = "NetworkDestinationIpV6"
            case networkDestinationPort = "NetworkDestinationPort"
            case networkDirection = "NetworkDirection"
            case networkProtocol = "NetworkProtocol"
            case networkSourceDomain = "NetworkSourceDomain"
            case networkSourceIpV4 = "NetworkSourceIpV4"
            case networkSourceIpV6 = "NetworkSourceIpV6"
            case networkSourceMac = "NetworkSourceMac"
            case networkSourcePort = "NetworkSourcePort"
            case noteText = "NoteText"
            case noteUpdatedAt = "NoteUpdatedAt"
            case noteUpdatedBy = "NoteUpdatedBy"
            case processLaunchedAt = "ProcessLaunchedAt"
            case processName = "ProcessName"
            case processParentPid = "ProcessParentPid"
            case processPath = "ProcessPath"
            case processPid = "ProcessPid"
            case processTerminatedAt = "ProcessTerminatedAt"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case productName = "ProductName"
            case recommendationText = "RecommendationText"
            case recordState = "RecordState"
            case relatedFindingsId = "RelatedFindingsId"
            case relatedFindingsProductArn = "RelatedFindingsProductArn"
            case resourceAwsEc2InstanceIamInstanceProfileArn = "ResourceAwsEc2InstanceIamInstanceProfileArn"
            case resourceAwsEc2InstanceImageId = "ResourceAwsEc2InstanceImageId"
            case resourceAwsEc2InstanceIpV4Addresses = "ResourceAwsEc2InstanceIpV4Addresses"
            case resourceAwsEc2InstanceIpV6Addresses = "ResourceAwsEc2InstanceIpV6Addresses"
            case resourceAwsEc2InstanceKeyName = "ResourceAwsEc2InstanceKeyName"
            case resourceAwsEc2InstanceLaunchedAt = "ResourceAwsEc2InstanceLaunchedAt"
            case resourceAwsEc2InstanceSubnetId = "ResourceAwsEc2InstanceSubnetId"
            case resourceAwsEc2InstanceType = "ResourceAwsEc2InstanceType"
            case resourceAwsEc2InstanceVpcId = "ResourceAwsEc2InstanceVpcId"
            case resourceAwsIamAccessKeyCreatedAt = "ResourceAwsIamAccessKeyCreatedAt"
            case resourceAwsIamAccessKeyStatus = "ResourceAwsIamAccessKeyStatus"
            case resourceAwsIamAccessKeyUserName = "ResourceAwsIamAccessKeyUserName"
            case resourceAwsS3BucketOwnerId = "ResourceAwsS3BucketOwnerId"
            case resourceAwsS3BucketOwnerName = "ResourceAwsS3BucketOwnerName"
            case resourceContainerImageId = "ResourceContainerImageId"
            case resourceContainerImageName = "ResourceContainerImageName"
            case resourceContainerLaunchedAt = "ResourceContainerLaunchedAt"
            case resourceContainerName = "ResourceContainerName"
            case resourceDetailsOther = "ResourceDetailsOther"
            case resourceId = "ResourceId"
            case resourcePartition = "ResourcePartition"
            case resourceRegion = "ResourceRegion"
            case resourceTags = "ResourceTags"
            case resourceType = "ResourceType"
            case severityLabel = "SeverityLabel"
            case severityNormalized = "SeverityNormalized"
            case severityProduct = "SeverityProduct"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicatorCategory = "ThreatIntelIndicatorCategory"
            case threatIntelIndicatorLastObservedAt = "ThreatIntelIndicatorLastObservedAt"
            case threatIntelIndicatorSource = "ThreatIntelIndicatorSource"
            case threatIntelIndicatorSourceUrl = "ThreatIntelIndicatorSourceUrl"
            case threatIntelIndicatorType = "ThreatIntelIndicatorType"
            case threatIntelIndicatorValue = "ThreatIntelIndicatorValue"
            case title = "Title"
            case `type` = "Type"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflowState = "WorkflowState"
        }
    }

    public struct AwsSnsTopicDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KmsMasterKeyId", required: false, type: .string), 
            AWSShapeMember(label: "Owner", required: false, type: .string), 
            AWSShapeMember(label: "Subscription", required: false, type: .list), 
            AWSShapeMember(label: "TopicName", required: false, type: .string)
        ]

        /// The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.
        public let kmsMasterKeyId: String?
        /// The subscription's owner.
        public let owner: String?
        /// Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
        public let subscription: [AwsSnsTopicSubscription]?
        /// The name of the topic.
        public let topicName: String?

        public init(kmsMasterKeyId: String? = nil, owner: String? = nil, subscription: [AwsSnsTopicSubscription]? = nil, topicName: String? = nil) {
            self.kmsMasterKeyId = kmsMasterKeyId
            self.owner = owner
            self.subscription = subscription
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try validate(self.kmsMasterKeyId, name:"kmsMasterKeyId", parent: name, pattern: ".*\\S.*")
            try validate(self.owner, name:"owner", parent: name, pattern: ".*\\S.*")
            try self.subscription?.forEach {
                try $0.validate(name: "\(name).subscription[]")
            }
            try validate(self.topicName, name:"topicName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsMasterKeyId = "KmsMasterKeyId"
            case owner = "Owner"
            case subscription = "Subscription"
            case topicName = "TopicName"
        }
    }

    public struct AwsSnsTopicSubscription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .string), 
            AWSShapeMember(label: "Protocol", required: false, type: .string)
        ]

        /// The subscription's endpoint (format depends on the protocol).
        public let endpoint: String?
        /// The subscription's protocol.
        public let `protocol`: String?

        public init(endpoint: String? = nil, protocol: String? = nil) {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.endpoint, name:"endpoint", parent: name, pattern: ".*\\S.*")
            try validate(self.`protocol`, name:"`protocol`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsSqsQueueDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeadLetterTargetArn", required: false, type: .string), 
            AWSShapeMember(label: "KmsDataKeyReusePeriodSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "KmsMasterKeyId", required: false, type: .string), 
            AWSShapeMember(label: "QueueName", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded. 
        public let deadLetterTargetArn: String?
        /// The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
        public let kmsDataKeyReusePeriodSeconds: Int?
        /// The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.
        public let kmsMasterKeyId: String?
        /// The name of the new queue.
        public let queueName: String?

        public init(deadLetterTargetArn: String? = nil, kmsDataKeyReusePeriodSeconds: Int? = nil, kmsMasterKeyId: String? = nil, queueName: String? = nil) {
            self.deadLetterTargetArn = deadLetterTargetArn
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsMasterKeyId = kmsMasterKeyId
            self.queueName = queueName
        }

        public func validate(name: String) throws {
            try validate(self.deadLetterTargetArn, name:"deadLetterTargetArn", parent: name, pattern: ".*\\S.*")
            try validate(self.kmsMasterKeyId, name:"kmsMasterKeyId", parent: name, pattern: ".*\\S.*")
            try validate(self.queueName, name:"queueName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterTargetArn = "DeadLetterTargetArn"
            case kmsDataKeyReusePeriodSeconds = "KmsDataKeyReusePeriodSeconds"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case queueName = "QueueName"
        }
    }

    public struct BatchDisableStandardsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StandardsSubscriptionArns", required: true, type: .list)
        ]

        /// The ARNs of the standards subscriptions to disable.
        public let standardsSubscriptionArns: [String]

        public init(standardsSubscriptionArns: [String]) {
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionArns.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.standardsSubscriptionArns, name:"standardsSubscriptionArns", parent: name, max: 25)
            try validate(self.standardsSubscriptionArns, name:"standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct BatchDisableStandardsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StandardsSubscriptions", required: false, type: .list)
        ]

        /// The details of the standards subscriptions that were disabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchEnableStandardsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StandardsSubscriptionRequests", required: true, type: .list)
        ]

        /// The list of standards compliance checks to enable.  In this release, Security Hub supports only the CIS AWS Foundations standard. The ARN for the standard is arn:aws:securityhub:::ruleset/cis-aws-foundations-benchmark/v/1.2.0. 
        public let standardsSubscriptionRequests: [StandardsSubscriptionRequest]

        public init(standardsSubscriptionRequests: [StandardsSubscriptionRequest]) {
            self.standardsSubscriptionRequests = standardsSubscriptionRequests
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionRequests.forEach {
                try $0.validate(name: "\(name).standardsSubscriptionRequests[]")
            }
            try validate(self.standardsSubscriptionRequests, name:"standardsSubscriptionRequests", parent: name, max: 25)
            try validate(self.standardsSubscriptionRequests, name:"standardsSubscriptionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
        }
    }

    public struct BatchEnableStandardsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StandardsSubscriptions", required: false, type: .list)
        ]

        /// The details of the standards subscriptions that were enabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchImportFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Findings", required: true, type: .list)
        ]

        /// A list of findings to import. To successfully import a finding, it must follow the AWS Security Finding Format. Maximum of 100 findings per request.
        public let findings: [AwsSecurityFinding]

        public init(findings: [AwsSecurityFinding]) {
            self.findings = findings
        }

        public func validate(name: String) throws {
            try self.findings.forEach {
                try $0.validate(name: "\(name).findings[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
        }
    }

    public struct BatchImportFindingsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedCount", required: true, type: .integer), 
            AWSShapeMember(label: "FailedFindings", required: false, type: .list), 
            AWSShapeMember(label: "SuccessCount", required: true, type: .integer)
        ]

        /// The number of findings that failed to import.
        public let failedCount: Int
        /// The list of the findings that failed to import.
        public let failedFindings: [ImportFindingsError]?
        /// The number of findings that were successfully imported.
        public let successCount: Int

        public init(failedCount: Int, failedFindings: [ImportFindingsError]? = nil, successCount: Int) {
            self.failedCount = failedCount
            self.failedFindings = failedFindings
            self.successCount = successCount
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "FailedCount"
            case failedFindings = "FailedFindings"
            case successCount = "SuccessCount"
        }
    }

    public struct Compliance: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// The result of a compliance check.
        public let status: ComplianceStatus?

        public init(status: ComplianceStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public enum ComplianceStatus: String, CustomStringConvertible, Codable {
        case passed = "PASSED"
        case warning = "WARNING"
        case failed = "FAILED"
        case notAvailable = "NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public struct ContainerDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImageId", required: false, type: .string), 
            AWSShapeMember(label: "ImageName", required: false, type: .string), 
            AWSShapeMember(label: "LaunchedAt", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The identifier of the image related to a finding.
        public let imageId: String?
        /// The name of the image related to a finding.
        public let imageName: String?
        /// The date and time when the container started.
        public let launchedAt: String?
        /// The name of the container related to a finding.
        public let name: String?

        public init(imageId: String? = nil, imageName: String? = nil, launchedAt: String? = nil, name: String? = nil) {
            self.imageId = imageId
            self.imageName = imageName
            self.launchedAt = launchedAt
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.imageId, name:"imageId", parent: name, pattern: ".*\\S.*")
            try validate(self.imageName, name:"imageName", parent: name, pattern: ".*\\S.*")
            try validate(self.launchedAt, name:"launchedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "ImageId"
            case imageName = "ImageName"
            case launchedAt = "LaunchedAt"
            case name = "Name"
        }
    }

    public enum ControlStatus: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct CreateActionTargetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", required: true, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The description for the custom action target.
        public let description: String
        /// The ID for the custom action target.
        public let id: String
        /// The name of the custom action target.
        public let name: String

        public init(description: String, id: String, name: String) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.description, name:"description", parent: name, pattern: ".*\\S.*")
            try validate(self.id, name:"id", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct CreateActionTargetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargetArn", required: true, type: .string)
        ]

        /// The ARN for the custom action target.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct CreateInsightRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: true, type: .structure), 
            AWSShapeMember(label: "GroupByAttribute", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// One or more attributes used to filter the findings included in the insight. Only findings that match the criteria defined in the filters are included in the insight.
        public let filters: AwsSecurityFindingFilters
        /// The attribute used as the aggregator to group related findings for the insight.
        public let groupByAttribute: String
        /// The name of the custom insight to create.
        public let name: String

        public init(filters: AwsSecurityFindingFilters, groupByAttribute: String, name: String) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try validate(self.groupByAttribute, name:"groupByAttribute", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct CreateInsightResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightArn", required: true, type: .string)
        ]

        /// The ARN of the insight created.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct CreateMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountDetails", required: false, type: .list)
        ]

        /// A list of account ID and email address pairs of the accounts to associate with the Security Hub master account.
        public let accountDetails: [AccountDetails]?

        public init(accountDetails: [AccountDetails]? = nil) {
            self.accountDetails = accountDetails
        }

        public func validate(name: String) throws {
            try self.accountDetails?.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails = "AccountDetails"
        }
    }

    public struct CreateMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", required: false, type: .list)
        ]

        /// A list of account ID and email address pairs of the AWS accounts that weren't processed.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DateFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DateRange", required: false, type: .structure), 
            AWSShapeMember(label: "End", required: false, type: .string), 
            AWSShapeMember(label: "Start", required: false, type: .string)
        ]

        /// A date range for the date filter.
        public let dateRange: DateRange?
        /// An end date for the date filter.
        public let end: String?
        /// A start date for the date filter.
        public let start: String?

        public init(dateRange: DateRange? = nil, end: String? = nil, start: String? = nil) {
            self.dateRange = dateRange
            self.end = end
            self.start = start
        }

        public func validate(name: String) throws {
            try validate(self.end, name:"end", parent: name, pattern: ".*\\S.*")
            try validate(self.start, name:"start", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case dateRange = "DateRange"
            case end = "End"
            case start = "Start"
        }
    }

    public struct DateRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Unit", required: false, type: .enum), 
            AWSShapeMember(label: "Value", required: false, type: .integer)
        ]

        /// A date range unit for the date filter.
        public let unit: DateRangeUnit?
        /// A date range value for the date filter.
        public let value: Int?

        public init(unit: DateRangeUnit? = nil, value: Int? = nil) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public enum DateRangeUnit: String, CustomStringConvertible, Codable {
        case days = "DAYS"
        public var description: String { return self.rawValue }
    }

    public struct DeclineInvitationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", required: true, type: .list)
        ]

        /// A list of account IDs that specify the accounts that invitations to Security Hub are declined from.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", required: false, type: .list)
        ]

        /// A list of account ID and email address pairs of the AWS accounts that weren't processed.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteActionTargetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargetArn", location: .uri(locationName: "ActionTargetArn"), required: true, type: .string)
        ]

        /// The ARN of the custom action target to delete.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        public func validate(name: String) throws {
            try validate(self.actionTargetArn, name:"actionTargetArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct DeleteActionTargetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargetArn", required: true, type: .string)
        ]

        /// The ARN of the custom action target that was deleted.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct DeleteInsightRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightArn", location: .uri(locationName: "InsightArn"), required: true, type: .string)
        ]

        /// The ARN of the insight to delete.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func validate(name: String) throws {
            try validate(self.insightArn, name:"insightArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct DeleteInsightResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightArn", required: true, type: .string)
        ]

        /// The ARN of the insight that was deleted.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct DeleteInvitationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", required: true, type: .list)
        ]

        /// A list of the account IDs that sent the invitations to delete.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", required: false, type: .list)
        ]

        /// A list of account ID and email address pairs of the AWS accounts that invitations weren't deleted for.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", required: false, type: .list)
        ]

        /// A list of account IDs of the member accounts to delete.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", required: false, type: .list)
        ]

        /// A list of account ID and email address pairs of the AWS accounts that weren't deleted.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DescribeActionTargetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargetArns", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of custom action target ARNs for the custom action targets to retrieve.
        public let actionTargetArns: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(actionTargetArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.actionTargetArns = actionTargetArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.actionTargetArns?.forEach {
                try validate($0, name: "actionTargetArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArns = "ActionTargetArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeActionTargetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargets", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of ActionTarget objects. Each object includes the ActionTargetArn, Description, and Name of a custom action target available in Security Hub.
        public let actionTargets: [ActionTarget]
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(actionTargets: [ActionTarget], nextToken: String? = nil) {
            self.actionTargets = actionTargets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargets = "ActionTargets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeHubRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HubArn", location: .querystring(locationName: "HubArn"), required: false, type: .string)
        ]

        /// The ARN of the Hub resource to retrieve.
        public let hubArn: String?

        public init(hubArn: String? = nil) {
            self.hubArn = hubArn
        }

        public func validate(name: String) throws {
            try validate(self.hubArn, name:"hubArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case hubArn = "HubArn"
        }
    }

    public struct DescribeHubResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HubArn", required: false, type: .string), 
            AWSShapeMember(label: "SubscribedAt", required: false, type: .string)
        ]

        /// The ARN of the Hub resource retrieved.
        public let hubArn: String?
        /// The date and time when Security Hub was enabled in the account.
        public let subscribedAt: String?

        public init(hubArn: String? = nil, subscribedAt: String? = nil) {
            self.hubArn = hubArn
            self.subscribedAt = subscribedAt
        }

        private enum CodingKeys: String, CodingKey {
            case hubArn = "HubArn"
            case subscribedAt = "SubscribedAt"
        }
    }

    public struct DescribeProductsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "MaxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "NextToken"), required: false, type: .string)
        ]

        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeProductsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Products", required: true, type: .list)
        ]

        /// The token that is required for pagination.
        public let nextToken: String?
        /// A list of products, including details for each product.
        public let products: [Product]

        public init(nextToken: String? = nil, products: [Product]) {
            self.nextToken = nextToken
            self.products = products
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case products = "Products"
        }
    }

    public struct DescribeStandardsControlsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "MaxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "NextToken"), required: false, type: .string), 
            AWSShapeMember(label: "StandardsSubscriptionArn", location: .uri(locationName: "StandardsSubscriptionArn"), required: true, type: .string)
        ]

        /// The maximum number of compliance standard controls to return.
        public let maxResults: Int?
        /// For requests to get the next page of results, the pagination token that was returned with the previous set of results. The initial request does not include a pagination token.
        public let nextToken: String?
        /// The ARN of a resource that represents your subscription to a supported standard.
        public let standardsSubscriptionArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.standardsSubscriptionArn, name:"standardsSubscriptionArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case standardsSubscriptionArn = "StandardsSubscriptionArn"
        }
    }

    public struct DescribeStandardsControlsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Controls", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of compliance standards controls.
        public let controls: [StandardsControl]?
        /// If there are more compliance standards control remaining in the results, then this is the pagination token to use to request the next page of compliance standard controls.
        public let nextToken: String?

        public init(controls: [StandardsControl]? = nil, nextToken: String? = nil) {
            self.controls = controls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "Controls"
            case nextToken = "NextToken"
        }
    }

    public struct DisableImportFindingsForProductRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProductSubscriptionArn", location: .uri(locationName: "ProductSubscriptionArn"), required: true, type: .string)
        ]

        /// The ARN of the integrated product to disable the integration for.
        public let productSubscriptionArn: String

        public init(productSubscriptionArn: String) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        public func validate(name: String) throws {
            try validate(self.productSubscriptionArn, name:"productSubscriptionArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case productSubscriptionArn = "ProductSubscriptionArn"
        }
    }

    public struct DisableImportFindingsForProductResponse: AWSShape {


        public init() {
        }

    }

    public struct DisableSecurityHubRequest: AWSShape {


        public init() {
        }

    }

    public struct DisableSecurityHubResponse: AWSShape {


        public init() {
        }

    }

    public struct DisassociateFromMasterAccountRequest: AWSShape {


        public init() {
        }

    }

    public struct DisassociateFromMasterAccountResponse: AWSShape {


        public init() {
        }

    }

    public struct DisassociateMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", required: false, type: .list)
        ]

        /// The account IDs of the member accounts to disassociate from the master account.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DisassociateMembersResponse: AWSShape {


        public init() {
        }

    }

    public struct EnableImportFindingsForProductRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProductArn", required: true, type: .string)
        ]

        /// The ARN of the product to enable the integration for.
        public let productArn: String

        public init(productArn: String) {
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try validate(self.productArn, name:"productArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case productArn = "ProductArn"
        }
    }

    public struct EnableImportFindingsForProductResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProductSubscriptionArn", required: false, type: .string)
        ]

        /// The ARN of your subscription to the product to enable integrations for.
        public let productSubscriptionArn: String?

        public init(productSubscriptionArn: String? = nil) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case productSubscriptionArn = "ProductSubscriptionArn"
        }
    }

    public struct EnableSecurityHubRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// The tags to add to the Hub resource when you enable Security Hub.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct EnableSecurityHubResponse: AWSShape {


        public init() {
        }

    }

    public struct GetEnabledStandardsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StandardsSubscriptionArns", required: false, type: .list)
        ]

        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// Paginates results. On your first call to the GetEnabledStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// A list of the standards subscription ARNs for the standards to retrieve.
        public let standardsSubscriptionArns: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArns: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try self.standardsSubscriptionArns?.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.standardsSubscriptionArns, name:"standardsSubscriptionArns", parent: name, max: 25)
            try validate(self.standardsSubscriptionArns, name:"standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct GetEnabledStandardsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StandardsSubscriptions", required: false, type: .list)
        ]

        /// The token that is required for pagination.
        public let nextToken: String?
        /// A list of StandardsSubscriptions objects that include information about the enabled standards.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(nextToken: String? = nil, standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.nextToken = nextToken
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct GetFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .structure), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SortCriteria", required: false, type: .list)
        ]

        /// The findings attributes used to define a condition to filter the findings returned.
        public let filters: AwsSecurityFindingFilters?
        /// The maximum number of findings to return.
        public let maxResults: Int?
        /// Paginates results. On your first call to the GetFindings operation, set the value of this parameter to NULL. For subsequent calls to the operation, fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
        public let nextToken: String?
        /// Findings attributes used to sort the list of findings returned.
        public let sortCriteria: [SortCriterion]?

        public init(filters: AwsSecurityFindingFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [SortCriterion]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Findings", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The findings that matched the filters specified in the request.
        public let findings: [AwsSecurityFinding]
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(findings: [AwsSecurityFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightResultsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightArn", location: .uri(locationName: "InsightArn"), required: true, type: .string)
        ]

        /// The ARN of the insight whose results you want to see.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func validate(name: String) throws {
            try validate(self.insightArn, name:"insightArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct GetInsightResultsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightResults", required: true, type: .structure)
        ]

        /// The insight results returned by the operation.
        public let insightResults: InsightResults

        public init(insightResults: InsightResults) {
            self.insightResults = insightResults
        }

        private enum CodingKeys: String, CodingKey {
            case insightResults = "InsightResults"
        }
    }

    public struct GetInsightsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightArns", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The ARNs of the insights that you want to describe.
        public let insightArns: [String]?
        /// The maximum number of items that you want in the response.
        public let maxResults: Int?
        /// Paginates results. On your first call to the GetInsights operation, set the value of this parameter to NULL. For subsequent calls to the operation, fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(insightArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightArns = insightArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.insightArns?.forEach {
                try validate($0, name: "insightArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case insightArns = "InsightArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Insights", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The insights returned by the operation.
        public let insights: [Insight]
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(insights: [Insight], nextToken: String? = nil) {
            self.insights = insights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insights = "Insights"
            case nextToken = "NextToken"
        }
    }

    public struct GetInvitationsCountRequest: AWSShape {


        public init() {
        }

    }

    public struct GetInvitationsCountResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InvitationsCount", required: false, type: .integer)
        ]

        /// The number of all membership invitations sent to this Security Hub member account, not including the currently accepted invitation. 
        public let invitationsCount: Int?

        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "InvitationsCount"
        }
    }

    public struct GetMasterAccountRequest: AWSShape {


        public init() {
        }

    }

    public struct GetMasterAccountResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Master", required: false, type: .structure)
        ]

        /// A list of details about the Security Hub master account for the current member account. 
        public let master: Invitation?

        public init(master: Invitation? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "Master"
        }
    }

    public struct GetMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", required: true, type: .list)
        ]

        /// A list of account IDs for the Security Hub member accounts that you want to return the details for. 
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct GetMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Members", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedAccounts", required: false, type: .list)
        ]

        /// A list of details about the Security Hub member accounts.
        public let members: [Member]?
        /// A list of account ID and email address pairs of the AWS accounts that couldn't be processed.
        public let unprocessedAccounts: [Result]?

        public init(members: [Member]? = nil, unprocessedAccounts: [Result]? = nil) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct ImportFindingsError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: true, type: .string), 
            AWSShapeMember(label: "ErrorMessage", required: true, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string)
        ]

        /// The code of the error made during the BatchImportFindings operation.
        public let errorCode: String
        /// The message of the error made during the BatchImportFindings operation.
        public let errorMessage: String
        /// The ID of the error made during the BatchImportFindings operation.
        public let id: String

        public init(errorCode: String, errorMessage: String, id: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case id = "Id"
        }
    }

    public struct Insight: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: true, type: .structure), 
            AWSShapeMember(label: "GroupByAttribute", required: true, type: .string), 
            AWSShapeMember(label: "InsightArn", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// One or more attributes used to filter the findings included in the insight. Only findings that match the criteria defined in the filters are included in the insight.
        public let filters: AwsSecurityFindingFilters
        /// The attribute that the insight's findings are grouped by. This attribute is used as a findings aggregator for the purposes of viewing and managing multiple related findings under a single operand.
        public let groupByAttribute: String
        /// The ARN of a Security Hub insight.
        public let insightArn: String
        /// The name of a Security Hub insight.
        public let name: String

        public init(filters: AwsSecurityFindingFilters, groupByAttribute: String, insightArn: String, name: String) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case name = "Name"
        }
    }

    public struct InsightResultValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Count", required: true, type: .integer), 
            AWSShapeMember(label: "GroupByAttributeValue", required: true, type: .string)
        ]

        /// The number of findings returned for each GroupByAttributeValue.
        public let count: Int
        /// The value of the attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttributeValue: String

        public init(count: Int, groupByAttributeValue: String) {
            self.count = count
            self.groupByAttributeValue = groupByAttributeValue
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case groupByAttributeValue = "GroupByAttributeValue"
        }
    }

    public struct InsightResults: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupByAttribute", required: true, type: .string), 
            AWSShapeMember(label: "InsightArn", required: true, type: .string), 
            AWSShapeMember(label: "ResultValues", required: true, type: .list)
        ]

        /// The attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttribute: String
        /// The ARN of the insight whose results are returned by the GetInsightResults operation.
        public let insightArn: String
        /// The list of insight result values returned by the GetInsightResults operation.
        public let resultValues: [InsightResultValue]

        public init(groupByAttribute: String, insightArn: String, resultValues: [InsightResultValue]) {
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.resultValues = resultValues
        }

        private enum CodingKeys: String, CodingKey {
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case resultValues = "ResultValues"
        }
    }

    public struct Invitation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "InvitationId", required: false, type: .string), 
            AWSShapeMember(label: "InvitedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "MemberStatus", required: false, type: .string)
        ]

        /// The account ID of the Security Hub master account that the invitation was sent from.
        public let accountId: String?
        /// The ID of the invitation sent to the member account.
        public let invitationId: String?
        /// The timestamp of when the invitation was sent.
        public let invitedAt: TimeStamp?
        /// The current status of the association between member and master accounts.
        public let memberStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: TimeStamp? = nil, memberStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.memberStatus = memberStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case invitationId = "InvitationId"
            case invitedAt = "InvitedAt"
            case memberStatus = "MemberStatus"
        }
    }

    public struct InviteMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountIds", required: false, type: .list)
        ]

        /// A list of IDs of the AWS accounts that you want to invite to Security Hub as members. 
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct InviteMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedAccounts", required: false, type: .list)
        ]

        /// A list of account ID and email address pairs of the AWS accounts that couldn't be processed. 
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct IpFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Cidr", required: false, type: .string)
        ]

        /// A finding's CIDR value.
        public let cidr: String?

        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try validate(self.cidr, name:"cidr", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct KeywordFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// A value for the keyword.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name:"value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct ListEnabledProductsForImportRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "MaxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "NextToken"), required: false, type: .string)
        ]

        /// The maximum number of items that you want in the response.
        public let maxResults: Int?
        /// Paginates results. On your first call to the ListEnabledProductsForImport operation, set the value of this parameter to NULL. For subsequent calls to the operation, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEnabledProductsForImportResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ProductSubscriptions", required: false, type: .list)
        ]

        /// The token that is required for pagination.
        public let nextToken: String?
        /// A list of ARNs for the resources that represent your subscriptions to products. 
        public let productSubscriptions: [String]?

        public init(nextToken: String? = nil, productSubscriptions: [String]? = nil) {
            self.nextToken = nextToken
            self.productSubscriptions = productSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case productSubscriptions = "ProductSubscriptions"
        }
    }

    public struct ListInvitationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "MaxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "NextToken"), required: false, type: .string)
        ]

        /// The maximum number of items that you want in the response. 
        public let maxResults: Int?
        /// Paginates results. On your first call to the ListInvitations operation, set the value of this parameter to NULL. For subsequent calls to the operation, fill nextToken in the request with the value of NextToken from the previous response to continue listing data. 
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListInvitationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Invitations", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The details of the invitations returned by the operation.
        public let invitations: [Invitation]?
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "MaxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "NextToken"), required: false, type: .string), 
            AWSShapeMember(label: "OnlyAssociated", location: .querystring(locationName: "OnlyAssociated"), required: false, type: .boolean)
        ]

        /// The maximum number of items that you want in the response. 
        public let maxResults: Int?
        /// Paginates results. Set the value of this parameter to NULL on your first call to the ListMembers operation. For subsequent calls to the operation, fill nextToken in the request with the value of nextToken from the previous response to continue listing data. 
        public let nextToken: String?
        /// Specifies which member accounts the response includes based on their relationship status with the master account. The default value is TRUE. If onlyAssociated is set to TRUE, the response includes member accounts whose relationship status with the master is set to ENABLED or DISABLED. If onlyAssociated is set to FALSE, the response includes all existing member accounts. 
        public let onlyAssociated: Bool?

        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: Bool? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case onlyAssociated = "OnlyAssociated"
        }
    }

    public struct ListMembersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Members", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Member details returned by the operation.
        public let members: [Member]?
        /// The token that is required for pagination.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "ResourceArn"), required: true, type: .string)
        ]

        /// The ARN of the resource to retrieve tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:aws:securityhub:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// The tags associated with a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LoadBalancerState: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", required: false, type: .string), 
            AWSShapeMember(label: "Reason", required: false, type: .string)
        ]

        /// The state code. The initial state of the load balancer is provisioning. After the load balancer is fully set up and ready to route traffic, its state is active. If the load balancer could not be set up, its state is failed. 
        public let code: String?
        /// A description of the state.
        public let reason: String?

        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        public func validate(name: String) throws {
            try validate(self.code, name:"code", parent: name, pattern: ".*\\S.*")
            try validate(self.reason, name:"reason", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case reason = "Reason"
        }
    }

    public struct Malware: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Path", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]

        /// The name of the malware that was observed.
        public let name: String
        /// The file system path of the malware that was observed.
        public let path: String?
        /// The state of the malware that was observed.
        public let state: MalwareState?
        /// The type of the malware that was observed.
        public let `type`: MalwareType?

        public init(name: String, path: String? = nil, state: MalwareState? = nil, type: MalwareType? = nil) {
            self.name = name
            self.path = path
            self.state = state
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
            try validate(self.path, name:"path", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case path = "Path"
            case state = "State"
            case `type` = "Type"
        }
    }

    public enum MalwareState: String, CustomStringConvertible, Codable {
        case observed = "OBSERVED"
        case removalFailed = "REMOVAL_FAILED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MalwareType: String, CustomStringConvertible, Codable {
        case adware = "ADWARE"
        case blendedThreat = "BLENDED_THREAT"
        case botnetAgent = "BOTNET_AGENT"
        case coinMiner = "COIN_MINER"
        case exploitKit = "EXPLOIT_KIT"
        case keylogger = "KEYLOGGER"
        case macro = "MACRO"
        case potentiallyUnwanted = "POTENTIALLY_UNWANTED"
        case spyware = "SPYWARE"
        case ransomware = "RANSOMWARE"
        case remoteAccess = "REMOTE_ACCESS"
        case rootkit = "ROOTKIT"
        case trojan = "TROJAN"
        case virus = "VIRUS"
        case worm = "WORM"
        public var description: String { return self.rawValue }
    }

    public struct MapFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Comparison", required: false, type: .enum), 
            AWSShapeMember(label: "Key", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// The condition to apply to a key value when querying for findings with a map filter.
        public let comparison: MapFilterComparison?
        /// The key of the map filter.
        public let key: String?
        /// The value for the key in the map filter.
        public let value: String?

        public init(comparison: MapFilterComparison? = nil, key: String? = nil, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, pattern: ".*\\S.*")
            try validate(self.value, name:"value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case key = "Key"
            case value = "Value"
        }
    }

    public enum MapFilterComparison: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public struct Member: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Email", required: false, type: .string), 
            AWSShapeMember(label: "InvitedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "MasterId", required: false, type: .string), 
            AWSShapeMember(label: "MemberStatus", required: false, type: .string), 
            AWSShapeMember(label: "UpdatedAt", required: false, type: .timestamp)
        ]

        /// The AWS account ID of the member account.
        public let accountId: String?
        /// The email address of the member account.
        public let email: String?
        /// A timestamp for the date and time when the invitation was sent to the member account.
        public let invitedAt: TimeStamp?
        /// The AWS account ID of the Security Hub master account associated with this member account.
        public let masterId: String?
        /// The status of the relationship between the member account and its master account. 
        public let memberStatus: String?
        /// The timestamp for the date and time when the member account was updated.
        public let updatedAt: TimeStamp?

        public init(accountId: String? = nil, email: String? = nil, invitedAt: TimeStamp? = nil, masterId: String? = nil, memberStatus: String? = nil, updatedAt: TimeStamp? = nil) {
            self.accountId = accountId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case email = "Email"
            case invitedAt = "InvitedAt"
            case masterId = "MasterId"
            case memberStatus = "MemberStatus"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Network: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationDomain", required: false, type: .string), 
            AWSShapeMember(label: "DestinationIpV4", required: false, type: .string), 
            AWSShapeMember(label: "DestinationIpV6", required: false, type: .string), 
            AWSShapeMember(label: "DestinationPort", required: false, type: .integer), 
            AWSShapeMember(label: "Direction", required: false, type: .enum), 
            AWSShapeMember(label: "Protocol", required: false, type: .string), 
            AWSShapeMember(label: "SourceDomain", required: false, type: .string), 
            AWSShapeMember(label: "SourceIpV4", required: false, type: .string), 
            AWSShapeMember(label: "SourceIpV6", required: false, type: .string), 
            AWSShapeMember(label: "SourceMac", required: false, type: .string), 
            AWSShapeMember(label: "SourcePort", required: false, type: .integer)
        ]

        /// The destination domain of network-related information about a finding.
        public let destinationDomain: String?
        /// The destination IPv4 address of network-related information about a finding.
        public let destinationIpV4: String?
        /// The destination IPv6 address of network-related information about a finding.
        public let destinationIpV6: String?
        /// The destination port of network-related information about a finding.
        public let destinationPort: Int?
        /// The direction of network traffic associated with a finding.
        public let direction: NetworkDirection?
        /// The protocol of network-related information about a finding.
        public let `protocol`: String?
        /// The source domain of network-related information about a finding.
        public let sourceDomain: String?
        /// The source IPv4 address of network-related information about a finding.
        public let sourceIpV4: String?
        /// The source IPv6 address of network-related information about a finding.
        public let sourceIpV6: String?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let sourceMac: String?
        /// The source port of network-related information about a finding.
        public let sourcePort: Int?

        public init(destinationDomain: String? = nil, destinationIpV4: String? = nil, destinationIpV6: String? = nil, destinationPort: Int? = nil, direction: NetworkDirection? = nil, protocol: String? = nil, sourceDomain: String? = nil, sourceIpV4: String? = nil, sourceIpV6: String? = nil, sourceMac: String? = nil, sourcePort: Int? = nil) {
            self.destinationDomain = destinationDomain
            self.destinationIpV4 = destinationIpV4
            self.destinationIpV6 = destinationIpV6
            self.destinationPort = destinationPort
            self.direction = direction
            self.`protocol` = `protocol`
            self.sourceDomain = sourceDomain
            self.sourceIpV4 = sourceIpV4
            self.sourceIpV6 = sourceIpV6
            self.sourceMac = sourceMac
            self.sourcePort = sourcePort
        }

        public func validate(name: String) throws {
            try validate(self.destinationDomain, name:"destinationDomain", parent: name, pattern: ".*\\S.*")
            try validate(self.destinationIpV4, name:"destinationIpV4", parent: name, pattern: ".*\\S.*")
            try validate(self.destinationIpV6, name:"destinationIpV6", parent: name, pattern: ".*\\S.*")
            try validate(self.`protocol`, name:"`protocol`", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceDomain, name:"sourceDomain", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceIpV4, name:"sourceIpV4", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceIpV6, name:"sourceIpV6", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceMac, name:"sourceMac", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationDomain = "DestinationDomain"
            case destinationIpV4 = "DestinationIpV4"
            case destinationIpV6 = "DestinationIpV6"
            case destinationPort = "DestinationPort"
            case direction = "Direction"
            case `protocol` = "Protocol"
            case sourceDomain = "SourceDomain"
            case sourceIpV4 = "SourceIpV4"
            case sourceIpV6 = "SourceIpV6"
            case sourceMac = "SourceMac"
            case sourcePort = "SourcePort"
        }
    }

    public enum NetworkDirection: String, CustomStringConvertible, Codable {
        case `in` = "IN"
        case out = "OUT"
        public var description: String { return self.rawValue }
    }

    public struct Note: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Text", required: true, type: .string), 
            AWSShapeMember(label: "UpdatedAt", required: true, type: .string), 
            AWSShapeMember(label: "UpdatedBy", required: true, type: .string)
        ]

        /// The text of a note.
        public let text: String
        /// The timestamp of when the note was updated.
        public let updatedAt: String
        /// The principal that created a note.
        public let updatedBy: String

        public init(text: String, updatedAt: String, updatedBy: String) {
            self.text = text
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try validate(self.text, name:"text", parent: name, pattern: ".*\\S.*")
            try validate(self.updatedAt, name:"updatedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.updatedBy, name:"updatedBy", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedAt = "UpdatedAt"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NoteUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Text", required: true, type: .string), 
            AWSShapeMember(label: "UpdatedBy", required: true, type: .string)
        ]

        /// The updated note text.
        public let text: String
        /// The principal that updated the note.
        public let updatedBy: String

        public init(text: String, updatedBy: String) {
            self.text = text
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try validate(self.text, name:"text", parent: name, pattern: ".*\\S.*")
            try validate(self.updatedBy, name:"updatedBy", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NumberFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Eq", required: false, type: .double), 
            AWSShapeMember(label: "Gte", required: false, type: .double), 
            AWSShapeMember(label: "Lte", required: false, type: .double)
        ]

        /// The equal-to condition to be applied to a single field when querying for findings.
        public let eq: Double?
        /// The greater-than-equal condition to be applied to a single field when querying for findings. 
        public let gte: Double?
        /// The less-than-equal condition to be applied to a single field when querying for findings. 
        public let lte: Double?

        public init(eq: Double? = nil, gte: Double? = nil, lte: Double? = nil) {
            self.eq = eq
            self.gte = gte
            self.lte = lte
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "Eq"
            case gte = "Gte"
            case lte = "Lte"
        }
    }

    public enum Partition: String, CustomStringConvertible, Codable {
        case aws = "aws"
        case awsCn = "aws-cn"
        case awsUsGov = "aws-us-gov"
        public var description: String { return self.rawValue }
    }

    public struct ProcessDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LaunchedAt", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ParentPid", required: false, type: .integer), 
            AWSShapeMember(label: "Path", required: false, type: .string), 
            AWSShapeMember(label: "Pid", required: false, type: .integer), 
            AWSShapeMember(label: "TerminatedAt", required: false, type: .string)
        ]

        /// The date/time that the process was launched.
        public let launchedAt: String?
        /// The name of the process.
        public let name: String?
        /// The parent process ID.
        public let parentPid: Int?
        /// The path to the process executable.
        public let path: String?
        /// The process ID.
        public let pid: Int?
        /// The date and time when the process was terminated.
        public let terminatedAt: String?

        public init(launchedAt: String? = nil, name: String? = nil, parentPid: Int? = nil, path: String? = nil, pid: Int? = nil, terminatedAt: String? = nil) {
            self.launchedAt = launchedAt
            self.name = name
            self.parentPid = parentPid
            self.path = path
            self.pid = pid
            self.terminatedAt = terminatedAt
        }

        public func validate(name: String) throws {
            try validate(self.launchedAt, name:"launchedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
            try validate(self.path, name:"path", parent: name, pattern: ".*\\S.*")
            try validate(self.terminatedAt, name:"terminatedAt", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case launchedAt = "LaunchedAt"
            case name = "Name"
            case parentPid = "ParentPid"
            case path = "Path"
            case pid = "Pid"
            case terminatedAt = "TerminatedAt"
        }
    }

    public struct Product: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActivationUrl", required: false, type: .string), 
            AWSShapeMember(label: "Categories", required: false, type: .list), 
            AWSShapeMember(label: "CompanyName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "MarketplaceUrl", required: false, type: .string), 
            AWSShapeMember(label: "ProductArn", required: true, type: .string), 
            AWSShapeMember(label: "ProductName", required: false, type: .string), 
            AWSShapeMember(label: "ProductSubscriptionResourcePolicy", required: false, type: .string)
        ]

        /// The URL used to activate the product.
        public let activationUrl: String?
        /// The categories assigned to the product.
        public let categories: [String]?
        /// The name of the company that provides the product.
        public let companyName: String?
        /// A description of the product.
        public let description: String?
        /// The URL for the page that contains more information about the product.
        public let marketplaceUrl: String?
        /// The ARN assigned to the product.
        public let productArn: String
        /// The name of the product.
        public let productName: String?
        /// The resource policy associated with the product.
        public let productSubscriptionResourcePolicy: String?

        public init(activationUrl: String? = nil, categories: [String]? = nil, companyName: String? = nil, description: String? = nil, marketplaceUrl: String? = nil, productArn: String, productName: String? = nil, productSubscriptionResourcePolicy: String? = nil) {
            self.activationUrl = activationUrl
            self.categories = categories
            self.companyName = companyName
            self.description = description
            self.marketplaceUrl = marketplaceUrl
            self.productArn = productArn
            self.productName = productName
            self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case activationUrl = "ActivationUrl"
            case categories = "Categories"
            case companyName = "CompanyName"
            case description = "Description"
            case marketplaceUrl = "MarketplaceUrl"
            case productArn = "ProductArn"
            case productName = "ProductName"
            case productSubscriptionResourcePolicy = "ProductSubscriptionResourcePolicy"
        }
    }

    public struct Recommendation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Text", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// Describes the recommended steps to take to remediate an issue identified in a finding.
        public let text: String?
        /// A URL to a page or site that contains information about how to remediate a finding.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        public func validate(name: String) throws {
            try validate(self.text, name:"text", parent: name, pattern: ".*\\S.*")
            try validate(self.url, name:"url", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case url = "Url"
        }
    }

    public enum RecordState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public struct RelatedFinding: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "ProductArn", required: true, type: .string)
        ]

        /// The product-generated identifier for a related finding.
        public let id: String
        /// The ARN of the product that generated a related finding.
        public let productArn: String

        public init(id: String, productArn: String) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try validate(self.id, name:"id", parent: name, pattern: ".*\\S.*")
            try validate(self.productArn, name:"productArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct Remediation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Recommendation", required: false, type: .structure)
        ]

        /// A recommendation on the steps to take to remediate the issue identified by a finding.
        public let recommendation: Recommendation?

        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        public func validate(name: String) throws {
            try self.recommendation?.validate(name: "\(name).recommendation")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "Recommendation"
        }
    }

    public struct Resource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Details", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "Partition", required: false, type: .enum), 
            AWSShapeMember(label: "Region", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map), 
            AWSShapeMember(label: "Type", required: true, type: .string)
        ]

        /// Additional details about the resource related to a finding.
        public let details: ResourceDetails?
        /// The canonical identifier for the given resource type.
        public let id: String
        /// The canonical AWS partition name that the Region is assigned to.
        public let partition: Partition?
        /// The canonical AWS external Region name where this resource is located.
        public let region: String?
        /// A list of AWS tags associated with a resource at the time the finding was processed.
        public let tags: [String: String]?
        /// The type of the resource that details are provided for.
        public let `type`: String

        public init(details: ResourceDetails? = nil, id: String, partition: Partition? = nil, region: String? = nil, tags: [String: String]? = nil, type: String) {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try self.details?.validate(name: "\(name).details")
            try validate(self.id, name:"id", parent: name, pattern: ".*\\S.*")
            try validate(self.region, name:"region", parent: name, pattern: ".*\\S.*")
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.`type`, name:"`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case details = "Details"
            case id = "Id"
            case partition = "Partition"
            case region = "Region"
            case tags = "Tags"
            case `type` = "Type"
        }
    }

    public struct ResourceDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AwsCloudFrontDistribution", required: false, type: .structure), 
            AWSShapeMember(label: "AwsEc2Instance", required: false, type: .structure), 
            AWSShapeMember(label: "AwsElbv2LoadBalancer", required: false, type: .structure), 
            AWSShapeMember(label: "AwsIamAccessKey", required: false, type: .structure), 
            AWSShapeMember(label: "AwsIamRole", required: false, type: .structure), 
            AWSShapeMember(label: "AwsKmsKey", required: false, type: .structure), 
            AWSShapeMember(label: "AwsLambdaFunction", required: false, type: .structure), 
            AWSShapeMember(label: "AwsS3Bucket", required: false, type: .structure), 
            AWSShapeMember(label: "AwsSnsTopic", required: false, type: .structure), 
            AWSShapeMember(label: "AwsSqsQueue", required: false, type: .structure), 
            AWSShapeMember(label: "Container", required: false, type: .structure), 
            AWSShapeMember(label: "Other", required: false, type: .map)
        ]

        /// Details about a CloudFront distribution.
        public let awsCloudFrontDistribution: AwsCloudFrontDistributionDetails?
        /// Details about an Amazon EC2 instance related to a finding.
        public let awsEc2Instance: AwsEc2InstanceDetails?
        /// Details about a load balancer.
        public let awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails?
        /// Details about an IAM access key related to a finding.
        public let awsIamAccessKey: AwsIamAccessKeyDetails?
        /// Details about an IAM role.
        public let awsIamRole: AwsIamRoleDetails?
        /// Details about a KMS key.
        public let awsKmsKey: AwsKmsKeyDetails?
        /// Details about a Lambda function.
        public let awsLambdaFunction: AwsLambdaFunctionDetails?
        /// Details about an Amazon S3 Bucket related to a finding.
        public let awsS3Bucket: AwsS3BucketDetails?
        /// Details about an SNS topic.
        public let awsSnsTopic: AwsSnsTopicDetails?
        /// Details about an SQS queue.
        public let awsSqsQueue: AwsSqsQueueDetails?
        /// Details about a container resource related to a finding.
        public let container: ContainerDetails?
        /// Details about a resource that doesn't have a specific type defined.
        public let other: [String: String]?

        public init(awsCloudFrontDistribution: AwsCloudFrontDistributionDetails? = nil, awsEc2Instance: AwsEc2InstanceDetails? = nil, awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails? = nil, awsIamAccessKey: AwsIamAccessKeyDetails? = nil, awsIamRole: AwsIamRoleDetails? = nil, awsKmsKey: AwsKmsKeyDetails? = nil, awsLambdaFunction: AwsLambdaFunctionDetails? = nil, awsS3Bucket: AwsS3BucketDetails? = nil, awsSnsTopic: AwsSnsTopicDetails? = nil, awsSqsQueue: AwsSqsQueueDetails? = nil, container: ContainerDetails? = nil, other: [String: String]? = nil) {
            self.awsCloudFrontDistribution = awsCloudFrontDistribution
            self.awsEc2Instance = awsEc2Instance
            self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
            self.awsIamAccessKey = awsIamAccessKey
            self.awsIamRole = awsIamRole
            self.awsKmsKey = awsKmsKey
            self.awsLambdaFunction = awsLambdaFunction
            self.awsS3Bucket = awsS3Bucket
            self.awsSnsTopic = awsSnsTopic
            self.awsSqsQueue = awsSqsQueue
            self.container = container
            self.other = other
        }

        public func validate(name: String) throws {
            try self.awsCloudFrontDistribution?.validate(name: "\(name).awsCloudFrontDistribution")
            try self.awsEc2Instance?.validate(name: "\(name).awsEc2Instance")
            try self.awsElbv2LoadBalancer?.validate(name: "\(name).awsElbv2LoadBalancer")
            try self.awsIamAccessKey?.validate(name: "\(name).awsIamAccessKey")
            try self.awsIamRole?.validate(name: "\(name).awsIamRole")
            try self.awsKmsKey?.validate(name: "\(name).awsKmsKey")
            try self.awsLambdaFunction?.validate(name: "\(name).awsLambdaFunction")
            try self.awsS3Bucket?.validate(name: "\(name).awsS3Bucket")
            try self.awsSnsTopic?.validate(name: "\(name).awsSnsTopic")
            try self.awsSqsQueue?.validate(name: "\(name).awsSqsQueue")
            try self.container?.validate(name: "\(name).container")
            try self.other?.forEach {
                try validate($0.key, name:"other.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name:"other[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudFrontDistribution = "AwsCloudFrontDistribution"
            case awsEc2Instance = "AwsEc2Instance"
            case awsElbv2LoadBalancer = "AwsElbv2LoadBalancer"
            case awsIamAccessKey = "AwsIamAccessKey"
            case awsIamRole = "AwsIamRole"
            case awsKmsKey = "AwsKmsKey"
            case awsLambdaFunction = "AwsLambdaFunction"
            case awsS3Bucket = "AwsS3Bucket"
            case awsSnsTopic = "AwsSnsTopic"
            case awsSqsQueue = "AwsSqsQueue"
            case container = "Container"
            case other = "Other"
        }
    }

    public struct Result: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "ProcessingResult", required: false, type: .string)
        ]

        /// An AWS account ID of the account that wasn't be processed.
        public let accountId: String?
        /// The reason that the account wasn't be processed.
        public let processingResult: String?

        public init(accountId: String? = nil, processingResult: String? = nil) {
            self.accountId = accountId
            self.processingResult = processingResult
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case processingResult = "ProcessingResult"
        }
    }

    public struct Severity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Normalized", required: true, type: .integer), 
            AWSShapeMember(label: "Product", required: false, type: .double)
        ]

        /// The normalized severity of a finding.
        public let normalized: Int
        /// The native severity as defined by the AWS service or integrated partner product that generated the finding.
        public let product: Double?

        public init(normalized: Int, product: Double? = nil) {
            self.normalized = normalized
            self.product = product
        }

        private enum CodingKeys: String, CodingKey {
            case normalized = "Normalized"
            case product = "Product"
        }
    }

    public enum SeverityRating: String, CustomStringConvertible, Codable {
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case critical = "CRITICAL"
        public var description: String { return self.rawValue }
    }

    public struct SortCriterion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Field", required: false, type: .string), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum)
        ]

        /// The finding attribute used to sort findings.
        public let field: String?
        /// The order used to sort findings.
        public let sortOrder: SortOrder?

        public init(field: String? = nil, sortOrder: SortOrder? = nil) {
            self.field = field
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try validate(self.field, name:"field", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case sortOrder = "SortOrder"
        }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable {
        case asc = "asc"
        case desc = "desc"
        public var description: String { return self.rawValue }
    }

    public struct StandardsControl: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ControlId", required: false, type: .string), 
            AWSShapeMember(label: "ControlStatus", required: false, type: .enum), 
            AWSShapeMember(label: "ControlStatusUpdatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "DisabledReason", required: false, type: .string), 
            AWSShapeMember(label: "RemediationUrl", required: false, type: .string), 
            AWSShapeMember(label: "SeverityRating", required: false, type: .enum), 
            AWSShapeMember(label: "StandardsControlArn", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: false, type: .string)
        ]

        /// The identifier of the compliance standard control.
        public let controlId: String?
        /// The current status of the compliance standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.
        public let controlStatus: ControlStatus?
        /// The date and time that the status of the compliance standard control was most recently updated.
        public let controlStatusUpdatedAt: TimeStamp?
        /// The longer description of the compliance standard control. Provides information about what the control is checking for.
        public let description: String?
        /// The reason provided for the most recent change in status for the control.
        public let disabledReason: String?
        /// A link to remediation information for the control in the Security Hub user documentation
        public let remediationUrl: String?
        /// The severity of findings generated from this compliance standard control. The finding severity is based on an assessment of how easy it would be to compromise AWS resources if the compliance issue is detected.
        public let severityRating: SeverityRating?
        /// The ARN of the compliance standard control.
        public let standardsControlArn: String?
        /// The title of the compliance standard control.
        public let title: String?

        public init(controlId: String? = nil, controlStatus: ControlStatus? = nil, controlStatusUpdatedAt: TimeStamp? = nil, description: String? = nil, disabledReason: String? = nil, remediationUrl: String? = nil, severityRating: SeverityRating? = nil, standardsControlArn: String? = nil, title: String? = nil) {
            self.controlId = controlId
            self.controlStatus = controlStatus
            self.controlStatusUpdatedAt = controlStatusUpdatedAt
            self.description = description
            self.disabledReason = disabledReason
            self.remediationUrl = remediationUrl
            self.severityRating = severityRating
            self.standardsControlArn = standardsControlArn
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case controlId = "ControlId"
            case controlStatus = "ControlStatus"
            case controlStatusUpdatedAt = "ControlStatusUpdatedAt"
            case description = "Description"
            case disabledReason = "DisabledReason"
            case remediationUrl = "RemediationUrl"
            case severityRating = "SeverityRating"
            case standardsControlArn = "StandardsControlArn"
            case title = "Title"
        }
    }

    public enum StandardsStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case ready = "READY"
        case failed = "FAILED"
        case deleting = "DELETING"
        case incomplete = "INCOMPLETE"
        public var description: String { return self.rawValue }
    }

    public struct StandardsSubscription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StandardsArn", required: true, type: .string), 
            AWSShapeMember(label: "StandardsInput", required: true, type: .map), 
            AWSShapeMember(label: "StandardsStatus", required: true, type: .enum), 
            AWSShapeMember(label: "StandardsSubscriptionArn", required: true, type: .string)
        ]

        /// The ARN of a standard. In this release, Security Hub supports only the CIS AWS Foundations standard, which uses the following ARN: arn:aws:securityhub:::ruleset/cis-aws-foundations-benchmark/v/1.2.0. 
        public let standardsArn: String
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]
        /// The status of the standards subscription.
        public let standardsStatus: StandardsStatus
        /// The ARN of a resource that represents your subscription to a supported standard.
        public let standardsSubscriptionArn: String

        public init(standardsArn: String, standardsInput: [String: String], standardsStatus: StandardsStatus, standardsSubscriptionArn: String) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
            self.standardsStatus = standardsStatus
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
            case standardsStatus = "StandardsStatus"
            case standardsSubscriptionArn = "StandardsSubscriptionArn"
        }
    }

    public struct StandardsSubscriptionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StandardsArn", required: true, type: .string), 
            AWSShapeMember(label: "StandardsInput", required: false, type: .map)
        ]

        /// The ARN of the standard that you want to enable.  In this release, Security Hub only supports the CIS AWS Foundations standard.  Its ARN is arn:aws:securityhub:::ruleset/cis-aws-foundations-benchmark/v/1.2.0. 
        public let standardsArn: String
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]?

        public init(standardsArn: String, standardsInput: [String: String]? = nil) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
        }

        public func validate(name: String) throws {
            try validate(self.standardsArn, name:"standardsArn", parent: name, pattern: ".*\\S.*")
            try self.standardsInput?.forEach {
                try validate($0.key, name:"standardsInput.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name:"standardsInput[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
        }
    }

    public struct StringFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Comparison", required: false, type: .enum), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// The condition to be applied to a string value when querying for findings. 
        public let comparison: StringFilterComparison?
        /// The string filter value.
        public let value: String?

        public init(comparison: StringFilterComparison? = nil, value: String? = nil) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name:"value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case value = "Value"
        }
    }

    public enum StringFilterComparison: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "ResourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .map)
        ]

        /// The ARN of the resource to apply the tags to.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:aws:securityhub:.*")
            try self.tags.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct ThreatIntelIndicator: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", required: false, type: .enum), 
            AWSShapeMember(label: "LastObservedAt", required: false, type: .string), 
            AWSShapeMember(label: "Source", required: false, type: .string), 
            AWSShapeMember(label: "SourceUrl", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// The category of a threat intel indicator.
        public let category: ThreatIntelIndicatorCategory?
        /// The date and time when the most recent instance of a threat intel indicator was observed.
        public let lastObservedAt: String?
        /// The source of the threat intel indicator.
        public let source: String?
        /// The URL to the page or site where you can get more information about the threat intel indicator.
        public let sourceUrl: String?
        /// The type of a threat intel indicator.
        public let `type`: ThreatIntelIndicatorType?
        /// The value of a threat intel indicator.
        public let value: String?

        public init(category: ThreatIntelIndicatorCategory? = nil, lastObservedAt: String? = nil, source: String? = nil, sourceUrl: String? = nil, type: ThreatIntelIndicatorType? = nil, value: String? = nil) {
            self.category = category
            self.lastObservedAt = lastObservedAt
            self.source = source
            self.sourceUrl = sourceUrl
            self.`type` = `type`
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.lastObservedAt, name:"lastObservedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.source, name:"source", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceUrl, name:"sourceUrl", parent: name, pattern: ".*\\S.*")
            try validate(self.value, name:"value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case lastObservedAt = "LastObservedAt"
            case source = "Source"
            case sourceUrl = "SourceUrl"
            case `type` = "Type"
            case value = "Value"
        }
    }

    public enum ThreatIntelIndicatorCategory: String, CustomStringConvertible, Codable {
        case backdoor = "BACKDOOR"
        case cardStealer = "CARD_STEALER"
        case commandAndControl = "COMMAND_AND_CONTROL"
        case dropSite = "DROP_SITE"
        case exploitSite = "EXPLOIT_SITE"
        case keylogger = "KEYLOGGER"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorType: String, CustomStringConvertible, Codable {
        case domain = "DOMAIN"
        case emailAddress = "EMAIL_ADDRESS"
        case hashMd5 = "HASH_MD5"
        case hashSha1 = "HASH_SHA1"
        case hashSha256 = "HASH_SHA256"
        case hashSha512 = "HASH_SHA512"
        case ipv4Address = "IPV4_ADDRESS"
        case ipv6Address = "IPV6_ADDRESS"
        case mutex = "MUTEX"
        case process = "PROCESS"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "ResourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]

        /// The ARN of the resource to remove the tags from.
        public let resourceArn: String
        /// The tag keys associated with the tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:aws:securityhub:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateActionTargetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActionTargetArn", location: .uri(locationName: "ActionTargetArn"), required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The ARN of the custom action target to update.
        public let actionTargetArn: String
        /// The updated description for the custom action target.
        public let description: String?
        /// The updated name of the custom action target.
        public let name: String?

        public init(actionTargetArn: String, description: String? = nil, name: String? = nil) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.actionTargetArn, name:"actionTargetArn", parent: name, pattern: ".*\\S.*")
            try validate(self.description, name:"description", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateActionTargetResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateFindingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: true, type: .structure), 
            AWSShapeMember(label: "Note", required: false, type: .structure), 
            AWSShapeMember(label: "RecordState", required: false, type: .enum)
        ]

        /// A collection of attributes that specify which findings you want to update.
        public let filters: AwsSecurityFindingFilters
        /// The updated note for the finding.
        public let note: NoteUpdate?
        /// The updated record state for the finding.
        public let recordState: RecordState?

        public init(filters: AwsSecurityFindingFilters, note: NoteUpdate? = nil, recordState: RecordState? = nil) {
            self.filters = filters
            self.note = note
            self.recordState = recordState
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.note?.validate(name: "\(name).note")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case note = "Note"
            case recordState = "RecordState"
        }
    }

    public struct UpdateFindingsResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateInsightRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .structure), 
            AWSShapeMember(label: "GroupByAttribute", required: false, type: .string), 
            AWSShapeMember(label: "InsightArn", location: .uri(locationName: "InsightArn"), required: true, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The updated filters that define this insight.
        public let filters: AwsSecurityFindingFilters?
        /// The updated GroupBy attribute that defines this insight.
        public let groupByAttribute: String?
        /// The ARN of the insight that you want to update.
        public let insightArn: String
        /// The updated name for the insight.
        public let name: String?

        public init(filters: AwsSecurityFindingFilters? = nil, groupByAttribute: String? = nil, insightArn: String, name: String? = nil) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try validate(self.groupByAttribute, name:"groupByAttribute", parent: name, pattern: ".*\\S.*")
            try validate(self.insightArn, name:"insightArn", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name:"name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case name = "Name"
        }
    }

    public struct UpdateInsightResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateStandardsControlRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ControlStatus", required: false, type: .enum), 
            AWSShapeMember(label: "DisabledReason", required: false, type: .string), 
            AWSShapeMember(label: "StandardsControlArn", location: .uri(locationName: "StandardsControlArn"), required: true, type: .string)
        ]

        /// The updated status of the compliance standard control.
        public let controlStatus: ControlStatus?
        /// A description of the reason why you are disabling a compliance standard control.
        public let disabledReason: String?
        /// The ARN of the compliance standard control to enable or disable.
        public let standardsControlArn: String

        public init(controlStatus: ControlStatus? = nil, disabledReason: String? = nil, standardsControlArn: String) {
            self.controlStatus = controlStatus
            self.disabledReason = disabledReason
            self.standardsControlArn = standardsControlArn
        }

        public func validate(name: String) throws {
            try validate(self.disabledReason, name:"disabledReason", parent: name, pattern: ".*\\S.*")
            try validate(self.standardsControlArn, name:"standardsControlArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case controlStatus = "ControlStatus"
            case disabledReason = "DisabledReason"
            case standardsControlArn = "StandardsControlArn"
        }
    }

    public struct UpdateStandardsControlResponse: AWSShape {


        public init() {
        }

    }

    public enum VerificationState: String, CustomStringConvertible, Codable {
        case unknown = "UNKNOWN"
        case truePositive = "TRUE_POSITIVE"
        case falsePositive = "FALSE_POSITIVE"
        case benignPositive = "BENIGN_POSITIVE"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowState: String, CustomStringConvertible, Codable {
        case new = "NEW"
        case assigned = "ASSIGNED"
        case inProgress = "IN_PROGRESS"
        case deferred = "DEFERRED"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }
}
