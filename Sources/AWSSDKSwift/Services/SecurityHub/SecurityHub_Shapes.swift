//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore
import Foundation

extension SecurityHub {
    //MARK: Enums

    public enum AwsIamAccessKeyStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum ComplianceStatus: String, CustomStringConvertible, Codable {
        case passed = "PASSED"
        case warning = "WARNING"
        case failed = "FAILED"
        case notAvailable = "NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum ControlStatus: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum DateRangeUnit: String, CustomStringConvertible, Codable {
        case days = "DAYS"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationType: String, CustomStringConvertible, Codable {
        case sendFindingsToSecurityHub = "SEND_FINDINGS_TO_SECURITY_HUB"
        case receiveFindingsFromSecurityHub = "RECEIVE_FINDINGS_FROM_SECURITY_HUB"
        public var description: String { return self.rawValue }
    }

    public enum MalwareState: String, CustomStringConvertible, Codable {
        case observed = "OBSERVED"
        case removalFailed = "REMOVAL_FAILED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MalwareType: String, CustomStringConvertible, Codable {
        case adware = "ADWARE"
        case blendedThreat = "BLENDED_THREAT"
        case botnetAgent = "BOTNET_AGENT"
        case coinMiner = "COIN_MINER"
        case exploitKit = "EXPLOIT_KIT"
        case keylogger = "KEYLOGGER"
        case macro = "MACRO"
        case potentiallyUnwanted = "POTENTIALLY_UNWANTED"
        case spyware = "SPYWARE"
        case ransomware = "RANSOMWARE"
        case remoteAccess = "REMOTE_ACCESS"
        case rootkit = "ROOTKIT"
        case trojan = "TROJAN"
        case virus = "VIRUS"
        case worm = "WORM"
        public var description: String { return self.rawValue }
    }

    public enum MapFilterComparison: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NetworkDirection: String, CustomStringConvertible, Codable {
        case `in` = "IN"
        case out = "OUT"
        public var description: String { return self.rawValue }
    }

    public enum Partition: String, CustomStringConvertible, Codable {
        case aws = "aws"
        case awsCn = "aws-cn"
        case awsUsGov = "aws-us-gov"
        public var description: String { return self.rawValue }
    }

    public enum RecordState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum SeverityLabel: String, CustomStringConvertible, Codable {
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case critical = "CRITICAL"
        public var description: String { return self.rawValue }
    }

    public enum SeverityRating: String, CustomStringConvertible, Codable {
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case critical = "CRITICAL"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable {
        case asc = "asc"
        case desc = "desc"
        public var description: String { return self.rawValue }
    }

    public enum StandardsStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case ready = "READY"
        case failed = "FAILED"
        case deleting = "DELETING"
        case incomplete = "INCOMPLETE"
        public var description: String { return self.rawValue }
    }

    public enum StringFilterComparison: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorCategory: String, CustomStringConvertible, Codable {
        case backdoor = "BACKDOOR"
        case cardStealer = "CARD_STEALER"
        case commandAndControl = "COMMAND_AND_CONTROL"
        case dropSite = "DROP_SITE"
        case exploitSite = "EXPLOIT_SITE"
        case keylogger = "KEYLOGGER"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorType: String, CustomStringConvertible, Codable {
        case domain = "DOMAIN"
        case emailAddress = "EMAIL_ADDRESS"
        case hashMd5 = "HASH_MD5"
        case hashSha1 = "HASH_SHA1"
        case hashSha256 = "HASH_SHA256"
        case hashSha512 = "HASH_SHA512"
        case ipv4Address = "IPV4_ADDRESS"
        case ipv6Address = "IPV6_ADDRESS"
        case mutex = "MUTEX"
        case process = "PROCESS"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum VerificationState: String, CustomStringConvertible, Codable {
        case unknown = "UNKNOWN"
        case truePositive = "TRUE_POSITIVE"
        case falsePositive = "FALSE_POSITIVE"
        case benignPositive = "BENIGN_POSITIVE"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowState: String, CustomStringConvertible, Codable {
        case new = "NEW"
        case assigned = "ASSIGNED"
        case inProgress = "IN_PROGRESS"
        case deferred = "DEFERRED"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable {
        case new = "NEW"
        case notified = "NOTIFIED"
        case resolved = "RESOLVED"
        case suppressed = "SUPPRESSED"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AcceptInvitationRequest: AWSEncodableShape {

        /// The ID of the invitation sent from the Security Hub master account.
        public let invitationId: String
        /// The account ID of the Security Hub master account that sent the invitation.
        public let masterId: String

        public init(invitationId: String, masterId: String) {
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func validate(name: String) throws {
            try validate(self.invitationId, name: "invitationId", parent: name, pattern: ".*\\S.*")
            try validate(self.masterId, name: "masterId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "InvitationId"
            case masterId = "MasterId"
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct AccountDetails: AWSEncodableShape {

        /// The ID of an AWS account.
        public let accountId: String?
        /// The email of an AWS account.
        public let email: String?

        public init(accountId: String? = nil, email: String? = nil) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try validate(self.email, name: "email", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case email = "Email"
        }
    }

    public struct ActionTarget: AWSDecodableShape {

        /// The ARN for the target action.
        public let actionTargetArn: String
        /// The description of the target action.
        public let description: String
        /// The name of the action target.
        public let name: String

        public init(actionTargetArn: String, description: String, name: String) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct AvailabilityZone: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the subnet. You can specify one subnet per Availability Zone.
        public let subnetId: String?
        /// The name of the Availability Zone.
        public let zoneName: String?

        public init(subnetId: String? = nil, zoneName: String? = nil) {
            self.subnetId = subnetId
            self.zoneName = zoneName
        }

        public func validate(name: String) throws {
            try validate(self.subnetId, name: "subnetId", parent: name, pattern: ".*\\S.*")
            try validate(self.zoneName, name: "zoneName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case zoneName = "ZoneName"
        }
    }

    public struct AwsCloudFrontDistributionDetails: AWSEncodableShape & AWSDecodableShape {

        /// The domain name corresponding to the distribution.
        public let domainName: String?
        /// The entity tag is a hash of the object.
        public let eTag: String?
        /// The date and time that the distribution was last modified.
        public let lastModifiedTime: String?
        /// A complex type that controls whether access logs are written for the distribution.
        public let logging: AwsCloudFrontDistributionLogging?
        /// A complex type that contains information about origins for this distribution.
        public let origins: AwsCloudFrontDistributionOrigins?
        /// Indicates the current status of the distribution.
        public let status: String?
        /// A unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution.
        public let webAclId: String?

        public init(domainName: String? = nil, eTag: String? = nil, lastModifiedTime: String? = nil, logging: AwsCloudFrontDistributionLogging? = nil, origins: AwsCloudFrontDistributionOrigins? = nil, status: String? = nil, webAclId: String? = nil) {
            self.domainName = domainName
            self.eTag = eTag
            self.lastModifiedTime = lastModifiedTime
            self.logging = logging
            self.origins = origins
            self.status = status
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try validate(self.domainName, name: "domainName", parent: name, pattern: ".*\\S.*")
            try validate(self.eTag, name: "eTag", parent: name, pattern: ".*\\S.*")
            try validate(self.lastModifiedTime, name: "lastModifiedTime", parent: name, pattern: ".*\\S.*")
            try self.logging?.validate(name: "\(name).logging")
            try self.origins?.validate(name: "\(name).origins")
            try validate(self.status, name: "status", parent: name, pattern: ".*\\S.*")
            try validate(self.webAclId, name: "webAclId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case eTag = "ETag"
            case lastModifiedTime = "LastModifiedTime"
            case logging = "Logging"
            case origins = "Origins"
            case status = "Status"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsCloudFrontDistributionLogging: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon S3 bucket to store the access logs in.
        public let bucket: String?
        /// With this field, you can enable or disable the selected distribution.
        public let enabled: Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs.
        public let includeCookies: Bool?
        /// An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool? = nil, includeCookies: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try validate(self.bucket, name: "bucket", parent: name, pattern: ".*\\S.*")
            try validate(self.prefix, name: "prefix", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case enabled = "Enabled"
            case includeCookies = "IncludeCookies"
            case prefix = "Prefix"
        }
    }

    public struct AwsCloudFrontDistributionOriginItem: AWSEncodableShape & AWSDecodableShape {

        /// Amazon S3 origins: The DNS name of the Amazon S3 bucket from which you want CloudFront to get objects for this origin.
        public let domainName: String?
        /// A unique identifier for the origin or origin group.
        public let id: String?
        /// An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
        public let originPath: String?

        public init(domainName: String? = nil, id: String? = nil, originPath: String? = nil) {
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
        }

        public func validate(name: String) throws {
            try validate(self.domainName, name: "domainName", parent: name, pattern: ".*\\S.*")
            try validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
            try validate(self.originPath, name: "originPath", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case id = "Id"
            case originPath = "OriginPath"
        }
    }

    public struct AwsCloudFrontDistributionOrigins: AWSEncodableShape & AWSDecodableShape {

        /// A complex type that contains origins or origin groups for this distribution.
        public let items: [AwsCloudFrontDistributionOriginItem]?

        public init(items: [AwsCloudFrontDistributionOriginItem]? = nil) {
            self.items = items
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCodeBuildProjectDetails: AWSEncodableShape & AWSDecodableShape {

        /// The AWS Key Management Service (AWS KMS) customer master key (CMK) used to encrypt the build output artifacts. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK alias (using the format alias/alias-name). 
        public let encryptionKey: String?
        /// Information about the build environment for this build project.
        public let environment: AwsCodeBuildProjectEnvironment?
        /// The name of the build project.
        public let name: String?
        /// The ARN of the IAM role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account.
        public let serviceRole: String?
        /// Information about the build input source code for this build project.
        public let source: AwsCodeBuildProjectSource?
        /// Information about the VPC configuration that AWS CodeBuild accesses.
        public let vpcConfig: AwsCodeBuildProjectVpcConfig?

        public init(encryptionKey: String? = nil, environment: AwsCodeBuildProjectEnvironment? = nil, name: String? = nil, serviceRole: String? = nil, source: AwsCodeBuildProjectSource? = nil, vpcConfig: AwsCodeBuildProjectVpcConfig? = nil) {
            self.encryptionKey = encryptionKey
            self.environment = environment
            self.name = name
            self.serviceRole = serviceRole
            self.source = source
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: ".*\\S.*")
            try self.environment?.validate(name: "\(name).environment")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try validate(self.serviceRole, name: "serviceRole", parent: name, pattern: ".*\\S.*")
            try self.source?.validate(name: "\(name).source")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKey = "EncryptionKey"
            case environment = "Environment"
            case name = "Name"
            case serviceRole = "ServiceRole"
            case source = "Source"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsCodeBuildProjectEnvironment: AWSEncodableShape & AWSDecodableShape {

        /// The certificate to use with this build project.
        public let certificate: String?
        /// The type of credentials AWS CodeBuild uses to pull images in your build. Valid values:    CODEBUILD specifies that AWS CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the AWS CodeBuild service principal.    SERVICE_ROLE specifies that AWS CodeBuild uses your build project's service role.   When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an AWS CodeBuild curated image, you must use CODEBUILD credentials.
        public let imagePullCredentialsType: String?
        /// The credentials for access to a private registry.
        public let registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential?
        /// The type of build environment to use for related builds. The environment type ARM_CONTAINER is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt). The environment type LINUX_CONTAINER with compute type build.general1.2xlarge is available only in regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). The environment type LINUX_GPU_CONTAINER is available only in regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney) , China (Beijing), and China (Ningxia). Valid values: WINDOWS_CONTAINER | LINUX_CONTAINER | LINUX_GPU_CONTAINER | ARM_CONTAINER 
        public let `type`: String?

        public init(certificate: String? = nil, imagePullCredentialsType: String? = nil, registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential? = nil, type: String? = nil) {
            self.certificate = certificate
            self.imagePullCredentialsType = imagePullCredentialsType
            self.registryCredential = registryCredential
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.certificate, name: "certificate", parent: name, pattern: ".*\\S.*")
            try validate(self.imagePullCredentialsType, name: "imagePullCredentialsType", parent: name, pattern: ".*\\S.*")
            try self.registryCredential?.validate(name: "\(name).registryCredential")
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
            case imagePullCredentialsType = "ImagePullCredentialsType"
            case registryCredential = "RegistryCredential"
            case `type` = "Type"
        }
    }

    public struct AwsCodeBuildProjectEnvironmentRegistryCredential: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) or name of credentials created using AWS Secrets Manager.  The credential can use the name of the credentials only if they exist in your current AWS Region.  
        public let credential: String?
        /// The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for AWS Secrets Manager.
        public let credentialProvider: String?

        public init(credential: String? = nil, credentialProvider: String? = nil) {
            self.credential = credential
            self.credentialProvider = credentialProvider
        }

        public func validate(name: String) throws {
            try validate(self.credential, name: "credential", parent: name, pattern: ".*\\S.*")
            try validate(self.credentialProvider, name: "credentialProvider", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case credential = "Credential"
            case credentialProvider = "CredentialProvider"
        }
    }

    public struct AwsCodeBuildProjectSource: AWSEncodableShape & AWSDecodableShape {

        /// Information about the Git clone depth for the build project.
        public let gitCloneDepth: Int?
        /// Whether to ignore SSL warnings while connecting to the project source code.
        public let insecureSsl: Bool?
        /// Information about the location of the source code to be built. Valid values include:   For source code settings that are specified in the source action of a pipeline in AWS CodePipeline, location should not be specified. If it is specified, AWS CodePipeline ignores it. This is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.   For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the buildspec file (for example, https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name ).   For source code in an S3 input bucket, one of the following.   The path to the ZIP file that contains the source code (for example, bucket-name/path/to/object-name.zip).    The path to the folder that contains the source code (for example, bucket-name/path/to/source-code/folder/).     For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the buildspec file.   For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the buildspec file.   
        public let location: String?
        /// The type of repository that contains the source code to be built. Valid values are:    BITBUCKET - The source code is in a Bitbucket repository.    CODECOMMIT - The source code is in an AWS CodeCommit repository.    CODEPIPELINE - The source code settings are specified in the source action of a pipeline in AWS CodePipeline.    GITHUB - The source code is in a GitHub repository.    GITHUB_ENTERPRISE - The source code is in a GitHub Enterprise repository.    NO_SOURCE - The project does not have input source code.    S3 - The source code is in an S3 input bucket.   
        public let `type`: String?

        public init(gitCloneDepth: Int? = nil, insecureSsl: Bool? = nil, location: String? = nil, type: String? = nil) {
            self.gitCloneDepth = gitCloneDepth
            self.insecureSsl = insecureSsl
            self.location = location
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.location, name: "location", parent: name, pattern: ".*\\S.*")
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case gitCloneDepth = "GitCloneDepth"
            case insecureSsl = "InsecureSsl"
            case location = "Location"
            case `type` = "Type"
        }
    }

    public struct AwsCodeBuildProjectVpcConfig: AWSEncodableShape & AWSDecodableShape {

        /// A list of one or more security group IDs in your Amazon VPC.
        public let securityGroupIds: [String]?
        /// A list of one or more subnet IDs in your Amazon VPC.
        public let subnets: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: ".*\\S.*")
            }
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2InstanceDetails: AWSEncodableShape & AWSDecodableShape {

        /// The IAM profile ARN of the instance.
        public let iamInstanceProfileArn: String?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let imageId: String?
        /// The IPv4 addresses associated with the instance.
        public let ipV4Addresses: [String]?
        /// The IPv6 addresses associated with the instance.
        public let ipV6Addresses: [String]?
        /// The key name associated with the instance.
        public let keyName: String?
        /// The date/time the instance was launched.
        public let launchedAt: String?
        /// The identifier of the subnet that the instance was launched in.
        public let subnetId: String?
        /// The instance type of the instance. 
        public let `type`: String?
        /// The identifier of the VPC that the instance was launched in.
        public let vpcId: String?

        public init(iamInstanceProfileArn: String? = nil, imageId: String? = nil, ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil, keyName: String? = nil, launchedAt: String? = nil, subnetId: String? = nil, type: String? = nil, vpcId: String? = nil) {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.subnetId = subnetId
            self.`type` = `type`
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try validate(self.iamInstanceProfileArn, name: "iamInstanceProfileArn", parent: name, pattern: ".*\\S.*")
            try validate(self.imageId, name: "imageId", parent: name, pattern: ".*\\S.*")
            try self.ipV4Addresses?.forEach {
                try validate($0, name: "ipV4Addresses[]", parent: name, pattern: ".*\\S.*")
            }
            try self.ipV6Addresses?.forEach {
                try validate($0, name: "ipV6Addresses[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.keyName, name: "keyName", parent: name, pattern: ".*\\S.*")
            try validate(self.launchedAt, name: "launchedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.subnetId, name: "subnetId", parent: name, pattern: ".*\\S.*")
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case iamInstanceProfileArn = "IamInstanceProfileArn"
            case imageId = "ImageId"
            case ipV4Addresses = "IpV4Addresses"
            case ipV6Addresses = "IpV6Addresses"
            case keyName = "KeyName"
            case launchedAt = "LaunchedAt"
            case subnetId = "SubnetId"
            case `type` = "Type"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2NetworkInterfaceAttachment: AWSEncodableShape & AWSDecodableShape {

        /// The identifier of the network interface attachment
        public let attachmentId: String?
        /// The timestamp indicating when the attachment initiated.
        public let attachTime: String?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The device index of the network interface attachment on the instance.
        public let deviceIndex: Int?
        /// The ID of the instance.
        public let instanceId: String?
        /// The AWS account ID of the owner of the instance.
        public let instanceOwnerId: String?
        /// The attachment state. Valid values: attaching | attached | detaching | detached 
        public let status: String?

        public init(attachmentId: String? = nil, attachTime: String? = nil, deleteOnTermination: Bool? = nil, deviceIndex: Int? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, status: String? = nil) {
            self.attachmentId = attachmentId
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.attachmentId, name: "attachmentId", parent: name, pattern: ".*\\S.*")
            try validate(self.attachTime, name: "attachTime", parent: name, pattern: ".*\\S.*")
            try validate(self.instanceId, name: "instanceId", parent: name, pattern: ".*\\S.*")
            try validate(self.instanceOwnerId, name: "instanceOwnerId", parent: name, pattern: ".*\\S.*")
            try validate(self.status, name: "status", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachTime = "AttachTime"
            case deleteOnTermination = "DeleteOnTermination"
            case deviceIndex = "DeviceIndex"
            case instanceId = "InstanceId"
            case instanceOwnerId = "InstanceOwnerId"
            case status = "Status"
        }
    }

    public struct AwsEc2NetworkInterfaceDetails: AWSEncodableShape & AWSDecodableShape {

        /// The network interface attachment.
        public let attachment: AwsEc2NetworkInterfaceAttachment?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// Security groups for the network interface.
        public let securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]?
        /// Indicates whether traffic to or from the instance is validated.
        public let sourceDestCheck: Bool?

        public init(attachment: AwsEc2NetworkInterfaceAttachment? = nil, networkInterfaceId: String? = nil, securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]? = nil, sourceDestCheck: Bool? = nil) {
            self.attachment = attachment
            self.networkInterfaceId = networkInterfaceId
            self.securityGroups = securityGroups
            self.sourceDestCheck = sourceDestCheck
        }

        public func validate(name: String) throws {
            try self.attachment?.validate(name: "\(name).attachment")
            try validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: ".*\\S.*")
            try self.securityGroups?.forEach {
                try $0.validate(name: "\(name).securityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case networkInterfaceId = "NetworkInterfaceId"
            case securityGroups = "SecurityGroups"
            case sourceDestCheck = "SourceDestCheck"
        }
    }

    public struct AwsEc2NetworkInterfaceSecurityGroup: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try validate(self.groupId, name: "groupId", parent: name, pattern: ".*\\S.*")
            try validate(self.groupName, name: "groupName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
        }
    }

    public struct AwsEc2SecurityGroupDetails: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?
        /// The inbound rules associated with the security group.
        public let ipPermissions: [AwsEc2SecurityGroupIpPermission]?
        /// [VPC only] The outbound rules associated with the security group.
        public let ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]?
        /// The AWS account ID of the owner of the security group.
        public let ownerId: String?
        /// [VPC only] The ID of the VPC for the security group.
        public let vpcId: String?

        public init(groupId: String? = nil, groupName: String? = nil, ipPermissions: [AwsEc2SecurityGroupIpPermission]? = nil, ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.ipPermissionsEgress = ipPermissionsEgress
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try validate(self.groupId, name: "groupId", parent: name, pattern: ".*\\S.*")
            try validate(self.groupName, name: "groupName", parent: name, pattern: ".*\\S.*")
            try self.ipPermissions?.forEach {
                try $0.validate(name: "\(name).ipPermissions[]")
            }
            try self.ipPermissionsEgress?.forEach {
                try $0.validate(name: "\(name).ipPermissionsEgress[]")
            }
            try validate(self.ownerId, name: "ownerId", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case ipPermissions = "IpPermissions"
            case ipPermissionsEgress = "IpPermissionsEgress"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2SecurityGroupIpPermission: AWSEncodableShape & AWSDecodableShape {

        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. 
        public let fromPort: Int?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number. [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional. If you omit the port range, traffic for all types and codes is allowed. 
        public let ipProtocol: String?
        /// The IPv4 ranges.
        public let ipRanges: [AwsEc2SecurityGroupIpRange]?
        /// The IPv6 ranges.
        public let ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]?
        /// [VPC only] The prefix list IDs for an AWS service. With outbound rules, this is the AWS service to access through a VPC endpoint from instances associated with the security group.
        public let prefixListIds: [AwsEc2SecurityGroupPrefixListId]?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public let toPort: Int?
        /// The security group and AWS account ID pairs.
        public let userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]?

        public init(fromPort: Int? = nil, ipProtocol: String? = nil, ipRanges: [AwsEc2SecurityGroupIpRange]? = nil, ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]? = nil, prefixListIds: [AwsEc2SecurityGroupPrefixListId]? = nil, toPort: Int? = nil, userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]? = nil) {
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.userIdGroupPairs = userIdGroupPairs
        }

        public func validate(name: String) throws {
            try validate(self.ipProtocol, name: "ipProtocol", parent: name, pattern: ".*\\S.*")
            try self.ipRanges?.forEach {
                try $0.validate(name: "\(name).ipRanges[]")
            }
            try self.ipv6Ranges?.forEach {
                try $0.validate(name: "\(name).ipv6Ranges[]")
            }
            try self.prefixListIds?.forEach {
                try $0.validate(name: "\(name).prefixListIds[]")
            }
            try self.userIdGroupPairs?.forEach {
                try $0.validate(name: "\(name).userIdGroupPairs[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case ipProtocol = "IpProtocol"
            case ipRanges = "IpRanges"
            case ipv6Ranges = "Ipv6Ranges"
            case prefixListIds = "PrefixListIds"
            case toPort = "ToPort"
            case userIdGroupPairs = "UserIdGroupPairs"
        }
    }

    public struct AwsEc2SecurityGroupIpRange: AWSEncodableShape & AWSDecodableShape {

        /// The IPv4 CIDR range. You can either specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.
        public let cidrIp: String?

        public init(cidrIp: String? = nil) {
            self.cidrIp = cidrIp
        }

        public func validate(name: String) throws {
            try validate(self.cidrIp, name: "cidrIp", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIp = "CidrIp"
        }
    }

    public struct AwsEc2SecurityGroupIpv6Range: AWSEncodableShape & AWSDecodableShape {

        /// The IPv6 CIDR range. You can either specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.
        public let cidrIpv6: String?

        public init(cidrIpv6: String? = nil) {
            self.cidrIpv6 = cidrIpv6
        }

        public func validate(name: String) throws {
            try validate(self.cidrIpv6, name: "cidrIpv6", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIpv6 = "CidrIpv6"
        }
    }

    public struct AwsEc2SecurityGroupPrefixListId: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the prefix.
        public let prefixListId: String?

        public init(prefixListId: String? = nil) {
            self.prefixListId = prefixListId
        }

        public func validate(name: String) throws {
            try validate(self.prefixListId, name: "prefixListId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case prefixListId = "PrefixListId"
        }
    }

    public struct AwsEc2SecurityGroupUserIdGroupPair: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?
        /// The status of a VPC peering connection, if applicable.
        public let peeringStatus: String?
        /// The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS. 
        public let userId: String?
        /// The ID of the VPC for the referenced security group, if applicable.
        public let vpcId: String?
        /// The ID of the VPC peering connection, if applicable.
        public let vpcPeeringConnectionId: String?

        public init(groupId: String? = nil, groupName: String? = nil, peeringStatus: String? = nil, userId: String? = nil, vpcId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
            self.peeringStatus = peeringStatus
            self.userId = userId
            self.vpcId = vpcId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public func validate(name: String) throws {
            try validate(self.groupId, name: "groupId", parent: name, pattern: ".*\\S.*")
            try validate(self.groupName, name: "groupName", parent: name, pattern: ".*\\S.*")
            try validate(self.peeringStatus, name: "peeringStatus", parent: name, pattern: ".*\\S.*")
            try validate(self.userId, name: "userId", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcPeeringConnectionId, name: "vpcPeeringConnectionId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case peeringStatus = "PeeringStatus"
            case userId = "UserId"
            case vpcId = "VpcId"
            case vpcPeeringConnectionId = "VpcPeeringConnectionId"
        }
    }

    public struct AwsElasticsearchDomainDetails: AWSEncodableShape & AWSDecodableShape {

        /// IAM policy document specifying the access policies for the new Amazon ES domain.
        public let accessPolicies: String?
        /// Additional options for the domain endpoint.
        public let domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions?
        /// Unique identifier for an Amazon ES domain.
        public let domainId: String?
        /// Name of an Amazon ES domain. Domain names are unique across all domains owned by the same account within an AWS Region. Domain names must start with a lowercase letter and must be between 3 and 28 characters. Valid characters are a-z (lowercase only), 0-9, and â€“ (hyphen). 
        public let domainName: String?
        /// Elasticsearch version.
        public let elasticsearchVersion: String?
        /// Details about the configuration for encryption at rest.
        public let encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to an Amazon ES domain. The endpoint is a service URL. 
        public let endpoint: String?
        /// The key-value pair that exists if the Amazon ES domain uses VPC endpoints.
        public let endpoints: [String: String]?
        /// Details about the configuration for node-to-node encryption.
        public let nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions?
        /// Information that Amazon ES derives based on VPCOptions for the domain.
        public let vPCOptions: AwsElasticsearchDomainVPCOptions?

        public init(accessPolicies: String? = nil, domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions? = nil, domainId: String? = nil, domainName: String? = nil, elasticsearchVersion: String? = nil, encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions? = nil, endpoint: String? = nil, endpoints: [String: String]? = nil, nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions? = nil, vPCOptions: AwsElasticsearchDomainVPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.elasticsearchVersion = elasticsearchVersion
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.vPCOptions = vPCOptions
        }

        public func validate(name: String) throws {
            try validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: ".*\\S.*")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try validate(self.domainId, name: "domainId", parent: name, pattern: ".*\\S.*")
            try validate(self.domainName, name: "domainName", parent: name, pattern: ".*\\S.*")
            try validate(self.elasticsearchVersion, name: "elasticsearchVersion", parent: name, pattern: ".*\\S.*")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try validate(self.endpoint, name: "endpoint", parent: name, pattern: ".*\\S.*")
            try self.endpoints?.forEach {
                try validate($0.key, name: "endpoints.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
            try self.vPCOptions?.validate(name: "\(name).vPCOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case elasticsearchVersion = "ElasticsearchVersion"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case endpoint = "Endpoint"
            case endpoints = "Endpoints"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case vPCOptions = "VPCOptions"
        }
    }

    public struct AwsElasticsearchDomainDomainEndpointOptions: AWSEncodableShape & AWSDecodableShape {

        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public let enforceHTTPS: Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the Elasticsearch domain. Valid values:    Policy-Min-TLS-1-0-2019-07, which supports TLSv1.0 and higher    Policy-Min-TLS-1-2-2019-07, which only supports TLSv1.2  
        public let tLSSecurityPolicy: String?

        public init(enforceHTTPS: Bool? = nil, tLSSecurityPolicy: String? = nil) {
            self.enforceHTTPS = enforceHTTPS
            self.tLSSecurityPolicy = tLSSecurityPolicy
        }

        public func validate(name: String) throws {
            try validate(self.tLSSecurityPolicy, name: "tLSSecurityPolicy", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case enforceHTTPS = "EnforceHTTPS"
            case tLSSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct AwsElasticsearchDomainEncryptionAtRestOptions: AWSEncodableShape & AWSDecodableShape {

        /// Whether encryption at rest is enabled.
        public let enabled: Bool?
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public let kmsKeyId: String?

        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct AwsElasticsearchDomainNodeToNodeEncryptionOptions: AWSEncodableShape & AWSDecodableShape {

        /// Whether node-to-node encryption is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsElasticsearchDomainVPCOptions: AWSEncodableShape & AWSDecodableShape {

        /// The list of Availability Zones associated with the VPC subnets.
        public let availabilityZones: [String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public let subnetIds: [String]?
        /// ID for the VPC.
        public let vPCId: String?

        public init(availabilityZones: [String]? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vPCId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vPCId = vPCId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: ".*\\S.*")
            }
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: ".*\\S.*")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.vPCId, name: "vPCId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vPCId = "VPCId"
        }
    }

    public struct AwsElbv2LoadBalancerDetails: AWSEncodableShape & AWSDecodableShape {

        /// The Availability Zones for the load balancer.
        public let availabilityZones: [AvailabilityZone]?
        /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
        public let canonicalHostedZoneId: String?
        /// The date and time the load balancer was created.
        public let createdTime: String?
        /// The public DNS name of the load balancer.
        public let dNSName: String?
        /// The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
        public let ipAddressType: String?
        /// The nodes of an Internet-facing load balancer have public IP addresses.
        public let scheme: String?
        /// The IDs of the security groups for the load balancer.
        public let securityGroups: [String]?
        /// The state of the load balancer.
        public let state: LoadBalancerState?
        /// The type of load balancer.
        public let `type`: String?
        /// The ID of the VPC for the load balancer.
        public let vpcId: String?

        public init(availabilityZones: [AvailabilityZone]? = nil, canonicalHostedZoneId: String? = nil, createdTime: String? = nil, dNSName: String? = nil, ipAddressType: String? = nil, scheme: String? = nil, securityGroups: [String]? = nil, state: LoadBalancerState? = nil, type: String? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.dNSName = dNSName
            self.ipAddressType = ipAddressType
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.`type` = `type`
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try $0.validate(name: "\(name).availabilityZones[]")
            }
            try validate(self.canonicalHostedZoneId, name: "canonicalHostedZoneId", parent: name, pattern: ".*\\S.*")
            try validate(self.createdTime, name: "createdTime", parent: name, pattern: ".*\\S.*")
            try validate(self.dNSName, name: "dNSName", parent: name, pattern: ".*\\S.*")
            try validate(self.ipAddressType, name: "ipAddressType", parent: name, pattern: ".*\\S.*")
            try validate(self.scheme, name: "scheme", parent: name, pattern: ".*\\S.*")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: ".*\\S.*")
            }
            try self.state?.validate(name: "\(name).state")
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case canonicalHostedZoneId = "CanonicalHostedZoneId"
            case createdTime = "CreatedTime"
            case dNSName = "DNSName"
            case ipAddressType = "IpAddressType"
            case scheme = "Scheme"
            case securityGroups = "SecurityGroups"
            case state = "State"
            case `type` = "Type"
            case vpcId = "VpcId"
        }
    }

    public struct AwsIamAccessKeyDetails: AWSEncodableShape & AWSDecodableShape {

        /// The creation date/time of the IAM access key related to a finding.
        public let createdAt: String?
        /// The ID of the principal associated with an access key.
        public let principalId: String?
        /// The name of the principal.
        public let principalName: String?
        /// The type of principal associated with an access key.
        public let principalType: String?
        /// The status of the IAM access key related to a finding.
        public let status: AwsIamAccessKeyStatus?

        public init(createdAt: String? = nil, principalId: String? = nil, principalName: String? = nil, principalType: String? = nil, status: AwsIamAccessKeyStatus? = nil) {
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.createdAt, name: "createdAt", parent: name, pattern: ".*\\S.*")
            try validate(self.principalId, name: "principalId", parent: name, pattern: ".*\\S.*")
            try validate(self.principalName, name: "principalName", parent: name, pattern: ".*\\S.*")
            try validate(self.principalType, name: "principalType", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case principalId = "PrincipalId"
            case principalName = "PrincipalName"
            case principalType = "PrincipalType"
            case status = "Status"
        }
    }

    public struct AwsIamRoleDetails: AWSEncodableShape & AWSDecodableShape {

        /// The trust policy that grants permission to assume the role.
        public let assumeRolePolicyDocument: String?
        /// The date and time, in ISO 8601 date-time format, when the role was created.
        public let createDate: String?
        /// The maximum session duration (in seconds) that you want to set for the specified role.
        public let maxSessionDuration: Int?
        /// The path to the role.
        public let path: String?
        /// The stable and unique string identifying the role.
        public let roleId: String?
        /// The friendly name that identifies the role.
        public let roleName: String?

        public init(assumeRolePolicyDocument: String? = nil, createDate: String? = nil, maxSessionDuration: Int? = nil, path: String? = nil, roleId: String? = nil, roleName: String? = nil) {
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.roleId = roleId
            self.roleName = roleName
        }

        public func validate(name: String) throws {
            try validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, max: 131072)
            try validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, min: 1)
            try validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try validate(self.createDate, name: "createDate", parent: name, pattern: ".*\\S.*")
            try validate(self.path, name: "path", parent: name, pattern: ".*\\S.*")
            try validate(self.roleId, name: "roleId", parent: name, pattern: ".*\\S.*")
            try validate(self.roleName, name: "roleName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
            case createDate = "CreateDate"
            case maxSessionDuration = "MaxSessionDuration"
            case path = "Path"
            case roleId = "RoleId"
            case roleName = "RoleName"
        }
    }

    public struct AwsKmsKeyDetails: AWSEncodableShape & AWSDecodableShape {

        /// The twelve-digit account ID of the AWS account that owns the CMK.
        public let aWSAccountId: String?
        /// The date and time when the CMK was created.
        public let creationDate: Double?
        /// The globally unique identifier for the CMK.
        public let keyId: String?
        /// The manager of the CMK. CMKs in your AWS account are either customer managed or AWS managed.
        public let keyManager: String?
        /// The state of the CMK.
        public let keyState: String?
        /// The source of the CMK's key material. When this value is AWS_KMS, AWS KMS created the key material. When this value is EXTERNAL, the key material was imported from your existing key management infrastructure or the CMK lacks key material. When this value is AWS_CLOUDHSM, the key material was created in the AWS CloudHSM cluster associated with a custom key store.
        public let origin: String?

        public init(aWSAccountId: String? = nil, creationDate: Double? = nil, keyId: String? = nil, keyManager: String? = nil, keyState: String? = nil, origin: String? = nil) {
            self.aWSAccountId = aWSAccountId
            self.creationDate = creationDate
            self.keyId = keyId
            self.keyManager = keyManager
            self.keyState = keyState
            self.origin = origin
        }

        public func validate(name: String) throws {
            try validate(self.aWSAccountId, name: "aWSAccountId", parent: name, pattern: ".*\\S.*")
            try validate(self.keyId, name: "keyId", parent: name, pattern: ".*\\S.*")
            try validate(self.keyManager, name: "keyManager", parent: name, pattern: ".*\\S.*")
            try validate(self.keyState, name: "keyState", parent: name, pattern: ".*\\S.*")
            try validate(self.origin, name: "origin", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case aWSAccountId = "AWSAccountId"
            case creationDate = "CreationDate"
            case keyId = "KeyId"
            case keyManager = "KeyManager"
            case keyState = "KeyState"
            case origin = "Origin"
        }
    }

    public struct AwsLambdaFunctionCode: AWSEncodableShape & AWSDecodableShape {

        /// An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for you.
        public let zipFile: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: ".*\\S.*")
            try validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*\\S.*")
            try validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, pattern: ".*\\S.*")
            try validate(self.zipFile, name: "zipFile", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct AwsLambdaFunctionDeadLetterConfig: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public let targetArn: String?

        public init(targetArn: String? = nil) {
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try validate(self.targetArn, name: "targetArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case targetArn = "TargetArn"
        }
    }

    public struct AwsLambdaFunctionDetails: AWSEncodableShape & AWSDecodableShape {

        /// An AwsLambdaFunctionCode object.
        public let code: AwsLambdaFunctionCode?
        /// The SHA256 hash of the function's deployment package.
        public let codeSha256: String?
        /// The function's dead letter queue.
        public let deadLetterConfig: AwsLambdaFunctionDeadLetterConfig?
        /// The function's environment variables.
        public let environment: AwsLambdaFunctionEnvironment?
        /// The name of the function.
        public let functionName: String?
        /// The function that Lambda calls to begin executing your function.
        public let handler: String?
        /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed CMK.
        public let kmsKeyArn: String?
        /// The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public let lastModified: String?
        /// The function's layers.
        public let layers: [AwsLambdaFunctionLayer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public let masterArn: String?
        /// The memory that's allocated to the function.
        public let memorySize: Int?
        /// The latest updated revision of the function or alias.
        public let revisionId: String?
        /// The function's execution role.
        public let role: String?
        /// The runtime environment for the Lambda function.
        public let runtime: String?
        /// The amount of time that Lambda allows a function to run before stopping it.
        public let timeout: Int?
        /// The function's AWS X-Ray tracing configuration.
        public let tracingConfig: AwsLambdaFunctionTracingConfig?
        /// The version of the Lambda function.
        public let version: String?
        /// The function's networking configuration.
        public let vpcConfig: AwsLambdaFunctionVpcConfig?

        public init(code: AwsLambdaFunctionCode? = nil, codeSha256: String? = nil, deadLetterConfig: AwsLambdaFunctionDeadLetterConfig? = nil, environment: AwsLambdaFunctionEnvironment? = nil, functionName: String? = nil, handler: String? = nil, kmsKeyArn: String? = nil, lastModified: String? = nil, layers: [AwsLambdaFunctionLayer]? = nil, masterArn: String? = nil, memorySize: Int? = nil, revisionId: String? = nil, role: String? = nil, runtime: String? = nil, timeout: Int? = nil, tracingConfig: AwsLambdaFunctionTracingConfig? = nil, version: String? = nil, vpcConfig: AwsLambdaFunctionVpcConfig? = nil) {
            self.code = code
            self.codeSha256 = codeSha256
            self.deadLetterConfig = deadLetterConfig
            self.environment = environment
            self.functionName = functionName
            self.handler = handler
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.code?.validate(name: "\(name).code")
            try validate(self.codeSha256, name: "codeSha256", parent: name, pattern: ".*\\S.*")
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.environment?.validate(name: "\(name).environment")
            try validate(self.functionName, name: "functionName", parent: name, pattern: ".*\\S.*")
            try validate(self.handler, name: "handler", parent: name, pattern: ".*\\S.*")
            try validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: ".*\\S.*")
            try validate(self.lastModified, name: "lastModified", parent: name, pattern: ".*\\S.*")
            try self.layers?.forEach {
                try $0.validate(name: "\(name).layers[]")
            }
            try validate(self.masterArn, name: "masterArn", parent: name, pattern: ".*\\S.*")
            try validate(self.revisionId, name: "revisionId", parent: name, pattern: ".*\\S.*")
            try validate(self.role, name: "role", parent: name, pattern: ".*\\S.*")
            try validate(self.runtime, name: "runtime", parent: name, pattern: ".*\\S.*")
            try self.tracingConfig?.validate(name: "\(name).tracingConfig")
            try validate(self.version, name: "version", parent: name, pattern: ".*\\S.*")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case codeSha256 = "CodeSha256"
            case deadLetterConfig = "DeadLetterConfig"
            case environment = "Environment"
            case functionName = "FunctionName"
            case handler = "Handler"
            case kmsKeyArn = "KmsKeyArn"
            case lastModified = "LastModified"
            case layers = "Layers"
            case masterArn = "MasterArn"
            case memorySize = "MemorySize"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case version = "Version"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsLambdaFunctionEnvironment: AWSEncodableShape & AWSDecodableShape {

        /// An AwsLambdaFunctionEnvironmentError object.
        public let error: AwsLambdaFunctionEnvironmentError?
        /// Environment variable key-value pairs.
        public let variables: [String: String]?

        public init(error: AwsLambdaFunctionEnvironmentError? = nil, variables: [String: String]? = nil) {
            self.error = error
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.error?.validate(name: "\(name).error")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "variables[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case variables = "Variables"
        }
    }

    public struct AwsLambdaFunctionEnvironmentError: AWSEncodableShape & AWSDecodableShape {

        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        public func validate(name: String) throws {
            try validate(self.errorCode, name: "errorCode", parent: name, pattern: ".*\\S.*")
            try validate(self.message, name: "message", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AwsLambdaFunctionLayer: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the function layer.
        public let arn: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int?

        public init(arn: String? = nil, codeSize: Int? = nil) {
            self.arn = arn
            self.codeSize = codeSize
        }

        public func validate(name: String) throws {
            try validate(self.arn, name: "arn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case codeSize = "CodeSize"
        }
    }

    public struct AwsLambdaFunctionTracingConfig: AWSEncodableShape & AWSDecodableShape {

        /// The tracing mode.
        public let mode: String?

        public init(mode: String? = nil) {
            self.mode = mode
        }

        public func validate(name: String) throws {
            try validate(self.mode, name: "mode", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct AwsLambdaFunctionVpcConfig: AWSEncodableShape & AWSDecodableShape {

        /// A list of VPC security groups IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: ".*\\S.*")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VpcId"
        }
    }

    public struct AwsLambdaLayerVersionDetails: AWSEncodableShape & AWSDecodableShape {

        /// The layer's compatible runtimes. Maximum number of 5 items. Valid values: nodejs10.x | nodejs12.x | java8 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | dotnetcore1.0 | dotnetcore2.1 | go1.x | ruby2.5 | provided 
        public let compatibleRuntimes: [String]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000. 
        public let createdDate: String?
        /// The version number.
        public let version: Int64?

        public init(compatibleRuntimes: [String]? = nil, createdDate: String? = nil, version: Int64? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.version = version
        }

        public func validate(name: String) throws {
            try self.compatibleRuntimes?.forEach {
                try validate($0, name: "compatibleRuntimes[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.createdDate, name: "createdDate", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case createdDate = "CreatedDate"
            case version = "Version"
        }
    }

    public struct AwsRdsDbInstanceAssociatedRole: AWSEncodableShape & AWSDecodableShape {

        /// The name of the feature associated with the IAM)role.
        public let featureName: String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
        public let roleArn: String?
        /// Describes the state of the association between the IAM role and the DB instance. The Status property returns one of the following values:    ACTIVE - the IAM role ARN is associated with the DB instance and can be used to access other AWS services on your behalf.    PENDING - the IAM role ARN is being associated with the DB instance.    INVALID - the IAM role ARN is associated with the DB instance, but the DB instance is unable to assume the IAM role in order to access other AWS services on your behalf.   
        public let status: String?

        public init(featureName: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.featureName, name: "featureName", parent: name, pattern: ".*\\S.*")
            try validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*\\S.*")
            try validate(self.status, name: "status", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct AwsRdsDbInstanceDetails: AWSEncodableShape & AWSDecodableShape {

        /// The AWS Identity and Access Management (IAM) roles associated with the DB instance.
        public let associatedRoles: [AwsRdsDbInstanceAssociatedRole]?
        /// The identifier of the CA certificate for this DB instance.
        public let cACertificateIdentifier: String?
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public let dBClusterIdentifier: String?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public let dBInstanceClass: String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public let dBInstanceIdentifier: String?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public let dbInstancePort: Int?
        /// The AWS Region-unique, immutable identifier for the DB instance. This identifier is found in AWS CloudTrail log entries whenever the AWS KMS key for the DB instance is accessed. 
        public let dbiResourceId: String?
        /// The meaning of this parameter differs according to the database engine you use.  MySQL, MariaDB, SQL Server, PostgreSQL  Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.  Oracle  Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance. 
        public let dBName: String?
        /// Indicates whether the DB instance has deletion protection enabled. When deletion protection is enabled, the database cannot be deleted.
        public let deletionProtection: Bool?
        /// Specifies the connection endpoint.
        public let endpoint: AwsRdsDbInstanceEndpoint?
        /// Provides the name of the database engine to use for this DB instance.
        public let engine: String?
        /// Indicates the database engine version.
        public let engineVersion: String?
        /// True if mapping of AWS Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false. IAM database authentication can be enabled for the following database engines.   For MySQL 5.6, minor version 5.6.34 or higher   For MySQL 5.7, minor version 5.7.16 or higher   Aurora 5.6 or higher  
        public let iAMDatabaseAuthenticationEnabled: Bool?
        /// Provides the date and time the DB instance was created.
        public let instanceCreateTime: String?
        /// If StorageEncrypted is true, the AWS KMS key identifier for the encrypted DB instance.
        public let kmsKeyId: String?
        /// Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address. 
        public let publiclyAccessible: Bool?
        /// Specifies whether the DB instance is encrypted.
        public let storageEncrypted: Bool?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public let tdeCredentialArn: String?
        /// A list of VPC security groups that the DB instance belongs to.
        public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

        public init(associatedRoles: [AwsRdsDbInstanceAssociatedRole]? = nil, cACertificateIdentifier: String? = nil, dBClusterIdentifier: String? = nil, dBInstanceClass: String? = nil, dBInstanceIdentifier: String? = nil, dbInstancePort: Int? = nil, dbiResourceId: String? = nil, dBName: String? = nil, deletionProtection: Bool? = nil, endpoint: AwsRdsDbInstanceEndpoint? = nil, engine: String? = nil, engineVersion: String? = nil, iAMDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: String? = nil, kmsKeyId: String? = nil, publiclyAccessible: Bool? = nil, storageEncrypted: Bool? = nil, tdeCredentialArn: String? = nil, vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil) {
            self.associatedRoles = associatedRoles
            self.cACertificateIdentifier = cACertificateIdentifier
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dbInstancePort = dbInstancePort
            self.dbiResourceId = dbiResourceId
            self.dBName = dBName
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.publiclyAccessible = publiclyAccessible
            self.storageEncrypted = storageEncrypted
            self.tdeCredentialArn = tdeCredentialArn
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.associatedRoles?.forEach {
                try $0.validate(name: "\(name).associatedRoles[]")
            }
            try validate(self.cACertificateIdentifier, name: "cACertificateIdentifier", parent: name, pattern: ".*\\S.*")
            try validate(self.dBClusterIdentifier, name: "dBClusterIdentifier", parent: name, pattern: ".*\\S.*")
            try validate(self.dBInstanceClass, name: "dBInstanceClass", parent: name, pattern: ".*\\S.*")
            try validate(self.dBInstanceIdentifier, name: "dBInstanceIdentifier", parent: name, pattern: ".*\\S.*")
            try validate(self.dbiResourceId, name: "dbiResourceId", parent: name, pattern: ".*\\S.*")
            try validate(self.dBName, name: "dBName", parent: name, pattern: ".*\\S.*")
            try self.endpoint?.validate(name: "\(name).endpoint")
            try validate(self.engine, name: "engine", parent: name, pattern: ".*\\S.*")
            try validate(self.engineVersion, name: "engineVersion", parent: name, pattern: ".*\\S.*")
            try validate(self.instanceCreateTime, name: "instanceCreateTime", parent: name, pattern: ".*\\S.*")
            try validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*\\S.*")
            try validate(self.tdeCredentialArn, name: "tdeCredentialArn", parent: name, pattern: ".*\\S.*")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedRoles = "AssociatedRoles"
            case cACertificateIdentifier = "CACertificateIdentifier"
            case dBClusterIdentifier = "DBClusterIdentifier"
            case dBInstanceClass = "DBInstanceClass"
            case dBInstanceIdentifier = "DBInstanceIdentifier"
            case dbInstancePort = "DbInstancePort"
            case dbiResourceId = "DbiResourceId"
            case dBName = "DBName"
            case deletionProtection = "DeletionProtection"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case kmsKeyId = "KmsKeyId"
            case publiclyAccessible = "PubliclyAccessible"
            case storageEncrypted = "StorageEncrypted"
            case tdeCredentialArn = "TdeCredentialArn"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRdsDbInstanceEndpoint: AWSEncodableShape & AWSDecodableShape {

        /// Specifies the DNS address of the DB instance.
        public let address: String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Specifies the port that the database engine is listening on.
        public let port: Int?

        public init(address: String? = nil, hostedZoneId: String? = nil, port: Int? = nil) {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }

        public func validate(name: String) throws {
            try validate(self.address, name: "address", parent: name, pattern: ".*\\S.*")
            try validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case hostedZoneId = "HostedZoneId"
            case port = "Port"
        }
    }

    public struct AwsRdsDbInstanceVpcSecurityGroup: AWSEncodableShape & AWSDecodableShape {

        /// The status of the VPC security group.
        public let status: String?
        /// The name of the VPC security group.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public func validate(name: String) throws {
            try validate(self.status, name: "status", parent: name, pattern: ".*\\S.*")
            try validate(self.vpcSecurityGroupId, name: "vpcSecurityGroupId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct AwsS3BucketDetails: AWSEncodableShape & AWSDecodableShape {

        /// The date and time when the S3 bucket was created.
        public let createdAt: String?
        /// The canonical user ID of the owner of the S3 bucket.
        public let ownerId: String?
        /// The display name of the owner of the S3 bucket.
        public let ownerName: String?
        /// The encryption rules that are applied to the S3 bucket.
        public let serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration?

        public init(createdAt: String? = nil, ownerId: String? = nil, ownerName: String? = nil, serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration? = nil) {
            self.createdAt = createdAt
            self.ownerId = ownerId
            self.ownerName = ownerName
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        }

        public func validate(name: String) throws {
            try validate(self.createdAt, name: "createdAt", parent: name, pattern: ".*\\S.*")
            try validate(self.ownerId, name: "ownerId", parent: name, pattern: ".*\\S.*")
            try validate(self.ownerName, name: "ownerName", parent: name, pattern: ".*\\S.*")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case ownerId = "OwnerId"
            case ownerName = "OwnerName"
            case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        }
    }

    public struct AwsS3BucketServerSideEncryptionByDefault: AWSEncodableShape & AWSDecodableShape {

        /// AWS KMS customer master key (CMK) ID to use for the default encryption.
        public let kMSMasterKeyID: String?
        /// Server-side encryption algorithm to use for the default encryption.
        public let sSEAlgorithm: String?

        public init(kMSMasterKeyID: String? = nil, sSEAlgorithm: String? = nil) {
            self.kMSMasterKeyID = kMSMasterKeyID
            self.sSEAlgorithm = sSEAlgorithm
        }

        public func validate(name: String) throws {
            try validate(self.kMSMasterKeyID, name: "kMSMasterKeyID", parent: name, pattern: ".*\\S.*")
            try validate(self.sSEAlgorithm, name: "sSEAlgorithm", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case kMSMasterKeyID = "KMSMasterKeyID"
            case sSEAlgorithm = "SSEAlgorithm"
        }
    }

    public struct AwsS3BucketServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// The encryption rules that are applied to the S3 bucket.
        public let rules: [AwsS3BucketServerSideEncryptionRule]?

        public init(rules: [AwsS3BucketServerSideEncryptionRule]? = nil) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct AwsS3BucketServerSideEncryptionRule: AWSEncodableShape & AWSDecodableShape {

        /// Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption is applied.
        public let applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault?

        public init(applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault? = nil) {
            self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
        }

        public func validate(name: String) throws {
            try self.applyServerSideEncryptionByDefault?.validate(name: "\(name).applyServerSideEncryptionByDefault")
        }

        private enum CodingKeys: String, CodingKey {
            case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
        }
    }

    public struct AwsS3ObjectDetails: AWSEncodableShape & AWSDecodableShape {

        /// A standard MIME type describing the format of the object data.
        public let contentType: String?
        /// The opaque identifier assigned by a web server to a specific version of a resource found at a URL.
        public let eTag: String?
        /// The date and time when the object was last modified.
        public let lastModified: String?
        /// If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.
        public let serverSideEncryption: String?
        /// The identifier of the AWS Key Management Service (AWS KMS) symmetric customer managed customer master key (CMK) that was used for the object.
        public let sSEKMSKeyId: String?
        /// The version of the object.
        public let versionId: String?

        public init(contentType: String? = nil, eTag: String? = nil, lastModified: String? = nil, serverSideEncryption: String? = nil, sSEKMSKeyId: String? = nil, versionId: String? = nil) {
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.serverSideEncryption = serverSideEncryption
            self.sSEKMSKeyId = sSEKMSKeyId
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try validate(self.contentType, name: "contentType", parent: name, pattern: ".*\\S.*")
            try validate(self.eTag, name: "eTag", parent: name, pattern: ".*\\S.*")
            try validate(self.lastModified, name: "lastModified", parent: name, pattern: ".*\\S.*")
            try validate(self.serverSideEncryption, name: "serverSideEncryption", parent: name, pattern: ".*\\S.*")
            try validate(self.sSEKMSKeyId, name: "sSEKMSKeyId", parent: name, pattern: ".*\\S.*")
            try validate(self.versionId, name: "versionId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case eTag = "ETag"
            case lastModified = "LastModified"
            case serverSideEncryption = "ServerSideEncryption"
            case sSEKMSKeyId = "SSEKMSKeyId"
            case versionId = "VersionId"
        }
    }

    public struct AwsSecurityFinding: AWSEncodableShape & AWSDecodableShape {

        /// The AWS account ID that a finding is generated in.
        public let awsAccountId: String
        /// This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS AWS Foundations. Contains security standard-related finding details.
        public let compliance: Compliance?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider created the potential security issue that a finding captured.
        public let createdAt: String
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// A finding's description.  In this release, Description is a required property. 
        public let description: String
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.
        public let firstObservedAt: String?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plug-in, etc. 
        public let generatorId: String
        /// The security findings provider-specific identifier for a finding.
        public let id: String
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.
        public let lastObservedAt: String?
        /// A list of malware related to a finding.
        public let malware: [Malware]?
        /// The details of network-related information about a finding.
        public let network: Network?
        /// A user-defined note added to a finding.
        public let note: Note?
        /// The details of process-related information about a finding.
        public let process: ProcessDetails?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        public let productArn: String
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public let productFields: [String: String]?
        /// The record state of a finding.
        public let recordState: RecordState?
        /// A list of related findings.
        public let relatedFindings: [RelatedFinding]?
        /// A data type that describes the remediation options for a finding.
        public let remediation: Remediation?
        /// A set of resource data types that describe the resources that the finding refers to.
        public let resources: [Resource]
        /// The schema version that a finding is formatted for.
        public let schemaVersion: String
        /// A finding's severity.
        public let severity: Severity
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public let sourceUrl: String?
        /// Threat intelligence details related to a finding.
        public let threatIntelIndicators: [ThreatIntelIndicator]?
        /// A finding's title.  In this release, Title is a required property. 
        public let title: String
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let types: [String]
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. 
        public let updatedAt: String
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. 
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding. 
        public let verificationState: VerificationState?
        /// Provides information about the status of the investigation into a finding.
        public let workflow: Workflow?
        /// The workflow state of a finding. 
        public let workflowState: WorkflowState?

        public init(awsAccountId: String, compliance: Compliance? = nil, confidence: Int? = nil, createdAt: String, criticality: Int? = nil, description: String, firstObservedAt: String? = nil, generatorId: String, id: String, lastObservedAt: String? = nil, malware: [Malware]? = nil, network: Network? = nil, note: Note? = nil, process: ProcessDetails? = nil, productArn: String, productFields: [String: String]? = nil, recordState: RecordState? = nil, relatedFindings: [RelatedFinding]? = nil, remediation: Remediation? = nil, resources: [Resource], schemaVersion: String, severity: Severity, sourceUrl: String? = nil, threatIntelIndicators: [ThreatIntelIndicator]? = nil, title: String, types: [String], updatedAt: String, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, workflow: Workflow? = nil, workflowState: WorkflowState? = nil) {
            self.awsAccountId = awsAccountId
            self.compliance = compliance
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.malware = malware
            self.network = network
            self.note = note
            self.process = process
            self.productArn = productArn
            self.productFields = productFields
            self.recordState = recordState
            self.relatedFindings = relatedFindings
            self.remediation = remediation
            self.resources = resources
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.sourceUrl = sourceUrl
            self.threatIntelIndicators = threatIntelIndicators
            self.title = title
            self.types = types
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflow = workflow
            self.workflowState = workflowState
        }

        public func validate(name: String) throws {
            try validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: ".*\\S.*")
            try self.compliance?.validate(name: "\(name).compliance")
            try validate(self.createdAt, name: "createdAt", parent: name, pattern: ".*\\S.*")
            try validate(self.description, name: "description", parent: name, pattern: ".*\\S.*")
            try validate(self.firstObservedAt, name: "firstObservedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.generatorId, name: "generatorId", parent: name, pattern: ".*\\S.*")
            try validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
            try validate(self.lastObservedAt, name: "lastObservedAt", parent: name, pattern: ".*\\S.*")
            try self.malware?.forEach {
                try $0.validate(name: "\(name).malware[]")
            }
            try self.network?.validate(name: "\(name).network")
            try self.note?.validate(name: "\(name).note")
            try self.process?.validate(name: "\(name).process")
            try validate(self.productArn, name: "productArn", parent: name, pattern: ".*\\S.*")
            try self.productFields?.forEach {
                try validate($0.key, name: "productFields.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "productFields[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.remediation?.validate(name: "\(name).remediation")
            try self.resources.forEach {
                try $0.validate(name: "\(name).resources[]")
            }
            try validate(self.schemaVersion, name: "schemaVersion", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: ".*\\S.*")
            try self.threatIntelIndicators?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicators[]")
            }
            try validate(self.title, name: "title", parent: name, pattern: ".*\\S.*")
            try self.types.forEach {
                try validate($0, name: "types[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.updatedAt, name: "updatedAt", parent: name, pattern: ".*\\S.*")
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case compliance = "Compliance"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case lastObservedAt = "LastObservedAt"
            case malware = "Malware"
            case network = "Network"
            case note = "Note"
            case process = "Process"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case recordState = "RecordState"
            case relatedFindings = "RelatedFindings"
            case remediation = "Remediation"
            case resources = "Resources"
            case schemaVersion = "SchemaVersion"
            case severity = "Severity"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicators = "ThreatIntelIndicators"
            case title = "Title"
            case types = "Types"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflow = "Workflow"
            case workflowState = "WorkflowState"
        }
    }

    public struct AwsSecurityFindingFilters: AWSEncodableShape & AWSDecodableShape {

        /// The AWS account ID that a finding is generated in.
        public let awsAccountId: [StringFilter]?
        /// The name of the findings provider (company) that owns the solution (product) that generates findings.
        public let companyName: [StringFilter]?
        /// Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details.
        public let complianceStatus: [StringFilter]?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: [NumberFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.
        public let createdAt: [DateFilter]?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: [NumberFilter]?
        /// A finding's description.
        public let description: [StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.
        public let firstObservedAt: [DateFilter]?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plug-in, etc.
        public let generatorId: [StringFilter]?
        /// The security findings provider-specific identifier for a finding.
        public let id: [StringFilter]?
        /// A keyword for a finding.
        public let keyword: [KeywordFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.
        public let lastObservedAt: [DateFilter]?
        /// The name of the malware that was observed.
        public let malwareName: [StringFilter]?
        /// The filesystem path of the malware that was observed.
        public let malwarePath: [StringFilter]?
        /// The state of the malware that was observed.
        public let malwareState: [StringFilter]?
        /// The type of the malware that was observed.
        public let malwareType: [StringFilter]?
        /// The destination domain of network-related information about a finding.
        public let networkDestinationDomain: [StringFilter]?
        /// The destination IPv4 address of network-related information about a finding.
        public let networkDestinationIpV4: [IpFilter]?
        /// The destination IPv6 address of network-related information about a finding.
        public let networkDestinationIpV6: [IpFilter]?
        /// The destination port of network-related information about a finding.
        public let networkDestinationPort: [NumberFilter]?
        /// Indicates the direction of network traffic associated with a finding.
        public let networkDirection: [StringFilter]?
        /// The protocol of network-related information about a finding.
        public let networkProtocol: [StringFilter]?
        /// The source domain of network-related information about a finding.
        public let networkSourceDomain: [StringFilter]?
        /// The source IPv4 address of network-related information about a finding.
        public let networkSourceIpV4: [IpFilter]?
        /// The source IPv6 address of network-related information about a finding.
        public let networkSourceIpV6: [IpFilter]?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let networkSourceMac: [StringFilter]?
        /// The source port of network-related information about a finding.
        public let networkSourcePort: [NumberFilter]?
        /// The text of a note.
        public let noteText: [StringFilter]?
        /// The timestamp of when the note was updated.
        public let noteUpdatedAt: [DateFilter]?
        /// The principal that created a note.
        public let noteUpdatedBy: [StringFilter]?
        /// The date/time that the process was launched.
        public let processLaunchedAt: [DateFilter]?
        /// The name of the process.
        public let processName: [StringFilter]?
        /// The parent process ID.
        public let processParentPid: [NumberFilter]?
        /// The path to the process executable.
        public let processPath: [StringFilter]?
        /// The process ID.
        public let processPid: [NumberFilter]?
        /// The date/time that the process was terminated.
        public let processTerminatedAt: [DateFilter]?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.
        public let productArn: [StringFilter]?
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public let productFields: [MapFilter]?
        /// The name of the solution (product) that generates findings.
        public let productName: [StringFilter]?
        /// The recommendation of what to do about the issue described in a finding.
        public let recommendationText: [StringFilter]?
        /// The updated record state for the finding.
        public let recordState: [StringFilter]?
        /// The solution-generated identifier for a related finding.
        public let relatedFindingsId: [StringFilter]?
        /// The ARN of the solution that generated a related finding.
        public let relatedFindingsProductArn: [StringFilter]?
        /// The IAM profile ARN of the instance.
        public let resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let resourceAwsEc2InstanceImageId: [StringFilter]?
        /// The IPv4 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV4Addresses: [IpFilter]?
        /// The IPv6 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV6Addresses: [IpFilter]?
        /// The key name associated with the instance.
        public let resourceAwsEc2InstanceKeyName: [StringFilter]?
        /// The date and time the instance was launched.
        public let resourceAwsEc2InstanceLaunchedAt: [DateFilter]?
        /// The identifier of the subnet that the instance was launched in.
        public let resourceAwsEc2InstanceSubnetId: [StringFilter]?
        /// The instance type of the instance.
        public let resourceAwsEc2InstanceType: [StringFilter]?
        /// The identifier of the VPC that the instance was launched in.
        public let resourceAwsEc2InstanceVpcId: [StringFilter]?
        /// The creation date/time of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyCreatedAt: [DateFilter]?
        /// The status of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyStatus: [StringFilter]?
        /// The user associated with the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyUserName: [StringFilter]?
        /// The canonical user ID of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerId: [StringFilter]?
        /// The display name of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerName: [StringFilter]?
        /// The identifier of the image related to a finding.
        public let resourceContainerImageId: [StringFilter]?
        /// The name of the image related to a finding.
        public let resourceContainerImageName: [StringFilter]?
        /// The date/time that the container was started.
        public let resourceContainerLaunchedAt: [DateFilter]?
        /// The name of the container related to a finding.
        public let resourceContainerName: [StringFilter]?
        /// The details of a resource that doesn't have a specific subfield for the resource type defined.
        public let resourceDetailsOther: [MapFilter]?
        /// The canonical identifier for the given resource type.
        public let resourceId: [StringFilter]?
        /// The canonical AWS partition name that the Region is assigned to.
        public let resourcePartition: [StringFilter]?
        /// The canonical AWS external Region name where this resource is located.
        public let resourceRegion: [StringFilter]?
        /// A list of AWS tags associated with a resource at the time the finding was processed.
        public let resourceTags: [MapFilter]?
        /// Specifies the type of the resource that details are provided for.
        public let resourceType: [StringFilter]?
        /// The label of a finding's severity.
        public let severityLabel: [StringFilter]?
        /// The normalized severity of a finding.
        public let severityNormalized: [NumberFilter]?
        /// The native severity as defined by the security-findings provider's solution that generated the finding.
        public let severityProduct: [NumberFilter]?
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public let sourceUrl: [StringFilter]?
        /// The category of a threat intelligence indicator.
        public let threatIntelIndicatorCategory: [StringFilter]?
        /// The date/time of the last observation of a threat intelligence indicator.
        public let threatIntelIndicatorLastObservedAt: [DateFilter]?
        /// The source of the threat intelligence.
        public let threatIntelIndicatorSource: [StringFilter]?
        /// The URL for more details from the source of the threat intelligence.
        public let threatIntelIndicatorSourceUrl: [StringFilter]?
        /// The type of a threat intelligence indicator.
        public let threatIntelIndicatorType: [StringFilter]?
        /// The value of a threat intelligence indicator.
        public let threatIntelIndicatorValue: [StringFilter]?
        /// A finding's title.
        public let title: [StringFilter]?
        /// A finding type in the format of namespace/category/classifier that classifies a finding.
        public let `type`: [StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. 
        public let updatedAt: [DateFilter]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. 
        public let userDefinedFields: [MapFilter]?
        /// The veracity of a finding.
        public let verificationState: [StringFilter]?
        /// The workflow state of a finding.
        public let workflowState: [StringFilter]?
        /// The status of the investigation into a finding. Allowed values are the following.    NEW - The initial state of a finding, before it is reviewed.    NOTIFIED - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    SUPPRESSED - The finding will not be reviewed again and will not be acted upon.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.   
        public let workflowStatus: [StringFilter]?

        public init(awsAccountId: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, keyword: [KeywordFilter]? = nil, lastObservedAt: [DateFilter]? = nil, malwareName: [StringFilter]? = nil, malwarePath: [StringFilter]? = nil, malwareState: [StringFilter]? = nil, malwareType: [StringFilter]? = nil, networkDestinationDomain: [StringFilter]? = nil, networkDestinationIpV4: [IpFilter]? = nil, networkDestinationIpV6: [IpFilter]? = nil, networkDestinationPort: [NumberFilter]? = nil, networkDirection: [StringFilter]? = nil, networkProtocol: [StringFilter]? = nil, networkSourceDomain: [StringFilter]? = nil, networkSourceIpV4: [IpFilter]? = nil, networkSourceIpV6: [IpFilter]? = nil, networkSourceMac: [StringFilter]? = nil, networkSourcePort: [NumberFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, processLaunchedAt: [DateFilter]? = nil, processName: [StringFilter]? = nil, processParentPid: [NumberFilter]? = nil, processPath: [StringFilter]? = nil, processPid: [NumberFilter]? = nil, processTerminatedAt: [DateFilter]? = nil, productArn: [StringFilter]? = nil, productFields: [MapFilter]? = nil, productName: [StringFilter]? = nil, recommendationText: [StringFilter]? = nil, recordState: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil, resourceAwsEc2InstanceImageId: [StringFilter]? = nil, resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceKeyName: [StringFilter]? = nil, resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil, resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil, resourceAwsEc2InstanceType: [StringFilter]? = nil, resourceAwsEc2InstanceVpcId: [StringFilter]? = nil, resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil, resourceAwsIamAccessKeyStatus: [StringFilter]? = nil, resourceAwsIamAccessKeyUserName: [StringFilter]? = nil, resourceAwsS3BucketOwnerId: [StringFilter]? = nil, resourceAwsS3BucketOwnerName: [StringFilter]? = nil, resourceContainerImageId: [StringFilter]? = nil, resourceContainerImageName: [StringFilter]? = nil, resourceContainerLaunchedAt: [DateFilter]? = nil, resourceContainerName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, severityLabel: [StringFilter]? = nil, severityNormalized: [NumberFilter]? = nil, severityProduct: [NumberFilter]? = nil, sourceUrl: [StringFilter]? = nil, threatIntelIndicatorCategory: [StringFilter]? = nil, threatIntelIndicatorLastObservedAt: [DateFilter]? = nil, threatIntelIndicatorSource: [StringFilter]? = nil, threatIntelIndicatorSourceUrl: [StringFilter]? = nil, threatIntelIndicatorType: [StringFilter]? = nil, threatIntelIndicatorValue: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, workflowState: [StringFilter]? = nil, workflowStatus: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = keyword
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severityLabel = severityLabel
            self.severityNormalized = severityNormalized
            self.severityProduct = severityProduct
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.`type` = `type`
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.companyName?.forEach {
                try $0.validate(name: "\(name).companyName[]")
            }
            try self.complianceStatus?.forEach {
                try $0.validate(name: "\(name).complianceStatus[]")
            }
            try self.createdAt?.forEach {
                try $0.validate(name: "\(name).createdAt[]")
            }
            try self.description?.forEach {
                try $0.validate(name: "\(name).description[]")
            }
            try self.firstObservedAt?.forEach {
                try $0.validate(name: "\(name).firstObservedAt[]")
            }
            try self.generatorId?.forEach {
                try $0.validate(name: "\(name).generatorId[]")
            }
            try self.id?.forEach {
                try $0.validate(name: "\(name).id[]")
            }
            try self.keyword?.forEach {
                try $0.validate(name: "\(name).keyword[]")
            }
            try self.lastObservedAt?.forEach {
                try $0.validate(name: "\(name).lastObservedAt[]")
            }
            try self.malwareName?.forEach {
                try $0.validate(name: "\(name).malwareName[]")
            }
            try self.malwarePath?.forEach {
                try $0.validate(name: "\(name).malwarePath[]")
            }
            try self.malwareState?.forEach {
                try $0.validate(name: "\(name).malwareState[]")
            }
            try self.malwareType?.forEach {
                try $0.validate(name: "\(name).malwareType[]")
            }
            try self.networkDestinationDomain?.forEach {
                try $0.validate(name: "\(name).networkDestinationDomain[]")
            }
            try self.networkDestinationIpV4?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV4[]")
            }
            try self.networkDestinationIpV6?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV6[]")
            }
            try self.networkDirection?.forEach {
                try $0.validate(name: "\(name).networkDirection[]")
            }
            try self.networkProtocol?.forEach {
                try $0.validate(name: "\(name).networkProtocol[]")
            }
            try self.networkSourceDomain?.forEach {
                try $0.validate(name: "\(name).networkSourceDomain[]")
            }
            try self.networkSourceIpV4?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV4[]")
            }
            try self.networkSourceIpV6?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV6[]")
            }
            try self.networkSourceMac?.forEach {
                try $0.validate(name: "\(name).networkSourceMac[]")
            }
            try self.noteText?.forEach {
                try $0.validate(name: "\(name).noteText[]")
            }
            try self.noteUpdatedAt?.forEach {
                try $0.validate(name: "\(name).noteUpdatedAt[]")
            }
            try self.noteUpdatedBy?.forEach {
                try $0.validate(name: "\(name).noteUpdatedBy[]")
            }
            try self.processLaunchedAt?.forEach {
                try $0.validate(name: "\(name).processLaunchedAt[]")
            }
            try self.processName?.forEach {
                try $0.validate(name: "\(name).processName[]")
            }
            try self.processPath?.forEach {
                try $0.validate(name: "\(name).processPath[]")
            }
            try self.processTerminatedAt?.forEach {
                try $0.validate(name: "\(name).processTerminatedAt[]")
            }
            try self.productArn?.forEach {
                try $0.validate(name: "\(name).productArn[]")
            }
            try self.productFields?.forEach {
                try $0.validate(name: "\(name).productFields[]")
            }
            try self.productName?.forEach {
                try $0.validate(name: "\(name).productName[]")
            }
            try self.recommendationText?.forEach {
                try $0.validate(name: "\(name).recommendationText[]")
            }
            try self.recordState?.forEach {
                try $0.validate(name: "\(name).recordState[]")
            }
            try self.relatedFindingsId?.forEach {
                try $0.validate(name: "\(name).relatedFindingsId[]")
            }
            try self.relatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).relatedFindingsProductArn[]")
            }
            try self.resourceAwsEc2InstanceIamInstanceProfileArn?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIamInstanceProfileArn[]")
            }
            try self.resourceAwsEc2InstanceImageId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceImageId[]")
            }
            try self.resourceAwsEc2InstanceIpV4Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV4Addresses[]")
            }
            try self.resourceAwsEc2InstanceIpV6Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV6Addresses[]")
            }
            try self.resourceAwsEc2InstanceKeyName?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceKeyName[]")
            }
            try self.resourceAwsEc2InstanceLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceLaunchedAt[]")
            }
            try self.resourceAwsEc2InstanceSubnetId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceSubnetId[]")
            }
            try self.resourceAwsEc2InstanceType?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceType[]")
            }
            try self.resourceAwsEc2InstanceVpcId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceVpcId[]")
            }
            try self.resourceAwsIamAccessKeyCreatedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyCreatedAt[]")
            }
            try self.resourceAwsIamAccessKeyStatus?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyStatus[]")
            }
            try self.resourceAwsIamAccessKeyUserName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyUserName[]")
            }
            try self.resourceAwsS3BucketOwnerId?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerId[]")
            }
            try self.resourceAwsS3BucketOwnerName?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerName[]")
            }
            try self.resourceContainerImageId?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageId[]")
            }
            try self.resourceContainerImageName?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageName[]")
            }
            try self.resourceContainerLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceContainerLaunchedAt[]")
            }
            try self.resourceContainerName?.forEach {
                try $0.validate(name: "\(name).resourceContainerName[]")
            }
            try self.resourceDetailsOther?.forEach {
                try $0.validate(name: "\(name).resourceDetailsOther[]")
            }
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.resourcePartition?.forEach {
                try $0.validate(name: "\(name).resourcePartition[]")
            }
            try self.resourceRegion?.forEach {
                try $0.validate(name: "\(name).resourceRegion[]")
            }
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.severityLabel?.forEach {
                try $0.validate(name: "\(name).severityLabel[]")
            }
            try self.sourceUrl?.forEach {
                try $0.validate(name: "\(name).sourceUrl[]")
            }
            try self.threatIntelIndicatorCategory?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorCategory[]")
            }
            try self.threatIntelIndicatorLastObservedAt?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorLastObservedAt[]")
            }
            try self.threatIntelIndicatorSource?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSource[]")
            }
            try self.threatIntelIndicatorSourceUrl?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSourceUrl[]")
            }
            try self.threatIntelIndicatorType?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorType[]")
            }
            try self.threatIntelIndicatorValue?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorValue[]")
            }
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.`type`?.forEach {
                try $0.validate(name: "\(name).`type`[]")
            }
            try self.updatedAt?.forEach {
                try $0.validate(name: "\(name).updatedAt[]")
            }
            try self.userDefinedFields?.forEach {
                try $0.validate(name: "\(name).userDefinedFields[]")
            }
            try self.verificationState?.forEach {
                try $0.validate(name: "\(name).verificationState[]")
            }
            try self.workflowState?.forEach {
                try $0.validate(name: "\(name).workflowState[]")
            }
            try self.workflowStatus?.forEach {
                try $0.validate(name: "\(name).workflowStatus[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case companyName = "CompanyName"
            case complianceStatus = "ComplianceStatus"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case keyword = "Keyword"
            case lastObservedAt = "LastObservedAt"
            case malwareName = "MalwareName"
            case malwarePath = "MalwarePath"
            case malwareState = "MalwareState"
            case malwareType = "MalwareType"
            case networkDestinationDomain = "NetworkDestinationDomain"
            case networkDestinationIpV4 = "NetworkDestinationIpV4"
            case networkDestinationIpV6 = "NetworkDestinationIpV6"
            case networkDestinationPort = "NetworkDestinationPort"
            case networkDirection = "NetworkDirection"
            case networkProtocol = "NetworkProtocol"
            case networkSourceDomain = "NetworkSourceDomain"
            case networkSourceIpV4 = "NetworkSourceIpV4"
            case networkSourceIpV6 = "NetworkSourceIpV6"
            case networkSourceMac = "NetworkSourceMac"
            case networkSourcePort = "NetworkSourcePort"
            case noteText = "NoteText"
            case noteUpdatedAt = "NoteUpdatedAt"
            case noteUpdatedBy = "NoteUpdatedBy"
            case processLaunchedAt = "ProcessLaunchedAt"
            case processName = "ProcessName"
            case processParentPid = "ProcessParentPid"
            case processPath = "ProcessPath"
            case processPid = "ProcessPid"
            case processTerminatedAt = "ProcessTerminatedAt"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case productName = "ProductName"
            case recommendationText = "RecommendationText"
            case recordState = "RecordState"
            case relatedFindingsId = "RelatedFindingsId"
            case relatedFindingsProductArn = "RelatedFindingsProductArn"
            case resourceAwsEc2InstanceIamInstanceProfileArn = "ResourceAwsEc2InstanceIamInstanceProfileArn"
            case resourceAwsEc2InstanceImageId = "ResourceAwsEc2InstanceImageId"
            case resourceAwsEc2InstanceIpV4Addresses = "ResourceAwsEc2InstanceIpV4Addresses"
            case resourceAwsEc2InstanceIpV6Addresses = "ResourceAwsEc2InstanceIpV6Addresses"
            case resourceAwsEc2InstanceKeyName = "ResourceAwsEc2InstanceKeyName"
            case resourceAwsEc2InstanceLaunchedAt = "ResourceAwsEc2InstanceLaunchedAt"
            case resourceAwsEc2InstanceSubnetId = "ResourceAwsEc2InstanceSubnetId"
            case resourceAwsEc2InstanceType = "ResourceAwsEc2InstanceType"
            case resourceAwsEc2InstanceVpcId = "ResourceAwsEc2InstanceVpcId"
            case resourceAwsIamAccessKeyCreatedAt = "ResourceAwsIamAccessKeyCreatedAt"
            case resourceAwsIamAccessKeyStatus = "ResourceAwsIamAccessKeyStatus"
            case resourceAwsIamAccessKeyUserName = "ResourceAwsIamAccessKeyUserName"
            case resourceAwsS3BucketOwnerId = "ResourceAwsS3BucketOwnerId"
            case resourceAwsS3BucketOwnerName = "ResourceAwsS3BucketOwnerName"
            case resourceContainerImageId = "ResourceContainerImageId"
            case resourceContainerImageName = "ResourceContainerImageName"
            case resourceContainerLaunchedAt = "ResourceContainerLaunchedAt"
            case resourceContainerName = "ResourceContainerName"
            case resourceDetailsOther = "ResourceDetailsOther"
            case resourceId = "ResourceId"
            case resourcePartition = "ResourcePartition"
            case resourceRegion = "ResourceRegion"
            case resourceTags = "ResourceTags"
            case resourceType = "ResourceType"
            case severityLabel = "SeverityLabel"
            case severityNormalized = "SeverityNormalized"
            case severityProduct = "SeverityProduct"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicatorCategory = "ThreatIntelIndicatorCategory"
            case threatIntelIndicatorLastObservedAt = "ThreatIntelIndicatorLastObservedAt"
            case threatIntelIndicatorSource = "ThreatIntelIndicatorSource"
            case threatIntelIndicatorSourceUrl = "ThreatIntelIndicatorSourceUrl"
            case threatIntelIndicatorType = "ThreatIntelIndicatorType"
            case threatIntelIndicatorValue = "ThreatIntelIndicatorValue"
            case title = "Title"
            case `type` = "Type"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflowState = "WorkflowState"
            case workflowStatus = "WorkflowStatus"
        }
    }

    public struct AwsSecurityFindingIdentifier: AWSEncodableShape & AWSDecodableShape {

        /// The identifier of the finding that was specified by the finding provider.
        public let id: String
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        public let productArn: String

        public init(id: String, productArn: String) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
            try validate(self.productArn, name: "productArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct AwsSnsTopicDetails: AWSEncodableShape & AWSDecodableShape {

        /// The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.
        public let kmsMasterKeyId: String?
        /// The subscription's owner.
        public let owner: String?
        /// Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
        public let subscription: [AwsSnsTopicSubscription]?
        /// The name of the topic.
        public let topicName: String?

        public init(kmsMasterKeyId: String? = nil, owner: String? = nil, subscription: [AwsSnsTopicSubscription]? = nil, topicName: String? = nil) {
            self.kmsMasterKeyId = kmsMasterKeyId
            self.owner = owner
            self.subscription = subscription
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: ".*\\S.*")
            try validate(self.owner, name: "owner", parent: name, pattern: ".*\\S.*")
            try self.subscription?.forEach {
                try $0.validate(name: "\(name).subscription[]")
            }
            try validate(self.topicName, name: "topicName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsMasterKeyId = "KmsMasterKeyId"
            case owner = "Owner"
            case subscription = "Subscription"
            case topicName = "TopicName"
        }
    }

    public struct AwsSnsTopicSubscription: AWSEncodableShape & AWSDecodableShape {

        /// The subscription's endpoint (format depends on the protocol).
        public let endpoint: String?
        /// The subscription's protocol.
        public let `protocol`: String?

        public init(endpoint: String? = nil, protocol: String? = nil) {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.endpoint, name: "endpoint", parent: name, pattern: ".*\\S.*")
            try validate(self.`protocol`, name: "`protocol`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsSqsQueueDetails: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded. 
        public let deadLetterTargetArn: String?
        /// The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again.
        public let kmsDataKeyReusePeriodSeconds: Int?
        /// The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.
        public let kmsMasterKeyId: String?
        /// The name of the new queue.
        public let queueName: String?

        public init(deadLetterTargetArn: String? = nil, kmsDataKeyReusePeriodSeconds: Int? = nil, kmsMasterKeyId: String? = nil, queueName: String? = nil) {
            self.deadLetterTargetArn = deadLetterTargetArn
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsMasterKeyId = kmsMasterKeyId
            self.queueName = queueName
        }

        public func validate(name: String) throws {
            try validate(self.deadLetterTargetArn, name: "deadLetterTargetArn", parent: name, pattern: ".*\\S.*")
            try validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: ".*\\S.*")
            try validate(self.queueName, name: "queueName", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterTargetArn = "DeadLetterTargetArn"
            case kmsDataKeyReusePeriodSeconds = "KmsDataKeyReusePeriodSeconds"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case queueName = "QueueName"
        }
    }

    public struct AwsWafWebAclDetails: AWSEncodableShape & AWSDecodableShape {

        /// The action to perform if none of the Rules contained in the WebACL match.
        public let defaultAction: String?
        /// A friendly name or description of the WebACL. You can't change the name of a WebACL after you create it.
        public let name: String?
        /// An array that contains the action for each rule in a WebACL, the priority of the rule, and the ID of the rule.
        public let rules: [AwsWafWebAclRule]?
        /// A unique identifier for a WebACL.
        public let webAclId: String?

        public init(defaultAction: String? = nil, name: String? = nil, rules: [AwsWafWebAclRule]? = nil, webAclId: String? = nil) {
            self.defaultAction = defaultAction
            self.name = name
            self.rules = rules
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try validate(self.defaultAction, name: "defaultAction", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try validate(self.webAclId, name: "webAclId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case name = "Name"
            case rules = "Rules"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsWafWebAclRule: AWSEncodableShape & AWSDecodableShape {

        /// Specifies the action that CloudFront or AWS WAF takes when a web request matches the conditions in the Rule. 
        public let action: WafAction?
        /// Rules to exclude from a rule group.
        public let excludedRules: [WafExcludedRule]?
        /// Use the OverrideAction to test your RuleGroup. Any rule in a RuleGroup can potentially block a request. If you set the OverrideAction to None, the RuleGroup blocks a request if any individual rule in the RuleGroup matches the request and is configured to block that request. However, if you first want to test the RuleGroup, set the OverrideAction to Count. The RuleGroup then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.  ActivatedRule|OverrideAction applies only when updating or adding a RuleGroup to a WebACL. In this case you do not use ActivatedRule|Action. For all other update requests, ActivatedRule|Action is used instead of ActivatedRule|OverrideAction. 
        public let overrideAction: WafOverrideAction?
        /// Specifies the order in which the Rules in a WebACL are evaluated. Rules with a lower value for Priority are evaluated before Rules with a higher value. The value must be a unique integer. If you add multiple Rules to a WebACL, the values do not need to be consecutive.
        public let priority: Int?
        /// The identifier for a Rule.
        public let ruleId: String?
        /// The rule type. Valid values: REGULAR | RATE_BASED | GROUP  The default is REGULAR.
        public let `type`: String?

        public init(action: WafAction? = nil, excludedRules: [WafExcludedRule]? = nil, overrideAction: WafOverrideAction? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.excludedRules = excludedRules
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.excludedRules?.forEach {
                try $0.validate(name: "\(name).excludedRules[]")
            }
            try self.overrideAction?.validate(name: "\(name).overrideAction")
            try validate(self.ruleId, name: "ruleId", parent: name, pattern: ".*\\S.*")
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case excludedRules = "ExcludedRules"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case ruleId = "RuleId"
            case `type` = "Type"
        }
    }

    public struct BatchDisableStandardsRequest: AWSEncodableShape {

        /// The ARNs of the standards subscriptions to disable.
        public let standardsSubscriptionArns: [String]

        public init(standardsSubscriptionArns: [String]) {
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionArns.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, max: 25)
            try validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct BatchDisableStandardsResponse: AWSDecodableShape {

        /// The details of the standards subscriptions that were disabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchEnableStandardsRequest: AWSEncodableShape {

        /// The list of standards checks to enable.
        public let standardsSubscriptionRequests: [StandardsSubscriptionRequest]

        public init(standardsSubscriptionRequests: [StandardsSubscriptionRequest]) {
            self.standardsSubscriptionRequests = standardsSubscriptionRequests
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionRequests.forEach {
                try $0.validate(name: "\(name).standardsSubscriptionRequests[]")
            }
            try validate(self.standardsSubscriptionRequests, name: "standardsSubscriptionRequests", parent: name, max: 25)
            try validate(self.standardsSubscriptionRequests, name: "standardsSubscriptionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
        }
    }

    public struct BatchEnableStandardsResponse: AWSDecodableShape {

        /// The details of the standards subscriptions that were enabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchImportFindingsRequest: AWSEncodableShape {

        /// A list of findings to import. To successfully import a finding, it must follow the AWS Security Finding Format. Maximum of 100 findings per request.
        public let findings: [AwsSecurityFinding]

        public init(findings: [AwsSecurityFinding]) {
            self.findings = findings
        }

        public func validate(name: String) throws {
            try self.findings.forEach {
                try $0.validate(name: "\(name).findings[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
        }
    }

    public struct BatchImportFindingsResponse: AWSDecodableShape {

        /// The number of findings that failed to import.
        public let failedCount: Int
        /// The list of findings that failed to import.
        public let failedFindings: [ImportFindingsError]?
        /// The number of findings that were successfully imported.
        public let successCount: Int

        public init(failedCount: Int, failedFindings: [ImportFindingsError]? = nil, successCount: Int) {
            self.failedCount = failedCount
            self.failedFindings = failedFindings
            self.successCount = successCount
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "FailedCount"
            case failedFindings = "FailedFindings"
            case successCount = "SuccessCount"
        }
    }

    public struct BatchUpdateFindingsRequest: AWSEncodableShape {

        /// The updated value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// The updated value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. 
        public let criticality: Int?
        /// The list of findings to update. BatchUpdateFindings can be used to update up to 100 findings at a time. For each finding, the list provides the finding identifier and the ARN of the finding provider.
        public let findingIdentifiers: [AwsSecurityFindingIdentifier]
        public let note: NoteUpdate?
        /// A list of findings that are related to the updated findings.
        public let relatedFindings: [RelatedFinding]?
        /// Used to update the finding severity.
        public let severity: SeverityUpdate?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are as follows.   Software and Configuration Checks   TTPs   Effects   Unusual Behaviors   Sensitive Data Identifications   
        public let types: [String]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding. The available values for VerificationState are as follows.    UNKNOWN â€“ The default disposition of a security finding    TRUE_POSITIVE â€“ The security finding is confirmed    FALSE_POSITIVE â€“ The security finding was determined to be a false alarm    BENIGN_POSITIVE â€“ A special case of TRUE_POSITIVE where the finding doesn't pose any threat, is expected, or both  
        public let verificationState: VerificationState?
        /// Used to update the workflow status of a finding. The workflow status indicates the progress of the investigation into the finding. 
        public let workflow: WorkflowUpdate?

        public init(confidence: Int? = nil, criticality: Int? = nil, findingIdentifiers: [AwsSecurityFindingIdentifier], note: NoteUpdate? = nil, relatedFindings: [RelatedFinding]? = nil, severity: SeverityUpdate? = nil, types: [String]? = nil, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, workflow: WorkflowUpdate? = nil) {
            self.confidence = confidence
            self.criticality = criticality
            self.findingIdentifiers = findingIdentifiers
            self.note = note
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflow = workflow
        }

        public func validate(name: String) throws {
            try validate(self.confidence, name: "confidence", parent: name, max: 100)
            try validate(self.confidence, name: "confidence", parent: name, min: 0)
            try validate(self.criticality, name: "criticality", parent: name, max: 100)
            try validate(self.criticality, name: "criticality", parent: name, min: 0)
            try self.findingIdentifiers.forEach {
                try $0.validate(name: "\(name).findingIdentifiers[]")
            }
            try self.note?.validate(name: "\(name).note")
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.severity?.validate(name: "\(name).severity")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: ".*\\S.*")
            }
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case criticality = "Criticality"
            case findingIdentifiers = "FindingIdentifiers"
            case note = "Note"
            case relatedFindings = "RelatedFindings"
            case severity = "Severity"
            case types = "Types"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflow = "Workflow"
        }
    }

    public struct BatchUpdateFindingsResponse: AWSDecodableShape {

        /// The list of findings that were updated successfully.
        public let processedFindings: [AwsSecurityFindingIdentifier]
        /// The list of findings that were not updated.
        public let unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]

        public init(processedFindings: [AwsSecurityFindingIdentifier], unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]) {
            self.processedFindings = processedFindings
            self.unprocessedFindings = unprocessedFindings
        }

        private enum CodingKeys: String, CodingKey {
            case processedFindings = "ProcessedFindings"
            case unprocessedFindings = "UnprocessedFindings"
        }
    }

    public struct BatchUpdateFindingsUnprocessedFinding: AWSDecodableShape {

        /// The code associated with the error.
        public let errorCode: String
        /// The message associated with the error.
        public let errorMessage: String
        /// The identifier of the finding that was not updated.
        public let findingIdentifier: AwsSecurityFindingIdentifier

        public init(errorCode: String, errorMessage: String, findingIdentifier: AwsSecurityFindingIdentifier) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingIdentifier = findingIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case findingIdentifier = "FindingIdentifier"
        }
    }

    public struct Compliance: AWSEncodableShape & AWSDecodableShape {

        /// List of requirements that are related to a standards control.
        public let relatedRequirements: [String]?
        /// The result of a standards check.
        public let status: ComplianceStatus?

        public init(relatedRequirements: [String]? = nil, status: ComplianceStatus? = nil) {
            self.relatedRequirements = relatedRequirements
            self.status = status
        }

        public func validate(name: String) throws {
            try self.relatedRequirements?.forEach {
                try validate($0, name: "relatedRequirements[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case relatedRequirements = "RelatedRequirements"
            case status = "Status"
        }
    }

    public struct ContainerDetails: AWSEncodableShape & AWSDecodableShape {

        /// The identifier of the image related to a finding.
        public let imageId: String?
        /// The name of the image related to a finding.
        public let imageName: String?
        /// The date and time when the container started.
        public let launchedAt: String?
        /// The name of the container related to a finding.
        public let name: String?

        public init(imageId: String? = nil, imageName: String? = nil, launchedAt: String? = nil, name: String? = nil) {
            self.imageId = imageId
            self.imageName = imageName
            self.launchedAt = launchedAt
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.imageId, name: "imageId", parent: name, pattern: ".*\\S.*")
            try validate(self.imageName, name: "imageName", parent: name, pattern: ".*\\S.*")
            try validate(self.launchedAt, name: "launchedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "ImageId"
            case imageName = "ImageName"
            case launchedAt = "LaunchedAt"
            case name = "Name"
        }
    }

    public struct CreateActionTargetRequest: AWSEncodableShape {

        /// The description for the custom action target.
        public let description: String
        /// The ID for the custom action target.
        public let id: String
        /// The name of the custom action target.
        public let name: String

        public init(description: String, id: String, name: String) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.description, name: "description", parent: name, pattern: ".*\\S.*")
            try validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct CreateActionTargetResponse: AWSDecodableShape {

        /// The ARN for the custom action target.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct CreateInsightRequest: AWSEncodableShape {

        /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
        public let filters: AwsSecurityFindingFilters
        /// The attribute used to group the findings for the insight. The grouping attribute identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        public let groupByAttribute: String
        /// The name of the custom insight to create.
        public let name: String

        public init(filters: AwsSecurityFindingFilters, groupByAttribute: String, name: String) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try validate(self.groupByAttribute, name: "groupByAttribute", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct CreateInsightResponse: AWSDecodableShape {

        /// The ARN of the insight created.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct CreateMembersRequest: AWSEncodableShape {

        /// The list of accounts to associate with the Security Hub master account. For each account, the list includes the account ID and the email address.
        public let accountDetails: [AccountDetails]?

        public init(accountDetails: [AccountDetails]? = nil) {
            self.accountDetails = accountDetails
        }

        public func validate(name: String) throws {
            try self.accountDetails?.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails = "AccountDetails"
        }
    }

    public struct CreateMembersResponse: AWSDecodableShape {

        /// The list of AWS accounts that were not processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DateFilter: AWSEncodableShape & AWSDecodableShape {

        /// A date range for the date filter.
        public let dateRange: DateRange?
        /// An end date for the date filter.
        public let end: String?
        /// A start date for the date filter.
        public let start: String?

        public init(dateRange: DateRange? = nil, end: String? = nil, start: String? = nil) {
            self.dateRange = dateRange
            self.end = end
            self.start = start
        }

        public func validate(name: String) throws {
            try validate(self.end, name: "end", parent: name, pattern: ".*\\S.*")
            try validate(self.start, name: "start", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case dateRange = "DateRange"
            case end = "End"
            case start = "Start"
        }
    }

    public struct DateRange: AWSEncodableShape & AWSDecodableShape {

        /// A date range unit for the date filter.
        public let unit: DateRangeUnit?
        /// A date range value for the date filter.
        public let value: Int?

        public init(unit: DateRangeUnit? = nil, value: Int? = nil) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {

        /// The list of account IDs for the accounts from which to decline the invitations to Security Hub.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {

        /// The list of AWS accounts that were not processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteActionTargetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "actionTargetArn", location: .uri(locationName: "ActionTargetArn"))
        ]

        /// The ARN of the custom action target to delete.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        public func validate(name: String) throws {
            try validate(self.actionTargetArn, name: "actionTargetArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteActionTargetResponse: AWSDecodableShape {

        /// The ARN of the custom action target that was deleted.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct DeleteInsightRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightArn", location: .uri(locationName: "InsightArn"))
        ]

        /// The ARN of the insight to delete.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func validate(name: String) throws {
            try validate(self.insightArn, name: "insightArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInsightResponse: AWSDecodableShape {

        /// The ARN of the insight that was deleted.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {

        /// The list of the account IDs that sent the invitations to delete.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {

        /// The list of AWS accounts for which the invitations were not deleted. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteMembersRequest: AWSEncodableShape {

        /// The list of account IDs for the member accounts to delete.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteMembersResponse: AWSDecodableShape {

        /// The list of AWS accounts that were not deleted. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DescribeActionTargetsRequest: AWSEncodableShape {

        /// A list of custom action target ARNs for the custom action targets to retrieve.
        public let actionTargetArns: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeActionTargets operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(actionTargetArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.actionTargetArns = actionTargetArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.actionTargetArns?.forEach {
                try validate($0, name: "actionTargetArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArns = "ActionTargetArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeActionTargetsResponse: AWSDecodableShape {

        /// A list of ActionTarget objects. Each object includes the ActionTargetArn, Description, and Name of a custom action target available in Security Hub.
        public let actionTargets: [ActionTarget]
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(actionTargets: [ActionTarget], nextToken: String? = nil) {
            self.actionTargets = actionTargets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargets = "ActionTargets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeHubRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hubArn", location: .querystring(locationName: "HubArn"))
        ]

        /// The ARN of the Hub resource to retrieve.
        public let hubArn: String?

        public init(hubArn: String? = nil) {
            self.hubArn = hubArn
        }

        public func validate(name: String) throws {
            try validate(self.hubArn, name: "hubArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHubResponse: AWSDecodableShape {

        /// The ARN of the Hub resource that was retrieved.
        public let hubArn: String?
        /// The date and time when Security Hub was enabled in the account.
        public let subscribedAt: String?

        public init(hubArn: String? = nil, subscribedAt: String? = nil) {
            self.hubArn = hubArn
            self.subscribedAt = subscribedAt
        }

        private enum CodingKeys: String, CodingKey {
            case hubArn = "HubArn"
            case subscribedAt = "SubscribedAt"
        }
    }

    public struct DescribeProductsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeProducts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProductsResponse: AWSDecodableShape {

        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// A list of products, including details for each product.
        public let products: [Product]

        public init(nextToken: String? = nil, products: [Product]) {
            self.nextToken = nextToken
            self.products = products
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case products = "Products"
        }
    }

    public struct DescribeStandardsControlsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken")), 
            AWSMemberEncoding(label: "standardsSubscriptionArn", location: .uri(locationName: "StandardsSubscriptionArn"))
        ]

        /// The maximum number of security standard controls to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeStandardsControls operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The ARN of a resource that represents your subscription to a supported standard.
        public let standardsSubscriptionArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try validate(self.standardsSubscriptionArn, name: "standardsSubscriptionArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeStandardsControlsResponse: AWSDecodableShape {

        /// A list of security standards controls.
        public let controls: [StandardsControl]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(controls: [StandardsControl]? = nil, nextToken: String? = nil) {
            self.controls = controls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "Controls"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeStandardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        /// The maximum number of standards to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeStandardsResponse: AWSDecodableShape {

        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// A list of available standards.
        public let standards: [Standard]?

        public init(nextToken: String? = nil, standards: [Standard]? = nil) {
            self.nextToken = nextToken
            self.standards = standards
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standards = "Standards"
        }
    }

    public struct DisableImportFindingsForProductRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "productSubscriptionArn", location: .uri(locationName: "ProductSubscriptionArn"))
        ]

        /// The ARN of the integrated product to disable the integration for.
        public let productSubscriptionArn: String

        public init(productSubscriptionArn: String) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        public func validate(name: String) throws {
            try validate(self.productSubscriptionArn, name: "productSubscriptionArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisableImportFindingsForProductResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DisableSecurityHubRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct DisableSecurityHubResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DisassociateMembersRequest: AWSEncodableShape {

        /// The account IDs of the member accounts to disassociate from the master account.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DisassociateMembersResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct EnableImportFindingsForProductRequest: AWSEncodableShape {

        /// The ARN of the product to enable the integration for.
        public let productArn: String

        public init(productArn: String) {
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try validate(self.productArn, name: "productArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case productArn = "ProductArn"
        }
    }

    public struct EnableImportFindingsForProductResponse: AWSDecodableShape {

        /// The ARN of your subscription to the product to enable integrations for.
        public let productSubscriptionArn: String?

        public init(productSubscriptionArn: String? = nil) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case productSubscriptionArn = "ProductSubscriptionArn"
        }
    }

    public struct EnableSecurityHubRequest: AWSEncodableShape {

        /// Whether to enable the security standards that Security Hub has designated as automatically enabled. If you do not provide a value for EnableDefaultStandards, it is set to true. To not enable the automatically enabled standards, set EnableDefaultStandards to false.
        public let enableDefaultStandards: Bool?
        /// The tags to add to the Hub resource when you enable Security Hub.
        public let tags: [String: String]?

        public init(enableDefaultStandards: Bool? = nil, tags: [String: String]? = nil) {
            self.enableDefaultStandards = enableDefaultStandards
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enableDefaultStandards = "EnableDefaultStandards"
            case tags = "Tags"
        }
    }

    public struct EnableSecurityHubResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct GetEnabledStandardsRequest: AWSEncodableShape {

        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetEnabledStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The list of the standards subscription ARNs for the standards to retrieve.
        public let standardsSubscriptionArns: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArns: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.standardsSubscriptionArns?.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, max: 25)
            try validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct GetEnabledStandardsResponse: AWSDecodableShape {

        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// The list of StandardsSubscriptions objects that include information about the enabled standards.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(nextToken: String? = nil, standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.nextToken = nextToken
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {

        /// The finding attributes used to define a condition to filter the returned findings.
        public let filters: AwsSecurityFindingFilters?
        /// The maximum number of findings to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetFindings operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The finding attributes used to sort the list of returned findings.
        public let sortCriteria: [SortCriterion]?

        public init(filters: AwsSecurityFindingFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [SortCriterion]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {

        /// The findings that matched the filters specified in the request.
        public let findings: [AwsSecurityFinding]
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(findings: [AwsSecurityFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightResultsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightArn", location: .uri(locationName: "InsightArn"))
        ]

        /// The ARN of the insight for which to return results.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func validate(name: String) throws {
            try validate(self.insightArn, name: "insightArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInsightResultsResponse: AWSDecodableShape {

        /// The insight results returned by the operation.
        public let insightResults: InsightResults

        public init(insightResults: InsightResults) {
            self.insightResults = insightResults
        }

        private enum CodingKeys: String, CodingKey {
            case insightResults = "InsightResults"
        }
    }

    public struct GetInsightsRequest: AWSEncodableShape {

        /// The ARNs of the insights to describe. If you do not provide any insight ARNs, then GetInsights returns all of your custom insights. It does not return any managed insights.
        public let insightArns: [String]?
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetInsights operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(insightArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightArns = insightArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.insightArns?.forEach {
                try validate($0, name: "insightArns[]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case insightArns = "InsightArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightsResponse: AWSDecodableShape {

        /// The insights returned by the operation.
        public let insights: [Insight]
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(insights: [Insight], nextToken: String? = nil) {
            self.insights = insights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insights = "Insights"
            case nextToken = "NextToken"
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {

        /// The number of all membership invitations sent to this Security Hub member account, not including the currently accepted invitation.
        public let invitationsCount: Int?

        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "InvitationsCount"
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct GetMasterAccountResponse: AWSDecodableShape {

        /// A list of details about the Security Hub master account for the current member account. 
        public let master: Invitation?

        public init(master: Invitation? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "Master"
        }
    }

    public struct GetMembersRequest: AWSEncodableShape {

        /// The list of account IDs for the Security Hub member accounts to return the details for. 
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct GetMembersResponse: AWSDecodableShape {

        /// The list of details about the Security Hub member accounts.
        public let members: [Member]?
        /// The list of AWS accounts that could not be processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(members: [Member]? = nil, unprocessedAccounts: [Result]? = nil) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct ImportFindingsError: AWSDecodableShape {

        /// The code of the error returned by the BatchImportFindings operation.
        public let errorCode: String
        /// The message of the error returned by the BatchImportFindings operation.
        public let errorMessage: String
        /// The identifier of the finding that could not be updated.
        public let id: String

        public init(errorCode: String, errorMessage: String, id: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case id = "Id"
        }
    }

    public struct Insight: AWSDecodableShape {

        /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
        public let filters: AwsSecurityFindingFilters
        /// The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        public let groupByAttribute: String
        /// The ARN of a Security Hub insight.
        public let insightArn: String
        /// The name of a Security Hub insight.
        public let name: String

        public init(filters: AwsSecurityFindingFilters, groupByAttribute: String, insightArn: String, name: String) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case name = "Name"
        }
    }

    public struct InsightResultValue: AWSDecodableShape {

        /// The number of findings returned for each GroupByAttributeValue.
        public let count: Int
        /// The value of the attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttributeValue: String

        public init(count: Int, groupByAttributeValue: String) {
            self.count = count
            self.groupByAttributeValue = groupByAttributeValue
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case groupByAttributeValue = "GroupByAttributeValue"
        }
    }

    public struct InsightResults: AWSDecodableShape {

        /// The attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttribute: String
        /// The ARN of the insight whose results are returned by the GetInsightResults operation.
        public let insightArn: String
        /// The list of insight result values returned by the GetInsightResults operation.
        public let resultValues: [InsightResultValue]

        public init(groupByAttribute: String, insightArn: String, resultValues: [InsightResultValue]) {
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.resultValues = resultValues
        }

        private enum CodingKeys: String, CodingKey {
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case resultValues = "ResultValues"
        }
    }

    public struct Invitation: AWSDecodableShape {

        /// The account ID of the Security Hub master account that the invitation was sent from.
        public let accountId: String?
        /// The ID of the invitation sent to the member account.
        public let invitationId: String?
        /// The timestamp of when the invitation was sent.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var invitedAt: TimeStamp?
        /// The current status of the association between the member and master accounts.
        public let memberStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: TimeStamp? = nil, memberStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.memberStatus = memberStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case invitationId = "InvitationId"
            case invitedAt = "InvitedAt"
            case memberStatus = "MemberStatus"
        }
    }

    public struct InviteMembersRequest: AWSEncodableShape {

        /// The list of account IDs of the AWS accounts to invite to Security Hub as members. 
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct InviteMembersResponse: AWSDecodableShape {

        /// The list of AWS accounts that could not be processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct IpFilter: AWSEncodableShape & AWSDecodableShape {

        /// A finding's CIDR value.
        public let cidr: String?

        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try validate(self.cidr, name: "cidr", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct KeywordFilter: AWSEncodableShape & AWSDecodableShape {

        /// A value for the keyword.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name: "value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct ListEnabledProductsForImportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListEnabledProductsForImport operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnabledProductsForImportResponse: AWSDecodableShape {

        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// The list of ARNs for the resources that represent your subscriptions to products. 
        public let productSubscriptions: [String]?

        public init(nextToken: String? = nil, productSubscriptions: [String]? = nil) {
            self.nextToken = nextToken
            self.productSubscriptions = productSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case productSubscriptions = "ProductSubscriptions"
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken"))
        ]

        /// The maximum number of items to return in the response. 
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListInvitations operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {

        /// The details of the invitations returned by the operation.
        public let invitations: [Invitation]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "MaxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "NextToken")), 
            AWSMemberEncoding(label: "onlyAssociated", location: .querystring(locationName: "OnlyAssociated"))
        ]

        /// The maximum number of items to return in the response. 
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListMembers operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// Specifies which member accounts to include in the response based on their relationship status with the master account. The default value is TRUE. If OnlyAssociated is set to TRUE, the response includes member accounts whose relationship status with the master is set to ENABLED or DISABLED. If OnlyAssociated is set to FALSE, the response includes all existing member accounts. 
        public let onlyAssociated: Bool?

        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: Bool? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {

        /// Member details returned by the operation.
        public let members: [Member]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The ARN of the resource to retrieve tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// The tags associated with a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LoadBalancerState: AWSEncodableShape & AWSDecodableShape {

        /// The state code. The initial state of the load balancer is provisioning. After the load balancer is fully set up and ready to route traffic, its state is active. If the load balancer could not be set up, its state is failed. 
        public let code: String?
        /// A description of the state.
        public let reason: String?

        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        public func validate(name: String) throws {
            try validate(self.code, name: "code", parent: name, pattern: ".*\\S.*")
            try validate(self.reason, name: "reason", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case reason = "Reason"
        }
    }

    public struct Malware: AWSEncodableShape & AWSDecodableShape {

        /// The name of the malware that was observed.
        public let name: String
        /// The file system path of the malware that was observed.
        public let path: String?
        /// The state of the malware that was observed.
        public let state: MalwareState?
        /// The type of the malware that was observed.
        public let `type`: MalwareType?

        public init(name: String, path: String? = nil, state: MalwareState? = nil, type: MalwareType? = nil) {
            self.name = name
            self.path = path
            self.state = state
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try validate(self.path, name: "path", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case path = "Path"
            case state = "State"
            case `type` = "Type"
        }
    }

    public struct MapFilter: AWSEncodableShape & AWSDecodableShape {

        /// The condition to apply to a key value when querying for findings with a map filter.
        public let comparison: MapFilterComparison?
        /// The key of the map filter.
        public let key: String?
        /// The value for the key in the map filter.
        public let value: String?

        public init(comparison: MapFilterComparison? = nil, key: String? = nil, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name: "key", parent: name, pattern: ".*\\S.*")
            try validate(self.value, name: "value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct Member: AWSDecodableShape {

        /// The AWS account ID of the member account.
        public let accountId: String?
        /// The email address of the member account.
        public let email: String?
        /// A timestamp for the date and time when the invitation was sent to the member account.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var invitedAt: TimeStamp?
        /// The AWS account ID of the Security Hub master account associated with this member account.
        public let masterId: String?
        /// The status of the relationship between the member account and its master account. 
        public let memberStatus: String?
        /// The timestamp for the date and time when the member account was updated.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var updatedAt: TimeStamp?

        public init(accountId: String? = nil, email: String? = nil, invitedAt: TimeStamp? = nil, masterId: String? = nil, memberStatus: String? = nil, updatedAt: TimeStamp? = nil) {
            self.accountId = accountId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case email = "Email"
            case invitedAt = "InvitedAt"
            case masterId = "MasterId"
            case memberStatus = "MemberStatus"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Network: AWSEncodableShape & AWSDecodableShape {

        /// The destination domain of network-related information about a finding.
        public let destinationDomain: String?
        /// The destination IPv4 address of network-related information about a finding.
        public let destinationIpV4: String?
        /// The destination IPv6 address of network-related information about a finding.
        public let destinationIpV6: String?
        /// The destination port of network-related information about a finding.
        public let destinationPort: Int?
        /// The direction of network traffic associated with a finding.
        public let direction: NetworkDirection?
        /// The protocol of network-related information about a finding.
        public let `protocol`: String?
        /// The source domain of network-related information about a finding.
        public let sourceDomain: String?
        /// The source IPv4 address of network-related information about a finding.
        public let sourceIpV4: String?
        /// The source IPv6 address of network-related information about a finding.
        public let sourceIpV6: String?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let sourceMac: String?
        /// The source port of network-related information about a finding.
        public let sourcePort: Int?

        public init(destinationDomain: String? = nil, destinationIpV4: String? = nil, destinationIpV6: String? = nil, destinationPort: Int? = nil, direction: NetworkDirection? = nil, protocol: String? = nil, sourceDomain: String? = nil, sourceIpV4: String? = nil, sourceIpV6: String? = nil, sourceMac: String? = nil, sourcePort: Int? = nil) {
            self.destinationDomain = destinationDomain
            self.destinationIpV4 = destinationIpV4
            self.destinationIpV6 = destinationIpV6
            self.destinationPort = destinationPort
            self.direction = direction
            self.`protocol` = `protocol`
            self.sourceDomain = sourceDomain
            self.sourceIpV4 = sourceIpV4
            self.sourceIpV6 = sourceIpV6
            self.sourceMac = sourceMac
            self.sourcePort = sourcePort
        }

        public func validate(name: String) throws {
            try validate(self.destinationDomain, name: "destinationDomain", parent: name, pattern: ".*\\S.*")
            try validate(self.destinationIpV4, name: "destinationIpV4", parent: name, pattern: ".*\\S.*")
            try validate(self.destinationIpV6, name: "destinationIpV6", parent: name, pattern: ".*\\S.*")
            try validate(self.`protocol`, name: "`protocol`", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceDomain, name: "sourceDomain", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceIpV4, name: "sourceIpV4", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceIpV6, name: "sourceIpV6", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceMac, name: "sourceMac", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationDomain = "DestinationDomain"
            case destinationIpV4 = "DestinationIpV4"
            case destinationIpV6 = "DestinationIpV6"
            case destinationPort = "DestinationPort"
            case direction = "Direction"
            case `protocol` = "Protocol"
            case sourceDomain = "SourceDomain"
            case sourceIpV4 = "SourceIpV4"
            case sourceIpV6 = "SourceIpV6"
            case sourceMac = "SourceMac"
            case sourcePort = "SourcePort"
        }
    }

    public struct Note: AWSEncodableShape & AWSDecodableShape {

        /// The text of a note.
        public let text: String
        /// The timestamp of when the note was updated.
        public let updatedAt: String
        /// The principal that created a note.
        public let updatedBy: String

        public init(text: String, updatedAt: String, updatedBy: String) {
            self.text = text
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try validate(self.text, name: "text", parent: name, pattern: ".*\\S.*")
            try validate(self.updatedAt, name: "updatedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.updatedBy, name: "updatedBy", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedAt = "UpdatedAt"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NoteUpdate: AWSEncodableShape {

        /// The updated note text.
        public let text: String
        /// The principal that updated the note.
        public let updatedBy: String

        public init(text: String, updatedBy: String) {
            self.text = text
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try validate(self.text, name: "text", parent: name, pattern: ".*\\S.*")
            try validate(self.updatedBy, name: "updatedBy", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NumberFilter: AWSEncodableShape & AWSDecodableShape {

        /// The equal-to condition to be applied to a single field when querying for findings.
        public let eq: Double?
        /// The greater-than-equal condition to be applied to a single field when querying for findings. 
        public let gte: Double?
        /// The less-than-equal condition to be applied to a single field when querying for findings. 
        public let lte: Double?

        public init(eq: Double? = nil, gte: Double? = nil, lte: Double? = nil) {
            self.eq = eq
            self.gte = gte
            self.lte = lte
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "Eq"
            case gte = "Gte"
            case lte = "Lte"
        }
    }

    public struct ProcessDetails: AWSEncodableShape & AWSDecodableShape {

        /// The date/time that the process was launched.
        public let launchedAt: String?
        /// The name of the process.
        public let name: String?
        /// The parent process ID.
        public let parentPid: Int?
        /// The path to the process executable.
        public let path: String?
        /// The process ID.
        public let pid: Int?
        /// The date and time when the process was terminated.
        public let terminatedAt: String?

        public init(launchedAt: String? = nil, name: String? = nil, parentPid: Int? = nil, path: String? = nil, pid: Int? = nil, terminatedAt: String? = nil) {
            self.launchedAt = launchedAt
            self.name = name
            self.parentPid = parentPid
            self.path = path
            self.pid = pid
            self.terminatedAt = terminatedAt
        }

        public func validate(name: String) throws {
            try validate(self.launchedAt, name: "launchedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try validate(self.path, name: "path", parent: name, pattern: ".*\\S.*")
            try validate(self.terminatedAt, name: "terminatedAt", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case launchedAt = "LaunchedAt"
            case name = "Name"
            case parentPid = "ParentPid"
            case path = "Path"
            case pid = "Pid"
            case terminatedAt = "TerminatedAt"
        }
    }

    public struct Product: AWSDecodableShape {

        /// The URL used to activate the product.
        public let activationUrl: String?
        /// The categories assigned to the product.
        public let categories: [String]?
        /// The name of the company that provides the product.
        public let companyName: String?
        /// A description of the product.
        public let description: String?
        /// The types of integration that the product supports. Available values are the following.    SEND_FINDINGS_TO_SECURITY_HUB - Indicates that the integration sends findings to Security Hub.    RECEIVE_FINDINGS_FROM_SECURITY_HUB - Indicates that the integration receives findings from Security Hub.  
        public let integrationTypes: [IntegrationType]?
        /// The URL for the page that contains more information about the product.
        public let marketplaceUrl: String?
        /// The ARN assigned to the product.
        public let productArn: String
        /// The name of the product.
        public let productName: String?
        /// The resource policy associated with the product.
        public let productSubscriptionResourcePolicy: String?

        public init(activationUrl: String? = nil, categories: [String]? = nil, companyName: String? = nil, description: String? = nil, integrationTypes: [IntegrationType]? = nil, marketplaceUrl: String? = nil, productArn: String, productName: String? = nil, productSubscriptionResourcePolicy: String? = nil) {
            self.activationUrl = activationUrl
            self.categories = categories
            self.companyName = companyName
            self.description = description
            self.integrationTypes = integrationTypes
            self.marketplaceUrl = marketplaceUrl
            self.productArn = productArn
            self.productName = productName
            self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case activationUrl = "ActivationUrl"
            case categories = "Categories"
            case companyName = "CompanyName"
            case description = "Description"
            case integrationTypes = "IntegrationTypes"
            case marketplaceUrl = "MarketplaceUrl"
            case productArn = "ProductArn"
            case productName = "ProductName"
            case productSubscriptionResourcePolicy = "ProductSubscriptionResourcePolicy"
        }
    }

    public struct Recommendation: AWSEncodableShape & AWSDecodableShape {

        /// Describes the recommended steps to take to remediate an issue identified in a finding.
        public let text: String?
        /// A URL to a page or site that contains information about how to remediate a finding.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        public func validate(name: String) throws {
            try validate(self.text, name: "text", parent: name, pattern: ".*\\S.*")
            try validate(self.url, name: "url", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case url = "Url"
        }
    }

    public struct RelatedFinding: AWSEncodableShape & AWSDecodableShape {

        /// The product-generated identifier for a related finding.
        public let id: String
        /// The ARN of the product that generated a related finding.
        public let productArn: String

        public init(id: String, productArn: String) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
            try validate(self.productArn, name: "productArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct Remediation: AWSEncodableShape & AWSDecodableShape {

        /// A recommendation on the steps to take to remediate the issue identified by a finding.
        public let recommendation: Recommendation?

        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        public func validate(name: String) throws {
            try self.recommendation?.validate(name: "\(name).recommendation")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "Recommendation"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {

        /// Additional details about the resource related to a finding.
        public let details: ResourceDetails?
        /// The canonical identifier for the given resource type.
        public let id: String
        /// The canonical AWS partition name that the Region is assigned to.
        public let partition: Partition?
        /// The canonical AWS external Region name where this resource is located.
        public let region: String?
        /// A list of AWS tags associated with a resource at the time the finding was processed.
        public let tags: [String: String]?
        /// The type of the resource that details are provided for. If possible, set Type to one of the supported resource types. For example, if the resource is an EC2 instance, then set Type to AwsEc2Instance. If the resource does not match any of the provided types, then set Type to Other. 
        public let `type`: String

        public init(details: ResourceDetails? = nil, id: String, partition: Partition? = nil, region: String? = nil, tags: [String: String]? = nil, type: String) {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try self.details?.validate(name: "\(name).details")
            try validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
            try validate(self.region, name: "region", parent: name, pattern: ".*\\S.*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case details = "Details"
            case id = "Id"
            case partition = "Partition"
            case region = "Region"
            case tags = "Tags"
            case `type` = "Type"
        }
    }

    public struct ResourceDetails: AWSEncodableShape & AWSDecodableShape {

        /// Details about a CloudFront distribution.
        public let awsCloudFrontDistribution: AwsCloudFrontDistributionDetails?
        /// Details for an AWS CodeBuild project.
        public let awsCodeBuildProject: AwsCodeBuildProjectDetails?
        /// Details about an Amazon EC2 instance related to a finding.
        public let awsEc2Instance: AwsEc2InstanceDetails?
        /// Details for an AWS EC2 network interface.
        public let awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails?
        /// Details for an EC2 security group.
        public let awsEc2SecurityGroup: AwsEc2SecurityGroupDetails?
        /// Details for an Elasticsearch domain.
        public let awsElasticsearchDomain: AwsElasticsearchDomainDetails?
        /// Details about a load balancer.
        public let awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails?
        /// Details about an IAM access key related to a finding.
        public let awsIamAccessKey: AwsIamAccessKeyDetails?
        /// Details about an IAM role.
        public let awsIamRole: AwsIamRoleDetails?
        /// Details about a KMS key.
        public let awsKmsKey: AwsKmsKeyDetails?
        /// Details about a Lambda function.
        public let awsLambdaFunction: AwsLambdaFunctionDetails?
        /// Details for a Lambda layer version.
        public let awsLambdaLayerVersion: AwsLambdaLayerVersionDetails?
        /// Details for an RDS database instance.
        public let awsRdsDbInstance: AwsRdsDbInstanceDetails?
        /// Details about an Amazon S3 Bucket related to a finding.
        public let awsS3Bucket: AwsS3BucketDetails?
        /// Details about an Amazon S3 object related to a finding.
        public let awsS3Object: AwsS3ObjectDetails?
        /// Details about an SNS topic.
        public let awsSnsTopic: AwsSnsTopicDetails?
        /// Details about an SQS queue.
        public let awsSqsQueue: AwsSqsQueueDetails?
        /// Details for a WAF WebACL.
        public let awsWafWebAcl: AwsWafWebAclDetails?
        /// Details about a container resource related to a finding.
        public let container: ContainerDetails?
        /// Details about a resource that are not available in a type-specific details object. Use the Other object in the following cases.   The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the Other object to populate the fields that are missing from the type-specific object.   The resource type does not have a corresponding object. This includes resources for which the type is Other.   
        public let other: [String: String]?

        public init(awsCloudFrontDistribution: AwsCloudFrontDistributionDetails? = nil, awsCodeBuildProject: AwsCodeBuildProjectDetails? = nil, awsEc2Instance: AwsEc2InstanceDetails? = nil, awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails? = nil, awsEc2SecurityGroup: AwsEc2SecurityGroupDetails? = nil, awsElasticsearchDomain: AwsElasticsearchDomainDetails? = nil, awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails? = nil, awsIamAccessKey: AwsIamAccessKeyDetails? = nil, awsIamRole: AwsIamRoleDetails? = nil, awsKmsKey: AwsKmsKeyDetails? = nil, awsLambdaFunction: AwsLambdaFunctionDetails? = nil, awsLambdaLayerVersion: AwsLambdaLayerVersionDetails? = nil, awsRdsDbInstance: AwsRdsDbInstanceDetails? = nil, awsS3Bucket: AwsS3BucketDetails? = nil, awsS3Object: AwsS3ObjectDetails? = nil, awsSnsTopic: AwsSnsTopicDetails? = nil, awsSqsQueue: AwsSqsQueueDetails? = nil, awsWafWebAcl: AwsWafWebAclDetails? = nil, container: ContainerDetails? = nil, other: [String: String]? = nil) {
            self.awsCloudFrontDistribution = awsCloudFrontDistribution
            self.awsCodeBuildProject = awsCodeBuildProject
            self.awsEc2Instance = awsEc2Instance
            self.awsEc2NetworkInterface = awsEc2NetworkInterface
            self.awsEc2SecurityGroup = awsEc2SecurityGroup
            self.awsElasticsearchDomain = awsElasticsearchDomain
            self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
            self.awsIamAccessKey = awsIamAccessKey
            self.awsIamRole = awsIamRole
            self.awsKmsKey = awsKmsKey
            self.awsLambdaFunction = awsLambdaFunction
            self.awsLambdaLayerVersion = awsLambdaLayerVersion
            self.awsRdsDbInstance = awsRdsDbInstance
            self.awsS3Bucket = awsS3Bucket
            self.awsS3Object = awsS3Object
            self.awsSnsTopic = awsSnsTopic
            self.awsSqsQueue = awsSqsQueue
            self.awsWafWebAcl = awsWafWebAcl
            self.container = container
            self.other = other
        }

        public func validate(name: String) throws {
            try self.awsCloudFrontDistribution?.validate(name: "\(name).awsCloudFrontDistribution")
            try self.awsCodeBuildProject?.validate(name: "\(name).awsCodeBuildProject")
            try self.awsEc2Instance?.validate(name: "\(name).awsEc2Instance")
            try self.awsEc2NetworkInterface?.validate(name: "\(name).awsEc2NetworkInterface")
            try self.awsEc2SecurityGroup?.validate(name: "\(name).awsEc2SecurityGroup")
            try self.awsElasticsearchDomain?.validate(name: "\(name).awsElasticsearchDomain")
            try self.awsElbv2LoadBalancer?.validate(name: "\(name).awsElbv2LoadBalancer")
            try self.awsIamAccessKey?.validate(name: "\(name).awsIamAccessKey")
            try self.awsIamRole?.validate(name: "\(name).awsIamRole")
            try self.awsKmsKey?.validate(name: "\(name).awsKmsKey")
            try self.awsLambdaFunction?.validate(name: "\(name).awsLambdaFunction")
            try self.awsLambdaLayerVersion?.validate(name: "\(name).awsLambdaLayerVersion")
            try self.awsRdsDbInstance?.validate(name: "\(name).awsRdsDbInstance")
            try self.awsS3Bucket?.validate(name: "\(name).awsS3Bucket")
            try self.awsS3Object?.validate(name: "\(name).awsS3Object")
            try self.awsSnsTopic?.validate(name: "\(name).awsSnsTopic")
            try self.awsSqsQueue?.validate(name: "\(name).awsSqsQueue")
            try self.awsWafWebAcl?.validate(name: "\(name).awsWafWebAcl")
            try self.container?.validate(name: "\(name).container")
            try self.other?.forEach {
                try validate($0.key, name: "other.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "other[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudFrontDistribution = "AwsCloudFrontDistribution"
            case awsCodeBuildProject = "AwsCodeBuildProject"
            case awsEc2Instance = "AwsEc2Instance"
            case awsEc2NetworkInterface = "AwsEc2NetworkInterface"
            case awsEc2SecurityGroup = "AwsEc2SecurityGroup"
            case awsElasticsearchDomain = "AwsElasticsearchDomain"
            case awsElbv2LoadBalancer = "AwsElbv2LoadBalancer"
            case awsIamAccessKey = "AwsIamAccessKey"
            case awsIamRole = "AwsIamRole"
            case awsKmsKey = "AwsKmsKey"
            case awsLambdaFunction = "AwsLambdaFunction"
            case awsLambdaLayerVersion = "AwsLambdaLayerVersion"
            case awsRdsDbInstance = "AwsRdsDbInstance"
            case awsS3Bucket = "AwsS3Bucket"
            case awsS3Object = "AwsS3Object"
            case awsSnsTopic = "AwsSnsTopic"
            case awsSqsQueue = "AwsSqsQueue"
            case awsWafWebAcl = "AwsWafWebAcl"
            case container = "Container"
            case other = "Other"
        }
    }

    public struct Result: AWSDecodableShape {

        /// An AWS account ID of the account that was not processed.
        public let accountId: String?
        /// The reason that the account was not processed.
        public let processingResult: String?

        public init(accountId: String? = nil, processingResult: String? = nil) {
            self.accountId = accountId
            self.processingResult = processingResult
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case processingResult = "ProcessingResult"
        }
    }

    public struct Severity: AWSEncodableShape & AWSDecodableShape {

        /// The severity value of the finding. The allowed values are the following.    INFORMATIONAL - No issue was found.    LOW - The issue does not require action on its own.    MEDIUM - The issue must be addressed but not urgently.    HIGH - The issue must be addressed as a priority.    CRITICAL - The issue must be remediated immediately to avoid it escalating.  
        public let label: SeverityLabel?
        /// Deprecated. This attribute is being deprecated. Instead of providing Normalized, provide Label. If you provide Normalized and do not provide Label, Label is set automatically as follows.    0 - INFORMATIONAL    1â€“39 - LOW    40â€“69 - MEDIUM    70â€“89 - HIGH    90â€“100 - CRITICAL   
        public let normalized: Int?
        /// The native severity as defined by the AWS service or integrated partner product that generated the finding.
        public let product: Double?

        public init(label: SeverityLabel? = nil, normalized: Int? = nil, product: Double? = nil) {
            self.label = label
            self.normalized = normalized
            self.product = product
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case normalized = "Normalized"
            case product = "Product"
        }
    }

    public struct SeverityUpdate: AWSEncodableShape {

        /// The severity value of the finding. The allowed values are the following.    INFORMATIONAL - No issue was found.    LOW - The issue does not require action on its own.    MEDIUM - The issue must be addressed but not urgently.    HIGH - The issue must be addressed as a priority.    CRITICAL - The issue must be remediated immediately to avoid it escalating.  
        public let label: SeverityLabel?
        /// The normalized severity for the finding. This attribute is to be deprecated in favor of Label. If you provide Normalized and do not provide Label, Label is set automatically as follows.   0 - INFORMATIONAL    1â€“39 - LOW    40â€“69 - MEDIUM    70â€“89 - HIGH    90â€“100 - CRITICAL   
        public let normalized: Int?
        /// The native severity as defined by the AWS service or integrated partner product that generated the finding.
        public let product: Double?

        public init(label: SeverityLabel? = nil, normalized: Int? = nil, product: Double? = nil) {
            self.label = label
            self.normalized = normalized
            self.product = product
        }

        public func validate(name: String) throws {
            try validate(self.normalized, name: "normalized", parent: name, max: 100)
            try validate(self.normalized, name: "normalized", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case normalized = "Normalized"
            case product = "Product"
        }
    }

    public struct SortCriterion: AWSEncodableShape {

        /// The finding attribute used to sort findings.
        public let field: String?
        /// The order used to sort findings.
        public let sortOrder: SortOrder?

        public init(field: String? = nil, sortOrder: SortOrder? = nil) {
            self.field = field
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try validate(self.field, name: "field", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case sortOrder = "SortOrder"
        }
    }

    public struct Standard: AWSDecodableShape {

        /// A description of the standard.
        public let description: String?
        /// Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default. When Security Hub is enabled using the EnableSecurityHub API operation, the standard is enabled by default unless EnableDefaultStandards is set to false.
        public let enabledByDefault: Bool?
        /// The name of the standard.
        public let name: String?
        /// The ARN of a standard.
        public let standardsArn: String?

        public init(description: String? = nil, enabledByDefault: Bool? = nil, name: String? = nil, standardsArn: String? = nil) {
            self.description = description
            self.enabledByDefault = enabledByDefault
            self.name = name
            self.standardsArn = standardsArn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case enabledByDefault = "EnabledByDefault"
            case name = "Name"
            case standardsArn = "StandardsArn"
        }
    }

    public struct StandardsControl: AWSDecodableShape {

        /// The identifier of the security standard control.
        public let controlId: String?
        /// The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.
        public let controlStatus: ControlStatus?
        /// The date and time that the status of the security standard control was most recently updated.
        @OptionalCoding<ISO8601TimeStampCoder>
        public var controlStatusUpdatedAt: TimeStamp?
        /// The longer description of the security standard control. Provides information about what the control is checking for.
        public let description: String?
        /// The reason provided for the most recent change in status for the control.
        public let disabledReason: String?
        /// The list of requirements that are related to this control.
        public let relatedRequirements: [String]?
        /// A link to remediation information for the control in the Security Hub user documentation.
        public let remediationUrl: String?
        /// The severity of findings generated from this security standard control. The finding severity is based on an assessment of how easy it would be to compromise AWS resources if the issue is detected.
        public let severityRating: SeverityRating?
        /// The ARN of the security standard control.
        public let standardsControlArn: String?
        /// The title of the security standard control.
        public let title: String?

        public init(controlId: String? = nil, controlStatus: ControlStatus? = nil, controlStatusUpdatedAt: TimeStamp? = nil, description: String? = nil, disabledReason: String? = nil, relatedRequirements: [String]? = nil, remediationUrl: String? = nil, severityRating: SeverityRating? = nil, standardsControlArn: String? = nil, title: String? = nil) {
            self.controlId = controlId
            self.controlStatus = controlStatus
            self.controlStatusUpdatedAt = controlStatusUpdatedAt
            self.description = description
            self.disabledReason = disabledReason
            self.relatedRequirements = relatedRequirements
            self.remediationUrl = remediationUrl
            self.severityRating = severityRating
            self.standardsControlArn = standardsControlArn
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case controlId = "ControlId"
            case controlStatus = "ControlStatus"
            case controlStatusUpdatedAt = "ControlStatusUpdatedAt"
            case description = "Description"
            case disabledReason = "DisabledReason"
            case relatedRequirements = "RelatedRequirements"
            case remediationUrl = "RemediationUrl"
            case severityRating = "SeverityRating"
            case standardsControlArn = "StandardsControlArn"
            case title = "Title"
        }
    }

    public struct StandardsSubscription: AWSDecodableShape {

        /// The ARN of a standard.
        public let standardsArn: String
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]
        /// The status of the standards subscription.
        public let standardsStatus: StandardsStatus
        /// The ARN of a resource that represents your subscription to a supported standard.
        public let standardsSubscriptionArn: String

        public init(standardsArn: String, standardsInput: [String: String], standardsStatus: StandardsStatus, standardsSubscriptionArn: String) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
            self.standardsStatus = standardsStatus
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
            case standardsStatus = "StandardsStatus"
            case standardsSubscriptionArn = "StandardsSubscriptionArn"
        }
    }

    public struct StandardsSubscriptionRequest: AWSEncodableShape {

        /// The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the  DescribeStandards  operation.
        public let standardsArn: String
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]?

        public init(standardsArn: String, standardsInput: [String: String]? = nil) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
        }

        public func validate(name: String) throws {
            try validate(self.standardsArn, name: "standardsArn", parent: name, pattern: ".*\\S.*")
            try self.standardsInput?.forEach {
                try validate($0.key, name: "standardsInput.key", parent: name, pattern: ".*\\S.*")
                try validate($0.value, name: "standardsInput[\"\($0.key)\"]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
        }
    }

    public struct StringFilter: AWSEncodableShape & AWSDecodableShape {

        /// The condition to be applied to a string value when querying for findings. 
        public let comparison: StringFilterComparison?
        /// The string filter value.
        public let value: String?

        public init(comparison: StringFilterComparison? = nil, value: String? = nil) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name: "value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The ARN of the resource to apply the tags to.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:.*")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct ThreatIntelIndicator: AWSEncodableShape & AWSDecodableShape {

        /// The category of a threat intelligence indicator.
        public let category: ThreatIntelIndicatorCategory?
        /// The date and time when the most recent instance of a threat intelligence indicator was observed.
        public let lastObservedAt: String?
        /// The source of the threat intelligence indicator.
        public let source: String?
        /// The URL to the page or site where you can get more information about the threat intelligence indicator.
        public let sourceUrl: String?
        /// The type of threat intelligence indicator.
        public let `type`: ThreatIntelIndicatorType?
        /// The value of a threat intelligence indicator.
        public let value: String?

        public init(category: ThreatIntelIndicatorCategory? = nil, lastObservedAt: String? = nil, source: String? = nil, sourceUrl: String? = nil, type: ThreatIntelIndicatorType? = nil, value: String? = nil) {
            self.category = category
            self.lastObservedAt = lastObservedAt
            self.source = source
            self.sourceUrl = sourceUrl
            self.`type` = `type`
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.lastObservedAt, name: "lastObservedAt", parent: name, pattern: ".*\\S.*")
            try validate(self.source, name: "source", parent: name, pattern: ".*\\S.*")
            try validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: ".*\\S.*")
            try validate(self.value, name: "value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case lastObservedAt = "LastObservedAt"
            case source = "Source"
            case sourceUrl = "SourceUrl"
            case `type` = "Type"
            case value = "Value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the resource to remove the tags from.
        public let resourceArn: String
        /// The tag keys associated with the tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateActionTargetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "actionTargetArn", location: .uri(locationName: "ActionTargetArn"))
        ]

        /// The ARN of the custom action target to update.
        public let actionTargetArn: String
        /// The updated description for the custom action target.
        public let description: String?
        /// The updated name of the custom action target.
        public let name: String?

        public init(actionTargetArn: String, description: String? = nil, name: String? = nil) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.actionTargetArn, name: "actionTargetArn", parent: name, pattern: ".*\\S.*")
            try validate(self.description, name: "description", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateActionTargetResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateFindingsRequest: AWSEncodableShape {

        /// A collection of attributes that specify which findings you want to update.
        public let filters: AwsSecurityFindingFilters
        /// The updated note for the finding.
        public let note: NoteUpdate?
        /// The updated record state for the finding.
        public let recordState: RecordState?

        public init(filters: AwsSecurityFindingFilters, note: NoteUpdate? = nil, recordState: RecordState? = nil) {
            self.filters = filters
            self.note = note
            self.recordState = recordState
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.note?.validate(name: "\(name).note")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case note = "Note"
            case recordState = "RecordState"
        }
    }

    public struct UpdateFindingsResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateInsightRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightArn", location: .uri(locationName: "InsightArn"))
        ]

        /// The updated filters that define this insight.
        public let filters: AwsSecurityFindingFilters?
        /// The updated GroupBy attribute that defines this insight.
        public let groupByAttribute: String?
        /// The ARN of the insight that you want to update.
        public let insightArn: String
        /// The updated name for the insight.
        public let name: String?

        public init(filters: AwsSecurityFindingFilters? = nil, groupByAttribute: String? = nil, insightArn: String, name: String? = nil) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try validate(self.groupByAttribute, name: "groupByAttribute", parent: name, pattern: ".*\\S.*")
            try validate(self.insightArn, name: "insightArn", parent: name, pattern: ".*\\S.*")
            try validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct UpdateInsightResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateStandardsControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "standardsControlArn", location: .uri(locationName: "StandardsControlArn"))
        ]

        /// The updated status of the security standard control.
        public let controlStatus: ControlStatus?
        /// A description of the reason why you are disabling a security standard control.
        public let disabledReason: String?
        /// The ARN of the security standard control to enable or disable.
        public let standardsControlArn: String

        public init(controlStatus: ControlStatus? = nil, disabledReason: String? = nil, standardsControlArn: String) {
            self.controlStatus = controlStatus
            self.disabledReason = disabledReason
            self.standardsControlArn = standardsControlArn
        }

        public func validate(name: String) throws {
            try validate(self.disabledReason, name: "disabledReason", parent: name, pattern: ".*\\S.*")
            try validate(self.standardsControlArn, name: "standardsControlArn", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case controlStatus = "ControlStatus"
            case disabledReason = "DisabledReason"
        }
    }

    public struct UpdateStandardsControlResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct WafAction: AWSEncodableShape & AWSDecodableShape {

        /// Specifies how you want AWS WAF to respond to requests that match the settings in a Rule. Valid settings include the following:    ALLOW - AWS WAF allows requests    BLOCK - AWS WAF blocks requests    COUNT - AWS WAF increments a counter of the requests that match all of the conditions in the rule. AWS WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify COUNT for the default action for a WebACL.  
        public let `type`: String?

        public init(type: String? = nil) {
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
        }
    }

    public struct WafExcludedRule: AWSEncodableShape & AWSDecodableShape {

        /// The unique identifier for the rule to exclude from the rule group.
        public let ruleId: String?

        public init(ruleId: String? = nil) {
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try validate(self.ruleId, name: "ruleId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
        }
    }

    public struct WafOverrideAction: AWSEncodableShape & AWSDecodableShape {

        ///  COUNT overrides the action specified by the individual rule within a RuleGroup . If set to NONE, the rule's action takes place.
        public let `type`: String?

        public init(type: String? = nil) {
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.`type`, name: "`type`", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
        }
    }

    public struct Workflow: AWSEncodableShape & AWSDecodableShape {

        /// The status of the investigation into the finding. The allowed values are the following.    NEW - The initial state of a finding, before it is reviewed.    NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    SUPPRESSED - The finding will not be reviewed again and will not be acted upon.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.   
        public let status: WorkflowStatus?

        public init(status: WorkflowStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct WorkflowUpdate: AWSEncodableShape {

        /// The status of the investigation into the finding. The allowed values are the following.    NEW - The initial state of a finding, before it is reviewed.    NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.    SUPPRESSED - The finding will not be reviewed again and will not be acted upon.  
        public let status: WorkflowStatus?

        public init(status: WorkflowStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }
}
