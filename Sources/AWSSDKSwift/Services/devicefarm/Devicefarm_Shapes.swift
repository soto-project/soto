// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Devicefarm {

    public struct DeleteUploadResult: AWSShape {
        /// The key for the payload

    }

    public struct ListDevicesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project.
        public let arn: String?

        public init(nextToken: String? = nil, arn: String? = nil) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct NetworkProfile: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "uplinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "downlinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "downlinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "uplinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "downlinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The name of the network profile.
        public let name: String?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The description of the network profile.
        public let description: String?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The Amazon Resource Name (ARN) of the network profile.
        public let arn: String?

        public init(uplinkJitterMs: Int64? = nil, name: String? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkBandwidthBits: Int64? = nil, arn: String? = nil) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case uplinkJitterMs = "uplinkJitterMs"
            case name = "name"
            case downlinkJitterMs = "downlinkJitterMs"
            case downlinkDelayMs = "downlinkDelayMs"
            case uplinkLossPercent = "uplinkLossPercent"
            case downlinkLossPercent = "downlinkLossPercent"
            case description = "description"
            case uplinkDelayMs = "uplinkDelayMs"
            case uplinkBandwidthBits = "uplinkBandwidthBits"
            case `type` = "type"
            case downlinkBandwidthBits = "downlinkBandwidthBits"
            case arn = "arn"
        }
    }

    public struct GetTestResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "test", required: false, type: .structure)
        ]
        /// A test condition that is evaluated.
        public let test: Test?

        public init(test: Test? = nil) {
            self.test = test
        }

        private enum CodingKeys: String, CodingKey {
            case test = "test"
        }
    }

    public struct Rule: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "attribute", required: false, type: .enum), 
            AWSShapeMember(label: "operator", required: false, type: .enum), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]
        /// The rule's stringified attribute. For example, specify the value as "\"abc\"". Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   APPIUM_VERSION: The Appium version for the test.  
        public let attribute: DeviceAttribute?
        /// The rule's operator.   EQUALS: The equals operator.   GREATER_THAN: The greater-than operator.   IN: The in operator.   LESS_THAN: The less-than operator.   NOT_IN: The not-in operator.   CONTAINS: The contains operator.  
        public let `operator`: RuleOperator?
        /// The rule's value.
        public let value: String?

        public init(attribute: DeviceAttribute? = nil, operator: RuleOperator? = nil, value: String? = nil) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct ListTestsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The tests' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct GetUploadResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "upload", required: false, type: .structure)
        ]
        /// An app or a set of one or more tests to upload or that have been uploaded.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload = "upload"
        }
    }

    public struct CreateRemoteAccessSessionConfiguration: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "billingMethod", required: false, type: .enum)
        ]
        /// Returns the billing method for purposes of configuring a remote access session.
        public let billingMethod: BillingMethod?

        public init(billingMethod: BillingMethod? = nil) {
            self.billingMethod = billingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case billingMethod = "billingMethod"
        }
    }

    public struct ListSuitesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "suites", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the suites.
        public let suites: [Suite]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(suites: [Suite]? = nil, nextToken: String? = nil) {
            self.suites = suites
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case suites = "suites"
            case nextToken = "nextToken"
        }
    }

    public struct ListRemoteAccessSessionsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "remoteAccessSessions", required: false, type: .list)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A container representing the metadata from the service about each remote access session you are requesting.
        public let remoteAccessSessions: [RemoteAccessSession]?

        public init(nextToken: String? = nil, remoteAccessSessions: [RemoteAccessSession]? = nil) {
            self.nextToken = nextToken
            self.remoteAccessSessions = remoteAccessSessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case remoteAccessSessions = "remoteAccessSessions"
        }
    }

    public struct UpdateNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "uplinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "downlinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "downlinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "uplinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "downlinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The name of the network profile about which you are returning information.
        public let name: String?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The descriptoin of the network profile about which you are returning information.
        public let description: String?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The Amazon Resource Name (ARN) of the project that you wish to update network profile settings.
        public let arn: String

        public init(uplinkJitterMs: Int64? = nil, name: String? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkBandwidthBits: Int64? = nil, arn: String) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case uplinkJitterMs = "uplinkJitterMs"
            case name = "name"
            case downlinkJitterMs = "downlinkJitterMs"
            case downlinkDelayMs = "downlinkDelayMs"
            case uplinkLossPercent = "uplinkLossPercent"
            case downlinkLossPercent = "downlinkLossPercent"
            case description = "description"
            case uplinkDelayMs = "uplinkDelayMs"
            case uplinkBandwidthBits = "uplinkBandwidthBits"
            case `type` = "type"
            case downlinkBandwidthBits = "downlinkBandwidthBits"
            case arn = "arn"
        }
    }

    public struct GetDevicePoolResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePool", required: false, type: .structure)
        ]
        /// An object containing information about the requested device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool = "devicePool"
        }
    }

    public enum UploadStatus: String, CustomStringConvertible, Codable {
        case initialized = "INITIALIZED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct DevicePool: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "rules", required: false, type: .list), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The device pool's description.
        public let description: String?
        /// The device pool's name.
        public let name: String?
        /// The device pool's type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public let `type`: DevicePoolType?
        /// Information about the device pool's rules.
        public let rules: [Rule]?
        /// The device pool's ARN.
        public let arn: String?

        public init(description: String? = nil, name: String? = nil, type: DevicePoolType? = nil, rules: [Rule]? = nil, arn: String? = nil) {
            self.description = description
            self.name = name
            self.`type` = `type`
            self.rules = rules
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case `type` = "type"
            case rules = "rules"
            case arn = "arn"
        }
    }

    public struct CreateProjectResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "project", required: false, type: .structure)
        ]
        /// The newly created project.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct PurchaseOfferingResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringTransaction", required: false, type: .structure)
        ]
        /// Represents the offering transaction for the purchase result.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        private enum CodingKeys: String, CodingKey {
            case offeringTransaction = "offeringTransaction"
        }
    }

    public struct ExecutionConfiguration: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "accountsCleanup", required: false, type: .boolean), 
            AWSShapeMember(label: "jobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "appPackagesCleanup", required: false, type: .boolean)
        ]
        /// True if account cleanup is enabled at the beginning of the test; otherwise, false.
        public let accountsCleanup: Bool?
        /// The number of minutes a test run will execute before it times out.
        public let jobTimeoutMinutes: Int32?
        /// True if app package cleanup is enabled at the beginning of the test; otherwise, false.
        public let appPackagesCleanup: Bool?

        public init(accountsCleanup: Bool? = nil, jobTimeoutMinutes: Int32? = nil, appPackagesCleanup: Bool? = nil) {
            self.accountsCleanup = accountsCleanup
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.appPackagesCleanup = appPackagesCleanup
        }

        private enum CodingKeys: String, CodingKey {
            case accountsCleanup = "accountsCleanup"
            case jobTimeoutMinutes = "jobTimeoutMinutes"
            case appPackagesCleanup = "appPackagesCleanup"
        }
    }

    public struct MonetaryAmount: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "currencyCode", required: false, type: .enum), 
            AWSShapeMember(label: "amount", required: false, type: .double)
        ]
        /// The currency code of a monetary amount. For example, USD means "U.S. dollars."
        public let currencyCode: CurrencyCode?
        /// The numerical amount of an offering or transaction.
        public let amount: Double?

        public init(currencyCode: CurrencyCode? = nil, amount: Double? = nil) {
            self.currencyCode = currencyCode
            self.amount = amount
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "currencyCode"
            case amount = "amount"
        }
    }

    public struct CreateNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "uplinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "downlinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "downlinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "uplinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "downlinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "projectArn", required: true, type: .string)
        ]
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The name you wish to specify for the new network profile.
        public let name: String
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The description of the network profile.
        public let description: String?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile you wish to create. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
        public let projectArn: String

        public init(uplinkJitterMs: Int64? = nil, name: String, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkBandwidthBits: Int64? = nil, projectArn: String) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case uplinkJitterMs = "uplinkJitterMs"
            case name = "name"
            case downlinkJitterMs = "downlinkJitterMs"
            case downlinkDelayMs = "downlinkDelayMs"
            case uplinkLossPercent = "uplinkLossPercent"
            case downlinkLossPercent = "downlinkLossPercent"
            case description = "description"
            case uplinkDelayMs = "uplinkDelayMs"
            case uplinkBandwidthBits = "uplinkBandwidthBits"
            case `type` = "type"
            case downlinkBandwidthBits = "downlinkBandwidthBits"
            case projectArn = "projectArn"
        }
    }

    public struct GetDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The device pool's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct RemoteAccessSession: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "billingMethod", required: false, type: .enum), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "endpoint", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "device", required: false, type: .structure), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see AWS Device Farm terminology."
        public let billingMethod: BillingMethod?
        /// The status of the remote access session. Can be any of the following:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The name of the remote access session.
        public let name: String?
        /// The endpoint for the remote access sesssion.
        public let endpoint: String?
        /// The date and time the remote access session was created.
        public let created: TimeStamp?
        /// The date and time the remote access session was started.
        public let started: TimeStamp?
        /// The date and time the remote access session was stopped.
        public let stopped: TimeStamp?
        /// The number of minutes a device is used in a remote access sesssion (including setup and teardown minutes).
        public let deviceMinutes: DeviceMinutes?
        /// A message about the remote access session.
        public let message: String?
        /// The device (phone or tablet) used in the remote access session.
        public let device: Device?
        /// The result of the remote access session. Can be any of the following:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The Amazon Resource Name (ARN) of the remote access session.
        public let arn: String?

        public init(billingMethod: BillingMethod? = nil, status: ExecutionStatus? = nil, name: String? = nil, endpoint: String? = nil, created: TimeStamp? = nil, started: TimeStamp? = nil, stopped: TimeStamp? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, device: Device? = nil, result: ExecutionResult? = nil, arn: String? = nil) {
            self.billingMethod = billingMethod
            self.status = status
            self.name = name
            self.endpoint = endpoint
            self.created = created
            self.started = started
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.device = device
            self.result = result
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case billingMethod = "billingMethod"
            case status = "status"
            case name = "name"
            case endpoint = "endpoint"
            case created = "created"
            case started = "started"
            case stopped = "stopped"
            case deviceMinutes = "deviceMinutes"
            case message = "message"
            case device = "device"
            case result = "result"
            case arn = "arn"
        }
    }

    public struct RecurringCharge: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "frequency", required: false, type: .enum), 
            AWSShapeMember(label: "cost", required: false, type: .structure)
        ]
        /// The frequency in which charges will recur.
        public let frequency: RecurringChargeFrequency?
        /// The cost of the recurring charge.
        public let cost: MonetaryAmount?

        public init(frequency: RecurringChargeFrequency? = nil, cost: MonetaryAmount? = nil) {
            self.frequency = frequency
            self.cost = cost
        }

        private enum CodingKeys: String, CodingKey {
            case frequency = "frequency"
            case cost = "cost"
        }
    }

    public struct Suite: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The suite's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The suite's name.
        public let name: String?
        /// When the suite was created.
        public let created: TimeStamp?
        /// The suite's start time.
        public let started: TimeStamp?
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public let deviceMinutes: DeviceMinutes?
        /// The suite's stop time.
        public let stopped: TimeStamp?
        /// A message about the suite's result.
        public let message: String?
        /// The suite's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The suite's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The suite's result counters.
        public let counters: Counters?
        /// The suite's ARN.
        public let arn: String?

        public init(status: ExecutionStatus? = nil, name: String? = nil, created: TimeStamp? = nil, started: TimeStamp? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: TimeStamp? = nil, message: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.message = message
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case name = "name"
            case created = "created"
            case started = "started"
            case deviceMinutes = "deviceMinutes"
            case stopped = "stopped"
            case message = "message"
            case `type` = "type"
            case result = "result"
            case counters = "counters"
            case arn = "arn"
        }
    }

    public struct DeleteUploadRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm upload you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListUniqueProblemsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The unique problems' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct GetAccountSettingsRequest: AWSShape {
        /// The key for the payload

    }

    public enum CurrencyCode: String, CustomStringConvertible, Codable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public struct ProblemDetail: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The problem detail's name.
        public let name: String?
        /// The problem detail's ARN.
        public let arn: String?

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case arn = "arn"
        }
    }

    public struct ScheduleRunConfiguration: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "extraDataPackageArn", required: false, type: .string), 
            AWSShapeMember(label: "location", required: false, type: .structure), 
            AWSShapeMember(label: "networkProfileArn", required: false, type: .string), 
            AWSShapeMember(label: "auxiliaryApps", required: false, type: .list), 
            AWSShapeMember(label: "radios", required: false, type: .structure), 
            AWSShapeMember(label: "locale", required: false, type: .string), 
            AWSShapeMember(label: "billingMethod", required: false, type: .enum)
        ]
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm will extract to external data for Android or the app's sandbox for iOS.
        public let extraDataPackageArn: String?
        /// Information about the location that is used for the run.
        public let location: Location?
        /// Reserved for internal use.
        public let networkProfileArn: String?
        /// A list of auxiliary apps for the run.
        public let auxiliaryApps: [String]?
        /// Information about the radio states for the run.
        public let radios: Radios?
        /// Information about the locale that is used for the run.
        public let locale: String?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public let billingMethod: BillingMethod?

        public init(extraDataPackageArn: String? = nil, location: Location? = nil, networkProfileArn: String? = nil, auxiliaryApps: [String]? = nil, radios: Radios? = nil, locale: String? = nil, billingMethod: BillingMethod? = nil) {
            self.extraDataPackageArn = extraDataPackageArn
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.auxiliaryApps = auxiliaryApps
            self.radios = radios
            self.locale = locale
            self.billingMethod = billingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case extraDataPackageArn = "extraDataPackageArn"
            case location = "location"
            case networkProfileArn = "networkProfileArn"
            case auxiliaryApps = "auxiliaryApps"
            case radios = "radios"
            case locale = "locale"
            case billingMethod = "billingMethod"
        }
    }

    public struct GetJobResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "job", required: false, type: .structure)
        ]
        /// An object containing information about the requested job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public enum RuleOperator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case `in` = "IN"
        case notIn = "NOT_IN"
        case contains = "CONTAINS"
        public var description: String { return self.rawValue }
    }

    public struct ListOfferingsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "offerings", required: false, type: .list)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A value representing the list offering results.
        public let offerings: [Offering]?

        public init(nextToken: String? = nil, offerings: [Offering]? = nil) {
            self.nextToken = nextToken
            self.offerings = offerings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case offerings = "offerings"
        }
    }

    public struct StopRunResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "run", required: false, type: .structure)
        ]
        /// The run that was stopped.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "run"
        }
    }

    public struct ScheduleRunRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "executionConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "test", required: true, type: .structure), 
            AWSShapeMember(label: "appArn", required: false, type: .string), 
            AWSShapeMember(label: "devicePoolArn", required: true, type: .string), 
            AWSShapeMember(label: "configuration", required: false, type: .structure)
        ]
        /// The ARN of the project for the run to be scheduled.
        public let projectArn: String
        /// The name for the run to be scheduled.
        public let name: String?
        /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
        public let executionConfiguration: ExecutionConfiguration?
        /// Information about the test for the run to be scheduled.
        public let test: ScheduleRunTest
        /// The ARN of the app to schedule a run.
        public let appArn: String?
        /// The ARN of the device pool for the run to be scheduled.
        public let devicePoolArn: String
        /// Information about the settings for the run to be scheduled.
        public let configuration: ScheduleRunConfiguration?

        public init(projectArn: String, name: String? = nil, executionConfiguration: ExecutionConfiguration? = nil, test: ScheduleRunTest, appArn: String? = nil, devicePoolArn: String, configuration: ScheduleRunConfiguration? = nil) {
            self.projectArn = projectArn
            self.name = name
            self.executionConfiguration = executionConfiguration
            self.test = test
            self.appArn = appArn
            self.devicePoolArn = devicePoolArn
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case name = "name"
            case executionConfiguration = "executionConfiguration"
            case test = "test"
            case appArn = "appArn"
            case devicePoolArn = "devicePoolArn"
            case configuration = "configuration"
        }
    }

    public enum UploadType: String, CustomStringConvertible, Codable {
        case androidApp = "ANDROID_APP"
        case iosApp = "IOS_APP"
        case webApp = "WEB_APP"
        case externalData = "EXTERNAL_DATA"
        case appiumJavaJunitTestPackage = "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
        case appiumJavaTestngTestPackage = "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
        case appiumPythonTestPackage = "APPIUM_PYTHON_TEST_PACKAGE"
        case appiumWebJavaJunitTestPackage = "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
        case appiumWebJavaTestngTestPackage = "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
        case appiumWebPythonTestPackage = "APPIUM_WEB_PYTHON_TEST_PACKAGE"
        case calabashTestPackage = "CALABASH_TEST_PACKAGE"
        case instrumentationTestPackage = "INSTRUMENTATION_TEST_PACKAGE"
        case uiautomationTestPackage = "UIAUTOMATION_TEST_PACKAGE"
        case uiautomatorTestPackage = "UIAUTOMATOR_TEST_PACKAGE"
        case xctestTestPackage = "XCTEST_TEST_PACKAGE"
        case xctestUiTestPackage = "XCTEST_UI_TEST_PACKAGE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceAttribute: String, CustomStringConvertible, Codable {
        case arn = "ARN"
        case platform = "PLATFORM"
        case formFactor = "FORM_FACTOR"
        case manufacturer = "MANUFACTURER"
        case remoteAccessEnabled = "REMOTE_ACCESS_ENABLED"
        case appiumVersion = "APPIUM_VERSION"
        public var description: String { return self.rawValue }
    }

    public struct Artifact: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "extension", required: false, type: .string), 
            AWSShapeMember(label: "url", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The artifact's name.
        public let name: String?
        /// The artifact's type. Allowed values include the following:   UNKNOWN: An unknown type.   SCREENSHOT: The screenshot type.   DEVICE_LOG: The device log type.   MESSAGE_LOG: The message log type.   RESULT_LOG: The result log type.   SERVICE_LOG: The service log type.   WEBKIT_LOG: The web kit log type.   INSTRUMENTATION_OUTPUT: The instrumentation type.   EXERCISER_MONKEY_OUTPUT: For Android, the artifact (log) generated by an Android fuzz test.   CALABASH_JSON_OUTPUT: The Calabash JSON output type.   CALABASH_PRETTY_OUTPUT: The Calabash pretty output type.   CALABASH_STANDARD_OUTPUT: The Calabash standard output type.   CALABASH_JAVA_XML_OUTPUT: The Calabash Java XML output type.   AUTOMATION_OUTPUT: The automation output type.   APPIUM_SERVER_OUTPUT: The Appium server output type.   APPIUM_JAVA_OUTPUT: The Appium Java output type.   APPIUM_JAVA_XML_OUTPUT: The Appium Java XML output type.   APPIUM_PYTHON_OUTPUT: The Appium Python output type.   APPIUM_PYTHON_XML_OUTPUT: The Appium Python XML output type.   EXPLORER_EVENT_LOG: The Explorer event log output type.   EXPLORER_SUMMARY_LOG: The Explorer summary log output type.   APPLICATION_CRASH_REPORT: The application crash report output type.   XCTEST_LOG: The XCode test output type.  
        public let `type`: ArtifactType?
        /// The artifact's file extension.
        public let `extension`: String?
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the artifact's file.
        public let url: String?
        /// The artifact's ARN.
        public let arn: String?

        public init(name: String? = nil, type: ArtifactType? = nil, extension: String? = nil, url: String? = nil, arn: String? = nil) {
            self.name = name
            self.`type` = `type`
            self.`extension` = `extension`
            self.url = url
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `type` = "type"
            case `extension` = "extension"
            case url = "url"
            case arn = "arn"
        }
    }

    public struct CreateNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure)
        ]
        /// The network profile that is returned by the create network profile request.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
        }
    }

    public struct DeleteNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the network profile you want to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Project: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The project's name.
        public let name: String?
        /// When the project was created.
        public let created: TimeStamp?
        /// The default number of minutes (at the project level) a test run will execute before it times out. Default value is 60 minutes.
        public let defaultJobTimeoutMinutes: Int32?
        /// The project's ARN.
        public let arn: String?

        public init(name: String? = nil, created: TimeStamp? = nil, defaultJobTimeoutMinutes: Int32? = nil, arn: String? = nil) {
            self.name = name
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case created = "created"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
            case arn = "arn"
        }
    }

    public struct ScheduleRunResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "run", required: false, type: .structure)
        ]
        /// Information about the scheduled run.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "run"
        }
    }

    public struct GetRunRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The run's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListNetworkProfilesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfiles", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// A list of the available network profiles.
        public let networkProfiles: [NetworkProfile]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(networkProfiles: [NetworkProfile]? = nil, nextToken: String? = nil) {
            self.networkProfiles = networkProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfiles = "networkProfiles"
            case nextToken = "nextToken"
        }
    }

    public struct ListSamplesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list samples.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct CreateProjectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer)
        ]
        /// The project's name.
        public let name: String
        /// Sets the execution timeout value (in minutes) for a project. All test runs in this project will use the specified execution timeout value unless overridden when scheduling a run.
        public let defaultJobTimeoutMinutes: Int32?

        public init(name: String, defaultJobTimeoutMinutes: Int32? = nil) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
        }
    }

    public struct GetRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSession", required: false, type: .structure)
        ]
        /// A container that lists detailed information about the remote access session.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession = "remoteAccessSession"
        }
    }

    public struct UpdateDevicePoolResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePool", required: false, type: .structure)
        ]
        /// The device pool you just updated.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool = "devicePool"
        }
    }

    public struct PurchaseOfferingRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringPromotionId", required: false, type: .string), 
            AWSShapeMember(label: "quantity", required: false, type: .integer), 
            AWSShapeMember(label: "offeringId", required: false, type: .string)
        ]
        /// The ID of the offering promotion to be applied to the purchase.
        public let offeringPromotionId: String?
        /// The number of device slots you wish to purchase in an offering request.
        public let quantity: Int32?
        /// The ID of the offering.
        public let offeringId: String?

        public init(offeringPromotionId: String? = nil, quantity: Int32? = nil, offeringId: String? = nil) {
            self.offeringPromotionId = offeringPromotionId
            self.quantity = quantity
            self.offeringId = offeringId
        }

        private enum CodingKeys: String, CodingKey {
            case offeringPromotionId = "offeringPromotionId"
            case quantity = "quantity"
            case offeringId = "offeringId"
        }
    }

    public enum ArtifactCategory: String, CustomStringConvertible, Codable {
        case screenshot = "SCREENSHOT"
        case file = "FILE"
        case log = "LOG"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactType: String, CustomStringConvertible, Codable {
        case unknown = "UNKNOWN"
        case screenshot = "SCREENSHOT"
        case deviceLog = "DEVICE_LOG"
        case messageLog = "MESSAGE_LOG"
        case videoLog = "VIDEO_LOG"
        case resultLog = "RESULT_LOG"
        case serviceLog = "SERVICE_LOG"
        case webkitLog = "WEBKIT_LOG"
        case instrumentationOutput = "INSTRUMENTATION_OUTPUT"
        case exerciserMonkeyOutput = "EXERCISER_MONKEY_OUTPUT"
        case calabashJsonOutput = "CALABASH_JSON_OUTPUT"
        case calabashPrettyOutput = "CALABASH_PRETTY_OUTPUT"
        case calabashStandardOutput = "CALABASH_STANDARD_OUTPUT"
        case calabashJavaXmlOutput = "CALABASH_JAVA_XML_OUTPUT"
        case automationOutput = "AUTOMATION_OUTPUT"
        case appiumServerOutput = "APPIUM_SERVER_OUTPUT"
        case appiumJavaOutput = "APPIUM_JAVA_OUTPUT"
        case appiumJavaXmlOutput = "APPIUM_JAVA_XML_OUTPUT"
        case appiumPythonOutput = "APPIUM_PYTHON_OUTPUT"
        case appiumPythonXmlOutput = "APPIUM_PYTHON_XML_OUTPUT"
        case explorerEventLog = "EXPLORER_EVENT_LOG"
        case explorerSummaryLog = "EXPLORER_SUMMARY_LOG"
        case applicationCrashReport = "APPLICATION_CRASH_REPORT"
        case xctestLog = "XCTEST_LOG"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public struct StopRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the remote access session you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum OfferingTransactionType: String, CustomStringConvertible, Codable {
        case purchase = "PURCHASE"
        case renew = "RENEW"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public struct CreateUploadResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "upload", required: false, type: .structure)
        ]
        /// The newly created upload.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload = "upload"
        }
    }

    public struct UniqueProblem: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "problems", required: false, type: .list), 
            AWSShapeMember(label: "message", required: false, type: .string)
        ]
        /// Information about the problems.
        public let problems: [Problem]?
        /// A message about the unique problems' result.
        public let message: String?

        public init(problems: [Problem]? = nil, message: String? = nil) {
            self.problems = problems
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case problems = "problems"
            case message = "message"
        }
    }

    public struct UpdateNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure)
        ]
        /// A list of the available network profiles.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
        }
    }

    public struct ListNetworkProfilesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
        public let arn: String

        public init(type: NetworkProfileType? = nil, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct GetJobRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The job's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListRunsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "runs", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the runs.
        public let runs: [Run]?

        public init(nextToken: String? = nil, runs: [Run]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case runs = "runs"
        }
    }

    public struct ListTestsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "tests", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the tests.
        public let tests: [Test]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(tests: [Test]? = nil, nextToken: String? = nil) {
            self.tests = tests
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case tests = "tests"
            case nextToken = "nextToken"
        }
    }

    public struct DeleteNetworkProfileResult: AWSShape {
        /// The key for the payload

    }

    public struct ListOfferingPromotionsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringPromotions", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the offering promotions.
        public let offeringPromotions: [OfferingPromotion]?
        /// An identifier to be used in the next call to this operation, to return the next set of items in the list.
        public let nextToken: String?

        public init(offeringPromotions: [OfferingPromotion]? = nil, nextToken: String? = nil) {
            self.offeringPromotions = offeringPromotions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case offeringPromotions = "offeringPromotions"
            case nextToken = "nextToken"
        }
    }

    public struct OfferingTransaction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "transactionId", required: false, type: .string), 
            AWSShapeMember(label: "cost", required: false, type: .structure), 
            AWSShapeMember(label: "createdOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "offeringPromotionId", required: false, type: .string), 
            AWSShapeMember(label: "offeringStatus", required: false, type: .structure)
        ]
        /// The transaction ID of the offering transaction.
        public let transactionId: String?
        /// The cost of an offering transaction.
        public let cost: MonetaryAmount?
        /// The date on which an offering transaction was created.
        public let createdOn: TimeStamp?
        /// The ID that corresponds to a device offering promotion.
        public let offeringPromotionId: String?
        /// The status of an offering transaction.
        public let offeringStatus: OfferingStatus?

        public init(transactionId: String? = nil, cost: MonetaryAmount? = nil, createdOn: TimeStamp? = nil, offeringPromotionId: String? = nil, offeringStatus: OfferingStatus? = nil) {
            self.transactionId = transactionId
            self.cost = cost
            self.createdOn = createdOn
            self.offeringPromotionId = offeringPromotionId
            self.offeringStatus = offeringStatus
        }

        private enum CodingKeys: String, CodingKey {
            case transactionId = "transactionId"
            case cost = "cost"
            case createdOn = "createdOn"
            case offeringPromotionId = "offeringPromotionId"
            case offeringStatus = "offeringStatus"
        }
    }

    public enum RecurringChargeFrequency: String, CustomStringConvertible, Codable {
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public struct ListOfferingPromotionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct ListDevicesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "devices", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the devices.
        public let devices: [Device]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "devices"
            case nextToken = "nextToken"
        }
    }

    public struct ListUploadsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploads", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the uploads.
        public let uploads: [Upload]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(uploads: [Upload]? = nil, nextToken: String? = nil) {
            self.uploads = uploads
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case uploads = "uploads"
            case nextToken = "nextToken"
        }
    }

    public struct Offering: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "recurringCharges", required: false, type: .list), 
            AWSShapeMember(label: "id", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "platform", required: false, type: .enum)
        ]
        /// A string describing the offering.
        public let description: String?
        /// Specifies whether there are recurring charges for the offering.
        public let recurringCharges: [RecurringCharge]?
        /// The ID that corresponds to a device offering.
        public let id: String?
        /// The type of offering (e.g., "RECURRING") for a device.
        public let `type`: OfferingType?
        /// The platform of the device (e.g., ANDROID or IOS).
        public let platform: DevicePlatform?

        public init(description: String? = nil, recurringCharges: [RecurringCharge]? = nil, id: String? = nil, type: OfferingType? = nil, platform: DevicePlatform? = nil) {
            self.description = description
            self.recurringCharges = recurringCharges
            self.id = id
            self.`type` = `type`
            self.platform = platform
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case recurringCharges = "recurringCharges"
            case id = "id"
            case `type` = "type"
            case platform = "platform"
        }
    }

    public struct GetSuiteResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "suite", required: false, type: .structure)
        ]
        /// A collection of one or more tests.
        public let suite: Suite?

        public init(suite: Suite? = nil) {
            self.suite = suite
        }

        private enum CodingKeys: String, CodingKey {
            case suite = "suite"
        }
    }

    public struct GetSuiteRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The suite's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetUploadRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The upload's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Test: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The test's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The test's name.
        public let name: String?
        /// When the test was created.
        public let created: TimeStamp?
        /// The test's start time.
        public let started: TimeStamp?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public let deviceMinutes: DeviceMinutes?
        /// The test's stop time.
        public let stopped: TimeStamp?
        /// A message about the test's result.
        public let message: String?
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The test's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The test's result counters.
        public let counters: Counters?
        /// The test's ARN.
        public let arn: String?

        public init(status: ExecutionStatus? = nil, name: String? = nil, created: TimeStamp? = nil, started: TimeStamp? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: TimeStamp? = nil, message: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.message = message
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case name = "name"
            case created = "created"
            case started = "started"
            case deviceMinutes = "deviceMinutes"
            case stopped = "stopped"
            case message = "message"
            case `type` = "type"
            case result = "result"
            case counters = "counters"
            case arn = "arn"
        }
    }

    public struct DeleteRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the sesssion for which you want to delete remote access.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetOfferingStatusResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextPeriod", required: false, type: .map), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "current", required: false, type: .map)
        ]
        /// When specified, gets the offering status for the next period.
        public let nextPeriod: [String: OfferingStatus]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// When specified, gets the offering status for the current period.
        public let current: [String: OfferingStatus]?

        public init(nextPeriod: [String: OfferingStatus]? = nil, nextToken: String? = nil, current: [String: OfferingStatus]? = nil) {
            self.nextPeriod = nextPeriod
            self.nextToken = nextToken
            self.current = current
        }

        private enum CodingKeys: String, CodingKey {
            case nextPeriod = "nextPeriod"
            case nextToken = "nextToken"
            case current = "current"
        }
    }

    public enum TestType: String, CustomStringConvertible, Codable {
        case builtinFuzz = "BUILTIN_FUZZ"
        case builtinExplorer = "BUILTIN_EXPLORER"
        case appiumJavaJunit = "APPIUM_JAVA_JUNIT"
        case appiumJavaTestng = "APPIUM_JAVA_TESTNG"
        case appiumPython = "APPIUM_PYTHON"
        case appiumWebJavaJunit = "APPIUM_WEB_JAVA_JUNIT"
        case appiumWebJavaTestng = "APPIUM_WEB_JAVA_TESTNG"
        case appiumWebPython = "APPIUM_WEB_PYTHON"
        case calabash = "CALABASH"
        case instrumentation = "INSTRUMENTATION"
        case uiautomation = "UIAUTOMATION"
        case uiautomator = "UIAUTOMATOR"
        case xctest = "XCTEST"
        case xctestUi = "XCTEST_UI"
        public var description: String { return self.rawValue }
    }

    public struct GetOfferingStatusRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct IncompatibilityMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "message", required: false, type: .string)
        ]
        /// The type of incompatibility. Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   APPIUM_VERSION: The Appium version for the test.  
        public let `type`: DeviceAttribute?
        /// A message about the incompatibility.
        public let message: String?

        public init(type: DeviceAttribute? = nil, message: String? = nil) {
            self.`type` = `type`
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case message = "message"
        }
    }

    public struct CreateUploadRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "contentType", required: false, type: .string), 
            AWSShapeMember(label: "type", required: true, type: .enum), 
            AWSShapeMember(label: "projectArn", required: true, type: .string)
        ]
        /// The upload's file name. The name should not contain the '/' character. If uploading an iOS app, the file name needs to end with the .ipa extension. If uploading an Android app, the file name needs to end with the .apk extension. For all others, the file name must end with the .zip file extension.
        public let name: String
        /// The upload's content type (for example, "application/octet-stream").
        public let contentType: String?
        /// The upload's upload type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.    Note If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
        public let `type`: UploadType
        /// The ARN of the project for the upload.
        public let projectArn: String

        public init(name: String, contentType: String? = nil, type: UploadType, projectArn: String) {
            self.name = name
            self.contentType = contentType
            self.`type` = `type`
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case contentType = "contentType"
            case `type` = "type"
            case projectArn = "projectArn"
        }
    }

    public struct UpdateProjectResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "project", required: false, type: .structure)
        ]
        /// The project you wish to update.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct ScheduleRunTest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "filter", required: false, type: .string), 
            AWSShapeMember(label: "type", required: true, type: .enum), 
            AWSShapeMember(label: "testPackageArn", required: false, type: .string), 
            AWSShapeMember(label: "parameters", required: false, type: .map)
        ]
        /// The test's filter.
        public let filter: String?
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType
        /// The ARN of the uploaded test that will be run.
        public let testPackageArn: String?
        /// The test's parameters, such as the following test framework parameters and fixture settings: For Calabash tests:   profile: A cucumber profile, for example, "my_profile_name".   tags: You can limit execution to features or scenarios that have (or don't have) certain tags, for example, "@smoke" or "@smoke,~@wip".   For Appium tests (all types):   appium_version: The Appium version. Currently supported values are "1.4.16", "1.6.3", "latest", and "default".   latest will run the latest Appium version supported by Device Farm (1.6.3).   For default, Device Farm will choose a compatible version of Appium for the device. The current behavior is to run 1.4.16 on Android devices and iOS 9 and earlier, 1.6.3 for iOS 10 and later.   This behavior is subject to change.     For Fuzz tests (Android only):   event_count: The number of events, between 1 and 10000, that the UI fuzz test should perform.   throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should wait between events.   seed: A seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.   For Explorer tests:   username: A username to use if the Explorer encounters a login form. If not supplied, no username will be inserted.   password: A password to use if the Explorer encounters a login form. If not supplied, no password will be inserted.   For Instrumentation:   filter: A test filter string. Examples:   Running a single test case: "com.android.abc.Test1"   Running a single test: "com.android.abc.Test1#smoke"   Running multiple tests: "com.android.abc.Test1,com.android.abc.Test2"     For XCTest and XCTestUI:   filter: A test filter string. Examples:   Running a single test class: "LoginTests"   Running a multiple test classes: "LoginTests,SmokeTests"   Running a single test: "LoginTests/testValid"   Running multiple tests: "LoginTests/testValid,LoginTests/testInvalid"     For UIAutomator:   filter: A test filter string. Examples:   Running a single test case: "com.android.abc.Test1"   Running a single test: "com.android.abc.Test1#smoke"   Running multiple tests: "com.android.abc.Test1,com.android.abc.Test2"    
        public let parameters: [String: String]?

        public init(filter: String? = nil, type: TestType, testPackageArn: String? = nil, parameters: [String: String]? = nil) {
            self.filter = filter
            self.`type` = `type`
            self.testPackageArn = testPackageArn
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case `type` = "type"
            case testPackageArn = "testPackageArn"
            case parameters = "parameters"
        }
    }

    public struct DeleteDevicePoolResult: AWSShape {
        /// The key for the payload

    }

    public struct ListUploadsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct CreateRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSession", required: false, type: .structure)
        ]
        /// A container that describes the remote access session when the request to create a remote access session is sent.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession = "remoteAccessSession"
        }
    }

    public struct GetDeviceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The device type's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Radios: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "wifi", required: false, type: .boolean), 
            AWSShapeMember(label: "bluetooth", required: false, type: .boolean), 
            AWSShapeMember(label: "nfc", required: false, type: .boolean), 
            AWSShapeMember(label: "gps", required: false, type: .boolean)
        ]
        /// True if Wi-Fi is enabled at the beginning of the test; otherwise, false.
        public let wifi: Bool?
        /// True if Bluetooth is enabled at the beginning of the test; otherwise, false.
        public let bluetooth: Bool?
        /// True if NFC is enabled at the beginning of the test; otherwise, false.
        public let nfc: Bool?
        /// True if GPS is enabled at the beginning of the test; otherwise, false.
        public let gps: Bool?

        public init(wifi: Bool? = nil, bluetooth: Bool? = nil, nfc: Bool? = nil, gps: Bool? = nil) {
            self.wifi = wifi
            self.bluetooth = bluetooth
            self.nfc = nfc
            self.gps = gps
        }

        private enum CodingKeys: String, CodingKey {
            case wifi = "wifi"
            case bluetooth = "bluetooth"
            case nfc = "nfc"
            case gps = "gps"
        }
    }

    public enum DeviceFormFactor: String, CustomStringConvertible, Codable {
        case phone = "PHONE"
        case tablet = "TABLET"
        public var description: String { return self.rawValue }
    }

    public struct GetRunResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "run", required: false, type: .structure)
        ]
        /// The run you wish to get results from.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "run"
        }
    }

    public struct RenewOfferingResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringTransaction", required: false, type: .structure)
        ]
        /// Represents the status of the offering transaction for the renewal.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        private enum CodingKeys: String, CodingKey {
            case offeringTransaction = "offeringTransaction"
        }
    }

    public enum NetworkProfileType: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "deviceArn", required: true, type: .string), 
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "configuration", required: false, type: .structure)
        ]
        /// The name of the remote access session that you wish to create.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the device for which you want to create a remote access session.
        public let deviceArn: String
        /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
        public let projectArn: String
        /// The configuration information for the remote access session request.
        public let configuration: CreateRemoteAccessSessionConfiguration?

        public init(name: String? = nil, deviceArn: String, projectArn: String, configuration: CreateRemoteAccessSessionConfiguration? = nil) {
            self.name = name
            self.deviceArn = deviceArn
            self.projectArn = projectArn
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case deviceArn = "deviceArn"
            case projectArn = "projectArn"
            case configuration = "configuration"
        }
    }

    public struct ListJobsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "jobs", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the jobs.
        public let jobs: [Job]?

        public init(nextToken: String? = nil, jobs: [Job]? = nil) {
            self.nextToken = nextToken
            self.jobs = jobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case jobs = "jobs"
        }
    }

    public struct ListSamplesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "samples", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the samples.
        public let samples: [Sample]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(samples: [Sample]? = nil, nextToken: String? = nil) {
            self.samples = samples
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case samples = "samples"
            case nextToken = "nextToken"
        }
    }

    public struct CreateDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "rules", required: true, type: .list), 
            AWSShapeMember(label: "projectArn", required: true, type: .string)
        ]
        /// The device pool's description.
        public let description: String?
        /// The device pool's name.
        public let name: String
        /// The device pool's rules.
        public let rules: [Rule]
        /// The ARN of the project for the device pool.
        public let projectArn: String

        public init(description: String? = nil, name: String, rules: [Rule], projectArn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case rules = "rules"
            case projectArn = "projectArn"
        }
    }

    public struct ListProjectsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "projects", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the projects.
        public let projects: [Project]?

        public init(nextToken: String? = nil, projects: [Project]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projects = "projects"
        }
    }

    public struct OfferingStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "quantity", required: false, type: .integer), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "effectiveOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "offering", required: false, type: .structure)
        ]
        /// The number of available devices in the offering.
        public let quantity: Int32?
        /// The type specified for the offering status.
        public let `type`: OfferingTransactionType?
        /// The date on which the offering is effective.
        public let effectiveOn: TimeStamp?
        /// Represents the metadata of an offering status.
        public let offering: Offering?

        public init(quantity: Int32? = nil, type: OfferingTransactionType? = nil, effectiveOn: TimeStamp? = nil, offering: Offering? = nil) {
            self.quantity = quantity
            self.`type` = `type`
            self.effectiveOn = effectiveOn
            self.offering = offering
        }

        private enum CodingKeys: String, CodingKey {
            case quantity = "quantity"
            case `type` = "type"
            case effectiveOn = "effectiveOn"
            case offering = "offering"
        }
    }

    public struct ListDevicePoolsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The device pools' type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public let `type`: DevicePoolType?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The project ARN.
        public let arn: String

        public init(type: DevicePoolType? = nil, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct ListJobsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The jobs' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct Run: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "platform", required: false, type: .enum), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "completedJobs", required: false, type: .integer), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "totalJobs", required: false, type: .integer), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "networkProfile", required: false, type: .structure), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "billingMethod", required: false, type: .enum)
        ]
        /// The run's name.
        public let name: String?
        /// The run's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public let platform: DevicePlatform?
        /// The run's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The run's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The run's ARN.
        public let arn: String?
        /// The run's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The total number of completed jobs.
        public let completedJobs: Int32?
        /// When the run was created.
        public let created: TimeStamp?
        /// The run's start time.
        public let started: TimeStamp?
        /// The total number of jobs for the run.
        public let totalJobs: Int32?
        /// The run's stop time.
        public let stopped: TimeStamp?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public let deviceMinutes: DeviceMinutes?
        /// A message about the run's result.
        public let message: String?
        /// The network profile being used for a test run.
        public let networkProfile: NetworkProfile?
        /// The run's result counters.
        public let counters: Counters?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public let billingMethod: BillingMethod?

        public init(name: String? = nil, platform: DevicePlatform? = nil, type: TestType? = nil, result: ExecutionResult? = nil, arn: String? = nil, status: ExecutionStatus? = nil, completedJobs: Int32? = nil, created: TimeStamp? = nil, started: TimeStamp? = nil, totalJobs: Int32? = nil, stopped: TimeStamp? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, networkProfile: NetworkProfile? = nil, counters: Counters? = nil, billingMethod: BillingMethod? = nil) {
            self.name = name
            self.platform = platform
            self.`type` = `type`
            self.result = result
            self.arn = arn
            self.status = status
            self.completedJobs = completedJobs
            self.created = created
            self.started = started
            self.totalJobs = totalJobs
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.networkProfile = networkProfile
            self.counters = counters
            self.billingMethod = billingMethod
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case platform = "platform"
            case `type` = "type"
            case result = "result"
            case arn = "arn"
            case status = "status"
            case completedJobs = "completedJobs"
            case created = "created"
            case started = "started"
            case totalJobs = "totalJobs"
            case stopped = "stopped"
            case deviceMinutes = "deviceMinutes"
            case message = "message"
            case networkProfile = "networkProfile"
            case counters = "counters"
            case billingMethod = "billingMethod"
        }
    }

    public struct TrialMinutes: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "total", required: false, type: .double), 
            AWSShapeMember(label: "remaining", required: false, type: .double)
        ]
        /// The total number of free trial minutes that the account started with.
        public let total: Double?
        /// The number of free trial minutes remaining in the account.
        public let remaining: Double?

        public init(total: Double? = nil, remaining: Double? = nil) {
            self.total = total
            self.remaining = remaining
        }

        private enum CodingKeys: String, CodingKey {
            case total = "total"
            case remaining = "remaining"
        }
    }

    public struct DevicePoolCompatibilityResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "device", required: false, type: .structure), 
            AWSShapeMember(label: "compatible", required: false, type: .boolean), 
            AWSShapeMember(label: "incompatibilityMessages", required: false, type: .list)
        ]
        /// The device (phone or tablet) that you wish to return information about.
        public let device: Device?
        /// Whether the result was compatible with the device pool.
        public let compatible: Bool?
        /// Information about the compatibility.
        public let incompatibilityMessages: [IncompatibilityMessage]?

        public init(device: Device? = nil, compatible: Bool? = nil, incompatibilityMessages: [IncompatibilityMessage]? = nil) {
            self.device = device
            self.compatible = compatible
            self.incompatibilityMessages = incompatibilityMessages
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
            case compatible = "compatible"
            case incompatibilityMessages = "incompatibilityMessages"
        }
    }

    public struct Upload: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "metadata", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "contentType", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "url", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public let metadata: String?
        /// The upload's status. Must be one of the following values:   FAILED: A failed status.   INITIALIZED: An initialized status.   PROCESSING: A processing status.   SUCCEEDED: A succeeded status.  
        public let status: UploadStatus?
        /// The upload's content type (for example, "application/octet-stream").
        public let contentType: String?
        /// The upload's file name.
        public let name: String?
        /// When the upload was created.
        public let created: TimeStamp?
        /// A message about the upload's result.
        public let message: String?
        /// The upload's type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.  
        public let `type`: UploadType?
        /// The pre-signed Amazon S3 URL that was used to store a file through a corresponding PUT request.
        public let url: String?
        /// The upload's ARN.
        public let arn: String?

        public init(metadata: String? = nil, status: UploadStatus? = nil, contentType: String? = nil, name: String? = nil, created: TimeStamp? = nil, message: String? = nil, type: UploadType? = nil, url: String? = nil, arn: String? = nil) {
            self.metadata = metadata
            self.status = status
            self.contentType = contentType
            self.name = name
            self.created = created
            self.message = message
            self.`type` = `type`
            self.url = url
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case status = "status"
            case contentType = "contentType"
            case name = "name"
            case created = "created"
            case message = "message"
            case `type` = "type"
            case url = "url"
            case arn = "arn"
        }
    }

    public struct ListOfferingsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct DeleteRunResult: AWSShape {
        /// The key for the payload

    }

    public struct DeleteProjectResult: AWSShape {
        /// The key for the payload

    }

    public struct ListDevicePoolsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePools", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the device pools.
        public let devicePools: [DevicePool]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devicePools: [DevicePool]? = nil, nextToken: String? = nil) {
            self.devicePools = devicePools
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devicePools = "devicePools"
            case nextToken = "nextToken"
        }
    }

    public struct ListOfferingTransactionsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "offeringTransactions", required: false, type: .list)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
        public let offeringTransactions: [OfferingTransaction]?

        public init(nextToken: String? = nil, offeringTransactions: [OfferingTransaction]? = nil) {
            self.nextToken = nextToken
            self.offeringTransactions = offeringTransactions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case offeringTransactions = "offeringTransactions"
        }
    }

    public enum DevicePoolType: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListSuitesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The suites' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct CPU: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "frequency", required: false, type: .string), 
            AWSShapeMember(label: "architecture", required: false, type: .string), 
            AWSShapeMember(label: "clock", required: false, type: .double)
        ]
        /// The CPU's frequency.
        public let frequency: String?
        /// The CPU's architecture, for example x86 or ARM.
        public let architecture: String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public let clock: Double?

        public init(frequency: String? = nil, architecture: String? = nil, clock: Double? = nil) {
            self.frequency = frequency
            self.architecture = architecture
            self.clock = clock
        }

        private enum CodingKeys: String, CodingKey {
            case frequency = "frequency"
            case architecture = "architecture"
            case clock = "clock"
        }
    }

    public struct InstallToRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "appUpload", required: false, type: .structure)
        ]
        /// An app to upload or that has been uploaded.
        public let appUpload: Upload?

        public init(appUpload: Upload? = nil) {
            self.appUpload = appUpload
        }

        private enum CodingKeys: String, CodingKey {
            case appUpload = "appUpload"
        }
    }

    public struct GetNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the network profile you want to return information about.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Counters: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "warned", required: false, type: .integer), 
            AWSShapeMember(label: "errored", required: false, type: .integer), 
            AWSShapeMember(label: "failed", required: false, type: .integer), 
            AWSShapeMember(label: "skipped", required: false, type: .integer), 
            AWSShapeMember(label: "passed", required: false, type: .integer), 
            AWSShapeMember(label: "stopped", required: false, type: .integer), 
            AWSShapeMember(label: "total", required: false, type: .integer)
        ]
        /// The number of warned entities.
        public let warned: Int32?
        /// The number of errored entities.
        public let errored: Int32?
        /// The number of failed entities.
        public let failed: Int32?
        /// The number of skipped entities.
        public let skipped: Int32?
        /// The number of passed entities.
        public let passed: Int32?
        /// The number of stopped entities.
        public let stopped: Int32?
        /// The total number of entities.
        public let total: Int32?

        public init(warned: Int32? = nil, errored: Int32? = nil, failed: Int32? = nil, skipped: Int32? = nil, passed: Int32? = nil, stopped: Int32? = nil, total: Int32? = nil) {
            self.warned = warned
            self.errored = errored
            self.failed = failed
            self.skipped = skipped
            self.passed = passed
            self.stopped = stopped
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case warned = "warned"
            case errored = "errored"
            case failed = "failed"
            case skipped = "skipped"
            case passed = "passed"
            case stopped = "stopped"
            case total = "total"
        }
    }

    public struct DeleteRemoteAccessSessionResult: AWSShape {
        /// The key for the payload

    }

    public struct DeviceMinutes: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "total", required: false, type: .double), 
            AWSShapeMember(label: "metered", required: false, type: .double), 
            AWSShapeMember(label: "unmetered", required: false, type: .double)
        ]
        /// When specified, represents the total minutes used by the resource to run tests.
        public let total: Double?
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public let metered: Double?
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public let unmetered: Double?

        public init(total: Double? = nil, metered: Double? = nil, unmetered: Double? = nil) {
            self.total = total
            self.metered = metered
            self.unmetered = unmetered
        }

        private enum CodingKeys: String, CodingKey {
            case total = "total"
            case metered = "metered"
            case unmetered = "unmetered"
        }
    }

    public struct ListRemoteAccessSessionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct ListArtifactsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: true, type: .enum), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The artifacts' type. Allowed values include:   FILE: The artifacts are files.   LOG: The artifacts are logs.   SCREENSHOT: The artifacts are screenshots.  
        public let `type`: ArtifactCategory
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Run, Job, Suite, or Test ARN.
        public let arn: String

        public init(type: ArtifactCategory, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct GetTestRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The test's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetDeviceResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "device", required: false, type: .structure)
        ]
        /// An object containing information about the requested device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
        }
    }

    public struct DeleteProjectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm project you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case pendingConcurrency = "PENDING_CONCURRENCY"
        case pendingDevice = "PENDING_DEVICE"
        case processing = "PROCESSING"
        case scheduling = "SCHEDULING"
        case preparing = "PREPARING"
        case running = "RUNNING"
        case completed = "COMPLETED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public struct StopRunRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm run you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum OfferingType: String, CustomStringConvertible, Codable {
        case recurring = "RECURRING"
        public var description: String { return self.rawValue }
    }

    public struct OfferingPromotion: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "id", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string)
        ]
        /// The ID of the offering promotion.
        public let id: String?
        /// A string describing the offering promotion.
        public let description: String?

        public init(id: String? = nil, description: String? = nil) {
            self.id = id
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case description = "description"
        }
    }

    public struct ListUniqueProblemsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "uniqueProblems", required: false, type: .map), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the unique problems. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let uniqueProblems: [ExecutionResult: [UniqueProblem]]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(uniqueProblems: [ExecutionResult: [UniqueProblem]]? = nil, nextToken: String? = nil) {
            self.uniqueProblems = uniqueProblems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case uniqueProblems = "uniqueProblems"
            case nextToken = "nextToken"
        }
    }

    public enum DevicePlatform: String, CustomStringConvertible, Codable {
        case android = "ANDROID"
        case ios = "IOS"
        public var description: String { return self.rawValue }
    }

    public struct Problem: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "test", required: false, type: .structure), 
            AWSShapeMember(label: "suite", required: false, type: .structure), 
            AWSShapeMember(label: "job", required: false, type: .structure), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "device", required: false, type: .structure), 
            AWSShapeMember(label: "run", required: false, type: .structure), 
            AWSShapeMember(label: "result", required: false, type: .enum)
        ]
        /// Information about the associated test.
        public let test: ProblemDetail?
        /// Information about the associated suite.
        public let suite: ProblemDetail?
        /// Information about the associated job.
        public let job: ProblemDetail?
        /// A message about the problem's result.
        public let message: String?
        /// Information about the associated device.
        public let device: Device?
        /// Information about the associated run.
        public let run: ProblemDetail?
        /// The problem's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?

        public init(test: ProblemDetail? = nil, suite: ProblemDetail? = nil, job: ProblemDetail? = nil, message: String? = nil, device: Device? = nil, run: ProblemDetail? = nil, result: ExecutionResult? = nil) {
            self.test = test
            self.suite = suite
            self.job = job
            self.message = message
            self.device = device
            self.run = run
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case test = "test"
            case suite = "suite"
            case job = "job"
            case message = "message"
            case device = "device"
            case run = "run"
            case result = "result"
        }
    }

    public struct Sample: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "url", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The sample's type. Must be one of the following values:   CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.   MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.   NATIVE_AVG_DRAWTIME   NATIVE_FPS   NATIVE_FRAMES   NATIVE_MAX_DRAWTIME   NATIVE_MIN_DRAWTIME   OPENGL_AVG_DRAWTIME   OPENGL_FPS   OPENGL_FRAMES   OPENGL_MAX_DRAWTIME   OPENGL_MIN_DRAWTIME   RX   RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.   THREADS: A threads sample type. This is expressed as the total number of threads per app process.   TX   TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.  
        public let `type`: SampleType?
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the sample's file.
        public let url: String?
        /// The sample's ARN.
        public let arn: String?

        public init(type: SampleType? = nil, url: String? = nil, arn: String? = nil) {
            self.`type` = `type`
            self.url = url
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case url = "url"
            case arn = "arn"
        }
    }

    public struct DeleteRunRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) for the run you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateDevicePoolResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePool", required: false, type: .structure)
        ]
        /// The newly created device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool = "devicePool"
        }
    }

    public struct UpdateDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "rules", required: false, type: .list), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// A description of the device pool you wish to update.
        public let description: String?
        /// A string representing the name of the device pool you wish to update.
        public let name: String?
        /// Represents the rules you wish to modify for the device pool. Updating rules is optional; however, if you choose to update rules for your request, the update will replace the existing rules.
        public let rules: [Rule]?
        /// The Amazon Resourc Name (ARN) of the Device Farm device pool you wish to update.
        public let arn: String

        public init(description: String? = nil, name: String? = nil, rules: [Rule]? = nil, arn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case rules = "rules"
            case arn = "arn"
        }
    }

    public enum SampleType: String, CustomStringConvertible, Codable {
        case cpu = "CPU"
        case memory = "MEMORY"
        case threads = "THREADS"
        case rxRate = "RX_RATE"
        case txRate = "TX_RATE"
        case rx = "RX"
        case tx = "TX"
        case nativeFrames = "NATIVE_FRAMES"
        case nativeFps = "NATIVE_FPS"
        case nativeMinDrawtime = "NATIVE_MIN_DRAWTIME"
        case nativeAvgDrawtime = "NATIVE_AVG_DRAWTIME"
        case nativeMaxDrawtime = "NATIVE_MAX_DRAWTIME"
        case openglFrames = "OPENGL_FRAMES"
        case openglFps = "OPENGL_FPS"
        case openglMinDrawtime = "OPENGL_MIN_DRAWTIME"
        case openglAvgDrawtime = "OPENGL_AVG_DRAWTIME"
        case openglMaxDrawtime = "OPENGL_MAX_DRAWTIME"
        public var description: String { return self.rawValue }
    }

    public struct ListOfferingTransactionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct AccountSettings: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "trialMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "unmeteredDevices", required: false, type: .map), 
            AWSShapeMember(label: "maxJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "maxSlots", required: false, type: .map), 
            AWSShapeMember(label: "unmeteredRemoteAccessDevices", required: false, type: .map), 
            AWSShapeMember(label: "awsAccountNumber", required: false, type: .string), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer)
        ]
        /// Information about an AWS account's usage of free trial device minutes.
        public let trialMinutes: TrialMinutes?
        /// Returns the unmetered devices you have purchased or want to purchase.
        public let unmeteredDevices: [DevicePlatform: Int32]?
        /// The maximum number of minutes a test run will execute before it times out.
        public let maxJobTimeoutMinutes: Int32?
        /// The maximum number of device slots that the AWS account can purchase. Each maximum is expressed as an offering-id:number pair, where the offering-id represents one of the IDs returned by the ListOfferings command.
        public let maxSlots: [String: Int32]?
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public let unmeteredRemoteAccessDevices: [DevicePlatform: Int32]?
        /// The AWS account number specified in the AccountSettings container.
        public let awsAccountNumber: String?
        /// The default number of minutes (at the account level) a test run will execute before it times out. Default value is 60 minutes.
        public let defaultJobTimeoutMinutes: Int32?

        public init(trialMinutes: TrialMinutes? = nil, unmeteredDevices: [DevicePlatform: Int32]? = nil, maxJobTimeoutMinutes: Int32? = nil, maxSlots: [String: Int32]? = nil, unmeteredRemoteAccessDevices: [DevicePlatform: Int32]? = nil, awsAccountNumber: String? = nil, defaultJobTimeoutMinutes: Int32? = nil) {
            self.trialMinutes = trialMinutes
            self.unmeteredDevices = unmeteredDevices
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.maxSlots = maxSlots
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
            self.awsAccountNumber = awsAccountNumber
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case trialMinutes = "trialMinutes"
            case unmeteredDevices = "unmeteredDevices"
            case maxJobTimeoutMinutes = "maxJobTimeoutMinutes"
            case maxSlots = "maxSlots"
            case unmeteredRemoteAccessDevices = "unmeteredRemoteAccessDevices"
            case awsAccountNumber = "awsAccountNumber"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
        }
    }

    public struct StopRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSession", required: false, type: .structure)
        ]
        /// A container representing the metadata from the service about the remote access session you are stopping.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession = "remoteAccessSession"
        }
    }

    public struct ListArtifactsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "artifacts", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the artifacts.
        public let artifacts: [Artifact]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(artifacts: [Artifact]? = nil, nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "artifacts"
            case nextToken = "nextToken"
        }
    }

    public struct GetNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure)
        ]
        /// The network profile.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
        }
    }

    public struct Location: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "longitude", required: true, type: .double), 
            AWSShapeMember(label: "latitude", required: true, type: .double)
        ]
        /// The longitude.
        public let longitude: Double
        /// The latitude.
        public let latitude: Double

        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        private enum CodingKeys: String, CodingKey {
            case longitude = "longitude"
            case latitude = "latitude"
        }
    }

    public struct GetAccountSettingsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "accountSettings", required: false, type: .structure)
        ]
        /// The account settings.
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct GetDevicePoolCompatibilityRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "testType", required: false, type: .enum), 
            AWSShapeMember(label: "test", required: false, type: .structure), 
            AWSShapeMember(label: "appArn", required: false, type: .string), 
            AWSShapeMember(label: "devicePoolArn", required: true, type: .string)
        ]
        /// The test type for the specified device pool. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let testType: TestType?
        /// Information about the uploaded test to be run against the device pool.
        public let test: ScheduleRunTest?
        /// The ARN of the app that is associated with the specified device pool.
        public let appArn: String?
        /// The device pool's ARN.
        public let devicePoolArn: String

        public init(testType: TestType? = nil, test: ScheduleRunTest? = nil, appArn: String? = nil, devicePoolArn: String) {
            self.testType = testType
            self.test = test
            self.appArn = appArn
            self.devicePoolArn = devicePoolArn
        }

        private enum CodingKeys: String, CodingKey {
            case testType = "testType"
            case test = "test"
            case appArn = "appArn"
            case devicePoolArn = "devicePoolArn"
        }
    }

    public struct Resolution: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "height", required: false, type: .integer), 
            AWSShapeMember(label: "width", required: false, type: .integer)
        ]
        /// The screen resolution's height, expressed in pixels.
        public let height: Int32?
        /// The screen resolution's width, expressed in pixels.
        public let width: Int32?

        public init(height: Int32? = nil, width: Int32? = nil) {
            self.height = height
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case width = "width"
        }
    }

    public struct RenewOfferingRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringId", required: false, type: .string), 
            AWSShapeMember(label: "quantity", required: false, type: .integer)
        ]
        /// The ID of a request to renew an offering.
        public let offeringId: String?
        /// The quantity requested in an offering renewal.
        public let quantity: Int32?

        public init(offeringId: String? = nil, quantity: Int32? = nil) {
            self.offeringId = offeringId
            self.quantity = quantity
        }

        private enum CodingKeys: String, CodingKey {
            case offeringId = "offeringId"
            case quantity = "quantity"
        }
    }

    public struct Device: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "cpu", required: false, type: .structure), 
            AWSShapeMember(label: "platform", required: false, type: .enum), 
            AWSShapeMember(label: "heapSize", required: false, type: .long), 
            AWSShapeMember(label: "model", required: false, type: .string), 
            AWSShapeMember(label: "radio", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "memory", required: false, type: .long), 
            AWSShapeMember(label: "resolution", required: false, type: .structure), 
            AWSShapeMember(label: "os", required: false, type: .string), 
            AWSShapeMember(label: "image", required: false, type: .string), 
            AWSShapeMember(label: "remoteAccessEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "formFactor", required: false, type: .enum), 
            AWSShapeMember(label: "fleetType", required: false, type: .string), 
            AWSShapeMember(label: "fleetName", required: false, type: .string), 
            AWSShapeMember(label: "manufacturer", required: false, type: .string), 
            AWSShapeMember(label: "carrier", required: false, type: .string)
        ]
        /// The device's display name.
        public let name: String?
        /// Information about the device's CPU.
        public let cpu: CPU?
        /// The device's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public let platform: DevicePlatform?
        /// The device's heap size, expressed in bytes.
        public let heapSize: Int64?
        /// The device's model name.
        public let model: String?
        /// The device's radio.
        public let radio: String?
        /// The device's ARN.
        public let arn: String?
        /// The device's total memory size, expressed in bytes.
        public let memory: Int64?
        /// The resolution of the device.
        public let resolution: Resolution?
        /// The device's operating system type.
        public let os: String?
        /// The device's image name.
        public let image: String?
        /// Specifies whether remote access has been enabled for the specified device.
        public let remoteAccessEnabled: Bool?
        /// The device's form factor. Allowed values include:   PHONE: The phone form factor.   TABLET: The tablet form factor.  
        public let formFactor: DeviceFormFactor?
        /// The type of fleet to which this device belongs. Possible values for fleet type are PRIVATE and PUBLIC.
        public let fleetType: String?
        /// The name of the fleet to which this device belongs.
        public let fleetName: String?
        /// The device's manufacturer name.
        public let manufacturer: String?
        /// The device's carrier.
        public let carrier: String?

        public init(name: String? = nil, cpu: CPU? = nil, platform: DevicePlatform? = nil, heapSize: Int64? = nil, model: String? = nil, radio: String? = nil, arn: String? = nil, memory: Int64? = nil, resolution: Resolution? = nil, os: String? = nil, image: String? = nil, remoteAccessEnabled: Bool? = nil, formFactor: DeviceFormFactor? = nil, fleetType: String? = nil, fleetName: String? = nil, manufacturer: String? = nil, carrier: String? = nil) {
            self.name = name
            self.cpu = cpu
            self.platform = platform
            self.heapSize = heapSize
            self.model = model
            self.radio = radio
            self.arn = arn
            self.memory = memory
            self.resolution = resolution
            self.os = os
            self.image = image
            self.remoteAccessEnabled = remoteAccessEnabled
            self.formFactor = formFactor
            self.fleetType = fleetType
            self.fleetName = fleetName
            self.manufacturer = manufacturer
            self.carrier = carrier
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case cpu = "cpu"
            case platform = "platform"
            case heapSize = "heapSize"
            case model = "model"
            case radio = "radio"
            case arn = "arn"
            case memory = "memory"
            case resolution = "resolution"
            case os = "os"
            case image = "image"
            case remoteAccessEnabled = "remoteAccessEnabled"
            case formFactor = "formFactor"
            case fleetType = "fleetType"
            case fleetName = "fleetName"
            case manufacturer = "manufacturer"
            case carrier = "carrier"
        }
    }

    public struct ListRunsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct Job: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "device", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The device (phone or tablet).
        public let device: Device?
        /// The job's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The job's name.
        public let name: String?
        /// When the job was created.
        public let created: TimeStamp?
        /// The job's start time.
        public let started: TimeStamp?
        /// The job's stop time.
        public let stopped: TimeStamp?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public let deviceMinutes: DeviceMinutes?
        /// A message about the job's result.
        public let message: String?
        /// The job's type. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The job's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The job's result counters.
        public let counters: Counters?
        /// The job's ARN.
        public let arn: String?

        public init(device: Device? = nil, status: ExecutionStatus? = nil, name: String? = nil, created: TimeStamp? = nil, started: TimeStamp? = nil, stopped: TimeStamp? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.device = device
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
            case status = "status"
            case name = "name"
            case created = "created"
            case started = "started"
            case stopped = "stopped"
            case deviceMinutes = "deviceMinutes"
            case message = "message"
            case `type` = "type"
            case result = "result"
            case counters = "counters"
            case arn = "arn"
        }
    }

    public struct GetProjectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The project's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListProjectsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
        public let arn: String?

        public init(nextToken: String? = nil, arn: String? = nil) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct UpdateProjectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// A string representing the new name of the project that you are updating.
        public let name: String?
        /// The number of minutes a test run in the project will execute before it times out.
        public let defaultJobTimeoutMinutes: Int32?
        /// The Amazon Resource Name (ARN) of the project whose name you wish to update.
        public let arn: String

        public init(name: String? = nil, defaultJobTimeoutMinutes: Int32? = nil, arn: String) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
            case arn = "arn"
        }
    }

    public enum ExecutionResult: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case passed = "PASSED"
        case warned = "WARNED"
        case failed = "FAILED"
        case skipped = "SKIPPED"
        case errored = "ERRORED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum BillingMethod: String, CustomStringConvertible, Codable {
        case metered = "METERED"
        case unmetered = "UNMETERED"
        public var description: String { return self.rawValue }
    }

    public struct InstallToRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "appArn", required: true, type: .string), 
            AWSShapeMember(label: "remoteAccessSessionArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the app about which you are requesting information.
        public let appArn: String
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let remoteAccessSessionArn: String

        public init(appArn: String, remoteAccessSessionArn: String) {
            self.appArn = appArn
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case remoteAccessSessionArn = "remoteAccessSessionArn"
        }
    }

    public struct GetDevicePoolCompatibilityResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "incompatibleDevices", required: false, type: .list), 
            AWSShapeMember(label: "compatibleDevices", required: false, type: .list)
        ]
        /// Information about incompatible devices.
        public let incompatibleDevices: [DevicePoolCompatibilityResult]?
        /// Information about compatible devices.
        public let compatibleDevices: [DevicePoolCompatibilityResult]?

        public init(incompatibleDevices: [DevicePoolCompatibilityResult]? = nil, compatibleDevices: [DevicePoolCompatibilityResult]? = nil) {
            self.incompatibleDevices = incompatibleDevices
            self.compatibleDevices = compatibleDevices
        }

        private enum CodingKeys: String, CodingKey {
            case incompatibleDevices = "incompatibleDevices"
            case compatibleDevices = "compatibleDevices"
        }
    }

    public struct GetRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetProjectResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "project", required: false, type: .structure)
        ]
        /// The project you wish to get information about.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

}