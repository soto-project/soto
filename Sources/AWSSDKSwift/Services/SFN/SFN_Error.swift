// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore

/// Error enum for SFN
public enum SFNErrorType: AWSErrorType {
    case activityDoesNotExist(message: String?)
    case activityLimitExceeded(message: String?)
    case activityWorkerLimitExceeded(message: String?)
    case executionAlreadyExists(message: String?)
    case executionDoesNotExist(message: String?)
    case executionLimitExceeded(message: String?)
    case invalidArn(message: String?)
    case invalidDefinition(message: String?)
    case invalidExecutionInput(message: String?)
    case invalidName(message: String?)
    case invalidOutput(message: String?)
    case invalidToken(message: String?)
    case missingRequiredParameter(message: String?)
    case resourceNotFound(message: String?)
    case stateMachineAlreadyExists(message: String?)
    case stateMachineDeleting(message: String?)
    case stateMachineDoesNotExist(message: String?)
    case stateMachineLimitExceeded(message: String?)
    case taskDoesNotExist(message: String?)
    case taskTimedOut(message: String?)
    case tooManyTags(message: String?)
}

extension SFNErrorType {
    public init?(errorCode: String, message: String?){
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        switch errorCode {
        case "ActivityDoesNotExist":
            self = .activityDoesNotExist(message: message)
        case "ActivityLimitExceeded":
            self = .activityLimitExceeded(message: message)
        case "ActivityWorkerLimitExceeded":
            self = .activityWorkerLimitExceeded(message: message)
        case "ExecutionAlreadyExists":
            self = .executionAlreadyExists(message: message)
        case "ExecutionDoesNotExist":
            self = .executionDoesNotExist(message: message)
        case "ExecutionLimitExceeded":
            self = .executionLimitExceeded(message: message)
        case "InvalidArn":
            self = .invalidArn(message: message)
        case "InvalidDefinition":
            self = .invalidDefinition(message: message)
        case "InvalidExecutionInput":
            self = .invalidExecutionInput(message: message)
        case "InvalidName":
            self = .invalidName(message: message)
        case "InvalidOutput":
            self = .invalidOutput(message: message)
        case "InvalidToken":
            self = .invalidToken(message: message)
        case "MissingRequiredParameter":
            self = .missingRequiredParameter(message: message)
        case "ResourceNotFound":
            self = .resourceNotFound(message: message)
        case "StateMachineAlreadyExists":
            self = .stateMachineAlreadyExists(message: message)
        case "StateMachineDeleting":
            self = .stateMachineDeleting(message: message)
        case "StateMachineDoesNotExist":
            self = .stateMachineDoesNotExist(message: message)
        case "StateMachineLimitExceeded":
            self = .stateMachineLimitExceeded(message: message)
        case "TaskDoesNotExist":
            self = .taskDoesNotExist(message: message)
        case "TaskTimedOut":
            self = .taskTimedOut(message: message)
        case "TooManyTags":
            self = .tooManyTags(message: message)
        default:
            return nil
        }
    }
}

extension SFNErrorType : CustomStringConvertible {
    public var description : String {
        switch self {
        case .activityDoesNotExist(let message):
            return "ActivityDoesNotExist: \(message ?? "")"
        case .activityLimitExceeded(let message):
            return "ActivityLimitExceeded: \(message ?? "")"
        case .activityWorkerLimitExceeded(let message):
            return "ActivityWorkerLimitExceeded: \(message ?? "")"
        case .executionAlreadyExists(let message):
            return "ExecutionAlreadyExists: \(message ?? "")"
        case .executionDoesNotExist(let message):
            return "ExecutionDoesNotExist: \(message ?? "")"
        case .executionLimitExceeded(let message):
            return "ExecutionLimitExceeded: \(message ?? "")"
        case .invalidArn(let message):
            return "InvalidArn: \(message ?? "")"
        case .invalidDefinition(let message):
            return "InvalidDefinition: \(message ?? "")"
        case .invalidExecutionInput(let message):
            return "InvalidExecutionInput: \(message ?? "")"
        case .invalidName(let message):
            return "InvalidName: \(message ?? "")"
        case .invalidOutput(let message):
            return "InvalidOutput: \(message ?? "")"
        case .invalidToken(let message):
            return "InvalidToken: \(message ?? "")"
        case .missingRequiredParameter(let message):
            return "MissingRequiredParameter: \(message ?? "")"
        case .resourceNotFound(let message):
            return "ResourceNotFound: \(message ?? "")"
        case .stateMachineAlreadyExists(let message):
            return "StateMachineAlreadyExists: \(message ?? "")"
        case .stateMachineDeleting(let message):
            return "StateMachineDeleting: \(message ?? "")"
        case .stateMachineDoesNotExist(let message):
            return "StateMachineDoesNotExist: \(message ?? "")"
        case .stateMachineLimitExceeded(let message):
            return "StateMachineLimitExceeded: \(message ?? "")"
        case .taskDoesNotExist(let message):
            return "TaskDoesNotExist: \(message ?? "")"
        case .taskTimedOut(let message):
            return "TaskTimedOut: \(message ?? "")"
        case .tooManyTags(let message):
            return "TooManyTags: \(message ?? "")"
        }
    }
}
