// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Pinpoint {

    public struct ADMChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientId", required: true, type: .string), 
            AWSShapeMember(label: "ClientSecret", required: true, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]

        /// The Client ID that you received from Amazon to send messages by using ADM.
        public let clientId: String
        /// The Client Secret that you received from Amazon to send messages by using ADM.
        public let clientSecret: String
        /// Specifies whether to enable the ADM channel for the application.
        public let enabled: Bool?

        public init(clientId: String, clientSecret: String, enabled: Bool? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case clientSecret = "ClientSecret"
            case enabled = "Enabled"
        }
    }

    public struct ADMChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the ADM channel applies to.
        public let applicationId: String?
        /// The date and time when the ADM channel was enabled.
        public let creationDate: String?
        /// Specifies whether the ADM channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the ADM channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the ADM channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the ADM channel.
        public let lastModifiedBy: String?
        /// The date and time when the ADM channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the ADM channel, this value is ADM.
        public let platform: String
        /// The current version of the ADM channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct ADMMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "ConsolidationKey", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "ExpiresAfter", required: false, type: .string), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "MD5", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// The action to occur if the recipient taps the push notification. Valid values are: OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action. DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform. URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public let action: Action?
        /// The body of the notification message.
        public let body: String?
        /// An arbitrary string that indicates that multiple messages are logically the same and that Amazon Device Messaging (ADM) can drop previously enqueued messages in favor of this message.
        public let consolidationKey: String?
        /// The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public let data: [String: String]?
        /// The amount of time, in seconds, that ADM should store the message if the recipient's device is offline. Amazon Pinpoint specifies this value in the expiresAfter parameter when it sends the notification message to ADM.
        public let expiresAfter: String?
        /// The icon image name of the asset saved in your app.
        public let iconReference: String?
        /// The URL of the large icon image to display in the content view of the push notification.
        public let imageIconUrl: String?
        /// The URL of an image to display in the push notification.
        public let imageUrl: String?
        /// The base64-encoded, MD5 checksum of the value specified by the Data property. ADM uses the MD5 value to verify the integrity of the data.
        public let md5: String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. This value overrides the message.
        public let rawContent: String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.
        public let silentPush: Bool?
        /// The URL of the small icon image to display in the status bar and the content view of the push notification.
        public let smallImageIconUrl: String?
        /// The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public let sound: String?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?
        /// The title to display above the notification message on the recipient's device.
        public let title: String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, consolidationKey: String? = nil, data: [String: String]? = nil, expiresAfter: String? = nil, iconReference: String? = nil, imageIconUrl: String? = nil, imageUrl: String? = nil, md5: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.consolidationKey = consolidationKey
            self.data = data
            self.expiresAfter = expiresAfter
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.md5 = md5
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case consolidationKey = "ConsolidationKey"
            case data = "Data"
            case expiresAfter = "ExpiresAfter"
            case iconReference = "IconReference"
            case imageIconUrl = "ImageIconUrl"
            case imageUrl = "ImageUrl"
            case md5 = "MD5"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case smallImageIconUrl = "SmallImageIconUrl"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct APNSChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]

        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public let bundleId: String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.
        public let certificate: String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether to enable the APNs channel for the application.
        public let enabled: Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.
        public let privateKey: String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public let teamId: String?
        /// The authentication key to use for APNs tokens.
        public let tokenKey: String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the APNs channel applies to.
        public let applicationId: String?
        /// The date and time when the APNs channel was enabled.
        public let creationDate: String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether the APNs channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// Specifies whether the APNs channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public let hasTokenKey: Bool?
        /// (Deprecated) An identifier for the APNs channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the APNs channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the APNs channel.
        public let lastModifiedBy: String?
        /// The date and time when the APNs channel was last modified.
        public let lastModifiedDate: String?
        ///  The type of messaging or notification platform for the channel. For the APNs channel, this value is APNS.
        public let platform: String
        /// The current version of the APNs channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct APNSMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Badge", required: false, type: .integer), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Category", required: false, type: .string), 
            AWSShapeMember(label: "CollapseId", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "MediaUrl", required: false, type: .string), 
            AWSShapeMember(label: "PreferredAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "ThreadId", required: false, type: .string), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// The action to occur if the recipient taps the push notification. Valid values are: OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action. DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform. URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public let action: Action?
        /// The key that indicates whether and how to modify the badge of your app's icon when the recipient receives the push notification. If this key isn't included in the dictionary, the badge doesn't change. To remove the badge, set this value to 0.
        public let badge: Int?
        /// The body of the notification message.
        public let body: String?
        /// The key that indicates the notification type for the push notification. This key is a value that's defined by the identifier property of one of your app's registered categories.
        public let category: String?
        /// An arbitrary identifier that, if assigned to multiple messages, APNs uses to coalesce the messages into a single push notification instead of delivering each message individually. This value can't exceed 64 bytes. Amazon Pinpoint specifies this value in the apns-collapse-id request header when it sends the notification message to APNs.
        public let collapseId: String?
        /// The JSON payload to use for a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public let data: [String: String]?
        /// The URL of an image or video to display in the push notification.
        public let mediaUrl: String?
        /// The authentication method that you want Amazon Pinpoint to use when authenticating with Apple Push Notification service (APNs), CERTIFICATE or TOKEN.
        public let preferredAuthenticationMethod: String?
        /// para>5 - Low priority, the notification might be delayed, delivered as part of a group, or throttled./listitem> 10 - High priority, the notification is sent immediately. This is the default value. A high priority notification should trigger an alert, play a sound, or badge your app's icon on the recipient's device./para> Amazon Pinpoint specifies this value in the apns-priority request header when it sends the notification message to APNs. The equivalent values for Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), are normal, for 5, and high, for 10. If you specify an FCM value for this property, Amazon Pinpoint accepts and converts the value to the corresponding APNs value.
        public let priority: String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. This value overrides the message.
        public let rawContent: String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.
        public let silentPush: Bool?
        /// The key for the sound to play when the recipient receives the push notification. The value of this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.
        public let sound: String?
        /// The default message variables to use in the notification message. You can override these default variables with individual address variables.
        public let substitutions: [String: [String]]?
        /// The key that represents your app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.
        public let threadId: String?
        /// The amount of time, in seconds, that APNs should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If this value is 0, APNs treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again. Amazon Pinpoint specifies this value in the apns-expiration request header when it sends the notification message to APNs.
        public let timeToLive: Int?
        /// The title to display above the notification message on the recipient's device.
        public let title: String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public let url: String?

        public init(action: Action? = nil, badge: Int? = nil, body: String? = nil, category: String? = nil, collapseId: String? = nil, data: [String: String]? = nil, mediaUrl: String? = nil, preferredAuthenticationMethod: String? = nil, priority: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, threadId: String? = nil, timeToLive: Int? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.badge = badge
            self.body = body
            self.category = category
            self.collapseId = collapseId
            self.data = data
            self.mediaUrl = mediaUrl
            self.preferredAuthenticationMethod = preferredAuthenticationMethod
            self.priority = priority
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.sound = sound
            self.substitutions = substitutions
            self.threadId = threadId
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case badge = "Badge"
            case body = "Body"
            case category = "Category"
            case collapseId = "CollapseId"
            case data = "Data"
            case mediaUrl = "MediaUrl"
            case preferredAuthenticationMethod = "PreferredAuthenticationMethod"
            case priority = "Priority"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case threadId = "ThreadId"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct APNSSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]

        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public let bundleId: String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.
        public let certificate: String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether to enable the APNs sandbox channel for the application.
        public let enabled: Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.
        public let privateKey: String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public let teamId: String?
        /// The authentication key to use for APNs tokens.
        public let tokenKey: String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSSandboxChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the APNs sandbox channel applies to.
        public let applicationId: String?
        /// The date and time when the APNs sandbox channel was enabled.
        public let creationDate: String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether the APNs sandbox channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// Specifies whether the APNs sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public let hasTokenKey: Bool?
        /// (Deprecated) An identifier for the APNs sandbox channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the APNs sandbox channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the APNs sandbox channel.
        public let lastModifiedBy: String?
        /// The date and time when the APNs sandbox channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the APNs sandbox channel, this value is APNS_SANDBOX.
        public let platform: String
        /// The current version of the APNs sandbox channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct APNSVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]

        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public let bundleId: String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.
        public let certificate: String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether to enable the APNs VoIP channel for the application.
        public let enabled: Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.
        public let privateKey: String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public let teamId: String?
        /// The authentication key to use for APNs tokens.
        public let tokenKey: String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSVoipChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the APNs VoIP channel applies to.
        public let applicationId: String?
        /// The date and time when the APNs VoIP channel was enabled.
        public let creationDate: String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether the APNs VoIP channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// Specifies whether the APNs VoIP channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public let hasTokenKey: Bool?
        /// (Deprecated) An identifier for the APNs VoIP channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the APNs VoIP channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the APNs VoIP channel.
        public let lastModifiedBy: String?
        /// The date and time when the APNs VoIP channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the APNs VoIP channel, this value is APNS_VOIP.
        public let platform: String
        /// The current version of the APNs VoIP channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct APNSVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string)
        ]

        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public let bundleId: String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.
        public let certificate: String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment for this channel, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether the APNs VoIP sandbox channel is enabled for the application.
        public let enabled: Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.
        public let privateKey: String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public let teamId: String?
        /// The authentication key to use for APNs tokens.
        public let tokenKey: String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.
        public let tokenKeyId: String?

        public init(bundleId: String? = nil, certificate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, privateKey: String? = nil, teamId: String? = nil, tokenKey: String? = nil, tokenKeyId: String? = nil) {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case certificate = "Certificate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case privateKey = "PrivateKey"
            case teamId = "TeamId"
            case tokenKey = "TokenKey"
            case tokenKeyId = "TokenKeyId"
        }
    }

    public struct APNSVoipSandboxChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the APNs VoIP sandbox channel applies to.
        public let applicationId: String?
        /// The date and time when the APNs VoIP sandbox channel was enabled.
        public let creationDate: String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.
        public let defaultAuthenticationMethod: String?
        /// Specifies whether the APNs VoIP sandbox channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// Specifies whether the APNs VoIP sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public let hasTokenKey: Bool?
        /// (Deprecated) An identifier for the APNs VoIP sandbox channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the APNs VoIP sandbox channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the APNs VoIP sandbox channel.
        public let lastModifiedBy: String?
        /// The date and time when the APNs VoIP sandbox channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the APNs VoIP sandbox channel, this value is APNS_VOIP_SANDBOX.
        public let platform: String
        /// The current version of the APNs VoIP sandbox channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, defaultAuthenticationMethod: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public enum Action: String, CustomStringConvertible, Codable {
        case openApp = "OPEN_APP"
        case deepLink = "DEEP_LINK"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public struct ActivitiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of responses, one for each activity that was performed by the campaign.
        public let item: [ActivityResponse]
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public let nextToken: String?

        public init(item: [ActivityResponse], nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct ActivityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", required: true, type: .string), 
            AWSShapeMember(label: "End", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .string), 
            AWSShapeMember(label: "ScheduledStart", required: false, type: .string), 
            AWSShapeMember(label: "Start", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "SuccessfulEndpointCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimezonesCompletedCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimezonesTotalCount", required: false, type: .integer), 
            AWSShapeMember(label: "TotalEndpointCount", required: false, type: .integer), 
            AWSShapeMember(label: "TreatmentId", required: false, type: .string)
        ]

        /// The unique identifier for the application that the campaign applies to.
        public let applicationId: String
        /// The unique identifier for the campaign that the activity applies to.
        public let campaignId: String
        /// The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.
        public let end: String?
        /// The unique identifier for the activity.
        public let id: String
        /// Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.
        public let result: String?
        /// The scheduled start time, in ISO 8601 format, for the activity.
        public let scheduledStart: String?
        /// The actual start time, in ISO 8601 format, of the activity.
        public let start: String?
        /// The state of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.
        public let state: String?
        /// The total number of endpoints that the campaign successfully delivered messages to.
        public let successfulEndpointCount: Int?
        /// The total number of time zones that were completed.
        public let timezonesCompletedCount: Int?
        /// The total number of unique time zones that are in the segment for the campaign.
        public let timezonesTotalCount: Int?
        /// The total number of endpoints that the campaign attempted to deliver messages to.
        public let totalEndpointCount: Int?
        /// The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.
        public let treatmentId: String?

        public init(applicationId: String, campaignId: String, end: String? = nil, id: String, result: String? = nil, scheduledStart: String? = nil, start: String? = nil, state: String? = nil, successfulEndpointCount: Int? = nil, timezonesCompletedCount: Int? = nil, timezonesTotalCount: Int? = nil, totalEndpointCount: Int? = nil, treatmentId: String? = nil) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.end = end
            self.id = id
            self.result = result
            self.scheduledStart = scheduledStart
            self.start = start
            self.state = state
            self.successfulEndpointCount = successfulEndpointCount
            self.timezonesCompletedCount = timezonesCompletedCount
            self.timezonesTotalCount = timezonesTotalCount
            self.totalEndpointCount = totalEndpointCount
            self.treatmentId = treatmentId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case campaignId = "CampaignId"
            case end = "End"
            case id = "Id"
            case result = "Result"
            case scheduledStart = "ScheduledStart"
            case start = "Start"
            case state = "State"
            case successfulEndpointCount = "SuccessfulEndpointCount"
            case timezonesCompletedCount = "TimezonesCompletedCount"
            case timezonesTotalCount = "TimezonesTotalCount"
            case totalEndpointCount = "TotalEndpointCount"
            case treatmentId = "TreatmentId"
        }
    }

    public struct AddressConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BodyOverride", required: false, type: .string), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TitleOverride", required: false, type: .string)
        ]

        /// The message body to use instead of the default message body. This value overrides the default message body.
        public let bodyOverride: String?
        /// The channel to use when sending the message.
        public let channelType: ChannelType?
        /// An object that maps custom attributes to attributes for the address and is attached to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.
        public let context: [String: String]?
        /// The raw, JSON-formatted string to use as the payload for the notification message. This value overrides the message.
        public let rawContent: String?
        /// An object that maps variable values for the message. Amazon Pinpoint merges these values with the variable values specified by properties of the DefaultMessage object. The substitutions in this map take precedence over all other substitutions.
        public let substitutions: [String: [String]]?
        /// The message title to use instead of the default message title. This value overrides the default message title.
        public let titleOverride: String?

        public init(bodyOverride: String? = nil, channelType: ChannelType? = nil, context: [String: String]? = nil, rawContent: String? = nil, substitutions: [String: [String]]? = nil, titleOverride: String? = nil) {
            self.bodyOverride = bodyOverride
            self.channelType = channelType
            self.context = context
            self.rawContent = rawContent
            self.substitutions = substitutions
            self.titleOverride = titleOverride
        }

        private enum CodingKeys: String, CodingKey {
            case bodyOverride = "BodyOverride"
            case channelType = "ChannelType"
            case context = "Context"
            case rawContent = "RawContent"
            case substitutions = "Substitutions"
            case titleOverride = "TitleOverride"
        }
    }

    public struct ApplicationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: true, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The Amazon Resource Name (ARN) of the application.
        public let arn: String
        /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
        public let id: String
        /// The display name of the application. This name is displayed as the Project name on the Amazon Pinpoint console.
        public let name: String
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the application. Each tag consists of a required tag key and an associated tag value.
        public let tags: [String: String]?

        public init(arn: String, id: String, name: String, tags: [String: String]? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct ApplicationSettingsResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "CampaignHook", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure)
        ]

        /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
        public let applicationId: String
        /// The settings for the AWS Lambda function to use by default as a code hook for campaigns in the application.
        public let campaignHook: CampaignHook?
        /// The date and time, in ISO 8601 format, when the application's settings were last modified.
        public let lastModifiedDate: String?
        /// The default sending limits for campaigns in the application.
        public let limits: CampaignLimits?
        /// The default quiet time for campaigns in the application. Quiet time is a specific time range when campaigns don't send messages to endpoints, if all the following conditions are met: The EndpointDemographic.Timezone property of the endpoint is set to a valid value. The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign that has custom quiet time settings). The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign that has custom quiet time settings). If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign, even if quiet time is enabled.
        public let quietTime: QuietTime?

        public init(applicationId: String, campaignHook: CampaignHook? = nil, lastModifiedDate: String? = nil, limits: CampaignLimits? = nil, quietTime: QuietTime? = nil) {
            self.applicationId = applicationId
            self.campaignHook = campaignHook
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.quietTime = quietTime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case campaignHook = "CampaignHook"
            case lastModifiedDate = "LastModifiedDate"
            case limits = "Limits"
            case quietTime = "QuietTime"
        }
    }

    public struct ApplicationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of responses, one for each application that was returned.
        public let item: [ApplicationResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public let nextToken: String?

        public init(item: [ApplicationResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct AttributeDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributeType", required: false, type: .enum), 
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]

        /// The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.
        public let attributeType: AttributeType?
        /// The criteria values to use for the segment dimension. Depending on the value of the AttributeType property, endpoints are included or excluded from the segment if their attribute values match the criteria values.
        public let values: [String]

        public init(attributeType: AttributeType? = nil, values: [String]) {
            self.attributeType = attributeType
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case attributeType = "AttributeType"
            case values = "Values"
        }
    }

    public enum AttributeType: String, CustomStringConvertible, Codable {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct AttributesResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .list), 
            AWSShapeMember(label: "AttributeType", required: true, type: .string)
        ]

        /// The unique identifier for the application.
        public let applicationId: String
        /// An array that specifies the names of the attributes that were removed from the endpoints.
        public let attributes: [String]?
        /// The type of attribute or attributes that were removed from the endpoints. Valid values are: endpoint-custom-attributes - Custom attributes that describe endpoints endpoint-custom-metrics - Custom metrics that your app reports to Amazon Pinpoint for endpoints endpoint-user-attributes - Custom attributes that describe users
        public let attributeType: String

        public init(applicationId: String, attributes: [String]? = nil, attributeType: String) {
            self.applicationId = applicationId
            self.attributes = attributes
            self.attributeType = attributeType
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case attributes = "Attributes"
            case attributeType = "AttributeType"
        }
    }

    public struct BaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApiKey", required: true, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SecretKey", required: true, type: .string)
        ]

        /// The API key that you received from the Baidu Cloud Push service to communicate with the service.
        public let apiKey: String
        /// Specifies whether to enable the Baidu channel for the application.
        public let enabled: Bool?
        /// The secret key that you received from the Baidu Cloud Push service to communicate with the service.
        public let secretKey: String

        public init(apiKey: String, enabled: Bool? = nil, secretKey: String) {
            self.apiKey = apiKey
            self.enabled = enabled
            self.secretKey = secretKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "ApiKey"
            case enabled = "Enabled"
            case secretKey = "SecretKey"
        }
    }

    public struct BaiduChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Credential", required: true, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the Baidu channel applies to.
        public let applicationId: String?
        /// The date and time when the Baidu channel was enabled.
        public let creationDate: String?
        /// The API key that you received from the Baidu Cloud Push service to communicate with the service.
        public let credential: String
        /// Specifies whether the Baidu channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the Baidu channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the Baidu channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the Baidu channel.
        public let lastModifiedBy: String?
        /// The date and time when the Baidu channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the Baidu channel, this value is BAIDU.
        public let platform: String
        /// The current version of the Baidu channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, credential: String, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.credential = credential
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case credential = "Credential"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct BaiduMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// The action to occur if the recipient taps the push notification. Valid values are: OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action. DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform. URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public let action: Action?
        /// The body of the notification message.
        public let body: String?
        /// The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public let data: [String: String]?
        /// The icon image name of the asset saved in your app.
        public let iconReference: String?
        /// The URL of the large icon image to display in the content view of the push notification.
        public let imageIconUrl: String?
        /// The URL of an image to display in the push notification.
        public let imageUrl: String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. This value overrides the message.
        public let rawContent: String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.
        public let silentPush: Bool?
        /// The URL of the small icon image to display in the status bar and the content view of the push notification.
        public let smallImageIconUrl: String?
        /// The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public let sound: String?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?
        /// The amount of time, in seconds, that the Baidu Cloud Push service should store the message if the recipient's device is offline. The default value and maximum supported time is 604,800 seconds (7 days).
        public let timeToLive: Int?
        /// The title to display above the notification message on the recipient's device.
        public let title: String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, data: [String: String]? = nil, iconReference: String? = nil, imageIconUrl: String? = nil, imageUrl: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, timeToLive: Int? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.data = data
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case data = "Data"
            case iconReference = "IconReference"
            case imageIconUrl = "ImageIconUrl"
            case imageUrl = "ImageUrl"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case smallImageIconUrl = "SmallImageIconUrl"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct CampaignEmailMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "HtmlBody", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: true, type: .string)
        ]

        /// The body of the email for recipients whose email clients don't support HTML content.
        public let body: String?
        /// The verified email address to send the email from. The default address is the FromAddress specified for the email channel for the application.
        public let fromAddress: String?
        /// The body of the email, in HTML format, for recipients whose email clients support HTML content.
        public let htmlBody: String?
        /// The subject line, or title, of the email.
        public let title: String

        public init(body: String? = nil, fromAddress: String? = nil, htmlBody: String? = nil, title: String) {
            self.body = body
            self.fromAddress = fromAddress
            self.htmlBody = htmlBody
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case fromAddress = "FromAddress"
            case htmlBody = "HtmlBody"
            case title = "Title"
        }
    }

    public struct CampaignEventFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: true, type: .structure), 
            AWSShapeMember(label: "FilterType", required: true, type: .enum)
        ]

        /// The dimension settings of the event filter for the campaign.
        public let dimensions: EventDimensions
        /// The type of event that causes the campaign to be sent. Valid values are: SYSTEM, sends the campaign when a system event occurs; and, ENDPOINT, sends the campaign when an endpoint event (Events resource) occurs.
        public let filterType: FilterType

        public init(dimensions: EventDimensions, filterType: FilterType) {
            self.dimensions = dimensions
            self.filterType = filterType
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case filterType = "FilterType"
        }
    }

    public struct CampaignHook: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LambdaFunctionName", required: false, type: .string), 
            AWSShapeMember(label: "Mode", required: false, type: .enum), 
            AWSShapeMember(label: "WebUrl", required: false, type: .string)
        ]

        /// The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to send messages for a campaign.
        public let lambdaFunctionName: String?
        /// Specifies which Lambda mode to use when invoking the AWS Lambda function.
        public let mode: Mode?
        ///  The web URL that Amazon Pinpoint calls to invoke the AWS Lambda function over HTTPS.
        public let webUrl: String?

        public init(lambdaFunctionName: String? = nil, mode: Mode? = nil, webUrl: String? = nil) {
            self.lambdaFunctionName = lambdaFunctionName
            self.mode = mode
            self.webUrl = webUrl
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctionName = "LambdaFunctionName"
            case mode = "Mode"
            case webUrl = "WebUrl"
        }
    }

    public struct CampaignLimits: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Daily", required: false, type: .integer), 
            AWSShapeMember(label: "MaximumDuration", required: false, type: .integer), 
            AWSShapeMember(label: "MessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Total", required: false, type: .integer)
        ]

        /// The maximum number of messages that a campaign can send to a single endpoint during a 24-hour period. The maximum value is 100.
        public let daily: Int?
        /// The maximum amount of time, in seconds, that a campaign can attempt to deliver a message after the scheduled start time for the campaign. The minimum value is 60 seconds.
        public let maximumDuration: Int?
        /// The maximum number of messages that a campaign can send each second. The minimum value is 50. The maximum value is 20,000.
        public let messagesPerSecond: Int?
        /// The maximum number of messages that a campaign can send to a single endpoint during the course of the campaign. The maximum value is 100.
        public let total: Int?

        public init(daily: Int? = nil, maximumDuration: Int? = nil, messagesPerSecond: Int? = nil, total: Int? = nil) {
            self.daily = daily
            self.maximumDuration = maximumDuration
            self.messagesPerSecond = messagesPerSecond
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case daily = "Daily"
            case maximumDuration = "MaximumDuration"
            case messagesPerSecond = "MessagesPerSecond"
            case total = "Total"
        }
    }

    public struct CampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "Arn", required: true, type: .string), 
            AWSShapeMember(label: "CreationDate", required: true, type: .string), 
            AWSShapeMember(label: "DefaultState", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeMember(label: "Hook", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedDate", required: true, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentId", required: true, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: true, type: .integer), 
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.
        public let additionalTreatments: [TreatmentResource]?
        /// The unique identifier for the application that the campaign applies to.
        public let applicationId: String
        /// The Amazon Resource Name (ARN) of the campaign.
        public let arn: String
        /// The date, ISO 8601 format, when the campaign was created.
        public let creationDate: String
        /// The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment, to support A/B testing.
        public let defaultState: CampaignState?
        /// The custom description of the campaign.
        public let description: String?
        /// The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.
        public let holdoutPercent: Int?
        /// The settings for the AWS Lambda function to use as a code hook for the campaign.
        public let hook: CampaignHook?
        /// The unique identifier for the campaign.
        public let id: String
        /// Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.
        public let isPaused: Bool?
        /// The date, in ISO 8601 format, when the campaign was last modified.
        public let lastModifiedDate: String
        /// The messaging limits for the campaign.
        public let limits: CampaignLimits?
        /// The message configuration settings for the campaign.
        public let messageConfiguration: MessageConfiguration?
        /// The name of the campaign.
        public let name: String?
        /// The schedule settings for the campaign.
        public let schedule: Schedule?
        /// The unique identifier for the segment that's associated with the campaign.
        public let segmentId: String
        /// The version number of the segment that's associated with the campaign.
        public let segmentVersion: Int
        /// The current status of the campaign.
        public let state: CampaignState?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.
        public let tags: [String: String]?
        /// The custom description of a variation of the campaign that's used for A/B testing.
        public let treatmentDescription: String?
        /// The custom name of a variation of the campaign that's used for A/B testing.
        public let treatmentName: String?
        /// The version number of the campaign.
        public let version: Int?

        public init(additionalTreatments: [TreatmentResource]? = nil, applicationId: String, arn: String, creationDate: String, defaultState: CampaignState? = nil, description: String? = nil, holdoutPercent: Int? = nil, hook: CampaignHook? = nil, id: String, isPaused: Bool? = nil, lastModifiedDate: String, limits: CampaignLimits? = nil, messageConfiguration: MessageConfiguration? = nil, name: String? = nil, schedule: Schedule? = nil, segmentId: String, segmentVersion: Int, state: CampaignState? = nil, tags: [String: String]? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil, version: Int? = nil) {
            self.additionalTreatments = additionalTreatments
            self.applicationId = applicationId
            self.arn = arn
            self.creationDate = creationDate
            self.defaultState = defaultState
            self.description = description
            self.holdoutPercent = holdoutPercent
            self.hook = hook
            self.id = id
            self.isPaused = isPaused
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.messageConfiguration = messageConfiguration
            self.name = name
            self.schedule = schedule
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
            self.state = state
            self.tags = tags
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case additionalTreatments = "AdditionalTreatments"
            case applicationId = "ApplicationId"
            case arn = "Arn"
            case creationDate = "CreationDate"
            case defaultState = "DefaultState"
            case description = "Description"
            case holdoutPercent = "HoldoutPercent"
            case hook = "Hook"
            case id = "Id"
            case isPaused = "IsPaused"
            case lastModifiedDate = "LastModifiedDate"
            case limits = "Limits"
            case messageConfiguration = "MessageConfiguration"
            case name = "Name"
            case schedule = "Schedule"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
            case state = "State"
            case tags = "tags"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
            case version = "Version"
        }
    }

    public struct CampaignSmsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "MessageType", required: false, type: .enum), 
            AWSShapeMember(label: "SenderId", required: false, type: .string)
        ]

        /// The body of the SMS message.
        public let body: String?
        /// The type of SMS message. Valid values are: TRANSACTIONAL, the message is critical or time-sensitive, such as a one-time password that supports a customer transaction; and, PROMOTIONAL, the message isn't critical or time-sensitive, such as a marketing message.
        public let messageType: MessageType?
        /// The sender ID to display on recipients' devices when they receive the SMS message.
        public let senderId: String?

        public init(body: String? = nil, messageType: MessageType? = nil, senderId: String? = nil) {
            self.body = body
            self.messageType = messageType
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case messageType = "MessageType"
            case senderId = "SenderId"
        }
    }

    public struct CampaignState: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignStatus", required: false, type: .enum)
        ]

        /// The status of the campaign, or the status of a treatment that belongs to an A/B test campaign. If a campaign uses A/B testing, the campaign has a status of COMPLETED only when all campaign treatments have a status of COMPLETED.
        public let campaignStatus: CampaignStatus?

        public init(campaignStatus: CampaignStatus? = nil) {
            self.campaignStatus = campaignStatus
        }

        private enum CodingKeys: String, CodingKey {
            case campaignStatus = "CampaignStatus"
        }
    }

    public enum CampaignStatus: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case executing = "EXECUTING"
        case pendingNextRun = "PENDING_NEXT_RUN"
        case completed = "COMPLETED"
        case paused = "PAUSED"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct CampaignsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of responses, one for each campaign that's associated with the application.
        public let item: [CampaignResponse]
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public let nextToken: String?

        public init(item: [CampaignResponse], nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct ChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application.
        public let applicationId: String?
        /// The date and time, in ISO 8601 format, when the channel was enabled.
        public let creationDate: String?
        /// Specifies whether the channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the channel.
        public let lastModifiedBy: String?
        /// The date and time, in ISO 8601 format, when the channel was last modified.
        public let lastModifiedDate: String?
        /// The current version of the channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case version = "Version"
        }
    }

    public enum ChannelType: String, CustomStringConvertible, Codable {
        case gcm = "GCM"
        case apns = "APNS"
        case apnsSandbox = "APNS_SANDBOX"
        case apnsVoip = "APNS_VOIP"
        case apnsVoipSandbox = "APNS_VOIP_SANDBOX"
        case adm = "ADM"
        case sms = "SMS"
        case voice = "VOICE"
        case email = "EMAIL"
        case baidu = "BAIDU"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public struct ChannelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", required: true, type: .map)
        ]

        /// A map that contains a multipart response for each channel. For each item in this object, the ChannelType is the key and the Channel is the value.
        public let channels: [String: ChannelResponse]

        public init(channels: [String: ChannelResponse]) {
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
        }
    }

    public struct CreateAppRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CreateApplicationRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreateApplicationRequest", required: true, type: .structure)
        ]

        public let createApplicationRequest: CreateApplicationRequest

        public init(createApplicationRequest: CreateApplicationRequest) {
            self.createApplicationRequest = createApplicationRequest
        }

        private enum CodingKeys: String, CodingKey {
            case createApplicationRequest = "CreateApplicationRequest"
        }
    }

    public struct CreateAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]

        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct CreateApplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The display name of the application. This name is displayed as the Project name on the Amazon Pinpoint console.
        public let name: String
        /// A string-to-string map of key-value pairs that defines the tags to associate with the application. Each tag consists of a required tag key and an associated tag value.
        public let tags: [String: String]?

        public init(name: String, tags: [String: String]? = nil) {
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteCampaignRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteCampaignRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let writeCampaignRequest: WriteCampaignRequest

        public init(applicationId: String, writeCampaignRequest: WriteCampaignRequest) {
            self.applicationId = applicationId
            self.writeCampaignRequest = writeCampaignRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeCampaignRequest = "WriteCampaignRequest"
        }
    }

    public struct CreateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]

        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct CreateExportJobRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "ExportJobRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let exportJobRequest: ExportJobRequest

        public init(applicationId: String, exportJobRequest: ExportJobRequest) {
            self.applicationId = applicationId
            self.exportJobRequest = exportJobRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case exportJobRequest = "ExportJobRequest"
        }
    }

    public struct CreateExportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobResponse", required: true, type: .structure)
        ]

        public let exportJobResponse: ExportJobResponse

        public init(exportJobResponse: ExportJobResponse) {
            self.exportJobResponse = exportJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobResponse = "ExportJobResponse"
        }
    }

    public struct CreateImportJobRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "ImportJobRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let importJobRequest: ImportJobRequest

        public init(applicationId: String, importJobRequest: ImportJobRequest) {
            self.applicationId = applicationId
            self.importJobRequest = importJobRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case importJobRequest = "ImportJobRequest"
        }
    }

    public struct CreateImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobResponse", required: true, type: .structure)
        ]

        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobResponse = "ImportJobResponse"
        }
    }

    public struct CreateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteSegmentRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteSegmentRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let writeSegmentRequest: WriteSegmentRequest

        public init(applicationId: String, writeSegmentRequest: WriteSegmentRequest) {
            self.applicationId = applicationId
            self.writeSegmentRequest = writeSegmentRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeSegmentRequest = "WriteSegmentRequest"
        }
    }

    public struct CreateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]

        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct DefaultMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]

        /// The default message body of the push notification, email, or SMS message.
        public let body: String?
        /// The default message variables to use in the push notification, email, or SMS message. You can override these default variables with individual address variables.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case substitutions = "Substitutions"
        }
    }

    public struct DefaultPushNotificationMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// The default action to occur if a recipient taps the push notification. Valid values are: OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action. DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms. URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public let action: Action?
        /// The default body of the notification message.
        public let body: String?
        /// The JSON data payload to use for the default push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public let data: [String: String]?
        /// Specifies whether the default notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or delivering messages to an in-app notification center.
        public let silentPush: Bool?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?
        /// The default title to display above the notification message on a recipient's device.
        public let title: String?
        /// The default URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, data: [String: String]? = nil, silentPush: Bool? = nil, substitutions: [String: [String]]? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.data = data
            self.silentPush = silentPush
            self.substitutions = substitutions
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case data = "Data"
            case silentPush = "SilentPush"
            case substitutions = "Substitutions"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct DeleteAdmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]

        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct DeleteApnsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]

        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct DeleteApnsSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]

        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct DeleteApnsVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]

        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct DeleteApnsVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]

        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct DeleteAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]

        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct DeleteBaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]

        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct DeleteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let campaignId: String

        public init(applicationId: String, campaignId: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
        }
    }

    public struct DeleteCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]

        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct DeleteEmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]

        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct DeleteEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let endpointId: String

        public init(applicationId: String, endpointId: String) {
            self.applicationId = applicationId
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointId = "endpoint-id"
        }
    }

    public struct DeleteEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointResponse", required: true, type: .structure)
        ]

        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointResponse = "EndpointResponse"
        }
    }

    public struct DeleteEventStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]

        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct DeleteGcmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]

        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct DeleteSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let segmentId: String

        public init(applicationId: String, segmentId: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
        }
    }

    public struct DeleteSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]

        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct DeleteSmsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]

        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct DeleteUserEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "user-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let userId: String

        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case userId = "user-id"
        }
    }

    public struct DeleteUserEndpointsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointsResponse", required: true, type: .structure)
        ]

        public let endpointsResponse: EndpointsResponse

        public init(endpointsResponse: EndpointsResponse) {
            self.endpointsResponse = endpointsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointsResponse = "EndpointsResponse"
        }
    }

    public struct DeleteVoiceChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteVoiceChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VoiceChannelResponse", required: true, type: .structure)
        ]

        public let voiceChannelResponse: VoiceChannelResponse

        public init(voiceChannelResponse: VoiceChannelResponse) {
            self.voiceChannelResponse = voiceChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case voiceChannelResponse = "VoiceChannelResponse"
        }
    }

    public enum DeliveryStatus: String, CustomStringConvertible, Codable {
        case successful = "SUCCESSFUL"
        case throttled = "THROTTLED"
        case temporaryFailure = "TEMPORARY_FAILURE"
        case permanentFailure = "PERMANENT_FAILURE"
        case unknownFailure = "UNKNOWN_FAILURE"
        case optOut = "OPT_OUT"
        case duplicate = "DUPLICATE"
        public var description: String { return self.rawValue }
    }

    public enum DimensionType: String, CustomStringConvertible, Codable {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct DirectMessageConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "BaiduMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultPushNotificationMessage", required: false, type: .structure), 
            AWSShapeMember(label: "EmailMessage", required: false, type: .structure), 
            AWSShapeMember(label: "GCMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "SMSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "VoiceMessage", required: false, type: .structure)
        ]

        /// The default push notification message for the ADM (Amazon Device Messaging) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public let aDMMessage: ADMMessage?
        /// The default push notification message for the APNs (Apple Push Notification service) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public let aPNSMessage: APNSMessage?
        /// The default push notification message for the Baidu (Baidu Cloud Push) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public let baiduMessage: BaiduMessage?
        /// The default message body for all channels.
        public let defaultMessage: DefaultMessage?
        /// The default push notification message for all push channels.
        public let defaultPushNotificationMessage: DefaultPushNotificationMessage?
        /// The default message for the email channel. This message overrides the default message (DefaultMessage).
        public let emailMessage: EmailMessage?
        /// The default push notification message for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public let gCMMessage: GCMMessage?
        /// The default message for the SMS channel. This message overrides the default message (DefaultMessage).
        public let sMSMessage: SMSMessage?
        /// The default message for the voice channel. This message overrides the default message (DefaultMessage).
        public let voiceMessage: VoiceMessage?

        public init(aDMMessage: ADMMessage? = nil, aPNSMessage: APNSMessage? = nil, baiduMessage: BaiduMessage? = nil, defaultMessage: DefaultMessage? = nil, defaultPushNotificationMessage: DefaultPushNotificationMessage? = nil, emailMessage: EmailMessage? = nil, gCMMessage: GCMMessage? = nil, sMSMessage: SMSMessage? = nil, voiceMessage: VoiceMessage? = nil) {
            self.aDMMessage = aDMMessage
            self.aPNSMessage = aPNSMessage
            self.baiduMessage = baiduMessage
            self.defaultMessage = defaultMessage
            self.defaultPushNotificationMessage = defaultPushNotificationMessage
            self.emailMessage = emailMessage
            self.gCMMessage = gCMMessage
            self.sMSMessage = sMSMessage
            self.voiceMessage = voiceMessage
        }

        private enum CodingKeys: String, CodingKey {
            case aDMMessage = "ADMMessage"
            case aPNSMessage = "APNSMessage"
            case baiduMessage = "BaiduMessage"
            case defaultMessage = "DefaultMessage"
            case defaultPushNotificationMessage = "DefaultPushNotificationMessage"
            case emailMessage = "EmailMessage"
            case gCMMessage = "GCMMessage"
            case sMSMessage = "SMSMessage"
            case voiceMessage = "VoiceMessage"
        }
    }

    public enum Duration: String, CustomStringConvertible, Codable {
        case hr24 = "HR_24"
        case day7 = "DAY_7"
        case day14 = "DAY_14"
        case day30 = "DAY_30"
        public var description: String { return self.rawValue }
    }

    public struct EmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConfigurationSet", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FromAddress", required: true, type: .string), 
            AWSShapeMember(label: "Identity", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]

        /// The configuration set that you want to apply to email that you send through the channel by using the Amazon Pinpoint Email API.
        public let configurationSet: String?
        /// Specifies whether to enable the email channel for the application.
        public let enabled: Bool?
        ///  The verified email address that you want to send email from when you send email through the channel.
        public let fromAddress: String
        ///  The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you want to use when you send email through the channel.
        public let identity: String
        ///  The ARN of the AWS Identity and Access Management (IAM) role that you want Amazon Pinpoint to use when it submits email-related event data for the channel.
        public let roleArn: String?

        public init(configurationSet: String? = nil, enabled: Bool? = nil, fromAddress: String, identity: String, roleArn: String? = nil) {
            self.configurationSet = configurationSet
            self.enabled = enabled
            self.fromAddress = fromAddress
            self.identity = identity
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSet = "ConfigurationSet"
            case enabled = "Enabled"
            case fromAddress = "FromAddress"
            case identity = "Identity"
            case roleArn = "RoleArn"
        }
    }

    public struct EmailChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "ConfigurationSet", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Identity", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "MessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the email channel applies to.
        public let applicationId: String?
        /// The configuration set that's applied to email that's sent through the channel by using the Amazon Pinpoint Email API.
        public let configurationSet: String?
        /// The date and time, in ISO 8601 format, when the email channel was enabled.
        public let creationDate: String?
        /// Specifies whether the email channel is enabled for the application.
        public let enabled: Bool?
        /// The verified email address that you send email from when you send email through the channel.
        public let fromAddress: String?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the email channel. This property is retained only for backward compatibility.
        public let id: String?
        ///  The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you use when you send email through the channel.
        public let identity: String?
        /// Specifies whether the email channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the email channel.
        public let lastModifiedBy: String?
        /// The date and time, in ISO 8601 format, when the email channel was last modified.
        public let lastModifiedDate: String?
        /// The maximum number of emails that you can send through the channel each second.
        public let messagesPerSecond: Int?
        /// The type of messaging or notification platform for the channel. For the email channel, this value is EMAIL.
        public let platform: String
        ///  The ARN of the AWS Identity and Access Management (IAM) role that Amazon Pinpoint uses to submit email-related event data for the channel.
        public let roleArn: String?
        /// The current version of the email channel.
        public let version: Int?

        public init(applicationId: String? = nil, configurationSet: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, fromAddress: String? = nil, hasCredential: Bool? = nil, id: String? = nil, identity: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, messagesPerSecond: Int? = nil, platform: String, roleArn: String? = nil, version: Int? = nil) {
            self.applicationId = applicationId
            self.configurationSet = configurationSet
            self.creationDate = creationDate
            self.enabled = enabled
            self.fromAddress = fromAddress
            self.hasCredential = hasCredential
            self.id = id
            self.identity = identity
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.messagesPerSecond = messagesPerSecond
            self.platform = platform
            self.roleArn = roleArn
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case configurationSet = "ConfigurationSet"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case fromAddress = "FromAddress"
            case hasCredential = "HasCredential"
            case id = "Id"
            case identity = "Identity"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case messagesPerSecond = "MessagesPerSecond"
            case platform = "Platform"
            case roleArn = "RoleArn"
            case version = "Version"
        }
    }

    public struct EmailMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "FeedbackForwardingAddress", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "RawEmail", required: false, type: .structure), 
            AWSShapeMember(label: "ReplyToAddresses", required: false, type: .list), 
            AWSShapeMember(label: "SimpleEmail", required: false, type: .structure), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]

        /// The body of the email message.
        public let body: String?
        /// The email address to forward bounces and complaints to, if feedback forwarding is enabled.
        public let feedbackForwardingAddress: String?
        /// The verified email address to send the email message from. The default value is the FromAddress specified for the email channel.
        public let fromAddress: String?
        /// The email message, represented as a raw MIME message.
        public let rawEmail: RawEmail?
        /// The reply-to email address(es) for the email message. If a recipient replies to the email, each reply-to address receives the reply.
        public let replyToAddresses: [String]?
        /// The email message, composed of a subject, a text part, and an HTML part.
        public let simpleEmail: SimpleEmail?
        /// The default message variables to use in the email message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, feedbackForwardingAddress: String? = nil, fromAddress: String? = nil, rawEmail: RawEmail? = nil, replyToAddresses: [String]? = nil, simpleEmail: SimpleEmail? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.feedbackForwardingAddress = feedbackForwardingAddress
            self.fromAddress = fromAddress
            self.rawEmail = rawEmail
            self.replyToAddresses = replyToAddresses
            self.simpleEmail = simpleEmail
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case feedbackForwardingAddress = "FeedbackForwardingAddress"
            case fromAddress = "FromAddress"
            case rawEmail = "RawEmail"
            case replyToAddresses = "ReplyToAddresses"
            case simpleEmail = "SimpleEmail"
            case substitutions = "Substitutions"
        }
    }

    public struct EndpointBatchItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]

        /// The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.
        public let address: String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["science", "music", "travel"]. You can use these attributes as filter criteria when you create segments. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This limitation doesn't apply to attribute values.
        public let attributes: [String: [String]]?
        /// The channel to use when sending messages or push notifications to the endpoint.
        public let channelType: ChannelType?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public let demographic: EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint was created or updated.
        public let effectiveDate: String?
        /// Not used.
        public let endpointStatus: String?
        /// The unique identifier for the endpoint in the context of the batch.
        public let id: String?
        /// The geographic information for the endpoint.
        public let location: EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public let metrics: [String: Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public let optOut: String?
        /// The unique identifier for the request to create or update the endpoint.
        public let requestId: String?
        /// One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, id: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.id = id
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case id = "Id"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct EndpointBatchRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list)
        ]

        /// An array that defines the endpoints to create or update and, for each endpoint, the property values to set or change. An array can contain a maximum of 100 items.
        public let item: [EndpointBatchItem]

        public init(item: [EndpointBatchItem]) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct EndpointDemographic: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppVersion", required: false, type: .string), 
            AWSShapeMember(label: "Locale", required: false, type: .string), 
            AWSShapeMember(label: "Make", required: false, type: .string), 
            AWSShapeMember(label: "Model", required: false, type: .string), 
            AWSShapeMember(label: "ModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "PlatformVersion", required: false, type: .string), 
            AWSShapeMember(label: "Timezone", required: false, type: .string)
        ]

        /// The version of the app that's associated with the endpoint.
        public let appVersion: String?
        /// The locale of the endpoint, in the following format: the ISO 639-1 alpha-2 code, followed by an underscore (_), followed by an ISO 3166-1 alpha-2 value.
        public let locale: String?
        /// The manufacturer of the endpoint device, such as Apple or Samsung.
        public let make: String?
        /// The model name or number of the endpoint device, such as iPhone.
        public let model: String?
        /// The model version of the endpoint device.
        public let modelVersion: String?
        /// The platform of the endpoint device, such as iOS or Android.
        public let platform: String?
        /// The platform version of the endpoint device.
        public let platformVersion: String?
        /// The time zone of the endpoint, specified as a tz database name value, such as America/Los_Angeles.
        public let timezone: String?

        public init(appVersion: String? = nil, locale: String? = nil, make: String? = nil, model: String? = nil, modelVersion: String? = nil, platform: String? = nil, platformVersion: String? = nil, timezone: String? = nil) {
            self.appVersion = appVersion
            self.locale = locale
            self.make = make
            self.model = model
            self.modelVersion = modelVersion
            self.platform = platform
            self.platformVersion = platformVersion
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion = "AppVersion"
            case locale = "Locale"
            case make = "Make"
            case model = "Model"
            case modelVersion = "ModelVersion"
            case platform = "Platform"
            case platformVersion = "PlatformVersion"
            case timezone = "Timezone"
        }
    }

    public struct EndpointItemResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer)
        ]

        /// The custom message that's returned in the response as a result of processing the endpoint data.
        public let message: String?
        /// The status code that's returned in the response as a result of processing the endpoint data.
        public let statusCode: Int?

        public init(message: String? = nil, statusCode: Int? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct EndpointLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "City", required: false, type: .string), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "Latitude", required: false, type: .double), 
            AWSShapeMember(label: "Longitude", required: false, type: .double), 
            AWSShapeMember(label: "PostalCode", required: false, type: .string), 
            AWSShapeMember(label: "Region", required: false, type: .string)
        ]

        /// The name of the city where the endpoint is located.
        public let city: String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the endpoint is located. For example, US for the United States.
        public let country: String?
        /// The latitude coordinate of the endpoint location, rounded to one decimal place.
        public let latitude: Double?
        /// The longitude coordinate of the endpoint location, rounded to one decimal place.
        public let longitude: Double?
        /// The postal or ZIP code for the area where the endpoint is located.
        public let postalCode: String?
        /// The name of the region where the endpoint is located. For locations in the United States, this value is the name of a state.
        public let region: String?

        public init(city: String? = nil, country: String? = nil, latitude: Double? = nil, longitude: Double? = nil, postalCode: String? = nil, region: String? = nil) {
            self.city = city
            self.country = country
            self.latitude = latitude
            self.longitude = longitude
            self.postalCode = postalCode
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case country = "Country"
            case latitude = "Latitude"
            case longitude = "Longitude"
            case postalCode = "PostalCode"
            case region = "Region"
        }
    }

    public struct EndpointMessageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "DeliveryStatus", required: true, type: .enum), 
            AWSShapeMember(label: "MessageId", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: true, type: .integer), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "UpdatedToken", required: false, type: .string)
        ]

        /// The endpoint address that the message was delivered to.
        public let address: String?
        /// The delivery status of the message. Possible values are:  DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again. OPT_OUT - The user who's associated with the endpoint has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again. PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.    SUCCESSFUL - The message was successfully delivered to the endpoint. TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint will attempt to deliver the message again later. THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint. TIMEOUT - The message couldn't be sent within the timeout period. UNKNOWN_FAILURE - An unknown error occurred.
        public let deliveryStatus: DeliveryStatus
        /// The unique identifier for the message that was sent.
        public let messageId: String?
        /// The downstream service status code for delivering the message.
        public let statusCode: Int
        /// The status message for delivering the message.
        public let statusMessage: String?
        /// For push notifications that are sent through the GCM channel, specifies whether the token was updated as part of delivering the message.
        public let updatedToken: String?

        public init(address: String? = nil, deliveryStatus: DeliveryStatus, messageId: String? = nil, statusCode: Int, statusMessage: String? = nil, updatedToken: String? = nil) {
            self.address = address
            self.deliveryStatus = deliveryStatus
            self.messageId = messageId
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case deliveryStatus = "DeliveryStatus"
            case messageId = "MessageId"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case updatedToken = "UpdatedToken"
        }
    }

    public struct EndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]

        /// The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.
        public let address: String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["science", "music", "travel"]. You can use these attributes as filter criteria when you create segments. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This limitation doesn't apply to attribute values.
        public let attributes: [String: [String]]?
        /// The channel to use when sending messages or push notifications to the endpoint.
        public let channelType: ChannelType?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public let demographic: EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint is updated.
        public let effectiveDate: String?
        /// Not used.
        public let endpointStatus: String?
        /// The geographic information for the endpoint.
        public let location: EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public let metrics: [String: Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public let optOut: String?
        /// The unique identifier for the most recent request to update the endpoint.
        public let requestId: String?
        /// One or more custom user attributes that describe the user who's associated with the endpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct EndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "CohortId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]

        /// The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For example, the address for a push-notification channel is typically the token provided by a push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. The address for the SMS channel is a phone number in E.164 format, such as +12065550100. The address for the email channel is an email address.
        public let address: String?
        /// The unique identifier for the application that's associated with the endpoint.
        public let applicationId: String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["science", "music", "travel"]. You can use these attributes as filter criteria when you create segments.
        public let attributes: [String: [String]]?
        /// The channel that's used when sending messages or push notifications to the endpoint.
        public let channelType: ChannelType?
        /// A number from 0-99 that represents the cohort that the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an application. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for campaigns.
        public let cohortId: String?
        /// The date and time, in ISO 8601 format, when the endpoint was created.
        public let creationDate: String?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public let demographic: EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint was last updated.
        public let effectiveDate: String?
        /// Not used.
        public let endpointStatus: String?
        /// The unique identifier that you assigned to the endpoint. The identifier should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint identifiers that are associated with the application.
        public let id: String?
        /// The geographic information for the endpoint.
        public let location: EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public let metrics: [String: Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public let optOut: String?
        /// The unique identifier for the most recent request to update the endpoint.
        public let requestId: String?
        /// One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, applicationId: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, cohortId: String? = nil, creationDate: String? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, id: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.applicationId = applicationId
            self.attributes = attributes
            self.channelType = channelType
            self.cohortId = cohortId
            self.creationDate = creationDate
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.id = id
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case applicationId = "ApplicationId"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case cohortId = "CohortId"
            case creationDate = "CreationDate"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case id = "Id"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct EndpointSendConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BodyOverride", required: false, type: .string), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TitleOverride", required: false, type: .string)
        ]

        /// The body of the message. If specified, this value overrides the default message body.
        public let bodyOverride: String?
        /// A map of custom attributes to attach to the message for the address. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.
        public let context: [String: String]?
        /// The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides the message.
        public let rawContent: String?
        /// A map of the message variables to merge with the variables specified for the default message (DefaultMessage.Substitutions). The variables specified in this map take precedence over all other variables.
        public let substitutions: [String: [String]]?
        /// The title or subject line of the message. If specified, this value overrides the default message title or subject line.
        public let titleOverride: String?

        public init(bodyOverride: String? = nil, context: [String: String]? = nil, rawContent: String? = nil, substitutions: [String: [String]]? = nil, titleOverride: String? = nil) {
            self.bodyOverride = bodyOverride
            self.context = context
            self.rawContent = rawContent
            self.substitutions = substitutions
            self.titleOverride = titleOverride
        }

        private enum CodingKeys: String, CodingKey {
            case bodyOverride = "BodyOverride"
            case context = "Context"
            case rawContent = "RawContent"
            case substitutions = "Substitutions"
            case titleOverride = "TitleOverride"
        }
    }

    public struct EndpointUser: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserAttributes", required: false, type: .map), 
            AWSShapeMember(label: "UserId", required: false, type: .string)
        ]

        /// One or more custom attributes that describe the user by associating a name with an array of values. For example, the value of an attribute named Interests might be: ["science", "music", "travel"]. You can use these attributes as filter criteria when you create segments. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This limitation doesn't apply to attribute values.
        public let userAttributes: [String: [String]]?
        /// The unique identifier for the user.
        public let userId: String?

        public init(userAttributes: [String: [String]]? = nil, userId: String? = nil) {
            self.userAttributes = userAttributes
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userAttributes = "UserAttributes"
            case userId = "UserId"
        }
    }

    public struct EndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list)
        ]

        /// An array of responses, one for each endpoint that's associated with the user ID.
        public let item: [EndpointResponse]

        public init(item: [EndpointResponse]) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct Event: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppPackageName", required: false, type: .string), 
            AWSShapeMember(label: "AppTitle", required: false, type: .string), 
            AWSShapeMember(label: "AppVersionCode", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ClientSdkVersion", required: false, type: .string), 
            AWSShapeMember(label: "EventType", required: true, type: .string), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "SdkName", required: false, type: .string), 
            AWSShapeMember(label: "Session", required: false, type: .structure), 
            AWSShapeMember(label: "Timestamp", required: true, type: .string)
        ]

        /// The package name of the app that's recording the event.
        public let appPackageName: String?
        /// The title of the app that's recording the event.
        public let appTitle: String?
        /// The version number of the app that's recording the event.
        public let appVersionCode: String?
        /// One or more custom attributes that are associated with the event.
        public let attributes: [String: String]?
        /// The version of the SDK that's running on the client device.
        public let clientSdkVersion: String?
        /// The name of the event.
        public let eventType: String
        /// One or more custom metrics that are associated with the event.
        public let metrics: [String: Double]?
        /// The name of the SDK that's being used to record the event.
        public let sdkName: String?
        /// Information about the session in which the event occurred.
        public let session: Session?
        /// The date and time, in ISO 8601 format, when the event occurred.
        public let timestamp: String

        public init(appPackageName: String? = nil, appTitle: String? = nil, appVersionCode: String? = nil, attributes: [String: String]? = nil, clientSdkVersion: String? = nil, eventType: String, metrics: [String: Double]? = nil, sdkName: String? = nil, session: Session? = nil, timestamp: String) {
            self.appPackageName = appPackageName
            self.appTitle = appTitle
            self.appVersionCode = appVersionCode
            self.attributes = attributes
            self.clientSdkVersion = clientSdkVersion
            self.eventType = eventType
            self.metrics = metrics
            self.sdkName = sdkName
            self.session = session
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case appPackageName = "AppPackageName"
            case appTitle = "AppTitle"
            case appVersionCode = "AppVersionCode"
            case attributes = "Attributes"
            case clientSdkVersion = "ClientSdkVersion"
            case eventType = "EventType"
            case metrics = "Metrics"
            case sdkName = "SdkName"
            case session = "Session"
            case timestamp = "Timestamp"
        }
    }

    public struct EventDimensions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "EventType", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map)
        ]

        /// One or more custom attributes that your app reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.
        public let attributes: [String: AttributeDimension]?
        /// The name of the event that causes the campaign to be sent. This can be a standard type of event that Amazon Pinpoint generates, such as _session.start, or a custom event that's specific to your app.
        public let eventType: SetDimension?
        /// One or more custom metrics that your app reports to Amazon Pinpoint. You can use these metrics as selection criteria when you create an event filter.
        public let metrics: [String: MetricDimension]?

        public init(attributes: [String: AttributeDimension]? = nil, eventType: SetDimension? = nil, metrics: [String: MetricDimension]? = nil) {
            self.attributes = attributes
            self.eventType = eventType
            self.metrics = metrics
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case eventType = "EventType"
            case metrics = "Metrics"
        }
    }

    public struct EventItemResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer)
        ]

        /// A custom message that's returned in the response as a result of processing the event.
        public let message: String?
        /// The status code that's returned in the response as a result of processing the event. Possible values are: 202, for events that were accepted; and, 400, for events that weren't valid.
        public let statusCode: Int?

        public init(message: String? = nil, statusCode: Int? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct EventStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "DestinationStreamArn", required: true, type: .string), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string)
        ]

        /// The unique identifier for the application to publish event data for.
        public let applicationId: String
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream to publish event data to. For a Kinesis data stream, the ARN format is: arn:aws:kinesis:region:account-id:stream/stream_name
        ///                 For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:region:account-id:deliverystream/stream_name
        ///                
        public let destinationStreamArn: String
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when publishing event data, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The date, in ISO 8601 format, when the event stream was last modified.
        public let lastModifiedDate: String?
        /// The IAM user who last modified the event stream.
        public let lastUpdatedBy: String?
        /// The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.
        public let roleArn: String

        public init(applicationId: String, destinationStreamArn: String, externalId: String? = nil, lastModifiedDate: String? = nil, lastUpdatedBy: String? = nil, roleArn: String) {
            self.applicationId = applicationId
            self.destinationStreamArn = destinationStreamArn
            self.externalId = externalId
            self.lastModifiedDate = lastModifiedDate
            self.lastUpdatedBy = lastUpdatedBy
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case destinationStreamArn = "DestinationStreamArn"
            case externalId = "ExternalId"
            case lastModifiedDate = "LastModifiedDate"
            case lastUpdatedBy = "LastUpdatedBy"
            case roleArn = "RoleArn"
        }
    }

    public struct EventsBatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: true, type: .structure), 
            AWSShapeMember(label: "Events", required: true, type: .map)
        ]

        /// A set of properties and attributes that are associated with the endpoint.
        public let endpoint: PublicEndpoint
        /// A set of properties that are associated with the event.
        public let events: [String: Event]

        public init(endpoint: PublicEndpoint, events: [String: Event]) {
            self.endpoint = endpoint
            self.events = events
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case events = "Events"
        }
    }

    public struct EventsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BatchItem", required: true, type: .map)
        ]

        /// The batch of events to process. For each item in a batch, the endpoint ID acts as a key that has an EventsBatch object as its value.
        public let batchItem: [String: EventsBatch]

        public init(batchItem: [String: EventsBatch]) {
            self.batchItem = batchItem
        }

        private enum CodingKeys: String, CodingKey {
            case batchItem = "BatchItem"
        }
    }

    public struct EventsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Results", required: false, type: .map)
        ]

        /// A map that contains a multipart response for each endpoint. For each item in this object, the endpoint ID is the key and the item response is the value. If no item response exists, the value can also be one of the following: 202, the request was processed successfully; or 400, the payload wasn't valid or required fields were missing.
        public let results: [String: ItemResponse]?

        public init(results: [String: ItemResponse]? = nil) {
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
        }
    }

    public struct ExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "S3UrlPrefix", required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer)
        ]

        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location where you want to export endpoint definitions to.
        public let roleArn: String
        /// The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where you want to export endpoint definitions to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://bucket-name/folder-name/.
        public let s3UrlPrefix: String
        /// The identifier for the segment to export endpoint definitions from. If you don't specify this value, Amazon Pinpoint exports definitions for all the endpoints that are associated with the application.
        public let segmentId: String?
        /// The version of the segment to export endpoint definitions from, if specified.
        public let segmentVersion: Int?

        public init(roleArn: String, s3UrlPrefix: String, segmentId: String? = nil, segmentVersion: Int? = nil) {
            self.roleArn = roleArn
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case s3UrlPrefix = "S3UrlPrefix"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
        }
    }

    public struct ExportJobResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "S3UrlPrefix", required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer)
        ]

        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location where the endpoint definitions were exported to.
        public let roleArn: String
        /// The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where the endpoint definitions were exported to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://bucket-name/folder-name/.
        public let s3UrlPrefix: String
        /// The identifier for the segment that the endpoint definitions were exported from. If this value isn't present, Amazon Pinpoint exported definitions for all the endpoints that are associated with the application.
        public let segmentId: String?
        /// The version of the segment that the endpoint definitions were exported from.
        public let segmentVersion: Int?

        public init(roleArn: String, s3UrlPrefix: String, segmentId: String? = nil, segmentVersion: Int? = nil) {
            self.roleArn = roleArn
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case s3UrlPrefix = "S3UrlPrefix"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
        }
    }

    public struct ExportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "CompletionDate", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: true, type: .string), 
            AWSShapeMember(label: "Definition", required: true, type: .structure), 
            AWSShapeMember(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "Failures", required: false, type: .list), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "JobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeMember(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeMember(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: true, type: .string)
        ]

        /// The unique identifier for the application that's associated with the export job.
        public let applicationId: String
        /// The number of pieces that were processed successfully (completed) by the export job, as of the time of the request.
        public let completedPieces: Int?
        /// The date, in ISO 8601 format, when the export job was completed.
        public let completionDate: String?
        /// The date, in ISO 8601 format, when the export job was created.
        public let creationDate: String
        /// The resource settings that apply to the export job.
        public let definition: ExportJobResource
        /// The number of pieces that weren't processed successfully (failed) by the export job, as of the time of the request.
        public let failedPieces: Int?
        /// An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the export job, if any.
        public let failures: [String]?
        /// The unique identifier for the export job.
        public let id: String
        /// The status of the export job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.
        public let jobStatus: JobStatus
        /// The total number of endpoint definitions that weren't processed successfully (failed) by the export job, typically because an error, such as a syntax error, occurred.
        public let totalFailures: Int?
        /// The total number of pieces that must be processed to complete the export job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the export job.
        public let totalPieces: Int?
        /// The total number of endpoint definitions that were processed by the export job.
        public let totalProcessed: Int?
        /// The job type. This value is EXPORT for export jobs.
        public let `type`: String

        public init(applicationId: String, completedPieces: Int? = nil, completionDate: String? = nil, creationDate: String, definition: ExportJobResource, failedPieces: Int? = nil, failures: [String]? = nil, id: String, jobStatus: JobStatus, totalFailures: Int? = nil, totalPieces: Int? = nil, totalProcessed: Int? = nil, type: String) {
            self.applicationId = applicationId
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.failures = failures
            self.id = id
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalPieces = totalPieces
            self.totalProcessed = totalProcessed
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case completedPieces = "CompletedPieces"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case definition = "Definition"
            case failedPieces = "FailedPieces"
            case failures = "Failures"
            case id = "Id"
            case jobStatus = "JobStatus"
            case totalFailures = "TotalFailures"
            case totalPieces = "TotalPieces"
            case totalProcessed = "TotalProcessed"
            case `type` = "Type"
        }
    }

    public struct ExportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of responses, one for each export job that's associated with the application (Export Jobs resource) or segment (Segment Export Jobs resource).
        public let item: [ExportJobResponse]
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public let nextToken: String?

        public init(item: [ExportJobResponse], nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public enum FilterType: String, CustomStringConvertible, Codable {
        case system = "SYSTEM"
        case endpoint = "ENDPOINT"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum Frequency: String, CustomStringConvertible, Codable {
        case once = "ONCE"
        case hourly = "HOURLY"
        case daily = "DAILY"
        case weekly = "WEEKLY"
        case monthly = "MONTHLY"
        case event = "EVENT"
        public var description: String { return self.rawValue }
    }

    public struct GCMChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApiKey", required: true, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]

        /// The API key, also referred to as a server key, that you received from Google to communicate with Google services.
        public let apiKey: String
        /// Specifies whether to enable the GCM channel for the application.
        public let enabled: Bool?

        public init(apiKey: String, enabled: Bool? = nil) {
            self.apiKey = apiKey
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "ApiKey"
            case enabled = "Enabled"
        }
    }

    public struct GCMChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Credential", required: true, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the GCM channel applies to.
        public let applicationId: String?
        /// The date and time when the GCM channel was enabled.
        public let creationDate: String?
        /// The API key, also referred to as a server key, that you received from Google to communicate with Google services.
        public let credential: String
        /// Specifies whether the GCM channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the GCM channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the GCM channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the GCM channel.
        public let lastModifiedBy: String?
        /// The date and time when the GCM channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the GCM channel, this value is GCM.
        public let platform: String
        /// The current version of the GCM channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, credential: String, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.credential = credential
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case credential = "Credential"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct GCMMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "CollapseKey", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "RestrictedPackageName", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// The action to occur if the recipient taps the push notification. Valid values are: OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action. DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform. URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public let action: Action?
        /// The body of the notification message.
        public let body: String?
        /// An arbitrary string that identifies a group of messages that can be collapsed to ensure that only the last message is sent when delivery can resume. This helps avoid sending too many instances of the same messages when the recipient's device comes online again or becomes active. Amazon Pinpoint specifies this value in the Firebase Cloud Messaging (FCM) collapse_key parameter when it sends the notification message to FCM.
        public let collapseKey: String?
        /// The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public let data: [String: String]?
        /// The icon image name of the asset saved in your app.
        public let iconReference: String?
        /// The URL of the large icon image to display in the content view of the push notification.
        public let imageIconUrl: String?
        /// The URL of an image to display in the push notification.
        public let imageUrl: String?
        /// para>normal - The notification might be delayed. Delivery is optimized for battery usage on the recipient's device. Use this value unless immediate delivery is required./listitem> high - The notification is sent immediately and might wake a sleeping device./para> Amazon Pinpoint specifies this value in the FCM priority parameter when it sends the notification message to FCM. The equivalent values for Apple Push Notification service (APNs) are 5, for normal, and 10, for high. If you specify an APNs value for this property, Amazon Pinpoint accepts and converts the value to the corresponding FCM value.
        public let priority: String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. This value overrides the message.
        public let rawContent: String?
        /// The package name of the application where registration tokens must match in order for the recipient to receive the message.
        public let restrictedPackageName: String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.
        public let silentPush: Bool?
        /// The URL of the small icon image to display in the status bar and the content view of the push notification.
        public let smallImageIconUrl: String?
        /// The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public let sound: String?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?
        /// The amount of time, in seconds, that FCM should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If you don't specify this value, FCM defaults to the maximum value, which is 2,419,200 seconds (28 days). Amazon Pinpoint specifies this value in the FCM time_to_live parameter when it sends the notification message to FCM.
        public let timeToLive: Int?
        /// The title to display above the notification message on the recipient's device.
        public let title: String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, collapseKey: String? = nil, data: [String: String]? = nil, iconReference: String? = nil, imageIconUrl: String? = nil, imageUrl: String? = nil, priority: String? = nil, rawContent: String? = nil, restrictedPackageName: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, sound: String? = nil, substitutions: [String: [String]]? = nil, timeToLive: Int? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.collapseKey = collapseKey
            self.data = data
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.priority = priority
            self.rawContent = rawContent
            self.restrictedPackageName = restrictedPackageName
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case collapseKey = "CollapseKey"
            case data = "Data"
            case iconReference = "IconReference"
            case imageIconUrl = "ImageIconUrl"
            case imageUrl = "ImageUrl"
            case priority = "Priority"
            case rawContent = "RawContent"
            case restrictedPackageName = "RestrictedPackageName"
            case silentPush = "SilentPush"
            case smallImageIconUrl = "SmallImageIconUrl"
            case sound = "Sound"
            case substitutions = "Substitutions"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct GPSCoordinates: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Latitude", required: true, type: .double), 
            AWSShapeMember(label: "Longitude", required: true, type: .double)
        ]

        /// The latitude coordinate of the location.
        public let latitude: Double
        /// The longitude coordinate of the location.
        public let longitude: Double

        public init(latitude: Double, longitude: Double) {
            self.latitude = latitude
            self.longitude = longitude
        }

        private enum CodingKeys: String, CodingKey {
            case latitude = "Latitude"
            case longitude = "Longitude"
        }
    }

    public struct GPSPointDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Coordinates", required: true, type: .structure), 
            AWSShapeMember(label: "RangeInKilometers", required: false, type: .double)
        ]

        /// The GPS coordinates to measure distance from.
        public let coordinates: GPSCoordinates
        /// The range, in kilometers, from the GPS coordinates.
        public let rangeInKilometers: Double?

        public init(coordinates: GPSCoordinates, rangeInKilometers: Double? = nil) {
            self.coordinates = coordinates
            self.rangeInKilometers = rangeInKilometers
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
            case rangeInKilometers = "RangeInKilometers"
        }
    }

    public struct GetAdmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]

        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct GetApnsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]

        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct GetApnsSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]

        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct GetApnsVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]

        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct GetApnsVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]

        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct GetAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]

        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct GetApplicationSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationSettingsResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]

        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSettingsResource = "ApplicationSettingsResource"
        }
    }

    public struct GetAppsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let pageSize: String?
        public let token: String?

        public init(pageSize: String? = nil, token: String? = nil) {
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetAppsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationsResponse", required: true, type: .structure)
        ]

        public let applicationsResponse: ApplicationsResponse

        public init(applicationsResponse: ApplicationsResponse) {
            self.applicationsResponse = applicationsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationsResponse = "ApplicationsResponse"
        }
    }

    public struct GetBaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]

        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct GetCampaignActivitiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let campaignId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, campaignId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetCampaignActivitiesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ActivitiesResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActivitiesResponse", required: true, type: .structure)
        ]

        public let activitiesResponse: ActivitiesResponse

        public init(activitiesResponse: ActivitiesResponse) {
            self.activitiesResponse = activitiesResponse
        }

        private enum CodingKeys: String, CodingKey {
            case activitiesResponse = "ActivitiesResponse"
        }
    }

    public struct GetCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let campaignId: String

        public init(applicationId: String, campaignId: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
        }
    }

    public struct GetCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]

        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct GetCampaignVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "Version", location: .uri(locationName: "version"), required: true, type: .string)
        ]

        public let applicationId: String
        public let campaignId: String
        public let version: String

        public init(applicationId: String, campaignId: String, version: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case version = "version"
        }
    }

    public struct GetCampaignVersionResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]

        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct GetCampaignVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let campaignId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, campaignId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetCampaignVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignsResponse", required: true, type: .structure)
        ]

        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignsResponse = "CampaignsResponse"
        }
    }

    public struct GetCampaignsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetCampaignsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignsResponse", required: true, type: .structure)
        ]

        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignsResponse = "CampaignsResponse"
        }
    }

    public struct GetChannelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetChannelsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ChannelsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelsResponse", required: true, type: .structure)
        ]

        public let channelsResponse: ChannelsResponse

        public init(channelsResponse: ChannelsResponse) {
            self.channelsResponse = channelsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case channelsResponse = "ChannelsResponse"
        }
    }

    public struct GetEmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]

        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct GetEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let endpointId: String

        public init(applicationId: String, endpointId: String) {
            self.applicationId = applicationId
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointId = "endpoint-id"
        }
    }

    public struct GetEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointResponse", required: true, type: .structure)
        ]

        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointResponse = "EndpointResponse"
        }
    }

    public struct GetEventStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]

        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct GetExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let jobId: String

        public init(applicationId: String, jobId: String) {
            self.applicationId = applicationId
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case jobId = "job-id"
        }
    }

    public struct GetExportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobResponse", required: true, type: .structure)
        ]

        public let exportJobResponse: ExportJobResponse

        public init(exportJobResponse: ExportJobResponse) {
            self.exportJobResponse = exportJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobResponse = "ExportJobResponse"
        }
    }

    public struct GetExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetExportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobsResponse", required: true, type: .structure)
        ]

        public let exportJobsResponse: ExportJobsResponse

        public init(exportJobsResponse: ExportJobsResponse) {
            self.exportJobsResponse = exportJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobsResponse = "ExportJobsResponse"
        }
    }

    public struct GetGcmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]

        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct GetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let jobId: String

        public init(applicationId: String, jobId: String) {
            self.applicationId = applicationId
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case jobId = "job-id"
        }
    }

    public struct GetImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobResponse", required: true, type: .structure)
        ]

        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobResponse = "ImportJobResponse"
        }
    }

    public struct GetImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobsResponse", required: true, type: .structure)
        ]

        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobsResponse = "ImportJobsResponse"
        }
    }

    public struct GetSegmentExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let segmentId: String
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, segmentId: String, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.segmentId = segmentId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case segmentId = "segment-id"
            case token = "token"
        }
    }

    public struct GetSegmentExportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobsResponse", required: true, type: .structure)
        ]

        public let exportJobsResponse: ExportJobsResponse

        public init(exportJobsResponse: ExportJobsResponse) {
            self.exportJobsResponse = exportJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobsResponse = "ExportJobsResponse"
        }
    }

    public struct GetSegmentImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let segmentId: String
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, segmentId: String, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.segmentId = segmentId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case segmentId = "segment-id"
            case token = "token"
        }
    }

    public struct GetSegmentImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobsResponse", required: true, type: .structure)
        ]

        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobsResponse = "ImportJobsResponse"
        }
    }

    public struct GetSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let segmentId: String

        public init(applicationId: String, segmentId: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
        }
    }

    public struct GetSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]

        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct GetSegmentVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Version", location: .uri(locationName: "version"), required: true, type: .string)
        ]

        public let applicationId: String
        public let segmentId: String
        public let version: String

        public init(applicationId: String, segmentId: String, version: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case version = "version"
        }
    }

    public struct GetSegmentVersionResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]

        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct GetSegmentVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let segmentId: String
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, segmentId: String, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.segmentId = segmentId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case segmentId = "segment-id"
            case token = "token"
        }
    }

    public struct GetSegmentVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsResponse", required: true, type: .structure)
        ]

        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsResponse = "SegmentsResponse"
        }
    }

    public struct GetSegmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]

        public let applicationId: String
        public let pageSize: String?
        public let token: String?

        public init(applicationId: String, pageSize: String? = nil, token: String? = nil) {
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case pageSize = "page-size"
            case token = "token"
        }
    }

    public struct GetSegmentsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsResponse", required: true, type: .structure)
        ]

        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsResponse = "SegmentsResponse"
        }
    }

    public struct GetSmsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]

        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct GetUserEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "user-id"), required: true, type: .string)
        ]

        public let applicationId: String
        public let userId: String

        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case userId = "user-id"
        }
    }

    public struct GetUserEndpointsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointsResponse", required: true, type: .structure)
        ]

        public let endpointsResponse: EndpointsResponse

        public init(endpointsResponse: EndpointsResponse) {
            self.endpointsResponse = endpointsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointsResponse = "EndpointsResponse"
        }
    }

    public struct GetVoiceChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetVoiceChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VoiceChannelResponse", required: true, type: .structure)
        ]

        public let voiceChannelResponse: VoiceChannelResponse

        public init(voiceChannelResponse: VoiceChannelResponse) {
            self.voiceChannelResponse = voiceChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case voiceChannelResponse = "VoiceChannelResponse"
        }
    }

    public struct ImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: true, type: .enum), 
            AWSShapeMember(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "S3Url", required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentName", required: false, type: .string)
        ]

        /// Specifies whether to create a segment that contains the endpoints, when the endpoint definitions are imported.
        public let defineSegment: Bool?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the Amazon S3 location stores multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.
        public let format: Format
        /// Specifies whether to register the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.
        public let registerEndpoints: Bool?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.
        public let roleArn: String
        /// The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains. The URL should be in the following format: s3://bucket-name/folder-name/file-name. The location can end with the key for an individual object or a prefix that qualifies multiple objects.
        public let s3Url: String
        /// The identifier for the segment to update or add the imported endpoint definitions to, if the import job is meant to update an existing segment.
        public let segmentId: String?
        /// The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.
        public let segmentName: String?

        public init(defineSegment: Bool? = nil, externalId: String? = nil, format: Format, registerEndpoints: Bool? = nil, roleArn: String, s3Url: String, segmentId: String? = nil, segmentName: String? = nil) {
            self.defineSegment = defineSegment
            self.externalId = externalId
            self.format = format
            self.registerEndpoints = registerEndpoints
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.segmentId = segmentId
            self.segmentName = segmentName
        }

        private enum CodingKeys: String, CodingKey {
            case defineSegment = "DefineSegment"
            case externalId = "ExternalId"
            case format = "Format"
            case registerEndpoints = "RegisterEndpoints"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case segmentId = "SegmentId"
            case segmentName = "SegmentName"
        }
    }

    public struct ImportJobResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: true, type: .enum), 
            AWSShapeMember(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "S3Url", required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentName", required: false, type: .string)
        ]

        /// Specifies whether the import job creates a segment that contains the endpoints, when the endpoint definitions are imported.
        public let defineSegment: Bool?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the files are stored in an Amazon S3 location and that location contains multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.
        public let format: Format
        /// Specifies whether the import job registers the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.
        public let registerEndpoints: Bool?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.
        public let roleArn: String
        /// The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains. The URL should be in the following format: s3://bucket-name/folder-name/file-name. The location can end with the key for an individual object or a prefix that qualifies multiple objects.
        public let s3Url: String
        /// The identifier for the segment that the import job updates or adds endpoint definitions to, if the import job updates an existing segment.
        public let segmentId: String?
        /// The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.
        public let segmentName: String?

        public init(defineSegment: Bool? = nil, externalId: String? = nil, format: Format, registerEndpoints: Bool? = nil, roleArn: String, s3Url: String, segmentId: String? = nil, segmentName: String? = nil) {
            self.defineSegment = defineSegment
            self.externalId = externalId
            self.format = format
            self.registerEndpoints = registerEndpoints
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.segmentId = segmentId
            self.segmentName = segmentName
        }

        private enum CodingKeys: String, CodingKey {
            case defineSegment = "DefineSegment"
            case externalId = "ExternalId"
            case format = "Format"
            case registerEndpoints = "RegisterEndpoints"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case segmentId = "SegmentId"
            case segmentName = "SegmentName"
        }
    }

    public struct ImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "CompletionDate", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: true, type: .string), 
            AWSShapeMember(label: "Definition", required: true, type: .structure), 
            AWSShapeMember(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "Failures", required: false, type: .list), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "JobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeMember(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeMember(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: true, type: .string)
        ]

        /// The unique identifier for the application that's associated with the import job.
        public let applicationId: String
        /// The number of pieces that were processed successfully (completed) by the import job, as of the time of the request.
        public let completedPieces: Int?
        /// The date, in ISO 8601 format, when the import job was completed.
        public let completionDate: String?
        /// The date, in ISO 8601 format, when the import job was created.
        public let creationDate: String
        /// The resource settings that apply to the import job.
        public let definition: ImportJobResource
        /// The number of pieces that weren't processed successfully (failed) by the import job, as of the time of the request.
        public let failedPieces: Int?
        /// An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the import job, if any.
        public let failures: [String]?
        /// The unique identifier for the import job.
        public let id: String
        /// The status of the import job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.
        public let jobStatus: JobStatus
        /// The total number of endpoint definitions that weren't processed successfully (failed) by the import job, typically because an error, such as a syntax error, occurred.
        public let totalFailures: Int?
        /// The total number of pieces that must be processed to complete the import job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the import job.
        public let totalPieces: Int?
        /// The total number of endpoint definitions that were processed by the import job.
        public let totalProcessed: Int?
        /// The job type. This value is IMPORT for import jobs.
        public let `type`: String

        public init(applicationId: String, completedPieces: Int? = nil, completionDate: String? = nil, creationDate: String, definition: ImportJobResource, failedPieces: Int? = nil, failures: [String]? = nil, id: String, jobStatus: JobStatus, totalFailures: Int? = nil, totalPieces: Int? = nil, totalProcessed: Int? = nil, type: String) {
            self.applicationId = applicationId
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.failures = failures
            self.id = id
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalPieces = totalPieces
            self.totalProcessed = totalProcessed
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case completedPieces = "CompletedPieces"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case definition = "Definition"
            case failedPieces = "FailedPieces"
            case failures = "Failures"
            case id = "Id"
            case jobStatus = "JobStatus"
            case totalFailures = "TotalFailures"
            case totalPieces = "TotalPieces"
            case totalProcessed = "TotalProcessed"
            case `type` = "Type"
        }
    }

    public struct ImportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of responses, one for each import job that's associated with the application (Import Jobs resource) or segment (Segment Import Jobs resource).
        public let item: [ImportJobResponse]
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public let nextToken: String?

        public init(item: [ImportJobResponse], nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public enum Include: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct ItemResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointItemResponse", required: false, type: .structure), 
            AWSShapeMember(label: "EventsItemResponse", required: false, type: .map)
        ]

        /// The response that was received after the endpoint data was accepted.
        public let endpointItemResponse: EndpointItemResponse?
        /// A multipart response object that contains a key and a value for each event in the request. In each object, the event ID is the key and an EventItemResponse object is the value.
        public let eventsItemResponse: [String: EventItemResponse]?

        public init(endpointItemResponse: EndpointItemResponse? = nil, eventsItemResponse: [String: EventItemResponse]? = nil) {
            self.endpointItemResponse = endpointItemResponse
            self.eventsItemResponse = eventsItemResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointItemResponse = "EndpointItemResponse"
            case eventsItemResponse = "EventsItemResponse"
        }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case initializing = "INITIALIZING"
        case processing = "PROCESSING"
        case completing = "COMPLETING"
        case completed = "COMPLETED"
        case failing = "FAILING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string)
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "TagsModel"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagsModel", required: true, type: .structure)
        ]

        public let tagsModel: TagsModel

        public init(tagsModel: TagsModel) {
            self.tagsModel = tagsModel
        }

        private enum CodingKeys: String, CodingKey {
            case tagsModel = "TagsModel"
        }
    }

    public struct Message: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageSmallIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "JsonBody", required: false, type: .string), 
            AWSShapeMember(label: "MediaUrl", required: false, type: .string), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]

        /// The action to occur if a recipient taps the push notification. Valid values are: OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action. DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of iOS and Android. URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public let action: Action?
        /// The body of the notification message. The maximum number of characters is 200.
        public let body: String?
        /// The URL of the image to display as the push-notification icon, such as the icon for the app.
        public let imageIconUrl: String?
        /// The URL of the image to display as the small, push-notification icon, such as a small version of the icon for the app.
        public let imageSmallIconUrl: String?
        /// The URL of an image to display in the push notification.
        public let imageUrl: String?
        /// The JSON payload to use for a silent push notification.
        public let jsonBody: String?
        /// The URL of the image or video to display in the push notification.
        public let mediaUrl: String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. This value overrides other values for the message.
        public let rawContent: String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.
        public let silentPush: Bool?
        /// The number of seconds that the push-notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again. This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.
        public let timeToLive: Int?
        /// The title to display above the notification message on a recipient's device.
        public let title: String?
        /// The URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public let url: String?

        public init(action: Action? = nil, body: String? = nil, imageIconUrl: String? = nil, imageSmallIconUrl: String? = nil, imageUrl: String? = nil, jsonBody: String? = nil, mediaUrl: String? = nil, rawContent: String? = nil, silentPush: Bool? = nil, timeToLive: Int? = nil, title: String? = nil, url: String? = nil) {
            self.action = action
            self.body = body
            self.imageIconUrl = imageIconUrl
            self.imageSmallIconUrl = imageSmallIconUrl
            self.imageUrl = imageUrl
            self.jsonBody = jsonBody
            self.mediaUrl = mediaUrl
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case body = "Body"
            case imageIconUrl = "ImageIconUrl"
            case imageSmallIconUrl = "ImageSmallIconUrl"
            case imageUrl = "ImageUrl"
            case jsonBody = "JsonBody"
            case mediaUrl = "MediaUrl"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case timeToLive = "TimeToLive"
            case title = "Title"
            case url = "Url"
        }
    }

    public struct MessageBody: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "RequestID", required: false, type: .string)
        ]

        /// The message that's returned from the API.
        public let message: String?
        /// The unique identifier for the request or response.
        public let requestID: String?

        public init(message: String? = nil, requestID: String? = nil) {
            self.message = message
            self.requestID = requestID
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case requestID = "RequestID"
        }
    }

    public struct MessageConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "BaiduMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultMessage", required: false, type: .structure), 
            AWSShapeMember(label: "EmailMessage", required: false, type: .structure), 
            AWSShapeMember(label: "GCMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "SMSMessage", required: false, type: .structure)
        ]

        /// The message that the campaign sends through the ADM (Amazon Device Messaging) channel. This message overrides the default message.
        public let aDMMessage: Message?
        /// The message that the campaign sends through the APNs (Apple Push Notification service) channel. This message overrides the default message.
        public let aPNSMessage: Message?
        /// The message that the campaign sends through the Baidu (Baidu Cloud Push) channel. This message overrides the default message.
        public let baiduMessage: Message?
        /// The default message that the campaign sends through all the channels that are configured for the campaign.
        public let defaultMessage: Message?
        /// The message that the campaign sends through the email channel.
        public let emailMessage: CampaignEmailMessage?
        /// The message that the campaign sends through the GCM channel, which enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default message.
        public let gCMMessage: Message?
        /// The message that the campaign sends through the SMS channel.
        public let sMSMessage: CampaignSmsMessage?

        public init(aDMMessage: Message? = nil, aPNSMessage: Message? = nil, baiduMessage: Message? = nil, defaultMessage: Message? = nil, emailMessage: CampaignEmailMessage? = nil, gCMMessage: Message? = nil, sMSMessage: CampaignSmsMessage? = nil) {
            self.aDMMessage = aDMMessage
            self.aPNSMessage = aPNSMessage
            self.baiduMessage = baiduMessage
            self.defaultMessage = defaultMessage
            self.emailMessage = emailMessage
            self.gCMMessage = gCMMessage
            self.sMSMessage = sMSMessage
        }

        private enum CodingKeys: String, CodingKey {
            case aDMMessage = "ADMMessage"
            case aPNSMessage = "APNSMessage"
            case baiduMessage = "BaiduMessage"
            case defaultMessage = "DefaultMessage"
            case emailMessage = "EmailMessage"
            case gCMMessage = "GCMMessage"
            case sMSMessage = "SMSMessage"
        }
    }

    public struct MessageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Addresses", required: false, type: .map), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "Endpoints", required: false, type: .map), 
            AWSShapeMember(label: "MessageConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "TraceId", required: false, type: .string)
        ]

        /// A map of key-value pairs, where each key is an address and each value is an AddressConfiguration object. An address can be a push notification token, a phone number, or an email address. You can use an AddressConfiguration object to tailor the message for an address by specifying settings such as content overrides and message variables.
        public let addresses: [String: AddressConfiguration]?
        /// A map of custom attributes to attach to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.
        public let context: [String: String]?
        /// A map of key-value pairs, where each key is an endpoint ID and each value is an EndpointSendConfiguration object. You can use an EndpointSendConfiguration object to tailor the message for an endpoint by specifying settings such as content overrides and message variables.
        public let endpoints: [String: EndpointSendConfiguration]?
        /// The set of properties that defines the configuration settings for the message.
        public let messageConfiguration: DirectMessageConfiguration
        /// The unique identifier for tracing the message. This identifier is visible to message recipients.
        public let traceId: String?

        public init(addresses: [String: AddressConfiguration]? = nil, context: [String: String]? = nil, endpoints: [String: EndpointSendConfiguration]? = nil, messageConfiguration: DirectMessageConfiguration, traceId: String? = nil) {
            self.addresses = addresses
            self.context = context
            self.endpoints = endpoints
            self.messageConfiguration = messageConfiguration
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case addresses = "Addresses"
            case context = "Context"
            case endpoints = "Endpoints"
            case messageConfiguration = "MessageConfiguration"
            case traceId = "TraceId"
        }
    }

    public struct MessageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "EndpointResult", required: false, type: .map), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .map)
        ]

        /// The unique identifier for the application that was used to send the message.
        public let applicationId: String
        /// A map that contains a multipart response for each address that the message was sent to. In the map, the endpoint ID is the key and the result is the value.
        public let endpointResult: [String: EndpointMessageResult]?
        /// The identifier for the original request that the message was delivered for.
        public let requestId: String?
        /// A map that contains a multipart response for each address (email address, phone number, or push notification token) that the message was sent to. In the map, the address is the key and the result is the value.
        public let result: [String: MessageResult]?

        public init(applicationId: String, endpointResult: [String: EndpointMessageResult]? = nil, requestId: String? = nil, result: [String: MessageResult]? = nil) {
            self.applicationId = applicationId
            self.endpointResult = endpointResult
            self.requestId = requestId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case endpointResult = "EndpointResult"
            case requestId = "RequestId"
            case result = "Result"
        }
    }

    public struct MessageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeliveryStatus", required: true, type: .enum), 
            AWSShapeMember(label: "MessageId", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: true, type: .integer), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "UpdatedToken", required: false, type: .string)
        ]

        /// The delivery status of the message. Possible values are:  DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.   OPT_OUT - The user who's associated with the endpoint address has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again. PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint address. Amazon Pinpoint won't attempt to send the message again.   SUCCESSFUL - The message was successfully delivered to the endpoint address. TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint will attempt to deliver the message again later. THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint address. TIMEOUT - The message couldn't be sent within the timeout period. UNKNOWN_FAILURE - An unknown error occurred.
        public let deliveryStatus: DeliveryStatus
        /// The unique identifier for the message that was sent.
        public let messageId: String?
        /// The downstream service status code for delivering the message.
        public let statusCode: Int
        /// The status message for delivering the message.
        public let statusMessage: String?
        /// For push notifications that are sent through the GCM channel, specifies whether the token was updated as part of delivering the message.
        public let updatedToken: String?

        public init(deliveryStatus: DeliveryStatus, messageId: String? = nil, statusCode: Int, statusMessage: String? = nil, updatedToken: String? = nil) {
            self.deliveryStatus = deliveryStatus
            self.messageId = messageId
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStatus = "DeliveryStatus"
            case messageId = "MessageId"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case updatedToken = "UpdatedToken"
        }
    }

    public enum MessageType: String, CustomStringConvertible, Codable {
        case transactional = "TRANSACTIONAL"
        case promotional = "PROMOTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct MetricDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ComparisonOperator", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: true, type: .double)
        ]

        /// The operator to use when comparing metric values. Valid values are: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, and EQUAL.
        public let comparisonOperator: String
        /// The value to compare.
        public let value: Double

        public init(comparisonOperator: String, value: Double) {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case value = "Value"
        }
    }

    public enum Mode: String, CustomStringConvertible, Codable {
        case delivery = "DELIVERY"
        case filter = "FILTER"
        public var description: String { return self.rawValue }
    }

    public struct NumberValidateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IsoCountryCode", required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumber", required: false, type: .string)
        ]

        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.
        public let isoCountryCode: String?
        /// The phone number to retrieve information about. The phone number that you provide should include a valid numeric country code. Otherwise, the operation might result in an error.
        public let phoneNumber: String?

        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct NumberValidateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Carrier", required: false, type: .string), 
            AWSShapeMember(label: "City", required: false, type: .string), 
            AWSShapeMember(label: "CleansedPhoneNumberE164", required: false, type: .string), 
            AWSShapeMember(label: "CleansedPhoneNumberNational", required: false, type: .string), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "CountryCodeIso2", required: false, type: .string), 
            AWSShapeMember(label: "CountryCodeNumeric", required: false, type: .string), 
            AWSShapeMember(label: "County", required: false, type: .string), 
            AWSShapeMember(label: "OriginalCountryCodeIso2", required: false, type: .string), 
            AWSShapeMember(label: "OriginalPhoneNumber", required: false, type: .string), 
            AWSShapeMember(label: "PhoneType", required: false, type: .string), 
            AWSShapeMember(label: "PhoneTypeCode", required: false, type: .integer), 
            AWSShapeMember(label: "Timezone", required: false, type: .string), 
            AWSShapeMember(label: "ZipCode", required: false, type: .string)
        ]

        /// The carrier or service provider that the phone number is currently registered with.
        public let carrier: String?
        /// The name of the city where the phone number was originally registered.
        public let city: String?
        /// The cleansed phone number, in E.164 format, for the location where the phone number was originally registered.
        public let cleansedPhoneNumberE164: String?
        /// The cleansed phone number, in the format for the location where the phone number was originally registered.
        public let cleansedPhoneNumberNational: String?
        /// The name of the country or region where the phone number was originally registered.
        public let country: String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.
        public let countryCodeIso2: String?
        /// The numeric code for the country or region where the phone number was originally registered.
        public let countryCodeNumeric: String?
        /// The name of the county where the phone number was originally registered.
        public let county: String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, that was sent in the request body.
        public let originalCountryCodeIso2: String?
        /// The phone number that was sent in the request body.
        public let originalPhoneNumber: String?
        /// The description of the phone type. Valid values are: MOBILE, LANDLINE, VOIP,
        ///                   INVALID, PREPAID, and OTHER.
        public let phoneType: String?
        /// The phone type, represented by an integer. Valid values are: 0 (mobile), 1 (landline), 2 (VoIP), 3 (invalid), 4 (other), and 5 (prepaid).
        public let phoneTypeCode: Int?
        /// The time zone for the location where the phone number was originally registered.
        public let timezone: String?
        /// The postal or ZIP code for the location where the phone number was originally registered.
        public let zipCode: String?

        public init(carrier: String? = nil, city: String? = nil, cleansedPhoneNumberE164: String? = nil, cleansedPhoneNumberNational: String? = nil, country: String? = nil, countryCodeIso2: String? = nil, countryCodeNumeric: String? = nil, county: String? = nil, originalCountryCodeIso2: String? = nil, originalPhoneNumber: String? = nil, phoneType: String? = nil, phoneTypeCode: Int? = nil, timezone: String? = nil, zipCode: String? = nil) {
            self.carrier = carrier
            self.city = city
            self.cleansedPhoneNumberE164 = cleansedPhoneNumberE164
            self.cleansedPhoneNumberNational = cleansedPhoneNumberNational
            self.country = country
            self.countryCodeIso2 = countryCodeIso2
            self.countryCodeNumeric = countryCodeNumeric
            self.county = county
            self.originalCountryCodeIso2 = originalCountryCodeIso2
            self.originalPhoneNumber = originalPhoneNumber
            self.phoneType = phoneType
            self.phoneTypeCode = phoneTypeCode
            self.timezone = timezone
            self.zipCode = zipCode
        }

        private enum CodingKeys: String, CodingKey {
            case carrier = "Carrier"
            case city = "City"
            case cleansedPhoneNumberE164 = "CleansedPhoneNumberE164"
            case cleansedPhoneNumberNational = "CleansedPhoneNumberNational"
            case country = "Country"
            case countryCodeIso2 = "CountryCodeIso2"
            case countryCodeNumeric = "CountryCodeNumeric"
            case county = "County"
            case originalCountryCodeIso2 = "OriginalCountryCodeIso2"
            case originalPhoneNumber = "OriginalPhoneNumber"
            case phoneType = "PhoneType"
            case phoneTypeCode = "PhoneTypeCode"
            case timezone = "Timezone"
            case zipCode = "ZipCode"
        }
    }

    public struct PhoneNumberValidateRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "NumberValidateRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberValidateRequest", required: true, type: .structure)
        ]

        public let numberValidateRequest: NumberValidateRequest

        public init(numberValidateRequest: NumberValidateRequest) {
            self.numberValidateRequest = numberValidateRequest
        }

        private enum CodingKeys: String, CodingKey {
            case numberValidateRequest = "NumberValidateRequest"
        }
    }

    public struct PhoneNumberValidateResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "NumberValidateResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberValidateResponse", required: true, type: .structure)
        ]

        public let numberValidateResponse: NumberValidateResponse

        public init(numberValidateResponse: NumberValidateResponse) {
            self.numberValidateResponse = numberValidateResponse
        }

        private enum CodingKeys: String, CodingKey {
            case numberValidateResponse = "NumberValidateResponse"
        }
    }

    public struct PublicEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]

        /// The unique identifier for the recipient, such as a device token, email address, or mobile phone number.
        public let address: String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. You can use these attributes as filter criteria when you create segments.
        public let attributes: [String: [String]]?
        /// The channel that's used when sending messages or push notifications to the endpoint.
        public let channelType: ChannelType?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public let demographic: EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint was last updated.
        public let effectiveDate: String?
        /// The status of the update request for the endpoint. Possible values are: INACTIVE, the update failed; and, ACTIVE, the endpoint was updated successfully.
        public let endpointStatus: String?
        /// The geographic information for the endpoint.
        public let location: EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public let metrics: [String: Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public let optOut: String?
        /// A unique identifier that's generated each time the endpoint is updated.
        public let requestId: String?
        /// One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.
        public let user: EndpointUser?

        public init(address: String? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, demographic: EndpointDemographic? = nil, effectiveDate: String? = nil, endpointStatus: String? = nil, location: EndpointLocation? = nil, metrics: [String: Double]? = nil, optOut: String? = nil, requestId: String? = nil, user: EndpointUser? = nil) {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case demographic = "Demographic"
            case effectiveDate = "EffectiveDate"
            case endpointStatus = "EndpointStatus"
            case location = "Location"
            case metrics = "Metrics"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct PutEventStreamRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteEventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteEventStream", required: true, type: .structure)
        ]

        public let applicationId: String
        public let writeEventStream: WriteEventStream

        public init(applicationId: String, writeEventStream: WriteEventStream) {
            self.applicationId = applicationId
            self.writeEventStream = writeEventStream
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeEventStream = "WriteEventStream"
        }
    }

    public struct PutEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]

        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct PutEventsRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventsRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EventsRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let eventsRequest: EventsRequest

        public init(applicationId: String, eventsRequest: EventsRequest) {
            self.applicationId = applicationId
            self.eventsRequest = eventsRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case eventsRequest = "EventsRequest"
        }
    }

    public struct PutEventsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventsResponse", required: true, type: .structure)
        ]

        public let eventsResponse: EventsResponse

        public init(eventsResponse: EventsResponse) {
            self.eventsResponse = eventsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case eventsResponse = "EventsResponse"
        }
    }

    public struct QuietTime: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "End", required: false, type: .string), 
            AWSShapeMember(label: "Start", required: false, type: .string)
        ]

        /// The specific time when quiet time ends. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.
        public let end: String?
        /// The specific time when quiet time begins. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.
        public let start: String?

        public init(end: String? = nil, start: String? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
        }
    }

    public struct RawEmail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Data", required: false, type: .blob)
        ]

        /// The email message, represented as a raw MIME message. The entire message must be base64 encoded.
        public let data: Data?

        public init(data: Data? = nil) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    public struct RecencyDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: true, type: .enum), 
            AWSShapeMember(label: "RecencyType", required: true, type: .enum)
        ]

        /// The duration to use when determining whether an endpoint is active or inactive.
        public let duration: Duration
        /// The type of recency dimension to use for the segment. Valid values are: ACTIVE, endpoints that were active within the specified duration are included in the segment; and, INACTIVE, endpoints that weren't active within the specified duration are included in the segment.
        public let recencyType: RecencyType

        public init(duration: Duration, recencyType: RecencyType) {
            self.duration = duration
            self.recencyType = recencyType
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case recencyType = "RecencyType"
        }
    }

    public enum RecencyType: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct RemoveAttributesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "UpdateAttributesRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "AttributeType", location: .uri(locationName: "attribute-type"), required: true, type: .string), 
            AWSShapeMember(label: "UpdateAttributesRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let attributeType: String
        public let updateAttributesRequest: UpdateAttributesRequest

        public init(applicationId: String, attributeType: String, updateAttributesRequest: UpdateAttributesRequest) {
            self.applicationId = applicationId
            self.attributeType = attributeType
            self.updateAttributesRequest = updateAttributesRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case attributeType = "attribute-type"
            case updateAttributesRequest = "UpdateAttributesRequest"
        }
    }

    public struct RemoveAttributesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "AttributesResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributesResource", required: true, type: .structure)
        ]

        public let attributesResource: AttributesResource

        public init(attributesResource: AttributesResource) {
            self.attributesResource = attributesResource
        }

        private enum CodingKeys: String, CodingKey {
            case attributesResource = "AttributesResource"
        }
    }

    public struct SMSChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "ShortCode", required: false, type: .string)
        ]

        /// Specifies whether to enable the SMS channel for the application.
        public let enabled: Bool?
        /// The identity that you want to display on recipients' devices when they receive messages from the SMS channel.
        public let senderId: String?
        /// The registered short code that you want to use when you send messages through the SMS channel.
        public let shortCode: String?

        public init(enabled: Bool? = nil, senderId: String? = nil, shortCode: String? = nil) {
            self.enabled = enabled
            self.senderId = senderId
            self.shortCode = shortCode
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case senderId = "SenderId"
            case shortCode = "ShortCode"
        }
    }

    public struct SMSChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "PromotionalMessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "ShortCode", required: false, type: .string), 
            AWSShapeMember(label: "TransactionalMessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the SMS channel applies to.
        public let applicationId: String?
        /// The date and time, in ISO 8601 format, when the SMS channel was enabled.
        public let creationDate: String?
        /// Specifies whether the SMS channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the SMS channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the SMS channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the SMS channel.
        public let lastModifiedBy: String?
        /// The date and time, in ISO 8601 format, when the SMS channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the SMS channel, this value is SMS.
        public let platform: String
        /// The maximum number of promotional messages that you can send through the SMS channel each second.
        public let promotionalMessagesPerSecond: Int?
        /// The identity that displays on recipients' devices when they receive messages from the SMS channel.
        public let senderId: String?
        /// The registered short code to use when you send messages through the SMS channel.
        public let shortCode: String?
        /// The maximum number of transactional messages that you can send through the SMS channel each second.
        public let transactionalMessagesPerSecond: Int?
        /// The current version of the SMS channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, promotionalMessagesPerSecond: Int? = nil, senderId: String? = nil, shortCode: String? = nil, transactionalMessagesPerSecond: Int? = nil, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.promotionalMessagesPerSecond = promotionalMessagesPerSecond
            self.senderId = senderId
            self.shortCode = shortCode
            self.transactionalMessagesPerSecond = transactionalMessagesPerSecond
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case promotionalMessagesPerSecond = "PromotionalMessagesPerSecond"
            case senderId = "SenderId"
            case shortCode = "ShortCode"
            case transactionalMessagesPerSecond = "TransactionalMessagesPerSecond"
            case version = "Version"
        }
    }

    public struct SMSMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Keyword", required: false, type: .string), 
            AWSShapeMember(label: "MessageType", required: false, type: .enum), 
            AWSShapeMember(label: "OriginationNumber", required: false, type: .string), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]

        /// The body of the SMS message.
        public let body: String?
        /// The SMS program name that you provided to AWS Support when you requested your dedicated number.
        public let keyword: String?
        /// The SMS message type. Valid values are: TRANSACTIONAL, the message is critical or time-sensitive, such as a one-time password that supports a customer transaction; and, PROMOTIONAL, the message is not critical or time-sensitive, such as a marketing message.
        public let messageType: MessageType?
        /// The number that the SMS message originates from. This should be one of the dedicated long codes or short codes that you requested from AWS Support and is assigned to your AWS account. If you don't specify a long or short code, Amazon Pinpoint assigns a random long code to the SMS message.
        public let originationNumber: String?
        /// The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region.
        public let senderId: String?
        /// The message variables to use in the SMS message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, keyword: String? = nil, messageType: MessageType? = nil, originationNumber: String? = nil, senderId: String? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.keyword = keyword
            self.messageType = messageType
            self.originationNumber = originationNumber
            self.senderId = senderId
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case keyword = "Keyword"
            case messageType = "MessageType"
            case originationNumber = "OriginationNumber"
            case senderId = "SenderId"
            case substitutions = "Substitutions"
        }
    }

    public struct Schedule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: false, type: .string), 
            AWSShapeMember(label: "EventFilter", required: false, type: .structure), 
            AWSShapeMember(label: "Frequency", required: false, type: .enum), 
            AWSShapeMember(label: "IsLocalTime", required: false, type: .boolean), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure), 
            AWSShapeMember(label: "StartTime", required: true, type: .string), 
            AWSShapeMember(label: "Timezone", required: false, type: .string)
        ]

        /// The scheduled time, in ISO 8601 format, for the campaign to end.
        public let endTime: String?
        /// The type of event that causes the campaign to be sent, if the value of the Frequency property is EVENT.
        public let eventFilter: CampaignEventFilter?
        /// Specifies how often the campaign is sent or whether the campaign is sent in response to a specific event.
        public let frequency: Frequency?
        /// Specifies whether the start and end times for the campaign schedule use each recipient's local time. To base the schedule on each recipient's local time, set this value to true.
        public let isLocalTime: Bool?
        /// The default quiet time for the campaign. Quiet time is a specific time range when a campaign doesn't send messages to endpoints, if all the following conditions are met: The EndpointDemographic.Timezone property of the endpoint is set to a valid value. The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the campaign. The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the campaign. If any of the preceding conditions isn't met, the endpoint will receive messages from the campaign, even if quiet time is enabled.
        public let quietTime: QuietTime?
        /// The scheduled time, in ISO 8601 format, for the campaign to begin.
        public let startTime: String
        /// The starting UTC offset for the campaign schedule, if the value of the IsLocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05,
        ///                   UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+09, UTC+09:30,
        ///                   UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+13, UTC-02, UTC-03, UTC-04, UTC-05, UTC-06,
        ///                   UTC-07, UTC-08, UTC-09, UTC-10, and UTC-11.
        public let timezone: String?

        public init(endTime: String? = nil, eventFilter: CampaignEventFilter? = nil, frequency: Frequency? = nil, isLocalTime: Bool? = nil, quietTime: QuietTime? = nil, startTime: String, timezone: String? = nil) {
            self.endTime = endTime
            self.eventFilter = eventFilter
            self.frequency = frequency
            self.isLocalTime = isLocalTime
            self.quietTime = quietTime
            self.startTime = startTime
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case eventFilter = "EventFilter"
            case frequency = "Frequency"
            case isLocalTime = "IsLocalTime"
            case quietTime = "QuietTime"
            case startTime = "StartTime"
            case timezone = "Timezone"
        }
    }

    public struct SegmentBehaviors: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Recency", required: false, type: .structure)
        ]

        /// The dimension settings that are based on how recently an endpoint was active.
        public let recency: RecencyDimension?

        public init(recency: RecencyDimension? = nil) {
            self.recency = recency
        }

        private enum CodingKeys: String, CodingKey {
            case recency = "Recency"
        }
    }

    public struct SegmentDemographics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppVersion", required: false, type: .structure), 
            AWSShapeMember(label: "Channel", required: false, type: .structure), 
            AWSShapeMember(label: "DeviceType", required: false, type: .structure), 
            AWSShapeMember(label: "Make", required: false, type: .structure), 
            AWSShapeMember(label: "Model", required: false, type: .structure), 
            AWSShapeMember(label: "Platform", required: false, type: .structure)
        ]

        /// The app version criteria for the segment.
        public let appVersion: SetDimension?
        /// The channel criteria for the segment.
        public let channel: SetDimension?
        /// The device type criteria for the segment.
        public let deviceType: SetDimension?
        /// The device make criteria for the segment.
        public let make: SetDimension?
        /// The device model criteria for the segment.
        public let model: SetDimension?
        /// The device platform criteria for the segment.
        public let platform: SetDimension?

        public init(appVersion: SetDimension? = nil, channel: SetDimension? = nil, deviceType: SetDimension? = nil, make: SetDimension? = nil, model: SetDimension? = nil, platform: SetDimension? = nil) {
            self.appVersion = appVersion
            self.channel = channel
            self.deviceType = deviceType
            self.make = make
            self.model = model
            self.platform = platform
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion = "AppVersion"
            case channel = "Channel"
            case deviceType = "DeviceType"
            case make = "Make"
            case model = "Model"
            case platform = "Platform"
        }
    }

    public struct SegmentDimensions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "Behavior", required: false, type: .structure), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "UserAttributes", required: false, type: .map)
        ]

        /// One or more custom attributes to use as criteria for the segment.
        public let attributes: [String: AttributeDimension]?
        /// The behavior-based criteria, such as how recently users have used your app, for the segment.
        public let behavior: SegmentBehaviors?
        /// The demographic-based criteria, such as device platform, for the segment.
        public let demographic: SegmentDemographics?
        /// The location-based criteria, such as region or GPS coordinates, for the segment.
        public let location: SegmentLocation?
        /// One or more custom metrics to use as criteria for the segment.
        public let metrics: [String: MetricDimension]?
        /// One or more custom user attributes to use as criteria for the segment.
        public let userAttributes: [String: AttributeDimension]?

        public init(attributes: [String: AttributeDimension]? = nil, behavior: SegmentBehaviors? = nil, demographic: SegmentDemographics? = nil, location: SegmentLocation? = nil, metrics: [String: MetricDimension]? = nil, userAttributes: [String: AttributeDimension]? = nil) {
            self.attributes = attributes
            self.behavior = behavior
            self.demographic = demographic
            self.location = location
            self.metrics = metrics
            self.userAttributes = userAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case behavior = "Behavior"
            case demographic = "Demographic"
            case location = "Location"
            case metrics = "Metrics"
            case userAttributes = "UserAttributes"
        }
    }

    public struct SegmentGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .list), 
            AWSShapeMember(label: "SourceSegments", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]

        /// An array that defines the dimensions for the segment.
        public let dimensions: [SegmentDimensions]?
        /// The base segment to build the segment on. A base segment, also referred to as a source segment, defines the initial population of endpoints for a segment. When you add dimensions to a segment, Amazon Pinpoint filters the base segment by using the dimensions that you specify. You can specify more than one dimensional segment or only one imported segment. If you specify an imported segment, the Amazon Pinpoint console displays a segment size estimate that indicates the size of the imported segment without any filters applied to it.
        public let sourceSegments: [SegmentReference]?
        /// Specifies how to handle multiple base segments for the segment. For example, if you specify three base segments for the segment, whether the resulting segment is based on all, any, or none of the base segments.
        public let sourceType: SourceType?
        /// Specifies how to handle multiple dimensions for the segment. For example, if you specify three dimensions for the segment, whether the resulting segment includes endpoints that match all, any, or none of the dimensions.
        public let `type`: `Type`?

        public init(dimensions: [SegmentDimensions]? = nil, sourceSegments: [SegmentReference]? = nil, sourceType: SourceType? = nil, type: `Type`? = nil) {
            self.dimensions = dimensions
            self.sourceSegments = sourceSegments
            self.sourceType = sourceType
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case sourceSegments = "SourceSegments"
            case sourceType = "SourceType"
            case `type` = "Type"
        }
    }

    public struct SegmentGroupList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Groups", required: false, type: .list), 
            AWSShapeMember(label: "Include", required: false, type: .enum)
        ]

        /// An array that defines the set of segment criteria to evaluate when handling segment groups for the segment.
        public let groups: [SegmentGroup]?
        /// Specifies how to handle multiple segment groups for the segment. For example, if the segment includes three segment groups, whether the resulting segment includes endpoints that match all, any, or none of the segment groups.
        public let include: Include?

        public init(groups: [SegmentGroup]? = nil, include: Include? = nil) {
            self.groups = groups
            self.include = include
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case include = "Include"
        }
    }

    public struct SegmentImportResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelCounts", required: false, type: .map), 
            AWSShapeMember(label: "ExternalId", required: true, type: .string), 
            AWSShapeMember(label: "Format", required: true, type: .enum), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "S3Url", required: true, type: .string), 
            AWSShapeMember(label: "Size", required: true, type: .integer)
        ]

        /// The number of channel types in the endpoint definitions that were imported to create the segment.
        public let channelCounts: [String: Int]?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public let externalId: String
        /// The format of the files that were imported to create the segment. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.
        public let format: Format
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.
        public let roleArn: String
        /// The URL of the Amazon Simple Storage Service (Amazon S3) bucket that the endpoint definitions were imported from to create the segment.
        public let s3Url: String
        /// The number of endpoint definitions that were imported successfully to create the segment.
        public let size: Int

        public init(channelCounts: [String: Int]? = nil, externalId: String, format: Format, roleArn: String, s3Url: String, size: Int) {
            self.channelCounts = channelCounts
            self.externalId = externalId
            self.format = format
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case channelCounts = "ChannelCounts"
            case externalId = "ExternalId"
            case format = "Format"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case size = "Size"
        }
    }

    public struct SegmentLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Country", required: false, type: .structure), 
            AWSShapeMember(label: "GPSPoint", required: false, type: .structure)
        ]

        /// The country or region code, in ISO 3166-1 alpha-2 format, for the segment.
        public let country: SetDimension?
        /// The GPS location and range for the segment.
        public let gPSPoint: GPSPointDimension?

        public init(country: SetDimension? = nil, gPSPoint: GPSPointDimension? = nil) {
            self.country = country
            self.gPSPoint = gPSPoint
        }

        private enum CodingKeys: String, CodingKey {
            case country = "Country"
            case gPSPoint = "GPSPoint"
        }
    }

    public struct SegmentReference: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the segment.
        public let id: String
        /// The version number of the segment.
        public let version: Int?

        public init(id: String, version: Int? = nil) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case version = "Version"
        }
    }

    public struct SegmentResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "Arn", required: true, type: .string), 
            AWSShapeMember(label: "CreationDate", required: true, type: .string), 
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "ImportDefinition", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SegmentGroups", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentType", required: true, type: .enum), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the segment is associated with.
        public let applicationId: String
        /// The Amazon Resource Name (ARN) of the segment.
        public let arn: String
        /// The date and time when the segment was created.
        public let creationDate: String
        /// The dimension settings for the segment.
        public let dimensions: SegmentDimensions?
        /// The unique identifier for the segment.
        public let id: String
        /// The settings for the import job that's associated with the segment.
        public let importDefinition: SegmentImportResource?
        /// The date and time when the segment was last modified.
        public let lastModifiedDate: String?
        /// The name of the segment.
        public let name: String?
        /// A list of one or more segment groups that apply to the segment. Each segment group consists of zero or more base segments and the dimensions that are applied to those base segments.
        public let segmentGroups: SegmentGroupList?
        /// The segment type. Valid values are: DIMENSIONAL - A dynamic segment, which is a segment that uses selection criteria that you specify and is based on endpoint data that's reported by your app. Dynamic segments can change over time. IMPORT - A static segment, which is a segment that uses selection criteria that you specify and is based on endpoint definitions that you import from a file. Imported segments are static; they don't change over time.
        public let segmentType: SegmentType
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the segment. Each tag consists of a required tag key and an associated tag value.
        public let tags: [String: String]?
        /// The version number of the segment.
        public let version: Int?

        public init(applicationId: String, arn: String, creationDate: String, dimensions: SegmentDimensions? = nil, id: String, importDefinition: SegmentImportResource? = nil, lastModifiedDate: String? = nil, name: String? = nil, segmentGroups: SegmentGroupList? = nil, segmentType: SegmentType, tags: [String: String]? = nil, version: Int? = nil) {
            self.applicationId = applicationId
            self.arn = arn
            self.creationDate = creationDate
            self.dimensions = dimensions
            self.id = id
            self.importDefinition = importDefinition
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.segmentGroups = segmentGroups
            self.segmentType = segmentType
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case arn = "Arn"
            case creationDate = "CreationDate"
            case dimensions = "Dimensions"
            case id = "Id"
            case importDefinition = "ImportDefinition"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case segmentGroups = "SegmentGroups"
            case segmentType = "SegmentType"
            case tags = "tags"
            case version = "Version"
        }
    }

    public enum SegmentType: String, CustomStringConvertible, Codable {
        case dimensional = "DIMENSIONAL"
        case `import` = "IMPORT"
        public var description: String { return self.rawValue }
    }

    public struct SegmentsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of responses, one for each segment that's associated with the application (Segments resource) or each version of a segment that's associated with the application (Segment Versions resource).
        public let item: [SegmentResponse]
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public let nextToken: String?

        public init(item: [SegmentResponse], nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
            case nextToken = "NextToken"
        }
    }

    public struct SendMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "MessageRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let messageRequest: MessageRequest

        public init(applicationId: String, messageRequest: MessageRequest) {
            self.applicationId = applicationId
            self.messageRequest = messageRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case messageRequest = "MessageRequest"
        }
    }

    public struct SendMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageResponse", required: true, type: .structure)
        ]

        public let messageResponse: MessageResponse

        public init(messageResponse: MessageResponse) {
            self.messageResponse = messageResponse
        }

        private enum CodingKeys: String, CodingKey {
            case messageResponse = "MessageResponse"
        }
    }

    public struct SendUsersMessageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "MessageConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "TraceId", required: false, type: .string), 
            AWSShapeMember(label: "Users", required: true, type: .map)
        ]

        /// A map of custom attribute-value pairs. For a push notification, Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.
        public let context: [String: String]?
        /// The message definitions for the default message and any default messages that you defined for specific channels.
        public let messageConfiguration: DirectMessageConfiguration
        /// The unique identifier for tracing the message. This identifier is visible to message recipients.
        public let traceId: String?
        /// A map that associates user IDs with EndpointSendConfiguration objects. You can use an EndpointSendConfiguration object to tailor the message for a user by specifying settings such as content overrides and message variables.
        public let users: [String: EndpointSendConfiguration]

        public init(context: [String: String]? = nil, messageConfiguration: DirectMessageConfiguration, traceId: String? = nil, users: [String: EndpointSendConfiguration]) {
            self.context = context
            self.messageConfiguration = messageConfiguration
            self.traceId = traceId
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case context = "Context"
            case messageConfiguration = "MessageConfiguration"
            case traceId = "TraceId"
            case users = "Users"
        }
    }

    public struct SendUsersMessageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: true, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .map)
        ]

        /// The unique identifier for the application that was used to send the message.
        public let applicationId: String
        /// The unique identifier that was assigned to the message request.
        public let requestId: String?
        /// An object that indicates which endpoints the message was sent to, for each user. The object lists user IDs and, for each user ID, provides the endpoint IDs that the message was sent to. For each endpoint ID, it provides an EndpointMessageResult object.
        public let result: [String: [String: EndpointMessageResult]]?

        public init(applicationId: String, requestId: String? = nil, result: [String: [String: EndpointMessageResult]]? = nil) {
            self.applicationId = applicationId
            self.requestId = requestId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case requestId = "RequestId"
            case result = "Result"
        }
    }

    public struct SendUsersMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SendUsersMessageRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SendUsersMessageRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let sendUsersMessageRequest: SendUsersMessageRequest

        public init(applicationId: String, sendUsersMessageRequest: SendUsersMessageRequest) {
            self.applicationId = applicationId
            self.sendUsersMessageRequest = sendUsersMessageRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case sendUsersMessageRequest = "SendUsersMessageRequest"
        }
    }

    public struct SendUsersMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SendUsersMessageResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SendUsersMessageResponse", required: true, type: .structure)
        ]

        public let sendUsersMessageResponse: SendUsersMessageResponse

        public init(sendUsersMessageResponse: SendUsersMessageResponse) {
            self.sendUsersMessageResponse = sendUsersMessageResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sendUsersMessageResponse = "SendUsersMessageResponse"
        }
    }

    public struct Session: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "StartTimestamp", required: true, type: .string), 
            AWSShapeMember(label: "StopTimestamp", required: false, type: .string)
        ]

        /// The duration of the session, in milliseconds.
        public let duration: Int?
        /// The unique identifier for the session.
        public let id: String
        /// The date and time when the session began.
        public let startTimestamp: String
        /// The date and time when the session ended.
        public let stopTimestamp: String?

        public init(duration: Int? = nil, id: String, startTimestamp: String, stopTimestamp: String? = nil) {
            self.duration = duration
            self.id = id
            self.startTimestamp = startTimestamp
            self.stopTimestamp = stopTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case id = "Id"
            case startTimestamp = "StartTimestamp"
            case stopTimestamp = "StopTimestamp"
        }
    }

    public struct SetDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DimensionType", required: false, type: .enum), 
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]

        /// The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.
        public let dimensionType: DimensionType?
        /// The criteria values to use for the segment dimension. Depending on the value of the DimensionType property, endpoints are included or excluded from the segment if their values match the criteria values.
        public let values: [String]

        public init(dimensionType: DimensionType? = nil, values: [String]) {
            self.dimensionType = dimensionType
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct SimpleEmail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HtmlPart", required: false, type: .structure), 
            AWSShapeMember(label: "Subject", required: false, type: .structure), 
            AWSShapeMember(label: "TextPart", required: false, type: .structure)
        ]

        /// The body of the email message, in HTML format. We recommend using an HTML part for email clients that support HTML. You can include links, formatted text, and more in an HTML message.
        public let htmlPart: SimpleEmailPart?
        /// The subject line, or title, of the email.
        public let subject: SimpleEmailPart?
        /// The body of the email message, in text format. We recommend using a text part for email clients that don't support HTML and clients that are connected to high-latency networks, such as mobile devices.
        public let textPart: SimpleEmailPart?

        public init(htmlPart: SimpleEmailPart? = nil, subject: SimpleEmailPart? = nil, textPart: SimpleEmailPart? = nil) {
            self.htmlPart = htmlPart
            self.subject = subject
            self.textPart = textPart
        }

        private enum CodingKeys: String, CodingKey {
            case htmlPart = "HtmlPart"
            case subject = "Subject"
            case textPart = "TextPart"
        }
    }

    public struct SimpleEmailPart: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Charset", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .string)
        ]

        /// The applicable character set for the message content.
        public let charset: String?
        /// The textual data of the message content.
        public let data: String?

        public init(charset: String? = nil, data: String? = nil) {
            self.charset = charset
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case data = "Data"
        }
    }

    public enum SourceType: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct TagResourceRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "TagsModel"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string), 
            AWSShapeMember(label: "TagsModel", required: true, type: .structure)
        ]

        public let resourceArn: String
        public let tagsModel: TagsModel

        public init(resourceArn: String, tagsModel: TagsModel) {
            self.resourceArn = resourceArn
            self.tagsModel = tagsModel
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tagsModel = "TagsModel"
        }
    }

    public struct TagsModel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: true, type: .map)
        ]

        /// A string-to-string map of key-value pairs that defines the tags for an application, campaign, or segment. A project, campaign, or segment can have a maximum of 50 tags. Each tag consists of a required tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TreatmentResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SizePercent", required: true, type: .integer), 
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string)
        ]

        /// The unique identifier for the treatment.
        public let id: String
        /// The message configuration settings for the treatment.
        public let messageConfiguration: MessageConfiguration?
        /// The schedule settings for the treatment.
        public let schedule: Schedule?
        /// The allocated percentage of users (segment members) that the treatment is sent to.
        public let sizePercent: Int
        /// The status of the treatment.
        public let state: CampaignState?
        /// The custom description of the treatment.
        public let treatmentDescription: String?
        /// The custom name of the treatment. A treatment is a variation of a campaign that's used for A/B testing of a campaign.
        public let treatmentName: String?

        public init(id: String, messageConfiguration: MessageConfiguration? = nil, schedule: Schedule? = nil, sizePercent: Int, state: CampaignState? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil) {
            self.id = id
            self.messageConfiguration = messageConfiguration
            self.schedule = schedule
            self.sizePercent = sizePercent
            self.state = state
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case messageConfiguration = "MessageConfiguration"
            case schedule = "Schedule"
            case sizePercent = "SizePercent"
            case state = "State"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
        }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UpdateAdmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let aDMChannelRequest: ADMChannelRequest
        public let applicationId: String

        public init(aDMChannelRequest: ADMChannelRequest, applicationId: String) {
            self.aDMChannelRequest = aDMChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelRequest = "ADMChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]

        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct UpdateApnsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let aPNSChannelRequest: APNSChannelRequest
        public let applicationId: String

        public init(aPNSChannelRequest: APNSChannelRequest, applicationId: String) {
            self.aPNSChannelRequest = aPNSChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelRequest = "APNSChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]

        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct UpdateApnsSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let aPNSSandboxChannelRequest: APNSSandboxChannelRequest
        public let applicationId: String

        public init(aPNSSandboxChannelRequest: APNSSandboxChannelRequest, applicationId: String) {
            self.aPNSSandboxChannelRequest = aPNSSandboxChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelRequest = "APNSSandboxChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]

        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct UpdateApnsVoipChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let aPNSVoipChannelRequest: APNSVoipChannelRequest
        public let applicationId: String

        public init(aPNSVoipChannelRequest: APNSVoipChannelRequest, applicationId: String) {
            self.aPNSVoipChannelRequest = aPNSVoipChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelRequest = "APNSVoipChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]

        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct UpdateApnsVoipSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]

        public let aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest
        public let applicationId: String

        public init(aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest, applicationId: String) {
            self.aPNSVoipSandboxChannelRequest = aPNSVoipSandboxChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelRequest = "APNSVoipSandboxChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]

        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct UpdateApplicationSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteApplicationSettingsRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteApplicationSettingsRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let writeApplicationSettingsRequest: WriteApplicationSettingsRequest

        public init(applicationId: String, writeApplicationSettingsRequest: WriteApplicationSettingsRequest) {
            self.applicationId = applicationId
            self.writeApplicationSettingsRequest = writeApplicationSettingsRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeApplicationSettingsRequest = "WriteApplicationSettingsRequest"
        }
    }

    public struct UpdateApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationSettingsResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]

        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSettingsResource = "ApplicationSettingsResource"
        }
    }

    public struct UpdateAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Blacklist", required: false, type: .list)
        ]

        /// An array of the attributes to remove from all the endpoints that are associated with the application. The array can specify the complete, exact name of each attribute to remove or it can specify a glob pattern that an attribute name must match in order for the attribute to be removed.
        public let blacklist: [String]?

        public init(blacklist: [String]? = nil) {
            self.blacklist = blacklist
        }

        private enum CodingKeys: String, CodingKey {
            case blacklist = "Blacklist"
        }
    }

    public struct UpdateBaiduChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "BaiduChannelRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let baiduChannelRequest: BaiduChannelRequest

        public init(applicationId: String, baiduChannelRequest: BaiduChannelRequest) {
            self.applicationId = applicationId
            self.baiduChannelRequest = baiduChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case baiduChannelRequest = "BaiduChannelRequest"
        }
    }

    public struct UpdateBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]

        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct UpdateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteCampaignRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteCampaignRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let campaignId: String
        public let writeCampaignRequest: WriteCampaignRequest

        public init(applicationId: String, campaignId: String, writeCampaignRequest: WriteCampaignRequest) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.writeCampaignRequest = writeCampaignRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case campaignId = "campaign-id"
            case writeCampaignRequest = "WriteCampaignRequest"
        }
    }

    public struct UpdateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]

        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct UpdateEmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EmailChannelRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let emailChannelRequest: EmailChannelRequest

        public init(applicationId: String, emailChannelRequest: EmailChannelRequest) {
            self.applicationId = applicationId
            self.emailChannelRequest = emailChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case emailChannelRequest = "EmailChannelRequest"
        }
    }

    public struct UpdateEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]

        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct UpdateEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let endpointId: String
        public let endpointRequest: EndpointRequest

        public init(applicationId: String, endpointId: String, endpointRequest: EndpointRequest) {
            self.applicationId = applicationId
            self.endpointId = endpointId
            self.endpointRequest = endpointRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointId = "endpoint-id"
            case endpointRequest = "EndpointRequest"
        }
    }

    public struct UpdateEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageBody"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageBody", required: true, type: .structure)
        ]

        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        private enum CodingKeys: String, CodingKey {
            case messageBody = "MessageBody"
        }
    }

    public struct UpdateEndpointsBatchRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointBatchRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "EndpointBatchRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let endpointBatchRequest: EndpointBatchRequest

        public init(applicationId: String, endpointBatchRequest: EndpointBatchRequest) {
            self.applicationId = applicationId
            self.endpointBatchRequest = endpointBatchRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case endpointBatchRequest = "EndpointBatchRequest"
        }
    }

    public struct UpdateEndpointsBatchResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageBody"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageBody", required: true, type: .structure)
        ]

        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        private enum CodingKeys: String, CodingKey {
            case messageBody = "MessageBody"
        }
    }

    public struct UpdateGcmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "GCMChannelRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let gCMChannelRequest: GCMChannelRequest

        public init(applicationId: String, gCMChannelRequest: GCMChannelRequest) {
            self.applicationId = applicationId
            self.gCMChannelRequest = gCMChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case gCMChannelRequest = "GCMChannelRequest"
        }
    }

    public struct UpdateGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]

        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct UpdateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteSegmentRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteSegmentRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let segmentId: String
        public let writeSegmentRequest: WriteSegmentRequest

        public init(applicationId: String, segmentId: String, writeSegmentRequest: WriteSegmentRequest) {
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.writeSegmentRequest = writeSegmentRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case writeSegmentRequest = "WriteSegmentRequest"
        }
    }

    public struct UpdateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]

        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct UpdateSmsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SMSChannelRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let sMSChannelRequest: SMSChannelRequest

        public init(applicationId: String, sMSChannelRequest: SMSChannelRequest) {
            self.applicationId = applicationId
            self.sMSChannelRequest = sMSChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case sMSChannelRequest = "SMSChannelRequest"
        }
    }

    public struct UpdateSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]

        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct UpdateVoiceChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "VoiceChannelRequest", required: true, type: .structure)
        ]

        public let applicationId: String
        public let voiceChannelRequest: VoiceChannelRequest

        public init(applicationId: String, voiceChannelRequest: VoiceChannelRequest) {
            self.applicationId = applicationId
            self.voiceChannelRequest = voiceChannelRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case voiceChannelRequest = "VoiceChannelRequest"
        }
    }

    public struct UpdateVoiceChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "VoiceChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VoiceChannelResponse", required: true, type: .structure)
        ]

        public let voiceChannelResponse: VoiceChannelResponse

        public init(voiceChannelResponse: VoiceChannelResponse) {
            self.voiceChannelResponse = voiceChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case voiceChannelResponse = "VoiceChannelResponse"
        }
    }

    public struct VoiceChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]

        /// Specifies whether to enable the voice channel for the application.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct VoiceChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The unique identifier for the application that the voice channel applies to.
        public let applicationId: String?
        /// The date and time, in ISO 8601 format, when the voice channel was enabled.
        public let creationDate: String?
        /// Specifies whether the voice channel is enabled for the application.
        public let enabled: Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public let hasCredential: Bool?
        /// (Deprecated) An identifier for the voice channel. This property is retained only for backward compatibility.
        public let id: String?
        /// Specifies whether the voice channel is archived.
        public let isArchived: Bool?
        /// The user who last modified the voice channel.
        public let lastModifiedBy: String?
        /// The date and time, in ISO 8601 format, when the voice channel was last modified.
        public let lastModifiedDate: String?
        /// The type of messaging or notification platform for the channel. For the voice channel, this value is VOICE.
        public let platform: String
        /// The current version of the voice channel.
        public let version: Int?

        public init(applicationId: String? = nil, creationDate: String? = nil, enabled: Bool? = nil, hasCredential: Bool? = nil, id: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil, lastModifiedDate: String? = nil, platform: String, version: Int? = nil) {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case enabled = "Enabled"
            case hasCredential = "HasCredential"
            case id = "Id"
            case isArchived = "IsArchived"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedDate = "LastModifiedDate"
            case platform = "Platform"
            case version = "Version"
        }
    }

    public struct VoiceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", required: false, type: .string), 
            AWSShapeMember(label: "OriginationNumber", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "VoiceId", required: false, type: .string)
        ]

        /// The text script for the voice message.
        public let body: String?
        /// The language to use when delivering the message. For a list of supported languages, see the Amazon Polly Developer Guide.
        public let languageCode: String?
        /// The phone number from the pool or messaging service to send the message from. Although it isn't required, we recommend that you specify the phone number in E.164 format to ensure prompt and accurate delivery.
        public let originationNumber: String?
        /// The default message variables to use in the voice message. You can override the default variables with individual address variables.
        public let substitutions: [String: [String]]?
        /// The name of the voice to use when delivering the message. For a list of supported voices, see the Amazon Polly Developer Guide.
        public let voiceId: String?

        public init(body: String? = nil, languageCode: String? = nil, originationNumber: String? = nil, substitutions: [String: [String]]? = nil, voiceId: String? = nil) {
            self.body = body
            self.languageCode = languageCode
            self.originationNumber = originationNumber
            self.substitutions = substitutions
            self.voiceId = voiceId
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case languageCode = "LanguageCode"
            case originationNumber = "OriginationNumber"
            case substitutions = "Substitutions"
            case voiceId = "VoiceId"
        }
    }

    public struct WriteApplicationSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignHook", required: false, type: .structure), 
            AWSShapeMember(label: "CloudWatchMetricsEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure)
        ]

        /// The settings for the AWS Lambda function to use by default as a code hook for campaigns in the application. To override these settings for a specific campaign, use the Campaign resource to define custom Lambda function settings for the campaign.
        public let campaignHook: CampaignHook?
        /// Specifies whether to enable application-related alarms in Amazon CloudWatch.
        public let cloudWatchMetricsEnabled: Bool?
        /// The default sending limits for campaigns in the application. To override these limits for a specific campaign, use the Campaign resource to define custom limits for the campaign.
        public let limits: CampaignLimits?
        /// The default quiet time for campaigns in the application. Quiet time is a specific time range when campaigns don't send messages to endpoints, if all the following conditions are met: The EndpointDemographic.Timezone property of the endpoint is set to a valid value. The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign that has custom quiet time settings). The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign that has custom quiet time settings). If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign, even if quiet time is enabled. To override the default quiet time settings for a specific campaign, use the Campaign resource to define a custom quiet time for the campaign.
        public let quietTime: QuietTime?

        public init(campaignHook: CampaignHook? = nil, cloudWatchMetricsEnabled: Bool? = nil, limits: CampaignLimits? = nil, quietTime: QuietTime? = nil) {
            self.campaignHook = campaignHook
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.limits = limits
            self.quietTime = quietTime
        }

        private enum CodingKeys: String, CodingKey {
            case campaignHook = "CampaignHook"
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case limits = "Limits"
            case quietTime = "QuietTime"
        }
    }

    public struct WriteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeMember(label: "Hook", required: false, type: .structure), 
            AWSShapeMember(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string)
        ]

        /// An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.
        public let additionalTreatments: [WriteTreatmentResource]?
        /// The custom description of the campaign.
        public let description: String?
        /// The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.
        public let holdoutPercent: Int?
        /// The settings for the AWS Lambda function to use as a code hook for the campaign.
        public let hook: CampaignHook?
        /// Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by setting this value to false.
        public let isPaused: Bool?
        /// The messaging limits for the campaign.
        public let limits: CampaignLimits?
        /// The message configuration settings for the campaign.
        public let messageConfiguration: MessageConfiguration?
        /// The custom name of the campaign.
        public let name: String?
        /// The schedule settings for the campaign.
        public let schedule: Schedule?
        /// The unique identifier for the segment to associate with the campaign.
        public let segmentId: String?
        /// The version of the segment to associate with the campaign.
        public let segmentVersion: Int?
        /// A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.
        public let tags: [String: String]?
        /// The custom description of a variation of the campaign to use for A/B testing.
        public let treatmentDescription: String?
        /// The custom name of a variation of the campaign to use for A/B testing.
        public let treatmentName: String?

        public init(additionalTreatments: [WriteTreatmentResource]? = nil, description: String? = nil, holdoutPercent: Int? = nil, hook: CampaignHook? = nil, isPaused: Bool? = nil, limits: CampaignLimits? = nil, messageConfiguration: MessageConfiguration? = nil, name: String? = nil, schedule: Schedule? = nil, segmentId: String? = nil, segmentVersion: Int? = nil, tags: [String: String]? = nil, treatmentDescription: String? = nil, treatmentName: String? = nil) {
            self.additionalTreatments = additionalTreatments
            self.description = description
            self.holdoutPercent = holdoutPercent
            self.hook = hook
            self.isPaused = isPaused
            self.limits = limits
            self.messageConfiguration = messageConfiguration
            self.name = name
            self.schedule = schedule
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
            self.tags = tags
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }

        private enum CodingKeys: String, CodingKey {
            case additionalTreatments = "AdditionalTreatments"
            case description = "Description"
            case holdoutPercent = "HoldoutPercent"
            case hook = "Hook"
            case isPaused = "IsPaused"
            case limits = "Limits"
            case messageConfiguration = "MessageConfiguration"
            case name = "Name"
            case schedule = "Schedule"
            case segmentId = "SegmentId"
            case segmentVersion = "SegmentVersion"
            case tags = "tags"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
        }
    }

    public struct WriteEventStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationStreamArn", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream that you want to publish event data to. For a Kinesis data stream, the ARN format is: arn:aws:kinesis:region:account-id:stream/stream_name
        ///                 For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:region:account-id:deliverystream/stream_name
        ///                
        public let destinationStreamArn: String
        /// The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.
        public let roleArn: String

        public init(destinationStreamArn: String, roleArn: String) {
            self.destinationStreamArn = destinationStreamArn
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationStreamArn = "DestinationStreamArn"
            case roleArn = "RoleArn"
        }
    }

    public struct WriteSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SegmentGroups", required: false, type: .structure), 
            AWSShapeMember(label: "tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]

        /// The criteria that define the dimensions for the segment.
        public let dimensions: SegmentDimensions?
        /// The name of the segment.
        public let name: String?
        /// The segment group to use and the dimensions to apply to the group's base segments in order to build the segment. A segment group can consist of zero or more base segments. Your request can include only one segment group.
        public let segmentGroups: SegmentGroupList?
        /// A string-to-string map of key-value pairs that defines the tags to associate with the segment. Each tag consists of a required tag key and an associated tag value.
        public let tags: [String: String]?

        public init(dimensions: SegmentDimensions? = nil, name: String? = nil, segmentGroups: SegmentGroupList? = nil, tags: [String: String]? = nil) {
            self.dimensions = dimensions
            self.name = name
            self.segmentGroups = segmentGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case name = "Name"
            case segmentGroups = "SegmentGroups"
            case tags = "tags"
        }
    }

    public struct WriteTreatmentResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SizePercent", required: true, type: .integer), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string)
        ]

        /// The message configuration settings for the treatment.
        public let messageConfiguration: MessageConfiguration?
        /// The schedule settings for the treatment.
        public let schedule: Schedule?
        /// The allocated percentage of users (segment members) to send the treatment to.
        public let sizePercent: Int
        /// The custom description of the treatment.
        public let treatmentDescription: String?
        /// The custom name of the treatment. A treatment is a variation of a campaign that's used for A/B testing of a campaign.
        public let treatmentName: String?

        public init(messageConfiguration: MessageConfiguration? = nil, schedule: Schedule? = nil, sizePercent: Int, treatmentDescription: String? = nil, treatmentName: String? = nil) {
            self.messageConfiguration = messageConfiguration
            self.schedule = schedule
            self.sizePercent = sizePercent
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }

        private enum CodingKeys: String, CodingKey {
            case messageConfiguration = "MessageConfiguration"
            case schedule = "Schedule"
            case sizePercent = "SizePercent"
            case treatmentDescription = "TreatmentDescription"
            case treatmentName = "TreatmentName"
        }
    }
}
