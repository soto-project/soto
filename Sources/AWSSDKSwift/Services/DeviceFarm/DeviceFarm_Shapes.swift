// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension DeviceFarm {

    public struct GetOfferingStatusResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextPeriod", required: false, type: .map), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "current", required: false, type: .map)
        ]
        /// When specified, gets the offering status for the next period.
        public let nextPeriod: [String: OfferingStatus]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// When specified, gets the offering status for the current period.
        public let current: [String: OfferingStatus]?

        public init(nextPeriod: [String: OfferingStatus]? = nil, nextToken: String? = nil, current: [String: OfferingStatus]? = nil) {
            self.nextPeriod = nextPeriod
            self.nextToken = nextToken
            self.current = current
        }

        private enum CodingKeys: String, CodingKey {
            case nextPeriod = "nextPeriod"
            case nextToken = "nextToken"
            case current = "current"
        }
    }

    public struct ListDevicePoolsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "devicePools", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the device pools.
        public let devicePools: [DevicePool]?

        public init(nextToken: String? = nil, devicePools: [DevicePool]? = nil) {
            self.nextToken = nextToken
            self.devicePools = devicePools
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case devicePools = "devicePools"
        }
    }

    public struct DevicePool: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "rules", required: false, type: .list), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// The device pool's name.
        public let name: String?
        /// The device pool's ARN.
        public let arn: String?
        /// The device pool's description.
        public let description: String?
        /// Information about the device pool's rules.
        public let rules: [Rule]?
        /// The device pool's type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public let `type`: DevicePoolType?

        public init(name: String? = nil, arn: String? = nil, description: String? = nil, rules: [Rule]? = nil, type: DevicePoolType? = nil) {
            self.name = name
            self.arn = arn
            self.description = description
            self.rules = rules
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case arn = "arn"
            case description = "description"
            case rules = "rules"
            case `type` = "type"
        }
    }

    public struct RemoteAccessSession: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "skipAppResign", required: false, type: .boolean), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "remoteRecordEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "hostAddress", required: false, type: .string), 
            AWSShapeMember(label: "interactionMode", required: false, type: .enum), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "instanceArn", required: false, type: .string), 
            AWSShapeMember(label: "remoteRecordAppArn", required: false, type: .string), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "endpoint", required: false, type: .string), 
            AWSShapeMember(label: "clientId", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "remoteDebugEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "billingMethod", required: false, type: .enum), 
            AWSShapeMember(label: "device", required: false, type: .structure), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceUdid", required: false, type: .string)
        ]
        /// When set to true, for private devices, Device Farm will not sign your app again. For public devices, Device Farm always signs your apps again and this parameter has no effect. For more information about how Device Farm re-signs your app(s), see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// A message about the remote access session.
        public let message: String?
        /// This flag is set to true if remote recording is enabled for the remote access session.
        public let remoteRecordEnabled: Bool?
        /// The number of minutes a device is used in a remote access sesssion (including setup and teardown minutes).
        public let deviceMinutes: DeviceMinutes?
        /// IP address of the EC2 host where you need to connect to remotely debug devices. Only returned if remote debugging is enabled for the remote access session.
        public let hostAddress: String?
        /// The interaction mode of the remote access session. Valid values are:   INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.   NO_VIDEO: You are connected to the device but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.   VIDEO_ONLY: You can view the screen but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.  
        public let interactionMode: InteractionMode?
        /// The Amazon Resource Name (ARN) of the remote access session.
        public let arn: String?
        /// The status of the remote access session. Can be any of the following:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The Amazon Resource Name (ARN) of the instance.
        public let instanceArn: String?
        /// The Amazon Resource Name (ARN) for the app to be recorded in the remote access session.
        public let remoteRecordAppArn: String?
        /// The result of the remote access session. Can be any of the following:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The endpoint for the remote access sesssion.
        public let endpoint: String?
        /// Unique identifier of your client for the remote access session. Only returned if remote debugging is enabled for the remote access session.
        public let clientId: String?
        /// The name of the remote access session.
        public let name: String?
        /// This flag is set to true if remote debugging is enabled for the remote access session.
        public let remoteDebugEnabled: Bool?
        /// The date and time the remote access session was stopped.
        public let stopped: TimeStamp?
        /// The date and time the remote access session was created.
        public let created: TimeStamp?
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see AWS Device Farm terminology."
        public let billingMethod: BillingMethod?
        /// The device (phone or tablet) used in the remote access session.
        public let device: Device?
        /// The date and time the remote access session was started.
        public let started: TimeStamp?
        /// Unique device identifier for the remote device. Only returned if remote debugging is enabled for the remote access session.
        public let deviceUdid: String?

        public init(skipAppResign: Bool? = nil, message: String? = nil, remoteRecordEnabled: Bool? = nil, deviceMinutes: DeviceMinutes? = nil, hostAddress: String? = nil, interactionMode: InteractionMode? = nil, arn: String? = nil, status: ExecutionStatus? = nil, instanceArn: String? = nil, remoteRecordAppArn: String? = nil, result: ExecutionResult? = nil, endpoint: String? = nil, clientId: String? = nil, name: String? = nil, remoteDebugEnabled: Bool? = nil, stopped: TimeStamp? = nil, created: TimeStamp? = nil, billingMethod: BillingMethod? = nil, device: Device? = nil, started: TimeStamp? = nil, deviceUdid: String? = nil) {
            self.skipAppResign = skipAppResign
            self.message = message
            self.remoteRecordEnabled = remoteRecordEnabled
            self.deviceMinutes = deviceMinutes
            self.hostAddress = hostAddress
            self.interactionMode = interactionMode
            self.arn = arn
            self.status = status
            self.instanceArn = instanceArn
            self.remoteRecordAppArn = remoteRecordAppArn
            self.result = result
            self.endpoint = endpoint
            self.clientId = clientId
            self.name = name
            self.remoteDebugEnabled = remoteDebugEnabled
            self.stopped = stopped
            self.created = created
            self.billingMethod = billingMethod
            self.device = device
            self.started = started
            self.deviceUdid = deviceUdid
        }

        private enum CodingKeys: String, CodingKey {
            case skipAppResign = "skipAppResign"
            case message = "message"
            case remoteRecordEnabled = "remoteRecordEnabled"
            case deviceMinutes = "deviceMinutes"
            case hostAddress = "hostAddress"
            case interactionMode = "interactionMode"
            case arn = "arn"
            case status = "status"
            case instanceArn = "instanceArn"
            case remoteRecordAppArn = "remoteRecordAppArn"
            case result = "result"
            case endpoint = "endpoint"
            case clientId = "clientId"
            case name = "name"
            case remoteDebugEnabled = "remoteDebugEnabled"
            case stopped = "stopped"
            case created = "created"
            case billingMethod = "billingMethod"
            case device = "device"
            case started = "started"
            case deviceUdid = "deviceUdid"
        }
    }

    public struct DeviceFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "operator", required: false, type: .enum), 
            AWSShapeMember(label: "attribute", required: false, type: .enum), 
            AWSShapeMember(label: "values", required: false, type: .list)
        ]
        /// The filter operator.   The EQUALS operator is available for every attribute except INSTANCE_LABELS.   The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.   The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.   The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.  
        public let `operator`: DeviceFilterOperator?
        /// The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:   ARN: The Amazon Resource Name (ARN) of the device. For example, "arn:aws:devicefarm:us-west-2::device:12345Example".   PLATFORM: The device platform. Valid values are "ANDROID" or "IOS".   OS_VERSION: The operating system version. For example, "10.3.2".   MODEL: The device model. For example, "iPad 5th Gen".   AVAILABILITY: The current availability of the device. Valid values are "AVAILABLE", "HIGHLY_AVAILABLE", "BUSY", or "TEMPORARY_NOT_AVAILABLE".   FORM_FACTOR: The device form factor. Valid values are "PHONE" or "TABLET".   MANUFACTURER: The device manufacturer. For example, "Apple".   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging.   INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.   INSTANCE_LABELS: The label of the device instance.   FLEET_TYPE: The fleet type. Valid values are "PUBLIC" or "PRIVATE".  
        public let attribute: DeviceFilterAttribute?
        /// An array of one or more filter values used in a device filter.  Operator Values    The IN and NOT operators can take a values array that has more than one element.   The other operators require an array with a single element.    Attribute Values    The PLATFORM attribute can be set to "ANDROID" or "IOS".   The AVAILABILITY attribute can be set to "AVAILABLE", "HIGHLY_AVAILABLE", "BUSY", or "TEMPORARY_NOT_AVAILABLE".   The FORM_FACTOR attribute can be set to "PHONE" or "TABLET".   The FLEET_TYPE attribute can be set to "PUBLIC" or "PRIVATE".  
        public let values: [String]?

        public init(operator: DeviceFilterOperator? = nil, attribute: DeviceFilterAttribute? = nil, values: [String]? = nil) {
            self.`operator` = `operator`
            self.attribute = attribute
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "operator"
            case attribute = "attribute"
            case values = "values"
        }
    }

    public struct InstanceProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "rebootAfterUse", required: false, type: .boolean), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "excludeAppPackagesFromCleanup", required: false, type: .list), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "packageCleanup", required: false, type: .boolean)
        ]
        /// The description of the instance profile.
        public let description: String?
        /// When set to true, Device Farm will reboot the instance after a test run. The default value is true.
        public let rebootAfterUse: Bool?
        /// The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String?
        /// An array of strings specifying the list of app packages that should not be cleaned up from the device after a test run is over. The list of packages is only considered if you set packageCleanup to true.
        public let excludeAppPackagesFromCleanup: [String]?
        /// The name of the instance profile.
        public let name: String?
        /// When set to true, Device Farm will remove app packages after a test run. The default value is false for private devices.
        public let packageCleanup: Bool?

        public init(description: String? = nil, rebootAfterUse: Bool? = nil, arn: String? = nil, excludeAppPackagesFromCleanup: [String]? = nil, name: String? = nil, packageCleanup: Bool? = nil) {
            self.description = description
            self.rebootAfterUse = rebootAfterUse
            self.arn = arn
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case rebootAfterUse = "rebootAfterUse"
            case arn = "arn"
            case excludeAppPackagesFromCleanup = "excludeAppPackagesFromCleanup"
            case name = "name"
            case packageCleanup = "packageCleanup"
        }
    }

    public struct GetInstanceProfileResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceProfile", required: false, type: .structure)
        ]
        /// An object containing information about your instance profile.
        public let instanceProfile: InstanceProfile?

        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile = "instanceProfile"
        }
    }

    public struct OfferingStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "effectiveOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "quantity", required: false, type: .integer), 
            AWSShapeMember(label: "offering", required: false, type: .structure)
        ]
        /// The type specified for the offering status.
        public let `type`: OfferingTransactionType?
        /// The date on which the offering is effective.
        public let effectiveOn: TimeStamp?
        /// The number of available devices in the offering.
        public let quantity: Int32?
        /// Represents the metadata of an offering status.
        public let offering: Offering?

        public init(type: OfferingTransactionType? = nil, effectiveOn: TimeStamp? = nil, quantity: Int32? = nil, offering: Offering? = nil) {
            self.`type` = `type`
            self.effectiveOn = effectiveOn
            self.quantity = quantity
            self.offering = offering
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case effectiveOn = "effectiveOn"
            case quantity = "quantity"
            case offering = "offering"
        }
    }

    public struct Rule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "attribute", required: false, type: .enum), 
            AWSShapeMember(label: "operator", required: false, type: .enum), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]
        /// The rule's attribute. It is the aspect of a device such as platform or model used as selection criteria to create or update a device pool. Allowed values include:   ARN: The Amazon Resource Name (ARN) of a device. For example, "arn:aws:devicefarm:us-west-2::device:12345Example".   PLATFORM: The device platform. Valid values are "ANDROID" or "IOS".   FORM_FACTOR: The device form factor. Valid values are "PHONE" or "TABLET".   MANUFACTURER: The device manufacturer. For example, "Apple".   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging.   APPIUM_VERSION: The Appium version for the test.   INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.   INSTANCE_LABELS: The label of the device instance.   FLEET_TYPE: The fleet type. Valid values are "PUBLIC" or "PRIVATE".  
        public let attribute: DeviceAttribute?
        /// The rule's operator.   EQUALS: The equals operator.   GREATER_THAN: The greater-than operator.   IN: The in operator.   LESS_THAN: The less-than operator.   NOT_IN: The not-in operator.   CONTAINS: The contains operator.  
        public let `operator`: RuleOperator?
        /// The rule's value. The value must be passed in as a string using escaped quotes. For example: "value": "\"ANDROID\""
        public let value: String?

        public init(attribute: DeviceAttribute? = nil, operator: RuleOperator? = nil, value: String? = nil) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct DeleteProjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm project you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Device: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "carrier", required: false, type: .string), 
            AWSShapeMember(label: "instances", required: false, type: .list), 
            AWSShapeMember(label: "remoteDebugEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "fleetName", required: false, type: .string), 
            AWSShapeMember(label: "platform", required: false, type: .enum), 
            AWSShapeMember(label: "cpu", required: false, type: .structure), 
            AWSShapeMember(label: "formFactor", required: false, type: .enum), 
            AWSShapeMember(label: "os", required: false, type: .string), 
            AWSShapeMember(label: "manufacturer", required: false, type: .string), 
            AWSShapeMember(label: "remoteAccessEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "modelId", required: false, type: .string), 
            AWSShapeMember(label: "fleetType", required: false, type: .string), 
            AWSShapeMember(label: "image", required: false, type: .string), 
            AWSShapeMember(label: "model", required: false, type: .string), 
            AWSShapeMember(label: "availability", required: false, type: .enum), 
            AWSShapeMember(label: "memory", required: false, type: .long), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "radio", required: false, type: .string), 
            AWSShapeMember(label: "heapSize", required: false, type: .long), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "resolution", required: false, type: .structure)
        ]
        /// The device's carrier.
        public let carrier: String?
        /// The instances belonging to this device.
        public let instances: [DeviceInstance]?
        /// This flag is set to true if remote debugging is enabled for the device.
        public let remoteDebugEnabled: Bool?
        /// The name of the fleet to which this device belongs.
        public let fleetName: String?
        /// The device's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public let platform: DevicePlatform?
        /// Information about the device's CPU.
        public let cpu: CPU?
        /// The device's form factor. Allowed values include:   PHONE: The phone form factor.   TABLET: The tablet form factor.  
        public let formFactor: DeviceFormFactor?
        /// The device's operating system type.
        public let os: String?
        /// The device's manufacturer name.
        public let manufacturer: String?
        /// Specifies whether remote access has been enabled for the specified device.
        public let remoteAccessEnabled: Bool?
        /// The device's model ID.
        public let modelId: String?
        /// The type of fleet to which this device belongs. Possible values for fleet type are PRIVATE and PUBLIC.
        public let fleetType: String?
        /// The device's image name.
        public let image: String?
        /// The device's model name.
        public let model: String?
        /// Reflects how likely a device will be available for a test run.
        public let availability: DeviceAvailability?
        /// The device's total memory size, expressed in bytes.
        public let memory: Int64?
        /// The device's display name.
        public let name: String?
        /// The device's radio.
        public let radio: String?
        /// The device's heap size, expressed in bytes.
        public let heapSize: Int64?
        /// The device's ARN.
        public let arn: String?
        /// The resolution of the device.
        public let resolution: Resolution?

        public init(carrier: String? = nil, instances: [DeviceInstance]? = nil, remoteDebugEnabled: Bool? = nil, fleetName: String? = nil, platform: DevicePlatform? = nil, cpu: CPU? = nil, formFactor: DeviceFormFactor? = nil, os: String? = nil, manufacturer: String? = nil, remoteAccessEnabled: Bool? = nil, modelId: String? = nil, fleetType: String? = nil, image: String? = nil, model: String? = nil, availability: DeviceAvailability? = nil, memory: Int64? = nil, name: String? = nil, radio: String? = nil, heapSize: Int64? = nil, arn: String? = nil, resolution: Resolution? = nil) {
            self.carrier = carrier
            self.instances = instances
            self.remoteDebugEnabled = remoteDebugEnabled
            self.fleetName = fleetName
            self.platform = platform
            self.cpu = cpu
            self.formFactor = formFactor
            self.os = os
            self.manufacturer = manufacturer
            self.remoteAccessEnabled = remoteAccessEnabled
            self.modelId = modelId
            self.fleetType = fleetType
            self.image = image
            self.model = model
            self.availability = availability
            self.memory = memory
            self.name = name
            self.radio = radio
            self.heapSize = heapSize
            self.arn = arn
            self.resolution = resolution
        }

        private enum CodingKeys: String, CodingKey {
            case carrier = "carrier"
            case instances = "instances"
            case remoteDebugEnabled = "remoteDebugEnabled"
            case fleetName = "fleetName"
            case platform = "platform"
            case cpu = "cpu"
            case formFactor = "formFactor"
            case os = "os"
            case manufacturer = "manufacturer"
            case remoteAccessEnabled = "remoteAccessEnabled"
            case modelId = "modelId"
            case fleetType = "fleetType"
            case image = "image"
            case model = "model"
            case availability = "availability"
            case memory = "memory"
            case name = "name"
            case radio = "radio"
            case heapSize = "heapSize"
            case arn = "arn"
            case resolution = "resolution"
        }
    }

    public struct AccountSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "unmeteredDevices", required: false, type: .map), 
            AWSShapeMember(label: "trialMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "unmeteredRemoteAccessDevices", required: false, type: .map), 
            AWSShapeMember(label: "maxSlots", required: false, type: .map), 
            AWSShapeMember(label: "maxJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "awsAccountNumber", required: false, type: .string), 
            AWSShapeMember(label: "skipAppResign", required: false, type: .boolean)
        ]
        /// Returns the unmetered devices you have purchased or want to purchase.
        public let unmeteredDevices: [DevicePlatform: Int32]?
        /// Information about an AWS account's usage of free trial device minutes.
        public let trialMinutes: TrialMinutes?
        /// The default number of minutes (at the account level) a test run will execute before it times out. Default value is 60 minutes.
        public let defaultJobTimeoutMinutes: Int32?
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public let unmeteredRemoteAccessDevices: [DevicePlatform: Int32]?
        /// The maximum number of device slots that the AWS account can purchase. Each maximum is expressed as an offering-id:number pair, where the offering-id represents one of the IDs returned by the ListOfferings command.
        public let maxSlots: [String: Int32]?
        /// The maximum number of minutes a test run will execute before it times out.
        public let maxJobTimeoutMinutes: Int32?
        /// The AWS account number specified in the AccountSettings container.
        public let awsAccountNumber: String?
        /// When set to true, for private devices, Device Farm will not sign your app again. For public devices, Device Farm always signs your apps again and this parameter has no effect. For more information about how Device Farm re-signs your app(s), see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?

        public init(unmeteredDevices: [DevicePlatform: Int32]? = nil, trialMinutes: TrialMinutes? = nil, defaultJobTimeoutMinutes: Int32? = nil, unmeteredRemoteAccessDevices: [DevicePlatform: Int32]? = nil, maxSlots: [String: Int32]? = nil, maxJobTimeoutMinutes: Int32? = nil, awsAccountNumber: String? = nil, skipAppResign: Bool? = nil) {
            self.unmeteredDevices = unmeteredDevices
            self.trialMinutes = trialMinutes
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
            self.maxSlots = maxSlots
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.awsAccountNumber = awsAccountNumber
            self.skipAppResign = skipAppResign
        }

        private enum CodingKeys: String, CodingKey {
            case unmeteredDevices = "unmeteredDevices"
            case trialMinutes = "trialMinutes"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
            case unmeteredRemoteAccessDevices = "unmeteredRemoteAccessDevices"
            case maxSlots = "maxSlots"
            case maxJobTimeoutMinutes = "maxJobTimeoutMinutes"
            case awsAccountNumber = "awsAccountNumber"
            case skipAppResign = "skipAppResign"
        }
    }

    public struct GetAccountSettingsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accountSettings", required: false, type: .structure)
        ]
        /// The account settings.
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "accountSettings"
        }
    }

    public struct DeleteNetworkProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the network profile you want to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ScheduleRunResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "run", required: false, type: .structure)
        ]
        /// Information about the scheduled run.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "run"
        }
    }

    public struct GetVPCEConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to describe.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum UploadStatus: String, CustomStringConvertible, Codable {
        case initialized = "INITIALIZED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct DeleteVPCEConfigurationResult: AWSShape {

    }

    public struct CreateDevicePoolRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "rules", required: true, type: .list), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string)
        ]
        /// The device pool's rules.
        public let rules: [Rule]
        /// The device pool's name.
        public let name: String
        /// The ARN of the project for the device pool.
        public let projectArn: String
        /// The device pool's description.
        public let description: String?

        public init(rules: [Rule], name: String, projectArn: String, description: String? = nil) {
            self.rules = rules
            self.name = name
            self.projectArn = projectArn
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
            case name = "name"
            case projectArn = "projectArn"
            case description = "description"
        }
    }

    public struct StopRunResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "run", required: false, type: .structure)
        ]
        /// The run that was stopped.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "run"
        }
    }

    public struct ScheduleRunConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "location", required: false, type: .structure), 
            AWSShapeMember(label: "auxiliaryApps", required: false, type: .list), 
            AWSShapeMember(label: "locale", required: false, type: .string), 
            AWSShapeMember(label: "vpceConfigurationArns", required: false, type: .list), 
            AWSShapeMember(label: "networkProfileArn", required: false, type: .string), 
            AWSShapeMember(label: "radios", required: false, type: .structure), 
            AWSShapeMember(label: "extraDataPackageArn", required: false, type: .string), 
            AWSShapeMember(label: "billingMethod", required: false, type: .enum), 
            AWSShapeMember(label: "customerArtifactPaths", required: false, type: .structure)
        ]
        /// Information about the location that is used for the run.
        public let location: Location?
        /// A list of auxiliary apps for the run.
        public let auxiliaryApps: [String]?
        /// Information about the locale that is used for the run.
        public let locale: String?
        /// An array of Amazon Resource Names (ARNs) for your VPC endpoint configurations.
        public let vpceConfigurationArns: [String]?
        /// Reserved for internal use.
        public let networkProfileArn: String?
        /// Information about the radio states for the run.
        public let radios: Radios?
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm will extract to external data for Android or the app's sandbox for iOS.
        public let extraDataPackageArn: String?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public let billingMethod: BillingMethod?
        /// Input CustomerArtifactPaths object for the scheduled run configuration.
        public let customerArtifactPaths: CustomerArtifactPaths?

        public init(location: Location? = nil, auxiliaryApps: [String]? = nil, locale: String? = nil, vpceConfigurationArns: [String]? = nil, networkProfileArn: String? = nil, radios: Radios? = nil, extraDataPackageArn: String? = nil, billingMethod: BillingMethod? = nil, customerArtifactPaths: CustomerArtifactPaths? = nil) {
            self.location = location
            self.auxiliaryApps = auxiliaryApps
            self.locale = locale
            self.vpceConfigurationArns = vpceConfigurationArns
            self.networkProfileArn = networkProfileArn
            self.radios = radios
            self.extraDataPackageArn = extraDataPackageArn
            self.billingMethod = billingMethod
            self.customerArtifactPaths = customerArtifactPaths
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case auxiliaryApps = "auxiliaryApps"
            case locale = "locale"
            case vpceConfigurationArns = "vpceConfigurationArns"
            case networkProfileArn = "networkProfileArn"
            case radios = "radios"
            case extraDataPackageArn = "extraDataPackageArn"
            case billingMethod = "billingMethod"
            case customerArtifactPaths = "customerArtifactPaths"
        }
    }

    public struct ListRemoteAccessSessionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSessions", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// A container representing the metadata from the service about each remote access session you are requesting.
        public let remoteAccessSessions: [RemoteAccessSession]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(remoteAccessSessions: [RemoteAccessSession]? = nil, nextToken: String? = nil) {
            self.remoteAccessSessions = remoteAccessSessions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSessions = "remoteAccessSessions"
            case nextToken = "nextToken"
        }
    }

    public struct ListSamplesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "samples", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the samples.
        public let samples: [Sample]?

        public init(nextToken: String? = nil, samples: [Sample]? = nil) {
            self.nextToken = nextToken
            self.samples = samples
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case samples = "samples"
        }
    }

    public struct UpdateProjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The number of minutes a test run in the project will execute before it times out.
        public let defaultJobTimeoutMinutes: Int32?
        /// A string representing the new name of the project that you are updating.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the project whose name you wish to update.
        public let arn: String

        public init(defaultJobTimeoutMinutes: Int32? = nil, name: String? = nil, arn: String) {
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
            case name = "name"
            case arn = "arn"
        }
    }

    public enum DevicePoolType: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListDevicePoolsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The project ARN.
        public let arn: String
        /// The device pools' type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public let `type`: DevicePoolType?

        public init(nextToken: String? = nil, arn: String, type: DevicePoolType? = nil) {
            self.nextToken = nextToken
            self.arn = arn
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
            case `type` = "type"
        }
    }

    public struct ListRemoteAccessSessionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
        }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case pendingConcurrency = "PENDING_CONCURRENCY"
        case pendingDevice = "PENDING_DEVICE"
        case processing = "PROCESSING"
        case scheduling = "SCHEDULING"
        case preparing = "PREPARING"
        case running = "RUNNING"
        case completed = "COMPLETED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public struct ListProjectsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
        public let arn: String?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
        }
    }

    public struct GetRemoteAccessSessionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSession", required: false, type: .structure)
        ]
        /// A container that lists detailed information about the remote access session.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession = "remoteAccessSession"
        }
    }

    public struct DeviceSelectionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxDevices", required: false, type: .integer), 
            AWSShapeMember(label: "filters", required: false, type: .list), 
            AWSShapeMember(label: "matchedDevicesCount", required: false, type: .integer)
        ]
        /// The maximum number of devices to be selected by a device filter and included in a test run.
        public let maxDevices: Int32?
        /// The filters in a device selection result.
        public let filters: [DeviceFilter]?
        /// The number of devices that matched the device filter selection criteria.
        public let matchedDevicesCount: Int32?

        public init(maxDevices: Int32? = nil, filters: [DeviceFilter]? = nil, matchedDevicesCount: Int32? = nil) {
            self.maxDevices = maxDevices
            self.filters = filters
            self.matchedDevicesCount = matchedDevicesCount
        }

        private enum CodingKeys: String, CodingKey {
            case maxDevices = "maxDevices"
            case filters = "filters"
            case matchedDevicesCount = "matchedDevicesCount"
        }
    }

    public struct DeleteInstanceProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the instance profile you are requesting to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Problem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "suite", required: false, type: .structure), 
            AWSShapeMember(label: "job", required: false, type: .structure), 
            AWSShapeMember(label: "test", required: false, type: .structure), 
            AWSShapeMember(label: "run", required: false, type: .structure), 
            AWSShapeMember(label: "device", required: false, type: .structure), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "result", required: false, type: .enum)
        ]
        /// Information about the associated suite.
        public let suite: ProblemDetail?
        /// Information about the associated job.
        public let job: ProblemDetail?
        /// Information about the associated test.
        public let test: ProblemDetail?
        /// Information about the associated run.
        public let run: ProblemDetail?
        /// Information about the associated device.
        public let device: Device?
        /// A message about the problem's result.
        public let message: String?
        /// The problem's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?

        public init(suite: ProblemDetail? = nil, job: ProblemDetail? = nil, test: ProblemDetail? = nil, run: ProblemDetail? = nil, device: Device? = nil, message: String? = nil, result: ExecutionResult? = nil) {
            self.suite = suite
            self.job = job
            self.test = test
            self.run = run
            self.device = device
            self.message = message
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case suite = "suite"
            case job = "job"
            case test = "test"
            case run = "run"
            case device = "device"
            case message = "message"
            case result = "result"
        }
    }

    public struct GetOfferingStatusRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct UpdateProjectResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "project", required: false, type: .structure)
        ]
        /// The project you wish to update.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct Location: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "longitude", required: true, type: .double), 
            AWSShapeMember(label: "latitude", required: true, type: .double)
        ]
        /// The longitude.
        public let longitude: Double
        /// The latitude.
        public let latitude: Double

        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        private enum CodingKeys: String, CodingKey {
            case longitude = "longitude"
            case latitude = "latitude"
        }
    }

    public struct RenewOfferingResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringTransaction", required: false, type: .structure)
        ]
        /// Represents the status of the offering transaction for the renewal.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        private enum CodingKeys: String, CodingKey {
            case offeringTransaction = "offeringTransaction"
        }
    }

    public enum ExecutionResult: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case passed = "PASSED"
        case warned = "WARNED"
        case failed = "FAILED"
        case skipped = "SKIPPED"
        case errored = "ERRORED"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public struct CreateRemoteAccessSessionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSession", required: false, type: .structure)
        ]
        /// A container that describes the remote access session when the request to create a remote access session is sent.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession = "remoteAccessSession"
        }
    }

    public enum ExecutionResultCode: String, CustomStringConvertible, Codable {
        case parsingFailed = "PARSING_FAILED"
        case vpcEndpointSetupFailed = "VPC_ENDPOINT_SETUP_FAILED"
        public var description: String { return self.rawValue }
    }

    public struct UpdateUploadResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "upload", required: false, type: .structure)
        ]
        /// A test spec uploaded to Device Farm.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload = "upload"
        }
    }

    public struct CPU: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "architecture", required: false, type: .string), 
            AWSShapeMember(label: "frequency", required: false, type: .string), 
            AWSShapeMember(label: "clock", required: false, type: .double)
        ]
        /// The CPU's architecture, for example x86 or ARM.
        public let architecture: String?
        /// The CPU's frequency.
        public let frequency: String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public let clock: Double?

        public init(architecture: String? = nil, frequency: String? = nil, clock: Double? = nil) {
            self.architecture = architecture
            self.frequency = frequency
            self.clock = clock
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case frequency = "frequency"
            case clock = "clock"
        }
    }

    public struct Artifact: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "extension", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "url", required: false, type: .string)
        ]
        /// The artifact's type. Allowed values include the following:   UNKNOWN: An unknown type.   SCREENSHOT: The screenshot type.   DEVICE_LOG: The device log type.   MESSAGE_LOG: The message log type.   RESULT_LOG: The result log type.   SERVICE_LOG: The service log type.   WEBKIT_LOG: The web kit log type.   INSTRUMENTATION_OUTPUT: The instrumentation type.   EXERCISER_MONKEY_OUTPUT: For Android, the artifact (log) generated by an Android fuzz test.   CALABASH_JSON_OUTPUT: The Calabash JSON output type.   CALABASH_PRETTY_OUTPUT: The Calabash pretty output type.   CALABASH_STANDARD_OUTPUT: The Calabash standard output type.   CALABASH_JAVA_XML_OUTPUT: The Calabash Java XML output type.   AUTOMATION_OUTPUT: The automation output type.   APPIUM_SERVER_OUTPUT: The Appium server output type.   APPIUM_JAVA_OUTPUT: The Appium Java output type.   APPIUM_JAVA_XML_OUTPUT: The Appium Java XML output type.   APPIUM_PYTHON_OUTPUT: The Appium Python output type.   APPIUM_PYTHON_XML_OUTPUT: The Appium Python XML output type.   EXPLORER_EVENT_LOG: The Explorer event log output type.   EXPLORER_SUMMARY_LOG: The Explorer summary log output type.   APPLICATION_CRASH_REPORT: The application crash report output type.   XCTEST_LOG: The XCode test output type.  
        public let `type`: ArtifactType?
        /// The artifact's file extension.
        public let `extension`: String?
        /// The artifact's name.
        public let name: String?
        /// The artifact's ARN.
        public let arn: String?
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the artifact's file.
        public let url: String?

        public init(type: ArtifactType? = nil, extension: String? = nil, name: String? = nil, arn: String? = nil, url: String? = nil) {
            self.`type` = `type`
            self.`extension` = `extension`
            self.name = name
            self.arn = arn
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case `extension` = "extension"
            case name = "name"
            case arn = "arn"
            case url = "url"
        }
    }

    public struct Sample: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "url", required: false, type: .string)
        ]
        /// The sample's type. Must be one of the following values:   CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.   MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.   NATIVE_AVG_DRAWTIME   NATIVE_FPS   NATIVE_FRAMES   NATIVE_MAX_DRAWTIME   NATIVE_MIN_DRAWTIME   OPENGL_AVG_DRAWTIME   OPENGL_FPS   OPENGL_FRAMES   OPENGL_MAX_DRAWTIME   OPENGL_MIN_DRAWTIME   RX   RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.   THREADS: A threads sample type. This is expressed as the total number of threads per app process.   TX   TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.  
        public let `type`: SampleType?
        /// The sample's ARN.
        public let arn: String?
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the sample's file.
        public let url: String?

        public init(type: SampleType? = nil, arn: String? = nil, url: String? = nil) {
            self.`type` = `type`
            self.arn = arn
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case arn = "arn"
            case url = "url"
        }
    }

    public struct UpdateDeviceInstanceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "profileArn", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "labels", required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the profile that you want to associate with the device instance.
        public let profileArn: String?
        /// The Amazon Resource Name (ARN) of the device instance.
        public let arn: String
        /// An array of strings that you want to associate with the device instance.
        public let labels: [String]?

        public init(profileArn: String? = nil, arn: String, labels: [String]? = nil) {
            self.profileArn = profileArn
            self.arn = arn
            self.labels = labels
        }

        private enum CodingKeys: String, CodingKey {
            case profileArn = "profileArn"
            case arn = "arn"
            case labels = "labels"
        }
    }

    public struct ListOfferingTransactionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct InstallToRemoteAccessSessionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appArn", required: true, type: .string), 
            AWSShapeMember(label: "remoteAccessSessionArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the app about which you are requesting information.
        public let appArn: String
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let remoteAccessSessionArn: String

        public init(appArn: String, remoteAccessSessionArn: String) {
            self.appArn = appArn
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case remoteAccessSessionArn = "remoteAccessSessionArn"
        }
    }

    public enum ArtifactCategory: String, CustomStringConvertible, Codable {
        case screenshot = "SCREENSHOT"
        case file = "FILE"
        case log = "LOG"
        public var description: String { return self.rawValue }
    }

    public struct Job: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "instanceArn", required: false, type: .string), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "videoCapture", required: false, type: .boolean), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "videoEndpoint", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "device", required: false, type: .structure)
        ]
        /// The job's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The Amazon Resource Name (ARN) of the instance.
        public let instanceArn: String?
        /// The job's stop time.
        public let stopped: TimeStamp?
        /// When the job was created.
        public let created: TimeStamp?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public let deviceMinutes: DeviceMinutes?
        /// This value is set to true if video capture is enabled; otherwise, it is set to false.
        public let videoCapture: Bool?
        /// A message about the job's result.
        public let message: String?
        /// The job's name.
        public let name: String?
        /// The job's start time.
        public let started: TimeStamp?
        /// The job's ARN.
        public let arn: String?
        /// The endpoint for streaming device video.
        public let videoEndpoint: String?
        /// The job's type. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The job's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The job's result counters.
        public let counters: Counters?
        /// The device (phone or tablet).
        public let device: Device?

        public init(status: ExecutionStatus? = nil, instanceArn: String? = nil, stopped: TimeStamp? = nil, created: TimeStamp? = nil, deviceMinutes: DeviceMinutes? = nil, videoCapture: Bool? = nil, message: String? = nil, name: String? = nil, started: TimeStamp? = nil, arn: String? = nil, videoEndpoint: String? = nil, type: TestType? = nil, result: ExecutionResult? = nil, counters: Counters? = nil, device: Device? = nil) {
            self.status = status
            self.instanceArn = instanceArn
            self.stopped = stopped
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.videoCapture = videoCapture
            self.message = message
            self.name = name
            self.started = started
            self.arn = arn
            self.videoEndpoint = videoEndpoint
            self.`type` = `type`
            self.result = result
            self.counters = counters
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case instanceArn = "instanceArn"
            case stopped = "stopped"
            case created = "created"
            case deviceMinutes = "deviceMinutes"
            case videoCapture = "videoCapture"
            case message = "message"
            case name = "name"
            case started = "started"
            case arn = "arn"
            case videoEndpoint = "videoEndpoint"
            case `type` = "type"
            case result = "result"
            case counters = "counters"
            case device = "device"
        }
    }

    public struct PurchaseOfferingRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "quantity", required: false, type: .integer), 
            AWSShapeMember(label: "offeringId", required: false, type: .string), 
            AWSShapeMember(label: "offeringPromotionId", required: false, type: .string)
        ]
        /// The number of device slots you wish to purchase in an offering request.
        public let quantity: Int32?
        /// The ID of the offering.
        public let offeringId: String?
        /// The ID of the offering promotion to be applied to the purchase.
        public let offeringPromotionId: String?

        public init(quantity: Int32? = nil, offeringId: String? = nil, offeringPromotionId: String? = nil) {
            self.quantity = quantity
            self.offeringId = offeringId
            self.offeringPromotionId = offeringPromotionId
        }

        private enum CodingKeys: String, CodingKey {
            case quantity = "quantity"
            case offeringId = "offeringId"
            case offeringPromotionId = "offeringPromotionId"
        }
    }

    public struct ListJobsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "jobs", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the jobs.
        public let jobs: [Job]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct DeleteDevicePoolRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteDevicePoolResult: AWSShape {

    }

    public struct UpdateNetworkProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uplinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "uplinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "downlinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "uplinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "downlinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "uplinkBandwidthBits", required: false, type: .long)
        ]
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The name of the network profile about which you are returning information.
        public let name: String?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The Amazon Resource Name (ARN) of the project for which you want to update network profile settings.
        public let arn: String
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// The descriptoin of the network profile about which you are returning information.
        public let description: String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?

        public init(uplinkDelayMs: Int64? = nil, name: String? = nil, uplinkLossPercent: Int32? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, downlinkLossPercent: Int32? = nil, arn: String, uplinkJitterMs: Int64? = nil, description: String? = nil, downlinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, uplinkBandwidthBits: Int64? = nil) {
            self.uplinkDelayMs = uplinkDelayMs
            self.name = name
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkLossPercent = downlinkLossPercent
            self.arn = arn
            self.uplinkJitterMs = uplinkJitterMs
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.`type` = `type`
            self.uplinkBandwidthBits = uplinkBandwidthBits
        }

        private enum CodingKeys: String, CodingKey {
            case uplinkDelayMs = "uplinkDelayMs"
            case name = "name"
            case uplinkLossPercent = "uplinkLossPercent"
            case downlinkJitterMs = "downlinkJitterMs"
            case downlinkDelayMs = "downlinkDelayMs"
            case downlinkLossPercent = "downlinkLossPercent"
            case arn = "arn"
            case uplinkJitterMs = "uplinkJitterMs"
            case description = "description"
            case downlinkBandwidthBits = "downlinkBandwidthBits"
            case `type` = "type"
            case uplinkBandwidthBits = "uplinkBandwidthBits"
        }
    }

    public struct GetUploadResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "upload", required: false, type: .structure)
        ]
        /// An app or a set of one or more tests to upload or that have been uploaded.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload = "upload"
        }
    }

    public struct StopJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm job you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum InstanceStatus: String, CustomStringConvertible, Codable {
        case inUse = "IN_USE"
        case preparing = "PREPARING"
        case available = "AVAILABLE"
        case notAvailable = "NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public struct UpdateDevicePoolResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePool", required: false, type: .structure)
        ]
        /// The device pool you just updated.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool = "devicePool"
        }
    }

    public enum DeviceFilterOperator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanOrEquals = "LESS_THAN_OR_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEquals = "GREATER_THAN_OR_EQUALS"
        case `in` = "IN"
        case notIn = "NOT_IN"
        case contains = "CONTAINS"
        public var description: String { return self.rawValue }
    }

    public struct ListSuitesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The job's Amazon Resource Name (ARN).
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct CreateRemoteAccessSessionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteRecordAppArn", required: false, type: .string), 
            AWSShapeMember(label: "remoteDebugEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "skipAppResign", required: false, type: .boolean), 
            AWSShapeMember(label: "remoteRecordEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "clientId", required: false, type: .string), 
            AWSShapeMember(label: "interactionMode", required: false, type: .enum), 
            AWSShapeMember(label: "instanceArn", required: false, type: .string), 
            AWSShapeMember(label: "sshPublicKey", required: false, type: .string), 
            AWSShapeMember(label: "configuration", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "deviceArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) for the app to be recorded in the remote access session.
        public let remoteRecordAppArn: String?
        /// Set to true if you want to access devices remotely for debugging in your remote access session.
        public let remoteDebugEnabled: Bool?
        /// When set to true, for private devices, Device Farm will not sign your app again. For public devices, Device Farm always signs your apps again and this parameter has no effect. For more information about how Device Farm re-signs your app(s), see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// Set to true to enable remote recording for the remote access session.
        public let remoteRecordEnabled: Bool?
        /// Unique identifier for the client. If you want access to multiple devices on the same client, you should pass the same clientId value in each call to CreateRemoteAccessSession. This is required only if remoteDebugEnabled is set to true.
        public let clientId: String?
        /// The interaction mode of the remote access session. Valid values are:   INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.   NO_VIDEO: You are connected to the device but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.   VIDEO_ONLY: You can view the screen but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.  
        public let interactionMode: InteractionMode?
        /// The Amazon Resource Name (ARN) of the device instance for which you want to create a remote access session.
        public let instanceArn: String?
        /// The public key of the ssh key pair you want to use for connecting to remote devices in your remote debugging session. This is only required if remoteDebugEnabled is set to true.
        public let sshPublicKey: String?
        /// The configuration information for the remote access session request.
        public let configuration: CreateRemoteAccessSessionConfiguration?
        /// The name of the remote access session that you wish to create.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
        public let projectArn: String
        /// The Amazon Resource Name (ARN) of the device for which you want to create a remote access session.
        public let deviceArn: String

        public init(remoteRecordAppArn: String? = nil, remoteDebugEnabled: Bool? = nil, skipAppResign: Bool? = nil, remoteRecordEnabled: Bool? = nil, clientId: String? = nil, interactionMode: InteractionMode? = nil, instanceArn: String? = nil, sshPublicKey: String? = nil, configuration: CreateRemoteAccessSessionConfiguration? = nil, name: String? = nil, projectArn: String, deviceArn: String) {
            self.remoteRecordAppArn = remoteRecordAppArn
            self.remoteDebugEnabled = remoteDebugEnabled
            self.skipAppResign = skipAppResign
            self.remoteRecordEnabled = remoteRecordEnabled
            self.clientId = clientId
            self.interactionMode = interactionMode
            self.instanceArn = instanceArn
            self.sshPublicKey = sshPublicKey
            self.configuration = configuration
            self.name = name
            self.projectArn = projectArn
            self.deviceArn = deviceArn
        }

        private enum CodingKeys: String, CodingKey {
            case remoteRecordAppArn = "remoteRecordAppArn"
            case remoteDebugEnabled = "remoteDebugEnabled"
            case skipAppResign = "skipAppResign"
            case remoteRecordEnabled = "remoteRecordEnabled"
            case clientId = "clientId"
            case interactionMode = "interactionMode"
            case instanceArn = "instanceArn"
            case sshPublicKey = "sshPublicKey"
            case configuration = "configuration"
            case name = "name"
            case projectArn = "projectArn"
            case deviceArn = "deviceArn"
        }
    }

    public enum SampleType: String, CustomStringConvertible, Codable {
        case cpu = "CPU"
        case memory = "MEMORY"
        case threads = "THREADS"
        case rxRate = "RX_RATE"
        case txRate = "TX_RATE"
        case rx = "RX"
        case tx = "TX"
        case nativeFrames = "NATIVE_FRAMES"
        case nativeFps = "NATIVE_FPS"
        case nativeMinDrawtime = "NATIVE_MIN_DRAWTIME"
        case nativeAvgDrawtime = "NATIVE_AVG_DRAWTIME"
        case nativeMaxDrawtime = "NATIVE_MAX_DRAWTIME"
        case openglFrames = "OPENGL_FRAMES"
        case openglFps = "OPENGL_FPS"
        case openglMinDrawtime = "OPENGL_MIN_DRAWTIME"
        case openglAvgDrawtime = "OPENGL_AVG_DRAWTIME"
        case openglMaxDrawtime = "OPENGL_MAX_DRAWTIME"
        public var description: String { return self.rawValue }
    }

    public struct GetRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The run's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetDeviceResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "device", required: false, type: .structure)
        ]
        /// An object containing information about the requested device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
        }
    }

    public struct DeleteUploadRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm upload you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListTestsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The test suite's Amazon Resource Name (ARN).
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct StopRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the Amazon Resource Name (ARN) of the Device Farm run you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Upload: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "category", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "metadata", required: false, type: .string), 
            AWSShapeMember(label: "contentType", required: false, type: .string), 
            AWSShapeMember(label: "url", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "message", required: false, type: .string)
        ]
        /// The upload's status. Must be one of the following values:   FAILED: A failed status.   INITIALIZED: An initialized status.   PROCESSING: A processing status.   SUCCEEDED: A succeeded status.  
        public let status: UploadStatus?
        /// The upload's category. Allowed values include:   CURATED: An upload managed by AWS Device Farm.   PRIVATE: An upload managed by the AWS Device Farm customer.  
        public let category: UploadCategory?
        /// The upload's file name.
        public let name: String?
        /// The upload's ARN.
        public let arn: String?
        /// The upload's type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.   APPIUM_JAVA_JUNIT_TEST_SPEC: An Appium Java JUnit test spec upload.   APPIUM_JAVA_TESTNG_TEST_SPEC: An Appium Java TestNG test spec upload.   APPIUM_PYTHON_TEST_SPEC: An Appium Python test spec upload.   APPIUM_WEB_JAVA_JUNIT_TEST_SPEC: An Appium Java JUnit test spec upload.   APPIUM_WEB_JAVA_TESTNG_TEST_SPEC: An Appium Java TestNG test spec upload.   APPIUM_WEB_PYTHON_TEST_SPEC: An Appium Python test spec upload.   INSTRUMENTATION_TEST_SPEC: An instrumentation test spec upload.   XCTEST_UI_TEST_SPEC: An XCode UI test spec upload.  
        public let `type`: UploadType?
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public let metadata: String?
        /// The upload's content type (for example, "application/octet-stream").
        public let contentType: String?
        /// The pre-signed Amazon S3 URL that was used to store a file through a corresponding PUT request.
        public let url: String?
        /// When the upload was created.
        public let created: TimeStamp?
        /// A message about the upload's result.
        public let message: String?

        public init(status: UploadStatus? = nil, category: UploadCategory? = nil, name: String? = nil, arn: String? = nil, type: UploadType? = nil, metadata: String? = nil, contentType: String? = nil, url: String? = nil, created: TimeStamp? = nil, message: String? = nil) {
            self.status = status
            self.category = category
            self.name = name
            self.arn = arn
            self.`type` = `type`
            self.metadata = metadata
            self.contentType = contentType
            self.url = url
            self.created = created
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case category = "category"
            case name = "name"
            case arn = "arn"
            case `type` = "type"
            case metadata = "metadata"
            case contentType = "contentType"
            case url = "url"
            case created = "created"
            case message = "message"
        }
    }

    public enum ArtifactType: String, CustomStringConvertible, Codable {
        case unknown = "UNKNOWN"
        case screenshot = "SCREENSHOT"
        case deviceLog = "DEVICE_LOG"
        case messageLog = "MESSAGE_LOG"
        case videoLog = "VIDEO_LOG"
        case resultLog = "RESULT_LOG"
        case serviceLog = "SERVICE_LOG"
        case webkitLog = "WEBKIT_LOG"
        case instrumentationOutput = "INSTRUMENTATION_OUTPUT"
        case exerciserMonkeyOutput = "EXERCISER_MONKEY_OUTPUT"
        case calabashJsonOutput = "CALABASH_JSON_OUTPUT"
        case calabashPrettyOutput = "CALABASH_PRETTY_OUTPUT"
        case calabashStandardOutput = "CALABASH_STANDARD_OUTPUT"
        case calabashJavaXmlOutput = "CALABASH_JAVA_XML_OUTPUT"
        case automationOutput = "AUTOMATION_OUTPUT"
        case appiumServerOutput = "APPIUM_SERVER_OUTPUT"
        case appiumJavaOutput = "APPIUM_JAVA_OUTPUT"
        case appiumJavaXmlOutput = "APPIUM_JAVA_XML_OUTPUT"
        case appiumPythonOutput = "APPIUM_PYTHON_OUTPUT"
        case appiumPythonXmlOutput = "APPIUM_PYTHON_XML_OUTPUT"
        case explorerEventLog = "EXPLORER_EVENT_LOG"
        case explorerSummaryLog = "EXPLORER_SUMMARY_LOG"
        case applicationCrashReport = "APPLICATION_CRASH_REPORT"
        case xctestLog = "XCTEST_LOG"
        case video = "VIDEO"
        case customerArtifact = "CUSTOMER_ARTIFACT"
        case customerArtifactLog = "CUSTOMER_ARTIFACT_LOG"
        case testspecOutput = "TESTSPEC_OUTPUT"
        public var description: String { return self.rawValue }
    }

    public struct DeleteRunResult: AWSShape {

    }

    public struct DeleteRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) for the run you wish to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListProjectsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "projects", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the projects.
        public let projects: [Project]?

        public init(nextToken: String? = nil, projects: [Project]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projects = "projects"
        }
    }

    public struct ListUploadsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The type of upload. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.   APPIUM_JAVA_JUNIT_TEST_SPEC: An Appium Java JUnit test spec upload.   APPIUM_JAVA_TESTNG_TEST_SPEC: An Appium Java TestNG test spec upload.   APPIUM_PYTHON_TEST_SPEC: An Appium Python test spec upload.   APPIUM_WEB_JAVA_JUNIT_TEST_SPEC: An Appium Java JUnit test spec upload.   APPIUM_WEB_JAVA_TESTNG_TEST_SPEC: An Appium Java TestNG test spec upload.   APPIUM_WEB_PYTHON_TEST_SPEC: An Appium Python test spec upload.   INSTRUMENTATION_TEST_SPEC: An instrumentation test spec upload.   XCTEST_UI_TEST_SPEC: An XCode UI test spec upload.  
        public let `type`: UploadType?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
        public let arn: String

        public init(type: UploadType? = nil, nextToken: String? = nil, arn: String) {
            self.`type` = `type`
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public enum InteractionMode: String, CustomStringConvertible, Codable {
        case interactive = "INTERACTIVE"
        case noVideo = "NO_VIDEO"
        case videoOnly = "VIDEO_ONLY"
        public var description: String { return self.rawValue }
    }

    public struct IncompatibilityMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// A message about the incompatibility.
        public let message: String?
        /// The type of incompatibility. Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   APPIUM_VERSION: The Appium version for the test.  
        public let `type`: DeviceAttribute?

        public init(message: String? = nil, type: DeviceAttribute? = nil) {
            self.message = message
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case `type` = "type"
        }
    }

    public struct GetNetworkProfileResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure)
        ]
        /// The network profile.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
        }
    }

    public struct ListDevicesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "filters", required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the project.
        public let arn: String?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// Used to select a set of devices. A filter is made up of an attribute, an operator, and one or more values.   Attribute: The aspect of a device such as platform or model used as the selction criteria in a device filter. Allowed values include:   ARN: The Amazon Resource Name (ARN) of the device. For example, "arn:aws:devicefarm:us-west-2::device:12345Example".   PLATFORM: The device platform. Valid values are "ANDROID" or "IOS".   OS_VERSION: The operating system version. For example, "10.3.2".   MODEL: The device model. For example, "iPad 5th Gen".   AVAILABILITY: The current availability of the device. Valid values are "AVAILABLE", "HIGHLY_AVAILABLE", "BUSY", or "TEMPORARY_NOT_AVAILABLE".   FORM_FACTOR: The device form factor. Valid values are "PHONE" or "TABLET".   MANUFACTURER: The device manufacturer. For example, "Apple".   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging.   INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.   INSTANCE_LABELS: The label of the device instance.   FLEET_TYPE: The fleet type. Valid values are "PUBLIC" or "PRIVATE".     Operator: The filter operator.   The EQUALS operator is available for every attribute except INSTANCE_LABELS.   The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.   The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.   The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.     Values: An array of one or more filter values.   The IN and NOT operators can take a values array that has more than one element.   The other operators require an array with a single element.   In a request, the AVAILABILITY attribute takes "AVAILABLE", "HIGHLY_AVAILABLE", "BUSY", or "TEMPORARY_NOT_AVAILABLE" as values.    
        public let filters: [DeviceFilter]?

        public init(arn: String? = nil, nextToken: String? = nil, filters: [DeviceFilter]? = nil) {
            self.arn = arn
            self.nextToken = nextToken
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
            case filters = "filters"
        }
    }

    public struct Resolution: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "height", required: false, type: .integer), 
            AWSShapeMember(label: "width", required: false, type: .integer)
        ]
        /// The screen resolution's height, expressed in pixels.
        public let height: Int32?
        /// The screen resolution's width, expressed in pixels.
        public let width: Int32?

        public init(height: Int32? = nil, width: Int32? = nil) {
            self.height = height
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case width = "width"
        }
    }

    public struct GetNetworkProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the network profile you want to return information about.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetProjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The project's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteInstanceProfileResult: AWSShape {

    }

    public enum BillingMethod: String, CustomStringConvertible, Codable {
        case metered = "METERED"
        case unmetered = "UNMETERED"
        public var description: String { return self.rawValue }
    }

    public struct OfferingTransaction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringStatus", required: false, type: .structure), 
            AWSShapeMember(label: "cost", required: false, type: .structure), 
            AWSShapeMember(label: "transactionId", required: false, type: .string), 
            AWSShapeMember(label: "createdOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "offeringPromotionId", required: false, type: .string)
        ]
        /// The status of an offering transaction.
        public let offeringStatus: OfferingStatus?
        /// The cost of an offering transaction.
        public let cost: MonetaryAmount?
        /// The transaction ID of the offering transaction.
        public let transactionId: String?
        /// The date on which an offering transaction was created.
        public let createdOn: TimeStamp?
        /// The ID that corresponds to a device offering promotion.
        public let offeringPromotionId: String?

        public init(offeringStatus: OfferingStatus? = nil, cost: MonetaryAmount? = nil, transactionId: String? = nil, createdOn: TimeStamp? = nil, offeringPromotionId: String? = nil) {
            self.offeringStatus = offeringStatus
            self.cost = cost
            self.transactionId = transactionId
            self.createdOn = createdOn
            self.offeringPromotionId = offeringPromotionId
        }

        private enum CodingKeys: String, CodingKey {
            case offeringStatus = "offeringStatus"
            case cost = "cost"
            case transactionId = "transactionId"
            case createdOn = "createdOn"
            case offeringPromotionId = "offeringPromotionId"
        }
    }

    public struct PurchaseOfferingResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringTransaction", required: false, type: .structure)
        ]
        /// Represents the offering transaction for the purchase result.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        private enum CodingKeys: String, CodingKey {
            case offeringTransaction = "offeringTransaction"
        }
    }

    public struct CreateDevicePoolResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePool", required: false, type: .structure)
        ]
        /// The newly created device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool = "devicePool"
        }
    }

    public enum DevicePlatform: String, CustomStringConvertible, Codable {
        case android = "ANDROID"
        case ios = "IOS"
        public var description: String { return self.rawValue }
    }

    public struct DeviceInstance: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "udid", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "labels", required: false, type: .list), 
            AWSShapeMember(label: "deviceArn", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "instanceProfile", required: false, type: .structure)
        ]
        /// Unique device identifier for the device instance.
        public let udid: String?
        /// The status of the device instance. Valid values are listed below.
        public let status: InstanceStatus?
        /// An array of strings describing the device instance.
        public let labels: [String]?
        /// The Amazon Resource Name (ARN) of the device.
        public let deviceArn: String?
        /// The Amazon Resource Name (ARN) of the device instance.
        public let arn: String?
        /// A object containing information about the instance profile.
        public let instanceProfile: InstanceProfile?

        public init(udid: String? = nil, status: InstanceStatus? = nil, labels: [String]? = nil, deviceArn: String? = nil, arn: String? = nil, instanceProfile: InstanceProfile? = nil) {
            self.udid = udid
            self.status = status
            self.labels = labels
            self.deviceArn = deviceArn
            self.arn = arn
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case udid = "udid"
            case status = "status"
            case labels = "labels"
            case deviceArn = "deviceArn"
            case arn = "arn"
            case instanceProfile = "instanceProfile"
        }
    }

    public struct GetTestResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "test", required: false, type: .structure)
        ]
        /// A test condition that is evaluated.
        public let test: Test?

        public init(test: Test? = nil) {
            self.test = test
        }

        private enum CodingKeys: String, CodingKey {
            case test = "test"
        }
    }

    public struct Project: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]
        /// The project's ARN.
        public let arn: String?
        /// When the project was created.
        public let created: TimeStamp?
        /// The default number of minutes (at the project level) a test run will execute before it times out. Default value is 60 minutes.
        public let defaultJobTimeoutMinutes: Int32?
        /// The project's name.
        public let name: String?

        public init(arn: String? = nil, created: TimeStamp? = nil, defaultJobTimeoutMinutes: Int32? = nil, name: String? = nil) {
            self.arn = arn
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case created = "created"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
            case name = "name"
        }
    }

    public struct ListOfferingTransactionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "offeringTransactions", required: false, type: .list)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
        public let offeringTransactions: [OfferingTransaction]?

        public init(nextToken: String? = nil, offeringTransactions: [OfferingTransaction]? = nil) {
            self.nextToken = nextToken
            self.offeringTransactions = offeringTransactions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case offeringTransactions = "offeringTransactions"
        }
    }

    public struct GetSuiteRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The suite's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeviceSelectionConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxDevices", required: true, type: .integer), 
            AWSShapeMember(label: "filters", required: true, type: .list)
        ]
        /// The maximum number of devices to be included in a test run.
        public let maxDevices: Int32
        /// Used to dynamically select a set of devices for a test run. A filter is made up of an attribute, an operator, and one or more values.   Attribute: The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:   ARN: The Amazon Resource Name (ARN) of the device. For example, "arn:aws:devicefarm:us-west-2::device:12345Example".   PLATFORM: The device platform. Valid values are "ANDROID" or "IOS".   OS_VERSION: The operating system version. For example, "10.3.2".   MODEL: The device model. For example, "iPad 5th Gen".   AVAILABILITY: The current availability of the device. Valid values are "AVAILABLE", "HIGHLY_AVAILABLE", "BUSY", or "TEMPORARY_NOT_AVAILABLE".   FORM_FACTOR: The device form factor. Valid values are "PHONE" or "TABLET".   MANUFACTURER: The device manufacturer. For example, "Apple".   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access.   REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging.   INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.   INSTANCE_LABELS: The label of the device instance.   FLEET_TYPE: The fleet type. Valid values are "PUBLIC" or "PRIVATE".     Operator: The filter operator.   The EQUALS operator is available for every attribute except INSTANCE_LABELS.   The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.   The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.   The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.     Values: An array of one or more filter values.   The IN and NOT operators can take a values array that has more than one element.   The other operators require an array with a single element.   In a request, the AVAILABILITY attribute takes "AVAILABLE", "HIGHLY_AVAILABLE", "BUSY", or "TEMPORARY_NOT_AVAILABLE" as values.    
        public let filters: [DeviceFilter]

        public init(maxDevices: Int32, filters: [DeviceFilter]) {
            self.maxDevices = maxDevices
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxDevices = "maxDevices"
            case filters = "filters"
        }
    }

    public struct DeleteRemoteAccessSessionResult: AWSShape {

    }

    public struct GetDeviceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The device type's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetDevicePoolResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "devicePool", required: false, type: .structure)
        ]
        /// An object containing information about the requested device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool = "devicePool"
        }
    }

    public struct GetDeviceInstanceResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "deviceInstance", required: false, type: .structure)
        ]
        /// An object containing information about your device instance.
        public let deviceInstance: DeviceInstance?

        public init(deviceInstance: DeviceInstance? = nil) {
            self.deviceInstance = deviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case deviceInstance = "deviceInstance"
        }
    }

    public struct GetInstanceProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of your instance profile.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetTestRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The test's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListUploadsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploads", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the uploads.
        public let uploads: [Upload]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(uploads: [Upload]? = nil, nextToken: String? = nil) {
            self.uploads = uploads
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case uploads = "uploads"
            case nextToken = "nextToken"
        }
    }

    public struct GetJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The job's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetDeviceInstanceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the instance you're requesting information about.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListVPCEConfigurationsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "vpceConfigurations", required: false, type: .list)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// An array of VPCEConfiguration objects containing information about your VPC endpoint configuration.
        public let vpceConfigurations: [VPCEConfiguration]?

        public init(nextToken: String? = nil, vpceConfigurations: [VPCEConfiguration]? = nil) {
            self.nextToken = nextToken
            self.vpceConfigurations = vpceConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vpceConfigurations = "vpceConfigurations"
        }
    }

    public struct Counters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "stopped", required: false, type: .integer), 
            AWSShapeMember(label: "passed", required: false, type: .integer), 
            AWSShapeMember(label: "total", required: false, type: .integer), 
            AWSShapeMember(label: "errored", required: false, type: .integer), 
            AWSShapeMember(label: "skipped", required: false, type: .integer), 
            AWSShapeMember(label: "warned", required: false, type: .integer), 
            AWSShapeMember(label: "failed", required: false, type: .integer)
        ]
        /// The number of stopped entities.
        public let stopped: Int32?
        /// The number of passed entities.
        public let passed: Int32?
        /// The total number of entities.
        public let total: Int32?
        /// The number of errored entities.
        public let errored: Int32?
        /// The number of skipped entities.
        public let skipped: Int32?
        /// The number of warned entities.
        public let warned: Int32?
        /// The number of failed entities.
        public let failed: Int32?

        public init(stopped: Int32? = nil, passed: Int32? = nil, total: Int32? = nil, errored: Int32? = nil, skipped: Int32? = nil, warned: Int32? = nil, failed: Int32? = nil) {
            self.stopped = stopped
            self.passed = passed
            self.total = total
            self.errored = errored
            self.skipped = skipped
            self.warned = warned
            self.failed = failed
        }

        private enum CodingKeys: String, CodingKey {
            case stopped = "stopped"
            case passed = "passed"
            case total = "total"
            case errored = "errored"
            case skipped = "skipped"
            case warned = "warned"
            case failed = "failed"
        }
    }

    public struct Offering: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "id", required: false, type: .string), 
            AWSShapeMember(label: "platform", required: false, type: .enum), 
            AWSShapeMember(label: "recurringCharges", required: false, type: .list), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// The ID that corresponds to a device offering.
        public let id: String?
        /// The platform of the device (e.g., ANDROID or IOS).
        public let platform: DevicePlatform?
        /// Specifies whether there are recurring charges for the offering.
        public let recurringCharges: [RecurringCharge]?
        /// A string describing the offering.
        public let description: String?
        /// The type of offering (e.g., "RECURRING") for a device.
        public let `type`: OfferingType?

        public init(id: String? = nil, platform: DevicePlatform? = nil, recurringCharges: [RecurringCharge]? = nil, description: String? = nil, type: OfferingType? = nil) {
            self.id = id
            self.platform = platform
            self.recurringCharges = recurringCharges
            self.description = description
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case platform = "platform"
            case recurringCharges = "recurringCharges"
            case description = "description"
            case `type` = "type"
        }
    }

    public struct ListRunsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "runs", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the runs.
        public let runs: [Run]?

        public init(nextToken: String? = nil, runs: [Run]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case runs = "runs"
        }
    }

    public struct ListDeviceInstancesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "deviceInstances", required: false, type: .list)
        ]
        /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// An object containing information about your device instances.
        public let deviceInstances: [DeviceInstance]?

        public init(nextToken: String? = nil, deviceInstances: [DeviceInstance]? = nil) {
            self.nextToken = nextToken
            self.deviceInstances = deviceInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case deviceInstances = "deviceInstances"
        }
    }

    public struct CreateInstanceProfileResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceProfile", required: false, type: .structure)
        ]
        /// An object containing information about your instance profile.
        public let instanceProfile: InstanceProfile?

        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile = "instanceProfile"
        }
    }

    public struct CreateNetworkProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uplinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "downlinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "uplinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "downlinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "downlinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "uplinkDelayMs", required: false, type: .long)
        ]
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// The name you wish to specify for the new network profile.
        public let name: String
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// The type of network profile you wish to create. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// The description of the network profile.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
        public let projectArn: String
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?

        public init(uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, name: String, uplinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, downlinkDelayMs: Int64? = nil, uplinkJitterMs: Int64? = nil, downlinkJitterMs: Int64? = nil, description: String? = nil, projectArn: String, downlinkBandwidthBits: Int64? = nil, uplinkDelayMs: Int64? = nil) {
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.`type` = `type`
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.downlinkJitterMs = downlinkJitterMs
            self.description = description
            self.projectArn = projectArn
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
        }

        private enum CodingKeys: String, CodingKey {
            case uplinkLossPercent = "uplinkLossPercent"
            case downlinkLossPercent = "downlinkLossPercent"
            case name = "name"
            case uplinkBandwidthBits = "uplinkBandwidthBits"
            case `type` = "type"
            case downlinkDelayMs = "downlinkDelayMs"
            case uplinkJitterMs = "uplinkJitterMs"
            case downlinkJitterMs = "downlinkJitterMs"
            case description = "description"
            case projectArn = "projectArn"
            case downlinkBandwidthBits = "downlinkBandwidthBits"
            case uplinkDelayMs = "uplinkDelayMs"
        }
    }

    public enum TestType: String, CustomStringConvertible, Codable {
        case builtinFuzz = "BUILTIN_FUZZ"
        case builtinExplorer = "BUILTIN_EXPLORER"
        case webPerformanceProfile = "WEB_PERFORMANCE_PROFILE"
        case appiumJavaJunit = "APPIUM_JAVA_JUNIT"
        case appiumJavaTestng = "APPIUM_JAVA_TESTNG"
        case appiumPython = "APPIUM_PYTHON"
        case appiumWebJavaJunit = "APPIUM_WEB_JAVA_JUNIT"
        case appiumWebJavaTestng = "APPIUM_WEB_JAVA_TESTNG"
        case appiumWebPython = "APPIUM_WEB_PYTHON"
        case calabash = "CALABASH"
        case instrumentation = "INSTRUMENTATION"
        case uiautomation = "UIAUTOMATION"
        case uiautomator = "UIAUTOMATOR"
        case xctest = "XCTEST"
        case xctestUi = "XCTEST_UI"
        case remoteAccessRecord = "REMOTE_ACCESS_RECORD"
        case remoteAccessReplay = "REMOTE_ACCESS_REPLAY"
        public var description: String { return self.rawValue }
    }

    public struct GetUploadRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The upload's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct UpdateInstanceProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "rebootAfterUse", required: false, type: .boolean), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "packageCleanup", required: false, type: .boolean), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "excludeAppPackagesFromCleanup", required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String
        /// The updated choice for whether you want to reboot the device after use. The default value is true.
        public let rebootAfterUse: Bool?
        /// The updated name for your instance profile.
        public let name: String?
        /// The updated choice for whether you want to specify package cleanup. The default value is false for private devices.
        public let packageCleanup: Bool?
        /// The updated description for your instance profile.
        public let description: String?
        /// An array of strings specifying the list of app packages that should not be cleaned up from the device after a test run is over. The list of packages is only considered if you set packageCleanup to true.
        public let excludeAppPackagesFromCleanup: [String]?

        public init(arn: String, rebootAfterUse: Bool? = nil, name: String? = nil, packageCleanup: Bool? = nil, description: String? = nil, excludeAppPackagesFromCleanup: [String]? = nil) {
            self.arn = arn
            self.rebootAfterUse = rebootAfterUse
            self.name = name
            self.packageCleanup = packageCleanup
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case rebootAfterUse = "rebootAfterUse"
            case name = "name"
            case packageCleanup = "packageCleanup"
            case description = "description"
            case excludeAppPackagesFromCleanup = "excludeAppPackagesFromCleanup"
        }
    }

    public struct GetSuiteResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "suite", required: false, type: .structure)
        ]
        /// A collection of one or more tests.
        public let suite: Suite?

        public init(suite: Suite? = nil) {
            self.suite = suite
        }

        private enum CodingKeys: String, CodingKey {
            case suite = "suite"
        }
    }

    public struct DeleteNetworkProfileResult: AWSShape {

    }

    public struct MonetaryAmount: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "amount", required: false, type: .double), 
            AWSShapeMember(label: "currencyCode", required: false, type: .enum)
        ]
        /// The numerical amount of an offering or transaction.
        public let amount: Double?
        /// The currency code of a monetary amount. For example, USD means "U.S. dollars."
        public let currencyCode: CurrencyCode?

        public init(amount: Double? = nil, currencyCode: CurrencyCode? = nil) {
            self.amount = amount
            self.currencyCode = currencyCode
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case currencyCode = "currencyCode"
        }
    }

    public struct UpdateInstanceProfileResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceProfile", required: false, type: .structure)
        ]
        /// An object containing information about your instance profile.
        public let instanceProfile: InstanceProfile?

        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile = "instanceProfile"
        }
    }

    public struct UpdateVPCEConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vpceConfigurationDescription", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "vpceServiceName", required: false, type: .string), 
            AWSShapeMember(label: "vpceConfigurationName", required: false, type: .string), 
            AWSShapeMember(label: "serviceDnsName", required: false, type: .string)
        ]
        /// An optional description, providing more details about your VPC endpoint configuration.
        public let vpceConfigurationDescription: String?
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to update.
        public let arn: String
        /// The name of the VPC endpoint service running inside your AWS account that you want Device Farm to test.
        public let vpceServiceName: String?
        /// The friendly name you give to your VPC endpoint configuration, to manage your configurations more easily.
        public let vpceConfigurationName: String?
        /// The DNS (domain) name used to connect to your private service in your Amazon VPC. The DNS name must not already be in use on the Internet.
        public let serviceDnsName: String?

        public init(vpceConfigurationDescription: String? = nil, arn: String, vpceServiceName: String? = nil, vpceConfigurationName: String? = nil, serviceDnsName: String? = nil) {
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.arn = arn
            self.vpceServiceName = vpceServiceName
            self.vpceConfigurationName = vpceConfigurationName
            self.serviceDnsName = serviceDnsName
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfigurationDescription = "vpceConfigurationDescription"
            case arn = "arn"
            case vpceServiceName = "vpceServiceName"
            case vpceConfigurationName = "vpceConfigurationName"
            case serviceDnsName = "serviceDnsName"
        }
    }

    public struct ListUniqueProblemsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uniqueProblems", required: false, type: .map), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the unique problems. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let uniqueProblems: [ExecutionResult: [UniqueProblem]]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(uniqueProblems: [ExecutionResult: [UniqueProblem]]? = nil, nextToken: String? = nil) {
            self.uniqueProblems = uniqueProblems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case uniqueProblems = "uniqueProblems"
            case nextToken = "nextToken"
        }
    }

    public struct GetVPCEConfigurationResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vpceConfiguration", required: false, type: .structure)
        ]
        /// An object containing information about your VPC endpoint configuration.
        public let vpceConfiguration: VPCEConfiguration?

        public init(vpceConfiguration: VPCEConfiguration? = nil) {
            self.vpceConfiguration = vpceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfiguration = "vpceConfiguration"
        }
    }

    public struct GetDevicePoolCompatibilityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appArn", required: false, type: .string), 
            AWSShapeMember(label: "testType", required: false, type: .enum), 
            AWSShapeMember(label: "test", required: false, type: .structure), 
            AWSShapeMember(label: "devicePoolArn", required: true, type: .string), 
            AWSShapeMember(label: "configuration", required: false, type: .structure)
        ]
        /// The ARN of the app that is associated with the specified device pool.
        public let appArn: String?
        /// The test type for the specified device pool. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let testType: TestType?
        /// Information about the uploaded test to be run against the device pool.
        public let test: ScheduleRunTest?
        /// The device pool's ARN.
        public let devicePoolArn: String
        /// An object containing information about the settings for a run.
        public let configuration: ScheduleRunConfiguration?

        public init(appArn: String? = nil, testType: TestType? = nil, test: ScheduleRunTest? = nil, devicePoolArn: String, configuration: ScheduleRunConfiguration? = nil) {
            self.appArn = appArn
            self.testType = testType
            self.test = test
            self.devicePoolArn = devicePoolArn
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case testType = "testType"
            case test = "test"
            case devicePoolArn = "devicePoolArn"
            case configuration = "configuration"
        }
    }

    public struct GetRemoteAccessSessionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListDevicesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "devices", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the devices.
        public let devices: [Device]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "devices"
            case nextToken = "nextToken"
        }
    }

    public struct UpdateDevicePoolRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "rules", required: false, type: .list), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// Represents the rules you wish to modify for the device pool. Updating rules is optional; however, if you choose to update rules for your request, the update will replace the existing rules.
        public let rules: [Rule]?
        /// A description of the device pool you wish to update.
        public let description: String?
        /// A string representing the name of the device pool you wish to update.
        public let name: String?
        /// The Amazon Resourc Name (ARN) of the Device Farm device pool you wish to update.
        public let arn: String

        public init(rules: [Rule]? = nil, description: String? = nil, name: String? = nil, arn: String) {
            self.rules = rules
            self.description = description
            self.name = name
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
            case description = "description"
            case name = "name"
            case arn = "arn"
        }
    }

    public struct ListRunsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
        }
    }

    public struct NetworkProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "downlinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "downlinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "uplinkJitterMs", required: false, type: .long), 
            AWSShapeMember(label: "uplinkDelayMs", required: false, type: .long), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "downlinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "uplinkBandwidthBits", required: false, type: .long), 
            AWSShapeMember(label: "uplinkLossPercent", required: false, type: .integer), 
            AWSShapeMember(label: "downlinkDelayMs", required: false, type: .long)
        ]
        /// The Amazon Resource Name (ARN) of the network profile.
        public let arn: String?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int32?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// The description of the network profile.
        public let description: String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// The type of network profile. Valid values are listed below.
        public let `type`: NetworkProfileType?
        /// The name of the network profile.
        public let name: String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int32?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?

        public init(arn: String? = nil, downlinkJitterMs: Int64? = nil, downlinkLossPercent: Int32? = nil, uplinkJitterMs: Int64? = nil, uplinkDelayMs: Int64? = nil, description: String? = nil, downlinkBandwidthBits: Int64? = nil, type: NetworkProfileType? = nil, name: String? = nil, uplinkBandwidthBits: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkDelayMs: Int64? = nil) {
            self.arn = arn
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkDelayMs = uplinkDelayMs
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.`type` = `type`
            self.name = name
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkDelayMs = downlinkDelayMs
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case downlinkJitterMs = "downlinkJitterMs"
            case downlinkLossPercent = "downlinkLossPercent"
            case uplinkJitterMs = "uplinkJitterMs"
            case uplinkDelayMs = "uplinkDelayMs"
            case description = "description"
            case downlinkBandwidthBits = "downlinkBandwidthBits"
            case `type` = "type"
            case name = "name"
            case uplinkBandwidthBits = "uplinkBandwidthBits"
            case uplinkLossPercent = "uplinkLossPercent"
            case downlinkDelayMs = "downlinkDelayMs"
        }
    }

    public struct CreateInstanceProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "excludeAppPackagesFromCleanup", required: false, type: .list), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "rebootAfterUse", required: false, type: .boolean), 
            AWSShapeMember(label: "packageCleanup", required: false, type: .boolean)
        ]
        /// An array of strings specifying the list of app packages that should not be cleaned up from the device after a test run is over. The list of packages is only considered if you set packageCleanup to true.
        public let excludeAppPackagesFromCleanup: [String]?
        /// The name of your instance profile.
        public let name: String
        /// The description of your instance profile.
        public let description: String?
        /// When set to true, Device Farm will reboot the instance after a test run. The default value is true.
        public let rebootAfterUse: Bool?
        /// When set to true, Device Farm will remove app packages after a test run. The default value is false for private devices.
        public let packageCleanup: Bool?

        public init(excludeAppPackagesFromCleanup: [String]? = nil, name: String, description: String? = nil, rebootAfterUse: Bool? = nil, packageCleanup: Bool? = nil) {
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.description = description
            self.rebootAfterUse = rebootAfterUse
            self.packageCleanup = packageCleanup
        }

        private enum CodingKeys: String, CodingKey {
            case excludeAppPackagesFromCleanup = "excludeAppPackagesFromCleanup"
            case name = "name"
            case description = "description"
            case rebootAfterUse = "rebootAfterUse"
            case packageCleanup = "packageCleanup"
        }
    }

    public struct ListSamplesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the job used to list samples.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
        }
    }

    public struct InstallToRemoteAccessSessionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appUpload", required: false, type: .structure)
        ]
        /// An app to upload or that has been uploaded.
        public let appUpload: Upload?

        public init(appUpload: Upload? = nil) {
            self.appUpload = appUpload
        }

        private enum CodingKeys: String, CodingKey {
            case appUpload = "appUpload"
        }
    }

    public struct OfferingPromotion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "id", required: false, type: .string)
        ]
        /// A string describing the offering promotion.
        public let description: String?
        /// The ID of the offering promotion.
        public let id: String?

        public init(description: String? = nil, id: String? = nil) {
            self.description = description
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
        }
    }

    public struct GetRunResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "run", required: false, type: .structure)
        ]
        /// The run you wish to get results from.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "run"
        }
    }

    public struct DeleteUploadResult: AWSShape {

    }

    public struct ListOfferingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public enum RuleOperator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case `in` = "IN"
        case notIn = "NOT_IN"
        case contains = "CONTAINS"
        public var description: String { return self.rawValue }
    }

    public struct ListTestsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "tests", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the tests.
        public let tests: [Test]?

        public init(nextToken: String? = nil, tests: [Test]? = nil) {
            self.nextToken = nextToken
            self.tests = tests
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tests = "tests"
        }
    }

    public struct CreateProjectResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "project", required: false, type: .structure)
        ]
        /// The newly created project.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct CreateUploadRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "contentType", required: false, type: .string), 
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]
        /// The upload's file name. The name should not contain the '/' character. If uploading an iOS app, the file name needs to end with the .ipa extension. If uploading an Android app, the file name needs to end with the .apk extension. For all others, the file name must end with the .zip file extension.
        public let name: String
        /// The ARN of the project for the upload.
        public let projectArn: String
        /// The upload's content type (for example, "application/octet-stream").
        public let contentType: String?
        /// The upload's upload type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web application upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.   APPIUM_JAVA_JUNIT_TEST_SPEC: An Appium Java JUnit test spec upload.   APPIUM_JAVA_TESTNG_TEST_SPEC: An Appium Java TestNG test spec upload.   APPIUM_PYTHON_TEST_SPEC: An Appium Python test spec upload.   APPIUM_WEB_JAVA_JUNIT_TEST_SPEC: An Appium Java JUnit test spec upload.   APPIUM_WEB_JAVA_TESTNG_TEST_SPEC: An Appium Java TestNG test spec upload.   APPIUM_WEB_PYTHON_TEST_SPEC: An Appium Python test spec upload.   INSTRUMENTATION_TEST_SPEC: An instrumentation test spec upload.   XCTEST_UI_TEST_SPEC: An XCode UI test spec upload.    Note If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
        public let `type`: UploadType

        public init(name: String, projectArn: String, contentType: String? = nil, type: UploadType) {
            self.name = name
            self.projectArn = projectArn
            self.contentType = contentType
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case projectArn = "projectArn"
            case contentType = "contentType"
            case `type` = "type"
        }
    }

    public enum UploadType: String, CustomStringConvertible, Codable {
        case androidApp = "ANDROID_APP"
        case iosApp = "IOS_APP"
        case webApp = "WEB_APP"
        case externalData = "EXTERNAL_DATA"
        case appiumJavaJunitTestPackage = "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
        case appiumJavaTestngTestPackage = "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
        case appiumPythonTestPackage = "APPIUM_PYTHON_TEST_PACKAGE"
        case appiumWebJavaJunitTestPackage = "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
        case appiumWebJavaTestngTestPackage = "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
        case appiumWebPythonTestPackage = "APPIUM_WEB_PYTHON_TEST_PACKAGE"
        case calabashTestPackage = "CALABASH_TEST_PACKAGE"
        case instrumentationTestPackage = "INSTRUMENTATION_TEST_PACKAGE"
        case uiautomationTestPackage = "UIAUTOMATION_TEST_PACKAGE"
        case uiautomatorTestPackage = "UIAUTOMATOR_TEST_PACKAGE"
        case xctestTestPackage = "XCTEST_TEST_PACKAGE"
        case xctestUiTestPackage = "XCTEST_UI_TEST_PACKAGE"
        case appiumJavaJunitTestSpec = "APPIUM_JAVA_JUNIT_TEST_SPEC"
        case appiumJavaTestngTestSpec = "APPIUM_JAVA_TESTNG_TEST_SPEC"
        case appiumPythonTestSpec = "APPIUM_PYTHON_TEST_SPEC"
        case appiumWebJavaJunitTestSpec = "APPIUM_WEB_JAVA_JUNIT_TEST_SPEC"
        case appiumWebJavaTestngTestSpec = "APPIUM_WEB_JAVA_TESTNG_TEST_SPEC"
        case appiumWebPythonTestSpec = "APPIUM_WEB_PYTHON_TEST_SPEC"
        case instrumentationTestSpec = "INSTRUMENTATION_TEST_SPEC"
        case xctestUiTestSpec = "XCTEST_UI_TEST_SPEC"
        public var description: String { return self.rawValue }
    }

    public struct ListDeviceInstancesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// An integer specifying the maximum number of items you want to return in the API response.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public enum NetworkProfileType: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListSuitesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "suites", required: false, type: .list)
        ]
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the suites.
        public let suites: [Suite]?

        public init(nextToken: String? = nil, suites: [Suite]? = nil) {
            self.nextToken = nextToken
            self.suites = suites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case suites = "suites"
        }
    }

    public struct GetDevicePoolRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The device pool's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct UniqueProblem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "problems", required: false, type: .list)
        ]
        /// A message about the unique problems' result.
        public let message: String?
        /// Information about the problems.
        public let problems: [Problem]?

        public init(message: String? = nil, problems: [Problem]? = nil) {
            self.message = message
            self.problems = problems
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case problems = "problems"
        }
    }

    public enum DeviceAvailability: String, CustomStringConvertible, Codable {
        case temporaryNotAvailable = "TEMPORARY_NOT_AVAILABLE"
        case busy = "BUSY"
        case available = "AVAILABLE"
        case highlyAvailable = "HIGHLY_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum UploadCategory: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListArtifactsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "artifacts", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the artifacts.
        public let artifacts: [Artifact]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(artifacts: [Artifact]? = nil, nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "artifacts"
            case nextToken = "nextToken"
        }
    }

    public struct UpdateVPCEConfigurationResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vpceConfiguration", required: false, type: .structure)
        ]
        /// An object containing information about your VPC endpoint configuration.
        public let vpceConfiguration: VPCEConfiguration?

        public init(vpceConfiguration: VPCEConfiguration? = nil) {
            self.vpceConfiguration = vpceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfiguration = "vpceConfiguration"
        }
    }

    public struct ListNetworkProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public let `type`: NetworkProfileType?

        public init(arn: String, nextToken: String? = nil, type: NetworkProfileType? = nil) {
            self.arn = arn
            self.nextToken = nextToken
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
            case `type` = "type"
        }
    }

    public struct CreateVPCEConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vpceServiceName", required: true, type: .string), 
            AWSShapeMember(label: "serviceDnsName", required: true, type: .string), 
            AWSShapeMember(label: "vpceConfigurationName", required: true, type: .string), 
            AWSShapeMember(label: "vpceConfigurationDescription", required: false, type: .string)
        ]
        /// The name of the VPC endpoint service running inside your AWS account that you want Device Farm to test.
        public let vpceServiceName: String
        /// The DNS name of the service running in your VPC that you want Device Farm to test.
        public let serviceDnsName: String
        /// The friendly name you give to your VPC endpoint configuration, to manage your configurations more easily.
        public let vpceConfigurationName: String
        /// An optional description, providing more details about your VPC endpoint configuration.
        public let vpceConfigurationDescription: String?

        public init(vpceServiceName: String, serviceDnsName: String, vpceConfigurationName: String, vpceConfigurationDescription: String? = nil) {
            self.vpceServiceName = vpceServiceName
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceConfigurationDescription = vpceConfigurationDescription
        }

        private enum CodingKeys: String, CodingKey {
            case vpceServiceName = "vpceServiceName"
            case serviceDnsName = "serviceDnsName"
            case vpceConfigurationName = "vpceConfigurationName"
            case vpceConfigurationDescription = "vpceConfigurationDescription"
        }
    }

    public enum DeviceFormFactor: String, CustomStringConvertible, Codable {
        case phone = "PHONE"
        case tablet = "TABLET"
        public var description: String { return self.rawValue }
    }

    public struct ListUniqueProblemsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The unique problems' ARNs.
        public let arn: String

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case arn = "arn"
        }
    }

    public struct TrialMinutes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "total", required: false, type: .double), 
            AWSShapeMember(label: "remaining", required: false, type: .double)
        ]
        /// The total number of free trial minutes that the account started with.
        public let total: Double?
        /// The number of free trial minutes remaining in the account.
        public let remaining: Double?

        public init(total: Double? = nil, remaining: Double? = nil) {
            self.total = total
            self.remaining = remaining
        }

        private enum CodingKeys: String, CodingKey {
            case total = "total"
            case remaining = "remaining"
        }
    }

    public struct GetProjectResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "project", required: false, type: .structure)
        ]
        /// The project you wish to get information about.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct GetJobResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "job", required: false, type: .structure)
        ]
        /// An object containing information about the requested job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct UpdateUploadRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "contentType", required: false, type: .string), 
            AWSShapeMember(label: "editContent", required: false, type: .boolean), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the uploaded test spec.
        public let arn: String
        /// The upload's content type (for example, "application/x-yaml").
        public let contentType: String?
        /// Set to true if the YAML file has changed and needs to be updated; otherwise, set to false.
        public let editContent: Bool?
        /// The upload's test spec file name. The name should not contain the '/' character. The test spec file name must end with the .yaml or .yml file extension.
        public let name: String?

        public init(arn: String, contentType: String? = nil, editContent: Bool? = nil, name: String? = nil) {
            self.arn = arn
            self.contentType = contentType
            self.editContent = editContent
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case contentType = "contentType"
            case editContent = "editContent"
            case name = "name"
        }
    }

    public enum CurrencyCode: String, CustomStringConvertible, Codable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum DeviceFilterAttribute: String, CustomStringConvertible, Codable {
        case arn = "ARN"
        case platform = "PLATFORM"
        case osVersion = "OS_VERSION"
        case model = "MODEL"
        case availability = "AVAILABILITY"
        case formFactor = "FORM_FACTOR"
        case manufacturer = "MANUFACTURER"
        case remoteAccessEnabled = "REMOTE_ACCESS_ENABLED"
        case remoteDebugEnabled = "REMOTE_DEBUG_ENABLED"
        case instanceArn = "INSTANCE_ARN"
        case instanceLabels = "INSTANCE_LABELS"
        case fleetType = "FLEET_TYPE"
        public var description: String { return self.rawValue }
    }

    public struct Radios: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gps", required: false, type: .boolean), 
            AWSShapeMember(label: "bluetooth", required: false, type: .boolean), 
            AWSShapeMember(label: "wifi", required: false, type: .boolean), 
            AWSShapeMember(label: "nfc", required: false, type: .boolean)
        ]
        /// True if GPS is enabled at the beginning of the test; otherwise, false.
        public let gps: Bool?
        /// True if Bluetooth is enabled at the beginning of the test; otherwise, false.
        public let bluetooth: Bool?
        /// True if Wi-Fi is enabled at the beginning of the test; otherwise, false.
        public let wifi: Bool?
        /// True if NFC is enabled at the beginning of the test; otherwise, false.
        public let nfc: Bool?

        public init(gps: Bool? = nil, bluetooth: Bool? = nil, wifi: Bool? = nil, nfc: Bool? = nil) {
            self.gps = gps
            self.bluetooth = bluetooth
            self.wifi = wifi
            self.nfc = nfc
        }

        private enum CodingKeys: String, CodingKey {
            case gps = "gps"
            case bluetooth = "bluetooth"
            case wifi = "wifi"
            case nfc = "nfc"
        }
    }

    public struct ListOfferingsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "offerings", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// A value representing the list offering results.
        public let offerings: [Offering]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(offerings: [Offering]? = nil, nextToken: String? = nil) {
            self.offerings = offerings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case offerings = "offerings"
            case nextToken = "nextToken"
        }
    }

    public struct StopRemoteAccessSessionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the remote access session you wish to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct UpdateNetworkProfileResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure)
        ]
        /// A list of the available network profiles.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
        }
    }

    public struct ListVPCEConfigurationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An integer specifying the maximum number of items you want to return in the API response.
        public let maxResults: Int32?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct CreateNetworkProfileResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure)
        ]
        /// The network profile that is returned by the create network profile request.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
        }
    }

    public struct CreateUploadResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "upload", required: false, type: .structure)
        ]
        /// The newly created upload.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload = "upload"
        }
    }

    public struct CustomerArtifactPaths: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "androidPaths", required: false, type: .list), 
            AWSShapeMember(label: "iosPaths", required: false, type: .list), 
            AWSShapeMember(label: "deviceHostPaths", required: false, type: .list)
        ]
        /// Comma-separated list of paths on the Android device where the artifacts generated by the customer's tests will be pulled from.
        public let androidPaths: [String]?
        /// Comma-separated list of paths on the iOS device where the artifacts generated by the customer's tests will be pulled from.
        public let iosPaths: [String]?
        /// Comma-separated list of paths in the test execution environment where the artifacts generated by the customer's tests will be pulled from.
        public let deviceHostPaths: [String]?

        public init(androidPaths: [String]? = nil, iosPaths: [String]? = nil, deviceHostPaths: [String]? = nil) {
            self.androidPaths = androidPaths
            self.iosPaths = iosPaths
            self.deviceHostPaths = deviceHostPaths
        }

        private enum CodingKeys: String, CodingKey {
            case androidPaths = "androidPaths"
            case iosPaths = "iosPaths"
            case deviceHostPaths = "deviceHostPaths"
        }
    }

    public struct ScheduleRunTest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: true, type: .enum), 
            AWSShapeMember(label: "testSpecArn", required: false, type: .string), 
            AWSShapeMember(label: "filter", required: false, type: .string), 
            AWSShapeMember(label: "testPackageArn", required: false, type: .string), 
            AWSShapeMember(label: "parameters", required: false, type: .map)
        ]
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType
        /// The ARN of the YAML-formatted test specification.
        public let testSpecArn: String?
        /// The test's filter.
        public let filter: String?
        /// The ARN of the uploaded test that will be run.
        public let testPackageArn: String?
        /// The test's parameters, such as test framework parameters and fixture settings. Parameters are represented by name-value pairs of strings. For all tests:   app_performance_monitoring: Performance monitoring is enabled by default. Set this parameter to "false" to disable it.   For Calabash tests:   profile: A cucumber profile, for example, "my_profile_name".   tags: You can limit execution to features or scenarios that have (or don't have) certain tags, for example, "@smoke" or "@smoke,~@wip".   For Appium tests (all types):   appium_version: The Appium version. Currently supported values are "1.7.2", "1.7.1", "1.6.5", "latest", and "default".   latest will run the latest Appium version supported by Device Farm (1.7.2).   For default, Device Farm will choose a compatible version of Appium for the device. The current behavior is to run 1.7.2 on Android devices and iOS 9 and earlier, 1.7.2 for iOS 10 and later.   This behavior is subject to change.     For Fuzz tests (Android only):   event_count: The number of events, between 1 and 10000, that the UI fuzz test should perform.   throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should wait between events.   seed: A seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.   For Explorer tests:   username: A username to use if the Explorer encounters a login form. If not supplied, no username will be inserted.   password: A password to use if the Explorer encounters a login form. If not supplied, no password will be inserted.   For Instrumentation:   filter: A test filter string. Examples:   Running a single test case: "com.android.abc.Test1"   Running a single test: "com.android.abc.Test1#smoke"   Running multiple tests: "com.android.abc.Test1,com.android.abc.Test2"     For XCTest and XCTestUI:   filter: A test filter string. Examples:   Running a single test class: "LoginTests"   Running a multiple test classes: "LoginTests,SmokeTests"   Running a single test: "LoginTests/testValid"   Running multiple tests: "LoginTests/testValid,LoginTests/testInvalid"     For UIAutomator:   filter: A test filter string. Examples:   Running a single test case: "com.android.abc.Test1"   Running a single test: "com.android.abc.Test1#smoke"   Running multiple tests: "com.android.abc.Test1,com.android.abc.Test2"    
        public let parameters: [String: String]?

        public init(type: TestType, testSpecArn: String? = nil, filter: String? = nil, testPackageArn: String? = nil, parameters: [String: String]? = nil) {
            self.`type` = `type`
            self.testSpecArn = testSpecArn
            self.filter = filter
            self.testPackageArn = testPackageArn
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case testSpecArn = "testSpecArn"
            case filter = "filter"
            case testPackageArn = "testPackageArn"
            case parameters = "parameters"
        }
    }

    public struct CreateVPCEConfigurationResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vpceConfiguration", required: false, type: .structure)
        ]
        /// An object containing information about your VPC endpoint configuration.
        public let vpceConfiguration: VPCEConfiguration?

        public init(vpceConfiguration: VPCEConfiguration? = nil) {
            self.vpceConfiguration = vpceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfiguration = "vpceConfiguration"
        }
    }

    public struct ListOfferingPromotionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
        }
    }

    public struct GetAccountSettingsRequest: AWSShape {

    }

    public struct DeleteRemoteAccessSessionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the sesssion for which you want to delete remote access.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DevicePoolCompatibilityResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "incompatibilityMessages", required: false, type: .list), 
            AWSShapeMember(label: "compatible", required: false, type: .boolean), 
            AWSShapeMember(label: "device", required: false, type: .structure)
        ]
        /// Information about the compatibility.
        public let incompatibilityMessages: [IncompatibilityMessage]?
        /// Whether the result was compatible with the device pool.
        public let compatible: Bool?
        /// The device (phone or tablet) that you wish to return information about.
        public let device: Device?

        public init(incompatibilityMessages: [IncompatibilityMessage]? = nil, compatible: Bool? = nil, device: Device? = nil) {
            self.incompatibilityMessages = incompatibilityMessages
            self.compatible = compatible
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case incompatibilityMessages = "incompatibilityMessages"
            case compatible = "compatible"
            case device = "device"
        }
    }

    public struct CreateProjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "defaultJobTimeoutMinutes", required: false, type: .integer)
        ]
        /// The project's name.
        public let name: String
        /// Sets the execution timeout value (in minutes) for a project. All test runs in this project will use the specified execution timeout value unless overridden when scheduling a run.
        public let defaultJobTimeoutMinutes: Int32?

        public init(name: String, defaultJobTimeoutMinutes: Int32? = nil) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case defaultJobTimeoutMinutes = "defaultJobTimeoutMinutes"
        }
    }

    public struct Run: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "networkProfile", required: false, type: .structure), 
            AWSShapeMember(label: "billingMethod", required: false, type: .enum), 
            AWSShapeMember(label: "totalJobs", required: false, type: .integer), 
            AWSShapeMember(label: "parsingResultUrl", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "testSpecArn", required: false, type: .string), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "webUrl", required: false, type: .string), 
            AWSShapeMember(label: "deviceSelectionResult", required: false, type: .structure), 
            AWSShapeMember(label: "seed", required: false, type: .integer), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "platform", required: false, type: .enum), 
            AWSShapeMember(label: "devicePoolArn", required: false, type: .string), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "eventCount", required: false, type: .integer), 
            AWSShapeMember(label: "jobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "resultCode", required: false, type: .enum), 
            AWSShapeMember(label: "skipAppResign", required: false, type: .boolean), 
            AWSShapeMember(label: "customerArtifactPaths", required: false, type: .structure), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "location", required: false, type: .structure), 
            AWSShapeMember(label: "locale", required: false, type: .string), 
            AWSShapeMember(label: "appUpload", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "completedJobs", required: false, type: .integer), 
            AWSShapeMember(label: "radios", required: false, type: .structure)
        ]
        /// The network profile being used for a test run.
        public let networkProfile: NetworkProfile?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public let billingMethod: BillingMethod?
        /// The total number of jobs for the run.
        public let totalJobs: Int32?
        /// Read-only URL for an object in S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.
        public let parsingResultUrl: String?
        /// The run's ARN.
        public let arn: String?
        /// The ARN of the YAML-formatted test specification for the run.
        public let testSpecArn: String?
        /// The run's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// The run's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The Device Farm console URL for the recording of the run.
        public let webUrl: String?
        /// The results of a device filter used to select the devices for a test run.
        public let deviceSelectionResult: DeviceSelectionResult?
        /// For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.
        public let seed: Int32?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public let deviceMinutes: DeviceMinutes?
        /// The run's name.
        public let name: String?
        /// The run's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public let platform: DevicePlatform?
        /// The ARN of the device pool for the run.
        public let devicePoolArn: String?
        /// The run's result counters.
        public let counters: Counters?
        /// For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.
        public let eventCount: Int32?
        /// The number of minutes the job will execute before it times out.
        public let jobTimeoutMinutes: Int32?
        /// A message about the run's result.
        public let message: String?
        /// Supporting field for the result field. Set only if result is SKIPPED. PARSING_FAILED if the result is skipped because of test package parsing failure.
        public let resultCode: ExecutionResultCode?
        /// When set to true, for private devices, Device Farm will not sign your app again. For public devices, Device Farm always signs your apps again and this parameter has no effect. For more information about how Device Farm re-signs your app(s), see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// Output CustomerArtifactPaths object for the test run.
        public let customerArtifactPaths: CustomerArtifactPaths?
        /// When the run was created.
        public let created: TimeStamp?
        /// Information about the location that is used for the run.
        public let location: Location?
        /// Information about the locale that is used for the run.
        public let locale: String?
        /// An app to upload or that has been uploaded.
        public let appUpload: String?
        /// The run's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The run's stop time.
        public let stopped: TimeStamp?
        /// The run's start time.
        public let started: TimeStamp?
        /// The total number of completed jobs.
        public let completedJobs: Int32?
        /// Information about the radio states for the run.
        public let radios: Radios?

        public init(networkProfile: NetworkProfile? = nil, billingMethod: BillingMethod? = nil, totalJobs: Int32? = nil, parsingResultUrl: String? = nil, arn: String? = nil, testSpecArn: String? = nil, result: ExecutionResult? = nil, type: TestType? = nil, webUrl: String? = nil, deviceSelectionResult: DeviceSelectionResult? = nil, seed: Int32? = nil, deviceMinutes: DeviceMinutes? = nil, name: String? = nil, platform: DevicePlatform? = nil, devicePoolArn: String? = nil, counters: Counters? = nil, eventCount: Int32? = nil, jobTimeoutMinutes: Int32? = nil, message: String? = nil, resultCode: ExecutionResultCode? = nil, skipAppResign: Bool? = nil, customerArtifactPaths: CustomerArtifactPaths? = nil, created: TimeStamp? = nil, location: Location? = nil, locale: String? = nil, appUpload: String? = nil, status: ExecutionStatus? = nil, stopped: TimeStamp? = nil, started: TimeStamp? = nil, completedJobs: Int32? = nil, radios: Radios? = nil) {
            self.networkProfile = networkProfile
            self.billingMethod = billingMethod
            self.totalJobs = totalJobs
            self.parsingResultUrl = parsingResultUrl
            self.arn = arn
            self.testSpecArn = testSpecArn
            self.result = result
            self.`type` = `type`
            self.webUrl = webUrl
            self.deviceSelectionResult = deviceSelectionResult
            self.seed = seed
            self.deviceMinutes = deviceMinutes
            self.name = name
            self.platform = platform
            self.devicePoolArn = devicePoolArn
            self.counters = counters
            self.eventCount = eventCount
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.message = message
            self.resultCode = resultCode
            self.skipAppResign = skipAppResign
            self.customerArtifactPaths = customerArtifactPaths
            self.created = created
            self.location = location
            self.locale = locale
            self.appUpload = appUpload
            self.status = status
            self.stopped = stopped
            self.started = started
            self.completedJobs = completedJobs
            self.radios = radios
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "networkProfile"
            case billingMethod = "billingMethod"
            case totalJobs = "totalJobs"
            case parsingResultUrl = "parsingResultUrl"
            case arn = "arn"
            case testSpecArn = "testSpecArn"
            case result = "result"
            case `type` = "type"
            case webUrl = "webUrl"
            case deviceSelectionResult = "deviceSelectionResult"
            case seed = "seed"
            case deviceMinutes = "deviceMinutes"
            case name = "name"
            case platform = "platform"
            case devicePoolArn = "devicePoolArn"
            case counters = "counters"
            case eventCount = "eventCount"
            case jobTimeoutMinutes = "jobTimeoutMinutes"
            case message = "message"
            case resultCode = "resultCode"
            case skipAppResign = "skipAppResign"
            case customerArtifactPaths = "customerArtifactPaths"
            case created = "created"
            case location = "location"
            case locale = "locale"
            case appUpload = "appUpload"
            case status = "status"
            case stopped = "stopped"
            case started = "started"
            case completedJobs = "completedJobs"
            case radios = "radios"
        }
    }

    public struct ScheduleRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "configuration", required: false, type: .structure), 
            AWSShapeMember(label: "devicePoolArn", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "projectArn", required: true, type: .string), 
            AWSShapeMember(label: "appArn", required: false, type: .string), 
            AWSShapeMember(label: "deviceSelectionConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "test", required: true, type: .structure)
        ]
        /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
        public let executionConfiguration: ExecutionConfiguration?
        /// Information about the settings for the run to be scheduled.
        public let configuration: ScheduleRunConfiguration?
        /// The ARN of the device pool for the run to be scheduled. Either  devicePoolArn  or  deviceSelectionConfiguration  are required in a request.
        public let devicePoolArn: String?
        /// The name for the run to be scheduled.
        public let name: String?
        /// The ARN of the project for the run to be scheduled.
        public let projectArn: String
        /// The ARN of the app to schedule a run.
        public let appArn: String?
        /// The filter criteria used to dynamically select a set of devices for a test run, as well as the maximum number of devices to be included in the run. Either  devicePoolArn  or  deviceSelectionConfiguration  are required in a request.
        public let deviceSelectionConfiguration: DeviceSelectionConfiguration?
        /// Information about the test for the run to be scheduled.
        public let test: ScheduleRunTest

        public init(executionConfiguration: ExecutionConfiguration? = nil, configuration: ScheduleRunConfiguration? = nil, devicePoolArn: String? = nil, name: String? = nil, projectArn: String, appArn: String? = nil, deviceSelectionConfiguration: DeviceSelectionConfiguration? = nil, test: ScheduleRunTest) {
            self.executionConfiguration = executionConfiguration
            self.configuration = configuration
            self.devicePoolArn = devicePoolArn
            self.name = name
            self.projectArn = projectArn
            self.appArn = appArn
            self.deviceSelectionConfiguration = deviceSelectionConfiguration
            self.test = test
        }

        private enum CodingKeys: String, CodingKey {
            case executionConfiguration = "executionConfiguration"
            case configuration = "configuration"
            case devicePoolArn = "devicePoolArn"
            case name = "name"
            case projectArn = "projectArn"
            case appArn = "appArn"
            case deviceSelectionConfiguration = "deviceSelectionConfiguration"
            case test = "test"
        }
    }

    public enum OfferingType: String, CustomStringConvertible, Codable {
        case recurring = "RECURRING"
        public var description: String { return self.rawValue }
    }

    public struct Suite: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "message", required: false, type: .string)
        ]
        /// The suite's result counters.
        public let counters: Counters?
        /// The suite's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public let deviceMinutes: DeviceMinutes?
        /// The suite's name.
        public let name: String?
        /// The suite's start time.
        public let started: TimeStamp?
        /// The suite's ARN.
        public let arn: String?
        /// The suite's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// When the suite was created.
        public let created: TimeStamp?
        /// The suite's stop time.
        public let stopped: TimeStamp?
        /// The suite's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// A message about the suite's result.
        public let message: String?

        public init(counters: Counters? = nil, status: ExecutionStatus? = nil, deviceMinutes: DeviceMinutes? = nil, name: String? = nil, started: TimeStamp? = nil, arn: String? = nil, type: TestType? = nil, created: TimeStamp? = nil, stopped: TimeStamp? = nil, result: ExecutionResult? = nil, message: String? = nil) {
            self.counters = counters
            self.status = status
            self.deviceMinutes = deviceMinutes
            self.name = name
            self.started = started
            self.arn = arn
            self.`type` = `type`
            self.created = created
            self.stopped = stopped
            self.result = result
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case counters = "counters"
            case status = "status"
            case deviceMinutes = "deviceMinutes"
            case name = "name"
            case started = "started"
            case arn = "arn"
            case `type` = "type"
            case created = "created"
            case stopped = "stopped"
            case result = "result"
            case message = "message"
        }
    }

    public struct UpdateDeviceInstanceResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "deviceInstance", required: false, type: .structure)
        ]
        /// An object containing information about your device instance.
        public let deviceInstance: DeviceInstance?

        public init(deviceInstance: DeviceInstance? = nil) {
            self.deviceInstance = deviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case deviceInstance = "deviceInstance"
        }
    }

    public struct DeleteProjectResult: AWSShape {

    }

    public struct StopRemoteAccessSessionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "remoteAccessSession", required: false, type: .structure)
        ]
        /// A container representing the metadata from the service about the remote access session you are stopping.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession = "remoteAccessSession"
        }
    }

    public struct StopJobResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "job", required: false, type: .structure)
        ]
        /// The job that was stopped.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct GetDevicePoolCompatibilityResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "compatibleDevices", required: false, type: .list), 
            AWSShapeMember(label: "incompatibleDevices", required: false, type: .list)
        ]
        /// Information about compatible devices.
        public let compatibleDevices: [DevicePoolCompatibilityResult]?
        /// Information about incompatible devices.
        public let incompatibleDevices: [DevicePoolCompatibilityResult]?

        public init(compatibleDevices: [DevicePoolCompatibilityResult]? = nil, incompatibleDevices: [DevicePoolCompatibilityResult]? = nil) {
            self.compatibleDevices = compatibleDevices
            self.incompatibleDevices = incompatibleDevices
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleDevices = "compatibleDevices"
            case incompatibleDevices = "incompatibleDevices"
        }
    }

    public enum DeviceAttribute: String, CustomStringConvertible, Codable {
        case arn = "ARN"
        case platform = "PLATFORM"
        case formFactor = "FORM_FACTOR"
        case manufacturer = "MANUFACTURER"
        case remoteAccessEnabled = "REMOTE_ACCESS_ENABLED"
        case remoteDebugEnabled = "REMOTE_DEBUG_ENABLED"
        case appiumVersion = "APPIUM_VERSION"
        case instanceArn = "INSTANCE_ARN"
        case instanceLabels = "INSTANCE_LABELS"
        case fleetType = "FLEET_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum OfferingTransactionType: String, CustomStringConvertible, Codable {
        case purchase = "PURCHASE"
        case renew = "RENEW"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public struct ProblemDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]
        /// The problem detail's ARN.
        public let arn: String?
        /// The problem detail's name.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct ListJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The run's Amazon Resource Name (ARN).
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case nextToken = "nextToken"
        }
    }

    public struct ListInstanceProfilesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceProfiles", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// An object containing information about your instance profiles.
        public let instanceProfiles: [InstanceProfile]?
        /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(instanceProfiles: [InstanceProfile]? = nil, nextToken: String? = nil) {
            self.instanceProfiles = instanceProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfiles = "instanceProfiles"
            case nextToken = "nextToken"
        }
    }

    public enum RecurringChargeFrequency: String, CustomStringConvertible, Codable {
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public struct RenewOfferingRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "quantity", required: false, type: .integer), 
            AWSShapeMember(label: "offeringId", required: false, type: .string)
        ]
        /// The quantity requested in an offering renewal.
        public let quantity: Int32?
        /// The ID of a request to renew an offering.
        public let offeringId: String?

        public init(quantity: Int32? = nil, offeringId: String? = nil) {
            self.quantity = quantity
            self.offeringId = offeringId
        }

        private enum CodingKeys: String, CodingKey {
            case quantity = "quantity"
            case offeringId = "offeringId"
        }
    }

    public struct Test: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum), 
            AWSShapeMember(label: "result", required: false, type: .enum), 
            AWSShapeMember(label: "deviceMinutes", required: false, type: .structure), 
            AWSShapeMember(label: "stopped", required: false, type: .timestamp), 
            AWSShapeMember(label: "started", required: false, type: .timestamp), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "counters", required: false, type: .structure), 
            AWSShapeMember(label: "created", required: false, type: .timestamp), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public let `type`: TestType?
        /// The test's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public let result: ExecutionResult?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public let deviceMinutes: DeviceMinutes?
        /// The test's stop time.
        public let stopped: TimeStamp?
        /// The test's start time.
        public let started: TimeStamp?
        /// The test's ARN.
        public let arn: String?
        /// A message about the test's result.
        public let message: String?
        /// The test's result counters.
        public let counters: Counters?
        /// When the test was created.
        public let created: TimeStamp?
        /// The test's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public let status: ExecutionStatus?
        /// The test's name.
        public let name: String?

        public init(type: TestType? = nil, result: ExecutionResult? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: TimeStamp? = nil, started: TimeStamp? = nil, arn: String? = nil, message: String? = nil, counters: Counters? = nil, created: TimeStamp? = nil, status: ExecutionStatus? = nil, name: String? = nil) {
            self.`type` = `type`
            self.result = result
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.started = started
            self.arn = arn
            self.message = message
            self.counters = counters
            self.created = created
            self.status = status
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case result = "result"
            case deviceMinutes = "deviceMinutes"
            case stopped = "stopped"
            case started = "started"
            case arn = "arn"
            case message = "message"
            case counters = "counters"
            case created = "created"
            case status = "status"
            case name = "name"
        }
    }

    public struct DeviceMinutes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "unmetered", required: false, type: .double), 
            AWSShapeMember(label: "total", required: false, type: .double), 
            AWSShapeMember(label: "metered", required: false, type: .double)
        ]
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public let unmetered: Double?
        /// When specified, represents the total minutes used by the resource to run tests.
        public let total: Double?
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public let metered: Double?

        public init(unmetered: Double? = nil, total: Double? = nil, metered: Double? = nil) {
            self.unmetered = unmetered
            self.total = total
            self.metered = metered
        }

        private enum CodingKeys: String, CodingKey {
            case unmetered = "unmetered"
            case total = "total"
            case metered = "metered"
        }
    }

    public struct ListOfferingPromotionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "offeringPromotions", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the offering promotions.
        public let offeringPromotions: [OfferingPromotion]?
        /// An identifier to be used in the next call to this operation, to return the next set of items in the list.
        public let nextToken: String?

        public init(offeringPromotions: [OfferingPromotion]? = nil, nextToken: String? = nil) {
            self.offeringPromotions = offeringPromotions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case offeringPromotions = "offeringPromotions"
            case nextToken = "nextToken"
        }
    }

    public struct DeleteVPCEConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ExecutionConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "videoCapture", required: false, type: .boolean), 
            AWSShapeMember(label: "jobTimeoutMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "accountsCleanup", required: false, type: .boolean), 
            AWSShapeMember(label: "appPackagesCleanup", required: false, type: .boolean), 
            AWSShapeMember(label: "skipAppResign", required: false, type: .boolean)
        ]
        /// Set to true to enable video capture; otherwise, set to false. The default is true.
        public let videoCapture: Bool?
        /// The number of minutes a test run will execute before it times out.
        public let jobTimeoutMinutes: Int32?
        /// True if account cleanup is enabled at the beginning of the test; otherwise, false.
        public let accountsCleanup: Bool?
        /// True if app package cleanup is enabled at the beginning of the test; otherwise, false.
        public let appPackagesCleanup: Bool?
        /// When set to true, for private devices, Device Farm will not sign your app again. For public devices, Device Farm always signs your apps again and this parameter has no effect. For more information about how Device Farm re-signs your app(s), see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?

        public init(videoCapture: Bool? = nil, jobTimeoutMinutes: Int32? = nil, accountsCleanup: Bool? = nil, appPackagesCleanup: Bool? = nil, skipAppResign: Bool? = nil) {
            self.videoCapture = videoCapture
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.accountsCleanup = accountsCleanup
            self.appPackagesCleanup = appPackagesCleanup
            self.skipAppResign = skipAppResign
        }

        private enum CodingKeys: String, CodingKey {
            case videoCapture = "videoCapture"
            case jobTimeoutMinutes = "jobTimeoutMinutes"
            case accountsCleanup = "accountsCleanup"
            case appPackagesCleanup = "appPackagesCleanup"
            case skipAppResign = "skipAppResign"
        }
    }

    public struct VPCEConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vpceConfigurationDescription", required: false, type: .string), 
            AWSShapeMember(label: "vpceServiceName", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "vpceConfigurationName", required: false, type: .string), 
            AWSShapeMember(label: "serviceDnsName", required: false, type: .string)
        ]
        /// An optional description, providing more details about your VPC endpoint configuration.
        public let vpceConfigurationDescription: String?
        /// The name of the VPC endpoint service running inside your AWS account that you want Device Farm to test.
        public let vpceServiceName: String?
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration.
        public let arn: String?
        /// The friendly name you give to your VPC endpoint configuration, to manage your configurations more easily.
        public let vpceConfigurationName: String?
        /// The DNS name that maps to the private IP address of the service you want to access.
        public let serviceDnsName: String?

        public init(vpceConfigurationDescription: String? = nil, vpceServiceName: String? = nil, arn: String? = nil, vpceConfigurationName: String? = nil, serviceDnsName: String? = nil) {
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceServiceName = vpceServiceName
            self.arn = arn
            self.vpceConfigurationName = vpceConfigurationName
            self.serviceDnsName = serviceDnsName
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfigurationDescription = "vpceConfigurationDescription"
            case vpceServiceName = "vpceServiceName"
            case arn = "arn"
            case vpceConfigurationName = "vpceConfigurationName"
            case serviceDnsName = "serviceDnsName"
        }
    }

    public struct CreateRemoteAccessSessionConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "billingMethod", required: false, type: .enum), 
            AWSShapeMember(label: "vpceConfigurationArns", required: false, type: .list)
        ]
        /// The billing method for the remote access session.
        public let billingMethod: BillingMethod?
        /// An array of Amazon Resource Names (ARNs) included in the VPC endpoint configuration.
        public let vpceConfigurationArns: [String]?

        public init(billingMethod: BillingMethod? = nil, vpceConfigurationArns: [String]? = nil) {
            self.billingMethod = billingMethod
            self.vpceConfigurationArns = vpceConfigurationArns
        }

        private enum CodingKeys: String, CodingKey {
            case billingMethod = "billingMethod"
            case vpceConfigurationArns = "vpceConfigurationArns"
        }
    }

    public struct ListInstanceProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// An integer specifying the maximum number of items you want to return in the API response.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public struct RecurringCharge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "frequency", required: false, type: .enum), 
            AWSShapeMember(label: "cost", required: false, type: .structure)
        ]
        /// The frequency in which charges will recur.
        public let frequency: RecurringChargeFrequency?
        /// The cost of the recurring charge.
        public let cost: MonetaryAmount?

        public init(frequency: RecurringChargeFrequency? = nil, cost: MonetaryAmount? = nil) {
            self.frequency = frequency
            self.cost = cost
        }

        private enum CodingKeys: String, CodingKey {
            case frequency = "frequency"
            case cost = "cost"
        }
    }

    public struct ListNetworkProfilesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "networkProfiles", required: false, type: .list)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A list of the available network profiles.
        public let networkProfiles: [NetworkProfile]?

        public init(nextToken: String? = nil, networkProfiles: [NetworkProfile]? = nil) {
            self.nextToken = nextToken
            self.networkProfiles = networkProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case networkProfiles = "networkProfiles"
        }
    }

    public struct ListArtifactsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: true, type: .enum), 
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The artifacts' type. Allowed values include:   FILE: The artifacts are files.   LOG: The artifacts are logs.   SCREENSHOT: The artifacts are screenshots.  
        public let `type`: ArtifactCategory
        /// The Run, Job, Suite, or Test ARN.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(type: ArtifactCategory, arn: String, nextToken: String? = nil) {
            self.`type` = `type`
            self.arn = arn
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
            case arn = "arn"
            case nextToken = "nextToken"
        }
    }

}