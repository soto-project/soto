// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension SageMaker {

    public struct DescribeWorkteamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamName", required: true, type: .string)
        ]
        /// The name of the work team to return a description of.
        public let workteamName: String

        public init(workteamName: String) {
            self.workteamName = workteamName
        }

        private enum CodingKeys: String, CodingKey {
            case workteamName = "WorkteamName"
        }
    }

    public enum DetailedModelPackageStatus: String, CustomStringConvertible, Codable {
        case notstarted = "NotStarted"
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct StoppingCondition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRuntimeInSeconds", required: false, type: .integer)
        ]
        /// The maximum length of time, in seconds, that the training or compilation job can run. If the job does not complete during this time, Amazon SageMaker ends the job. If value is not specified, default value is 1 day. Maximum value is 5 days.
        public let maxRuntimeInSeconds: Int32?

        public init(maxRuntimeInSeconds: Int32? = nil) {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case maxRuntimeInSeconds = "MaxRuntimeInSeconds"
        }
    }

    public struct UpdateCodeRepositoryInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodeRepositoryName", required: true, type: .string), 
            AWSShapeMember(label: "GitConfig", required: false, type: .structure)
        ]
        /// The name of the git repository to update.
        public let codeRepositoryName: String
        /// The configuration of the git repository, including the URL and the Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the repository. The secret must have a staging label of AWSCURRENT and must be in the following format:  {"username": UserName, "password": Password} 
        public let gitConfig: GitConfigForUpdate?

        public init(codeRepositoryName: String, gitConfig: GitConfigForUpdate? = nil) {
            self.codeRepositoryName = codeRepositoryName
            self.gitConfig = gitConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
            case gitConfig = "GitConfig"
        }
    }

    public struct ListCompilationJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompilationJobSummaries", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of CompilationJobSummary objects, each describing a model compilation job. 
        public let compilationJobSummaries: [CompilationJobSummary]
        /// If the response is truncated, Amazon SageMaker returns this NextToken. To retrieve the next set of model compilation jobs, use this token in the next request.
        public let nextToken: String?

        public init(compilationJobSummaries: [CompilationJobSummary], nextToken: String? = nil) {
            self.compilationJobSummaries = compilationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobSummaries = "CompilationJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public enum CodeRepositorySortBy: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        case lastmodifiedtime = "LastModifiedTime"
        public var description: String { return self.rawValue }
    }

    public struct ListLabelingJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "LabelingJobSummaryList", required: false, type: .list)
        ]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of labeling jobs, use it in the subsequent request.
        public let nextToken: String?
        /// An array of LabelingJobSummary objects, each describing a labeling job.
        public let labelingJobSummaryList: [LabelingJobSummary]?

        public init(labelingJobSummaryList: [LabelingJobSummary]? = nil, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.labelingJobSummaryList = labelingJobSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case labelingJobSummaryList = "LabelingJobSummaryList"
        }
    }

    public struct ListTrainingJobsForHyperParameterTuningJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingJobSummaries", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of TrainingJobSummary objects that describe the training jobs that the ListTrainingJobsForHyperParameterTuningJob request returned.
        public let trainingJobSummaries: [HyperParameterTrainingJobSummary]
        /// If the result of this ListTrainingJobsForHyperParameterTuningJob request was truncated, the response includes a NextToken. To retrieve the next set of training jobs, use the token in the next request.
        public let nextToken: String?

        public init(nextToken: String? = nil, trainingJobSummaries: [HyperParameterTrainingJobSummary]) {
            self.trainingJobSummaries = trainingJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobSummaries = "TrainingJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public enum SearchSortOrder: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public struct ModelPackageSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelPackageArn", required: true, type: .string), 
            AWSShapeMember(label: "ModelPackageStatus", required: true, type: .enum), 
            AWSShapeMember(label: "ModelPackageDescription", required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "ModelPackageName", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String
        /// The overall status of the model package.
        public let modelPackageStatus: ModelPackageStatus
        /// A brief statement describing the model package.
        public let modelPackageDescription: String?
        /// A timestamp that shows when the model package was created.
        public let creationTime: TimeStamp
        /// The name of the model package.
        public let modelPackageName: String

        public init(creationTime: TimeStamp, modelPackageArn: String, modelPackageDescription: String? = nil, modelPackageName: String, modelPackageStatus: ModelPackageStatus) {
            self.modelPackageArn = modelPackageArn
            self.modelPackageStatus = modelPackageStatus
            self.modelPackageDescription = modelPackageDescription
            self.creationTime = creationTime
            self.modelPackageName = modelPackageName
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageArn = "ModelPackageArn"
            case modelPackageStatus = "ModelPackageStatus"
            case modelPackageDescription = "ModelPackageDescription"
            case creationTime = "CreationTime"
            case modelPackageName = "ModelPackageName"
        }
    }

    public struct Filter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .string), 
            AWSShapeMember(label: "Operator", required: false, type: .enum)
        ]
        /// A property name. For example, TrainingJobName. See TrainingJob properties for the list of valid property names for each supported resource.
        public let name: String
        /// A value used with Resource and Operator to determin if objects statisfy the filter's condition. For numerical properties, Value must be an integer or floating-point decimal. For timestamp properties, Value must be an ISO 8601 date-time string of the following format: YYYY-mm-dd'T'HH:MM:SS.
        public let value: String?
        /// A Boolean binary operator that is used to evaluate the filter. The operator field contains one of the following values:  Equals  The specified resource in Name equals the specified Value.  NotEquals  The specified resource in Name does not equal the specified Value.  GreaterThan  The specified resource in Name is greater than the specified Value. Not supported for text-based properties.  GreaterThanOrEqualTo  The specified resource in Name is greater than or equal to the specified Value. Not supported for text-based properties.  LessThan  The specified resource in Name is less than the specified Value. Not supported for text-based properties.  LessThanOrEqualTo  The specified resource in Name is less than or equal to the specified Value. Not supported for text-based properties.  Contains  Only supported for text-based properties. The word-list of the property contains the specified Value.  
        public let `operator`: Operator?

        public init(name: String, operator: Operator? = nil, value: String? = nil) {
            self.name = name
            self.value = value
            self.`operator` = `operator`
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
            case `operator` = "Operator"
        }
    }

    public struct CreateLabelingJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LabelingJobArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the labeling job. You use this ARN to identify the labeling job.
        public let labelingJobArn: String

        public init(labelingJobArn: String) {
            self.labelingJobArn = labelingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobArn = "LabelingJobArn"
        }
    }

    public struct ChannelSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SupportedCompressionTypes", required: false, type: .list), 
            AWSShapeMember(label: "SupportedContentTypes", required: true, type: .list), 
            AWSShapeMember(label: "IsRequired", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "SupportedInputModes", required: true, type: .list)
        ]
        /// The allowed compression types, if data compression is used.
        public let supportedCompressionTypes: [CompressionType]?
        /// The supported MIME types for the data.
        public let supportedContentTypes: [String]
        /// Indicates whether the channel is required by the algorithm.
        public let isRequired: Bool?
        /// The name of the channel./sagemaker/eia
        public let name: String
        /// A brief description of the channel.
        public let description: String?
        /// The allowed input mode, either FILE or PIPE. In FILE mode, Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used input mode. In PIPE mode, Amazon SageMaker streams input data from the source directly to your algorithm without using the EBS volume.
        public let supportedInputModes: [TrainingInputMode]

        public init(description: String? = nil, isRequired: Bool? = nil, name: String, supportedCompressionTypes: [CompressionType]? = nil, supportedContentTypes: [String], supportedInputModes: [TrainingInputMode]) {
            self.supportedCompressionTypes = supportedCompressionTypes
            self.supportedContentTypes = supportedContentTypes
            self.isRequired = isRequired
            self.name = name
            self.description = description
            self.supportedInputModes = supportedInputModes
        }

        private enum CodingKeys: String, CodingKey {
            case supportedCompressionTypes = "SupportedCompressionTypes"
            case supportedContentTypes = "SupportedContentTypes"
            case isRequired = "IsRequired"
            case name = "Name"
            case description = "Description"
            case supportedInputModes = "SupportedInputModes"
        }
    }

    public struct ListNotebookInstancesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "NotebookInstances", required: false, type: .list)
        ]
        /// If the response to the previous ListNotebookInstances request was truncated, Amazon SageMaker returns this token. To retrieve the next set of notebook instances, use the token in the next request.
        public let nextToken: String?
        /// An array of NotebookInstanceSummary objects, one for each notebook instance.
        public let notebookInstances: [NotebookInstanceSummary]?

        public init(nextToken: String? = nil, notebookInstances: [NotebookInstanceSummary]? = nil) {
            self.nextToken = nextToken
            self.notebookInstances = notebookInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case notebookInstances = "NotebookInstances"
        }
    }

    public struct DescribeWorkteamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Workteam", required: true, type: .structure)
        ]
        /// A Workteam instance that contains information about the work team. 
        public let workteam: Workteam

        public init(workteam: Workteam) {
            self.workteam = workteam
        }

        private enum CodingKeys: String, CodingKey {
            case workteam = "Workteam"
        }
    }

    public struct ListTrainingJobsForHyperParameterTuningJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "HyperParameterTuningJobName", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// The field to sort results by. The default is Name. If the value of this field is FinalObjectiveMetricValue, any training jobs that did not return an objective metric are not listed.
        public let sortBy: TrainingJobSortByOptions?
        /// A filter that returns only training jobs with the specified status.
        public let statusEquals: TrainingJobStatus?
        /// The name of the tuning job whose training jobs you want to list.
        public let hyperParameterTuningJobName: String
        /// If the result of the previous ListTrainingJobsForHyperParameterTuningJob request was truncated, the response includes a NextToken. To retrieve the next set of training jobs, use the token in the next request.
        public let nextToken: String?
        /// The maximum number of training jobs to return. The default value is 10.
        public let maxResults: Int32?

        public init(hyperParameterTuningJobName: String, maxResults: Int32? = nil, nextToken: String? = nil, sortBy: TrainingJobSortByOptions? = nil, sortOrder: SortOrder? = nil, statusEquals: TrainingJobStatus? = nil) {
            self.sortOrder = sortOrder
            self.sortBy = sortBy
            self.statusEquals = statusEquals
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case sortOrder = "SortOrder"
            case sortBy = "SortBy"
            case statusEquals = "StatusEquals"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct CreateHyperParameterTuningJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HyperParameterTuningJobArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the tuning job. Amazon SageMaker assigns an ARN to a hyperparameter tuning job when you create it.
        public let hyperParameterTuningJobArn: String

        public init(hyperParameterTuningJobArn: String) {
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
        }
    }

    public struct ModelPackageStatusItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Status", required: true, type: .enum), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string)
        ]
        /// The name of the model package for which the overall status is being repoorted.
        public let name: String
        /// The current status.
        public let status: DetailedModelPackageStatus
        /// The reason for failure, if the overall status is a failed state.
        public let failureReason: String?

        public init(failureReason: String? = nil, name: String, status: DetailedModelPackageStatus) {
            self.name = name
            self.status = status
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case status = "Status"
            case failureReason = "FailureReason"
        }
    }

    public struct SearchResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Results", required: false, type: .list)
        ]
        /// If the result of the previous Search request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// A list of SearchResult objects.
        public let results: [SearchRecord]?

        public init(nextToken: String? = nil, results: [SearchRecord]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct LabelCounters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Unlabeled", required: false, type: .integer), 
            AWSShapeMember(label: "MachineLabeled", required: false, type: .integer), 
            AWSShapeMember(label: "FailedNonRetryableError", required: false, type: .integer), 
            AWSShapeMember(label: "TotalLabeled", required: false, type: .integer), 
            AWSShapeMember(label: "HumanLabeled", required: false, type: .integer)
        ]
        /// The total number of objects not yet labeled.
        public let unlabeled: Int32?
        /// The total number of objects labeled by automated data labeling.
        public let machineLabeled: Int32?
        /// The total number of objects that could not be labeled due to an error.
        public let failedNonRetryableError: Int32?
        /// The total number of objects labeled.
        public let totalLabeled: Int32?
        /// The total number of objects labeled by a human worker.
        public let humanLabeled: Int32?

        public init(failedNonRetryableError: Int32? = nil, humanLabeled: Int32? = nil, machineLabeled: Int32? = nil, totalLabeled: Int32? = nil, unlabeled: Int32? = nil) {
            self.unlabeled = unlabeled
            self.machineLabeled = machineLabeled
            self.failedNonRetryableError = failedNonRetryableError
            self.totalLabeled = totalLabeled
            self.humanLabeled = humanLabeled
        }

        private enum CodingKeys: String, CodingKey {
            case unlabeled = "Unlabeled"
            case machineLabeled = "MachineLabeled"
            case failedNonRetryableError = "FailedNonRetryableError"
            case totalLabeled = "TotalLabeled"
            case humanLabeled = "HumanLabeled"
        }
    }

    public struct TrainingJobStatusCounters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Completed", required: false, type: .integer), 
            AWSShapeMember(label: "InProgress", required: false, type: .integer), 
            AWSShapeMember(label: "RetryableError", required: false, type: .integer), 
            AWSShapeMember(label: "Stopped", required: false, type: .integer), 
            AWSShapeMember(label: "NonRetryableError", required: false, type: .integer)
        ]
        /// The number of completed training jobs launched by the hyperparameter tuning job.
        public let completed: Int32?
        /// The number of in-progress training jobs launched by a hyperparameter tuning job.
        public let inProgress: Int32?
        /// The number of training jobs that failed, but can be retried. A failed training job can be retried only if it failed because an internal service error occurred.
        public let retryableError: Int32?
        /// The number of training jobs launched by a hyperparameter tuning job that were manually stopped.
        public let stopped: Int32?
        /// The number of training jobs that failed and can't be retried. A failed training job can't be retried if it failed because a client error occurred.
        public let nonRetryableError: Int32?

        public init(completed: Int32? = nil, inProgress: Int32? = nil, nonRetryableError: Int32? = nil, retryableError: Int32? = nil, stopped: Int32? = nil) {
            self.completed = completed
            self.inProgress = inProgress
            self.retryableError = retryableError
            self.stopped = stopped
            self.nonRetryableError = nonRetryableError
        }

        private enum CodingKeys: String, CodingKey {
            case completed = "Completed"
            case inProgress = "InProgress"
            case retryableError = "RetryableError"
            case stopped = "Stopped"
            case nonRetryableError = "NonRetryableError"
        }
    }

    public enum TrainingInputMode: String, CustomStringConvertible, Codable {
        case pipe = "Pipe"
        case file = "File"
        public var description: String { return self.rawValue }
    }

    public struct DescribeModelOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelName", required: true, type: .string), 
            AWSShapeMember(label: "Containers", required: false, type: .list), 
            AWSShapeMember(label: "ExecutionRoleArn", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "PrimaryContainer", required: false, type: .structure), 
            AWSShapeMember(label: "ModelArn", required: true, type: .string), 
            AWSShapeMember(label: "EnableNetworkIsolation", required: false, type: .boolean)
        ]
        /// Name of the Amazon SageMaker model.
        public let modelName: String
        /// The containers in the inference pipeline.
        public let containers: [ContainerDefinition]?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the model.
        public let executionRoleArn: String
        /// A timestamp that shows when the model was created.
        public let creationTime: TimeStamp
        /// A VpcConfig object that specifies the VPC that this model has access to. For more information, see Protect Endpoints by Using an Amazon Virtual Private Cloud 
        public let vpcConfig: VpcConfig?
        /// The location of the primary inference code, associated artifacts, and custom environment map that the inference code uses when it is deployed in production. 
        public let primaryContainer: ContainerDefinition?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String
        /// If True, no inbound or outbound network calls can be made to or from the model container.  The Semantic Segmentation built-in algorithm does not support network isolation. 
        public let enableNetworkIsolation: Bool?

        public init(containers: [ContainerDefinition]? = nil, creationTime: TimeStamp, enableNetworkIsolation: Bool? = nil, executionRoleArn: String, modelArn: String, modelName: String, primaryContainer: ContainerDefinition? = nil, vpcConfig: VpcConfig? = nil) {
            self.modelName = modelName
            self.containers = containers
            self.executionRoleArn = executionRoleArn
            self.creationTime = creationTime
            self.vpcConfig = vpcConfig
            self.primaryContainer = primaryContainer
            self.modelArn = modelArn
            self.enableNetworkIsolation = enableNetworkIsolation
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
            case containers = "Containers"
            case executionRoleArn = "ExecutionRoleArn"
            case creationTime = "CreationTime"
            case vpcConfig = "VpcConfig"
            case primaryContainer = "PrimaryContainer"
            case modelArn = "ModelArn"
            case enableNetworkIsolation = "EnableNetworkIsolation"
        }
    }

    public enum HyperParameterTuningJobStrategyType: String, CustomStringConvertible, Codable {
        case bayesian = "Bayesian"
        public var description: String { return self.rawValue }
    }

    public struct ListEndpointConfigsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp)
        ]
        /// The maximum number of training jobs to return in the response.
        public let maxResults: Int32?
        /// A filter that returns only endpoint configurations created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// If the result of the previous ListEndpointConfig request was truncated, the response includes a NextToken. To retrieve the next set of endpoint configurations, use the token in the next request. 
        public let nextToken: String?
        /// A string in the endpoint configuration name. This filter returns only endpoint configurations whose name contains the specified string. 
        public let nameContains: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: EndpointConfigSortKey?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: OrderKey?
        /// A filter that returns only endpoint configurations created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: EndpointConfigSortKey? = nil, sortOrder: OrderKey? = nil) {
            self.maxResults = maxResults
            self.creationTimeBefore = creationTimeBefore
            self.nextToken = nextToken
            self.nameContains = nameContains
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.creationTimeAfter = creationTimeAfter
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case creationTimeBefore = "CreationTimeBefore"
            case nextToken = "NextToken"
            case nameContains = "NameContains"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case creationTimeAfter = "CreationTimeAfter"
        }
    }

    public enum InstanceType: String, CustomStringConvertible, Codable {
        case mlT2Medium = "ml.t2.medium"
        case mlT2Large = "ml.t2.large"
        case mlT2Xlarge = "ml.t2.xlarge"
        case mlT22Xlarge = "ml.t2.2xlarge"
        case mlT3Medium = "ml.t3.medium"
        case mlT3Large = "ml.t3.large"
        case mlT3Xlarge = "ml.t3.xlarge"
        case mlT32Xlarge = "ml.t3.2xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC5DXlarge = "ml.c5d.xlarge"
        case mlC5D2Xlarge = "ml.c5d.2xlarge"
        case mlC5D4Xlarge = "ml.c5d.4xlarge"
        case mlC5D9Xlarge = "ml.c5d.9xlarge"
        case mlC5D18Xlarge = "ml.c5d.18xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        public var description: String { return self.rawValue }
    }

    public struct ListHyperParameterTuningJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum)
        ]
        /// The field to sort results by. The default is Name.
        public let sortBy: HyperParameterTuningJobSortByOptions?
        /// A filter that returns only tuning jobs that were created after the specified time.
        public let creationTimeAfter: TimeStamp?
        /// A filter that returns only tuning jobs that were modified before the specified time.
        public let lastModifiedTimeBefore: TimeStamp?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that returns only tuning jobs that were modified after the specified time.
        public let lastModifiedTimeAfter: TimeStamp?
        /// A filter that returns only tuning jobs that were created before the specified time.
        public let creationTimeBefore: TimeStamp?
        /// A string in the tuning job name. This filter returns only tuning jobs whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListHyperParameterTuningJobs request was truncated, the response includes a NextToken. To retrieve the next set of tuning jobs, use the token in the next request.
        public let nextToken: String?
        /// The maximum number of tuning jobs to return. The default value is 10.
        public let maxResults: Int32?
        /// A filter that returns only tuning jobs with the specified status.
        public let statusEquals: HyperParameterTuningJobStatus?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: HyperParameterTuningJobSortByOptions? = nil, sortOrder: SortOrder? = nil, statusEquals: HyperParameterTuningJobStatus? = nil) {
            self.sortBy = sortBy
            self.creationTimeAfter = creationTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.sortOrder = sortOrder
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.statusEquals = statusEquals
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "SortBy"
            case creationTimeAfter = "CreationTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case sortOrder = "SortOrder"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case creationTimeBefore = "CreationTimeBefore"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
            case statusEquals = "StatusEquals"
        }
    }

    public struct HyperParameterTrainingJobDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputDataConfig", required: false, type: .list), 
            AWSShapeMember(label: "ResourceConfig", required: true, type: .structure), 
            AWSShapeMember(label: "EnableNetworkIsolation", required: false, type: .boolean), 
            AWSShapeMember(label: "AlgorithmSpecification", required: true, type: .structure), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "StoppingCondition", required: true, type: .structure), 
            AWSShapeMember(label: "StaticHyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "OutputDataConfig", required: true, type: .structure), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string)
        ]
        /// An array of Channel objects that specify the input for the training jobs that the tuning job launches.
        public let inputDataConfig: [Channel]?
        /// The resources, including the compute instances and storage volumes, to use for the training jobs that the tuning job launches. Storage volumes store model artifacts and incremental states. Training algorithms might also use storage volumes for scratch space. If you want Amazon SageMaker to use the storage volume to store the training data, choose File as the TrainingInputMode in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.
        public let resourceConfig: ResourceConfig
        /// Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, Amazon SageMaker downloads and uploads customer data and model artifacts through the specifed VPC, but the training container does not have network access.  The Semantic Segmentation built-in algorithm does not support network isolation. 
        public let enableNetworkIsolation: Bool?
        /// The HyperParameterAlgorithmSpecification object that specifies the algorithm to use for the training jobs that the tuning job launches.
        public let algorithmSpecification: HyperParameterAlgorithmSpecification
        /// The VpcConfig object that specifies the VPC that you want the training jobs that this hyperparameter tuning job launches to connect to. Control access to and from your training container by configuring the VPC. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?
        /// Sets a maximum duration for the training jobs that the tuning job launches. Use this parameter to limit model training costs.  To stop a job, Amazon SageMaker sends the algorithm the SIGTERM signal. This delays job termination for 120 seconds. Algorithms might use this 120-second window to save the model artifacts. When Amazon SageMaker terminates a job because the stopping condition has been met, training algorithms provided by Amazon SageMaker save the intermediate results of the job.
        public let stoppingCondition: StoppingCondition
        /// Specifies the values of hyperparameters that do not change for the tuning job.
        public let staticHyperParameters: [String: String]?
        /// Specifies the path to the Amazon S3 bucket where you store model artifacts from the training jobs that the tuning job launches.
        public let outputDataConfig: OutputDataConfig
        /// The Amazon Resource Name (ARN) of the IAM role associated with the training jobs that the tuning job launches.
        public let roleArn: String

        public init(algorithmSpecification: HyperParameterAlgorithmSpecification, enableNetworkIsolation: Bool? = nil, inputDataConfig: [Channel]? = nil, outputDataConfig: OutputDataConfig, resourceConfig: ResourceConfig, roleArn: String, staticHyperParameters: [String: String]? = nil, stoppingCondition: StoppingCondition, vpcConfig: VpcConfig? = nil) {
            self.inputDataConfig = inputDataConfig
            self.resourceConfig = resourceConfig
            self.enableNetworkIsolation = enableNetworkIsolation
            self.algorithmSpecification = algorithmSpecification
            self.vpcConfig = vpcConfig
            self.stoppingCondition = stoppingCondition
            self.staticHyperParameters = staticHyperParameters
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case inputDataConfig = "InputDataConfig"
            case resourceConfig = "ResourceConfig"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case algorithmSpecification = "AlgorithmSpecification"
            case vpcConfig = "VpcConfig"
            case stoppingCondition = "StoppingCondition"
            case staticHyperParameters = "StaticHyperParameters"
            case outputDataConfig = "OutputDataConfig"
            case roleArn = "RoleArn"
        }
    }

    public struct SourceAlgorithmSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceAlgorithms", required: true, type: .list)
        ]
        /// A list of the algorithms that were used to create a model package.
        public let sourceAlgorithms: [SourceAlgorithm]

        public init(sourceAlgorithms: [SourceAlgorithm]) {
            self.sourceAlgorithms = sourceAlgorithms
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAlgorithms = "SourceAlgorithms"
        }
    }

    public struct ListCodeRepositoriesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CodeRepositorySummaryList", required: true, type: .list)
        ]
        /// If the result of a ListCodeRepositoriesOutput request was truncated, the response includes a NextToken. To get the next set of git repositories, use the token in the next request.
        public let nextToken: String?
        /// Gets a list of summaries of the git repositories. Each summary specifies the following values for the repository:    Name   Amazon Resource Name (ARN)   Creation time   Last modified time   Configuration information, including the URL location of the repository and the ARN of the AWS Secrets Manager secret that contains the credentials used to access the repository.     
        public let codeRepositorySummaryList: [CodeRepositorySummary]

        public init(codeRepositorySummaryList: [CodeRepositorySummary], nextToken: String? = nil) {
            self.nextToken = nextToken
            self.codeRepositorySummaryList = codeRepositorySummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case codeRepositorySummaryList = "CodeRepositorySummaryList"
        }
    }

    public enum NotebookInstanceAcceleratorType: String, CustomStringConvertible, Codable {
        case mlEia1Medium = "ml.eia1.medium"
        case mlEia1Large = "ml.eia1.large"
        case mlEia1Xlarge = "ml.eia1.xlarge"
        public var description: String { return self.rawValue }
    }

    public struct ProductionVariantSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VariantName", required: true, type: .string), 
            AWSShapeMember(label: "DesiredWeight", required: false, type: .float), 
            AWSShapeMember(label: "CurrentInstanceCount", required: false, type: .integer), 
            AWSShapeMember(label: "CurrentWeight", required: false, type: .float), 
            AWSShapeMember(label: "DesiredInstanceCount", required: false, type: .integer), 
            AWSShapeMember(label: "DeployedImages", required: false, type: .list)
        ]
        /// The name of the variant.
        public let variantName: String
        /// The requested weight, as specified in the UpdateEndpointWeightsAndCapacities request. 
        public let desiredWeight: Float?
        /// The number of instances associated with the variant.
        public let currentInstanceCount: Int32?
        /// The weight associated with the variant.
        public let currentWeight: Float?
        /// The number of instances requested in the UpdateEndpointWeightsAndCapacities request. 
        public let desiredInstanceCount: Int32?
        /// An array of DeployedImage objects that specify the Amazon EC2 Container Registry paths of the inference images deployed on instances of this ProductionVariant.
        public let deployedImages: [DeployedImage]?

        public init(currentInstanceCount: Int32? = nil, currentWeight: Float? = nil, deployedImages: [DeployedImage]? = nil, desiredInstanceCount: Int32? = nil, desiredWeight: Float? = nil, variantName: String) {
            self.variantName = variantName
            self.desiredWeight = desiredWeight
            self.currentInstanceCount = currentInstanceCount
            self.currentWeight = currentWeight
            self.desiredInstanceCount = desiredInstanceCount
            self.deployedImages = deployedImages
        }

        private enum CodingKeys: String, CodingKey {
            case variantName = "VariantName"
            case desiredWeight = "DesiredWeight"
            case currentInstanceCount = "CurrentInstanceCount"
            case currentWeight = "CurrentWeight"
            case desiredInstanceCount = "DesiredInstanceCount"
            case deployedImages = "DeployedImages"
        }
    }

    public enum SortBy: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public struct CreateCompilationJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompilationJobArn", required: true, type: .string)
        ]
        /// If the action is successful, the service sends back an HTTP 200 response. Amazon SageMaker returns the following data in JSON format:    CompilationJobArn: The Amazon Resource Name (ARN) of the compiled job.  
        public let compilationJobArn: String

        public init(compilationJobArn: String) {
            self.compilationJobArn = compilationJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobArn = "CompilationJobArn"
        }
    }

    public struct DescribeEndpointOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string), 
            AWSShapeMember(label: "ProductionVariants", required: false, type: .list), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndpointStatus", required: true, type: .enum), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// Name of the endpoint.
        public let endpointName: String
        /// A timestamp that shows when the endpoint was created.
        public let creationTime: TimeStamp
        /// The name of the endpoint configuration associated with this endpoint.
        public let endpointConfigName: String
        ///  An array of ProductionVariantSummary objects, one for each model hosted behind this endpoint. 
        public let productionVariants: [ProductionVariantSummary]?
        /// If the status of the endpoint is Failed, the reason why it failed. 
        public let failureReason: String?
        /// A timestamp that shows when the endpoint was last modified.
        public let lastModifiedTime: TimeStamp
        /// The status of the endpoint.    OutOfService: Endpoint is not available to take incoming requests.    Creating: CreateEndpoint is executing.    Updating: UpdateEndpoint or UpdateEndpointWeightsAndCapacities is executing.    SystemUpdating: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This maintenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.    RollingBack: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an InService status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an UpdateEndpointWeightsAndCapacities call or when the UpdateEndpointWeightsAndCapacities operation is called explicitly.    InService: Endpoint is available to process incoming requests.    Deleting: DeleteEndpoint is executing.    Failed: Endpoint could not be created, updated, or re-scaled. Use DescribeEndpointOutput$FailureReason for information about the failure. DeleteEndpoint is the only operation that can be performed on a failed endpoint.  
        public let endpointStatus: EndpointStatus
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String

        public init(creationTime: TimeStamp, endpointArn: String, endpointConfigName: String, endpointName: String, endpointStatus: EndpointStatus, failureReason: String? = nil, lastModifiedTime: TimeStamp, productionVariants: [ProductionVariantSummary]? = nil) {
            self.endpointName = endpointName
            self.creationTime = creationTime
            self.endpointConfigName = endpointConfigName
            self.productionVariants = productionVariants
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.endpointStatus = endpointStatus
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
            case creationTime = "CreationTime"
            case endpointConfigName = "EndpointConfigName"
            case productionVariants = "ProductionVariants"
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case endpointStatus = "EndpointStatus"
            case endpointArn = "EndpointArn"
        }
    }

    public enum NotebookInstanceLifecycleConfigSortOrder: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public struct ModelPackageValidationSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ValidationProfiles", required: true, type: .list), 
            AWSShapeMember(label: "ValidationRole", required: true, type: .string)
        ]
        /// An array of ModelPackageValidationProfile objects, each of which specifies a batch transform job that Amazon SageMaker runs to validate your model package.
        public let validationProfiles: [ModelPackageValidationProfile]
        /// The IAM roles to be used for the validation of a model package.
        public let validationRole: String

        public init(validationProfiles: [ModelPackageValidationProfile], validationRole: String) {
            self.validationProfiles = validationProfiles
            self.validationRole = validationRole
        }

        private enum CodingKeys: String, CodingKey {
            case validationProfiles = "ValidationProfiles"
            case validationRole = "ValidationRole"
        }
    }

    public enum BooleanOperator: String, CustomStringConvertible, Codable {
        case and = "And"
        case or = "Or"
        public var description: String { return self.rawValue }
    }

    public struct TrainingJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "TuningJobArn", required: false, type: .string), 
            AWSShapeMember(label: "ModelArtifacts", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "StoppingCondition", required: false, type: .structure), 
            AWSShapeMember(label: "ResourceConfig", required: false, type: .structure), 
            AWSShapeMember(label: "EnableNetworkIsolation", required: false, type: .boolean), 
            AWSShapeMember(label: "HyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "InputDataConfig", required: false, type: .list), 
            AWSShapeMember(label: "LabelingJobArn", required: false, type: .string), 
            AWSShapeMember(label: "TrainingJobName", required: false, type: .string), 
            AWSShapeMember(label: "TrainingJobArn", required: false, type: .string), 
            AWSShapeMember(label: "TrainingEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "AlgorithmSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "FinalMetricDataList", required: false, type: .list), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "SecondaryStatusTransitions", required: false, type: .list), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "OutputDataConfig", required: false, type: .structure), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "TrainingStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TrainingJobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "SecondaryStatus", required: false, type: .enum)
        ]
        /// A VpcConfig object that specifies the VPC that this training job has access to. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?
        /// The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.
        public let tuningJobArn: String?
        /// Information about the Amazon S3 location that is configured for storing model artifacts.
        public let modelArtifacts: ModelArtifacts?
        /// A timestamp that indicates when the status of the training job was last modified.
        public let lastModifiedTime: TimeStamp?
        /// An array of key-value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide.
        public let tags: [Tag]?
        /// The condition under which to stop the training job.
        public let stoppingCondition: StoppingCondition?
        /// Resources, including ML compute instances and ML storage volumes, that are configured for model training.
        public let resourceConfig: ResourceConfig?
        /// If the TrainingJob was created with network isolation, the value is set to true. If network isolation is enabled, nodes can't communicate beyond the VPC they run in.
        public let enableNetworkIsolation: Bool?
        /// Algorithm-specific parameters.
        public let hyperParameters: [String: String]?
        /// An array of Channel objects that describes each data input channel.
        public let inputDataConfig: [Channel]?
        /// The Amazon Resource Name (ARN) of the labeling job.
        public let labelingJobArn: String?
        /// The name of the training job.
        public let trainingJobName: String?
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String?
        /// Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of TrainingStartTime and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.
        public let trainingEndTime: TimeStamp?
        /// Information about the algorithm used for training, and algorithm metadata.
        public let algorithmSpecification: AlgorithmSpecification?
        /// A list of final metric values that are set when the Training Job completes. Used only if the training job was configured to use metrics.
        public let finalMetricDataList: [MetricData]?
        /// A timestamp that indicates when the training job was created.
        public let creationTime: TimeStamp?
        /// A history of all of the secondary statuses that the training job has transitioned through.
        public let secondaryStatusTransitions: [SecondaryStatusTransition]?
        /// The AWS Identity and Access Management (IAM) role configured for the training job.
        public let roleArn: String?
        /// The S3 path where model artifacts that you configured when creating the job are stored. Amazon SageMaker creates subfolders for model artifacts.
        public let outputDataConfig: OutputDataConfig?
        /// If the training job failed, the reason it failed.
        public let failureReason: String?
        /// Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of TrainingEndTime. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.
        public let trainingStartTime: TimeStamp?
        /// The status of the training job. Training job statuses are:    InProgress - The training is in progress.    Completed - The training job has completed.    Failed - The training job has failed. To see the reason for the failure, see the FailureReason field in the response to a DescribeTrainingJobResponse call.    Stopping - The training job is stopping.    Stopped - The training job has stopped.   For more detailed information, see SecondaryStatus. 
        public let trainingJobStatus: TrainingJobStatus?
        ///  Provides detailed information about the state of the training job. For detailed information about the secondary status of the training job, see StatusMessage under SecondaryStatusTransition. Amazon SageMaker provides primary statuses and secondary statuses that apply to each of them:  InProgress     Starting - Starting the training job.    Downloading - An optional stage for algorithms that support File training input mode. It indicates that data is being downloaded to the ML storage volumes.    Training - Training is in progress.    Uploading - Training is complete and the model artifacts are being uploaded to the S3 location.    Completed     Completed - The training job has completed.    Failed     Failed - The training job has failed. The reason for the failure is returned in the FailureReason field of DescribeTrainingJobResponse.    Stopped     MaxRuntimeExceeded - The job stopped because it exceeded the maximum allowed runtime.    Stopped - The training job has stopped.    Stopping     Stopping - Stopping the training job.      Valid values for SecondaryStatus are subject to change.   We no longer support the following secondary statuses:    LaunchingMLInstances     PreparingTrainingStack     DownloadingTrainingImage   
        public let secondaryStatus: SecondaryStatus?

        public init(algorithmSpecification: AlgorithmSpecification? = nil, creationTime: TimeStamp? = nil, enableNetworkIsolation: Bool? = nil, failureReason: String? = nil, finalMetricDataList: [MetricData]? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [Channel]? = nil, labelingJobArn: String? = nil, lastModifiedTime: TimeStamp? = nil, modelArtifacts: ModelArtifacts? = nil, outputDataConfig: OutputDataConfig? = nil, resourceConfig: ResourceConfig? = nil, roleArn: String? = nil, secondaryStatus: SecondaryStatus? = nil, secondaryStatusTransitions: [SecondaryStatusTransition]? = nil, stoppingCondition: StoppingCondition? = nil, tags: [Tag]? = nil, trainingEndTime: TimeStamp? = nil, trainingJobArn: String? = nil, trainingJobName: String? = nil, trainingJobStatus: TrainingJobStatus? = nil, trainingStartTime: TimeStamp? = nil, tuningJobArn: String? = nil, vpcConfig: VpcConfig? = nil) {
            self.vpcConfig = vpcConfig
            self.tuningJobArn = tuningJobArn
            self.modelArtifacts = modelArtifacts
            self.lastModifiedTime = lastModifiedTime
            self.tags = tags
            self.stoppingCondition = stoppingCondition
            self.resourceConfig = resourceConfig
            self.enableNetworkIsolation = enableNetworkIsolation
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.labelingJobArn = labelingJobArn
            self.trainingJobName = trainingJobName
            self.trainingJobArn = trainingJobArn
            self.trainingEndTime = trainingEndTime
            self.algorithmSpecification = algorithmSpecification
            self.finalMetricDataList = finalMetricDataList
            self.creationTime = creationTime
            self.secondaryStatusTransitions = secondaryStatusTransitions
            self.roleArn = roleArn
            self.outputDataConfig = outputDataConfig
            self.failureReason = failureReason
            self.trainingStartTime = trainingStartTime
            self.trainingJobStatus = trainingJobStatus
            self.secondaryStatus = secondaryStatus
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConfig = "VpcConfig"
            case tuningJobArn = "TuningJobArn"
            case modelArtifacts = "ModelArtifacts"
            case lastModifiedTime = "LastModifiedTime"
            case tags = "Tags"
            case stoppingCondition = "StoppingCondition"
            case resourceConfig = "ResourceConfig"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case hyperParameters = "HyperParameters"
            case inputDataConfig = "InputDataConfig"
            case labelingJobArn = "LabelingJobArn"
            case trainingJobName = "TrainingJobName"
            case trainingJobArn = "TrainingJobArn"
            case trainingEndTime = "TrainingEndTime"
            case algorithmSpecification = "AlgorithmSpecification"
            case finalMetricDataList = "FinalMetricDataList"
            case creationTime = "CreationTime"
            case secondaryStatusTransitions = "SecondaryStatusTransitions"
            case roleArn = "RoleArn"
            case outputDataConfig = "OutputDataConfig"
            case failureReason = "FailureReason"
            case trainingStartTime = "TrainingStartTime"
            case trainingJobStatus = "TrainingJobStatus"
            case secondaryStatus = "SecondaryStatus"
        }
    }

    public struct StopTrainingJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingJobName", required: true, type: .string)
        ]
        /// The name of the training job to stop.
        public let trainingJobName: String

        public init(trainingJobName: String) {
            self.trainingJobName = trainingJobName
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobName = "TrainingJobName"
        }
    }

    public struct TransformInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContentType", required: false, type: .string), 
            AWSShapeMember(label: "DataSource", required: true, type: .structure), 
            AWSShapeMember(label: "SplitType", required: false, type: .enum), 
            AWSShapeMember(label: "CompressionType", required: false, type: .enum)
        ]
        /// The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
        public let contentType: String?
        /// Describes the location of the channel data, meaning the S3 location of the input data that the model can consume.
        public let dataSource: TransformDataSource
        /// The method to use to split the transform job's data into smaller batches. The default value is None. If you don't want to split the data, specify None. If you want to split records on a newline character boundary, specify Line. To split records according to the RecordIO format, specify RecordIO. Amazon SageMaker will send maximum number of records per batch in each request up to the MaxPayloadInMB limit. For more information, see RecordIO data format.  For information about the RecordIO format, see Data Format. 
        public let splitType: SplitType?
        /// Compressing data helps save on storage space. If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
        public let compressionType: CompressionType?

        public init(compressionType: CompressionType? = nil, contentType: String? = nil, dataSource: TransformDataSource, splitType: SplitType? = nil) {
            self.contentType = contentType
            self.dataSource = dataSource
            self.splitType = splitType
            self.compressionType = compressionType
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case dataSource = "DataSource"
            case splitType = "SplitType"
            case compressionType = "CompressionType"
        }
    }

    public struct USD: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Cents", required: false, type: .integer), 
            AWSShapeMember(label: "TenthFractionsOfACent", required: false, type: .integer), 
            AWSShapeMember(label: "Dollars", required: false, type: .integer)
        ]
        /// The fractional portion, in cents, of the amount. 
        public let cents: Int32?
        /// Fractions of a cent, in tenths.
        public let tenthFractionsOfACent: Int32?
        /// The whole number of dollars in the amount.
        public let dollars: Int32?

        public init(cents: Int32? = nil, dollars: Int32? = nil, tenthFractionsOfACent: Int32? = nil) {
            self.cents = cents
            self.tenthFractionsOfACent = tenthFractionsOfACent
            self.dollars = dollars
        }

        private enum CodingKeys: String, CodingKey {
            case cents = "Cents"
            case tenthFractionsOfACent = "TenthFractionsOfACent"
            case dollars = "Dollars"
        }
    }

    public struct CreateLabelingJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HumanTaskConfig", required: true, type: .structure), 
            AWSShapeMember(label: "StoppingConditions", required: false, type: .structure), 
            AWSShapeMember(label: "LabelAttributeName", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "InputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "LabelingJobAlgorithmsConfig", required: false, type: .structure), 
            AWSShapeMember(label: "LabelCategoryConfigS3Uri", required: false, type: .string), 
            AWSShapeMember(label: "OutputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "LabelingJobName", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]
        /// Configures the information required for human workers to complete a labeling task.
        public let humanTaskConfig: HumanTaskConfig
        /// A set of conditions for stopping the labeling job. If any of the conditions are met, the job is automatically stopped. You can use these conditions to control the cost of data labeling.
        public let stoppingConditions: LabelingJobStoppingConditions?
        /// The attribute name to use for the label in the output manifest file. This is the key for the key/value pair formed with the label that a worker assigns to the object. The name can't end with "-metadata" or "-ref".
        public let labelAttributeName: String
        /// The Amazon Resource Number (ARN) that Amazon SageMaker assumes to perform tasks on your behalf during data labeling. You must grant this role the necessary permissions so that Amazon SageMaker can successfully complete data labeling.
        public let roleArn: String
        /// Input data for the labeling job, such as the Amazon S3 location of the data objects and the location of the manifest file that describes the data objects.
        public let inputConfig: LabelingJobInputConfig
        /// Configures the information required to perform automated data labeling.
        public let labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig?
        /// The S3 URL of the file that defines the categories used to label the data objects.
        public let labelCategoryConfigS3Uri: String?
        /// The location of the output data and the AWS Key Management Service key ID for the key used to encrypt the output data, if any.
        public let outputConfig: LabelingJobOutputConfig
        /// The name of the labeling job. This name is used to identify the job in a list of labeling jobs.
        public let labelingJobName: String
        /// An array of key/value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide.
        public let tags: [Tag]?

        public init(humanTaskConfig: HumanTaskConfig, inputConfig: LabelingJobInputConfig, labelAttributeName: String, labelCategoryConfigS3Uri: String? = nil, labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig? = nil, labelingJobName: String, outputConfig: LabelingJobOutputConfig, roleArn: String, stoppingConditions: LabelingJobStoppingConditions? = nil, tags: [Tag]? = nil) {
            self.humanTaskConfig = humanTaskConfig
            self.stoppingConditions = stoppingConditions
            self.labelAttributeName = labelAttributeName
            self.roleArn = roleArn
            self.inputConfig = inputConfig
            self.labelingJobAlgorithmsConfig = labelingJobAlgorithmsConfig
            self.labelCategoryConfigS3Uri = labelCategoryConfigS3Uri
            self.outputConfig = outputConfig
            self.labelingJobName = labelingJobName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case humanTaskConfig = "HumanTaskConfig"
            case stoppingConditions = "StoppingConditions"
            case labelAttributeName = "LabelAttributeName"
            case roleArn = "RoleArn"
            case inputConfig = "InputConfig"
            case labelingJobAlgorithmsConfig = "LabelingJobAlgorithmsConfig"
            case labelCategoryConfigS3Uri = "LabelCategoryConfigS3Uri"
            case outputConfig = "OutputConfig"
            case labelingJobName = "LabelingJobName"
            case tags = "Tags"
        }
    }

    public struct TransformDataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3DataSource", required: true, type: .structure)
        ]
        /// The S3 location of the data source that is associated with a channel.
        public let s3DataSource: TransformS3DataSource

        public init(s3DataSource: TransformS3DataSource) {
            self.s3DataSource = s3DataSource
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "S3DataSource"
        }
    }

    public struct ListNotebookInstanceLifecycleConfigsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigs", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of NotebookInstanceLifecycleConfiguration objects, each listing a lifecycle configuration.
        public let notebookInstanceLifecycleConfigs: [NotebookInstanceLifecycleConfigSummary]?
        /// If the response is truncated, Amazon SageMaker returns this token. To get the next set of lifecycle configurations, use it in the next request. 
        public let nextToken: String?

        public init(nextToken: String? = nil, notebookInstanceLifecycleConfigs: [NotebookInstanceLifecycleConfigSummary]? = nil) {
            self.notebookInstanceLifecycleConfigs = notebookInstanceLifecycleConfigs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigs = "NotebookInstanceLifecycleConfigs"
            case nextToken = "NextToken"
        }
    }

    public struct FinalHyperParameterTuningJobObjectiveMetric: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: true, type: .float), 
            AWSShapeMember(label: "MetricName", required: true, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]
        /// The value of the objective metric.
        public let value: Float
        /// The name of the objective metric.
        public let metricName: String
        /// Whether to minimize or maximize the objective metric. Valid values are Minimize and Maximize.
        public let `type`: HyperParameterTuningJobObjectiveType?

        public init(metricName: String, type: HyperParameterTuningJobObjectiveType? = nil, value: Float) {
            self.value = value
            self.metricName = metricName
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case metricName = "MetricName"
            case `type` = "Type"
        }
    }

    public struct RenderingError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", required: true, type: .string), 
            AWSShapeMember(label: "Message", required: true, type: .string)
        ]
        /// A unique identifier for a specific class of errors.
        public let code: String
        /// A human-readable message describing the error.
        public let message: String

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct AlgorithmValidationProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransformJobDefinition", required: false, type: .structure), 
            AWSShapeMember(label: "ProfileName", required: true, type: .string), 
            AWSShapeMember(label: "TrainingJobDefinition", required: true, type: .structure)
        ]
        /// The TransformJobDefinition object that describes the transform job that Amazon SageMaker runs to validate your algorithm.
        public let transformJobDefinition: TransformJobDefinition?
        /// The name of the profile for the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let profileName: String
        /// The TrainingJobDefinition object that describes the training job that Amazon SageMaker runs to validate your algorithm.
        public let trainingJobDefinition: TrainingJobDefinition

        public init(profileName: String, trainingJobDefinition: TrainingJobDefinition, transformJobDefinition: TransformJobDefinition? = nil) {
            self.transformJobDefinition = transformJobDefinition
            self.profileName = profileName
            self.trainingJobDefinition = trainingJobDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobDefinition = "TransformJobDefinition"
            case profileName = "ProfileName"
            case trainingJobDefinition = "TrainingJobDefinition"
        }
    }

    public struct ListTrainingJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// A filter that retrieves only training jobs with a specific status.
        public let statusEquals: TrainingJobStatus?
        /// If the result of the previous ListTrainingJobs request was truncated, the response includes a NextToken. To retrieve the next set of training jobs, use the token in the next request. 
        public let nextToken: String?
        /// A filter that returns only training jobs created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// A filter that returns only training jobs modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: TimeStamp?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that returns only training jobs created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// A filter that returns only training jobs modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: TimeStamp?
        /// A string in the training job name. This filter returns only training jobs whose name contains the specified string.
        public let nameContains: String?
        /// The maximum number of training jobs to return in the response.
        public let maxResults: Int32?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: TrainingJobStatus? = nil) {
            self.statusEquals = statusEquals
            self.nextToken = nextToken
            self.creationTimeAfter = creationTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.nameContains = nameContains
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case statusEquals = "StatusEquals"
            case nextToken = "NextToken"
            case creationTimeAfter = "CreationTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case nameContains = "NameContains"
            case maxResults = "MaxResults"
        }
    }

    public struct TransformJobDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BatchStrategy", required: false, type: .enum), 
            AWSShapeMember(label: "TransformOutput", required: true, type: .structure), 
            AWSShapeMember(label: "Environment", required: false, type: .map), 
            AWSShapeMember(label: "TransformResources", required: true, type: .structure), 
            AWSShapeMember(label: "TransformInput", required: true, type: .structure), 
            AWSShapeMember(label: "MaxPayloadInMB", required: false, type: .integer), 
            AWSShapeMember(label: "MaxConcurrentTransforms", required: false, type: .integer)
        ]
        /// A string that determines the number of records included in a single mini-batch.  SingleRecord means only one record is used per mini-batch. MultiRecord means a mini-batch is set to contain as many records that can fit within the MaxPayloadInMB limit.
        public let batchStrategy: BatchStrategy?
        /// Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        public let transformOutput: TransformOutput
        /// The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        public let environment: [String: String]?
        /// Identifies the ML compute instances for the transform job.
        public let transformResources: TransformResources
        /// A description of the input source and the way the transform job consumes it.
        public let transformInput: TransformInput
        /// The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
        public let maxPayloadInMB: Int32?
        /// The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
        public let maxConcurrentTransforms: Int32?

        public init(batchStrategy: BatchStrategy? = nil, environment: [String: String]? = nil, maxConcurrentTransforms: Int32? = nil, maxPayloadInMB: Int32? = nil, transformInput: TransformInput, transformOutput: TransformOutput, transformResources: TransformResources) {
            self.batchStrategy = batchStrategy
            self.transformOutput = transformOutput
            self.environment = environment
            self.transformResources = transformResources
            self.transformInput = transformInput
            self.maxPayloadInMB = maxPayloadInMB
            self.maxConcurrentTransforms = maxConcurrentTransforms
        }

        private enum CodingKeys: String, CodingKey {
            case batchStrategy = "BatchStrategy"
            case transformOutput = "TransformOutput"
            case environment = "Environment"
            case transformResources = "TransformResources"
            case transformInput = "TransformInput"
            case maxPayloadInMB = "MaxPayloadInMB"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
        }
    }

    public struct ParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContinuousParameterRangeSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "CategoricalParameterRangeSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "IntegerParameterRangeSpecification", required: false, type: .structure)
        ]
        /// A ContinuousParameterRangeSpecification object that defines the possible values for a continuous hyperparameter.
        public let continuousParameterRangeSpecification: ContinuousParameterRangeSpecification?
        /// A CategoricalParameterRangeSpecification object that defines the possible values for a categorical hyperparameter.
        public let categoricalParameterRangeSpecification: CategoricalParameterRangeSpecification?
        /// A IntegerParameterRangeSpecification object that defines the possible values for an integer hyperparameter.
        public let integerParameterRangeSpecification: IntegerParameterRangeSpecification?

        public init(categoricalParameterRangeSpecification: CategoricalParameterRangeSpecification? = nil, continuousParameterRangeSpecification: ContinuousParameterRangeSpecification? = nil, integerParameterRangeSpecification: IntegerParameterRangeSpecification? = nil) {
            self.continuousParameterRangeSpecification = continuousParameterRangeSpecification
            self.categoricalParameterRangeSpecification = categoricalParameterRangeSpecification
            self.integerParameterRangeSpecification = integerParameterRangeSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case continuousParameterRangeSpecification = "ContinuousParameterRangeSpecification"
            case categoricalParameterRangeSpecification = "CategoricalParameterRangeSpecification"
            case integerParameterRangeSpecification = "IntegerParameterRangeSpecification"
        }
    }

    public struct ResourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceType", required: true, type: .enum), 
            AWSShapeMember(label: "VolumeSizeInGB", required: true, type: .integer), 
            AWSShapeMember(label: "InstanceCount", required: true, type: .integer), 
            AWSShapeMember(label: "VolumeKmsKeyId", required: false, type: .string)
        ]
        /// The ML compute instance type. 
        public let instanceType: TrainingInstanceType
        /// The size of the ML storage volume that you want to provision.  ML storage volumes store model artifacts and incremental states. Training algorithms might also use the ML storage volume for scratch space. If you want to store the training data in the ML storage volume, choose File as the TrainingInputMode in the algorithm specification.  You must specify sufficient ML storage for your scenario.    Amazon SageMaker supports only the General Purpose SSD (gp2) ML storage volume type.  
        public let volumeSizeInGB: Int32
        /// The number of ML compute instances to use. For distributed training, provide a value greater than 1. 
        public let instanceCount: Int32
        /// The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the training job. The VolumeKmsKeyId can be any of the following formats:   // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"   
        public let volumeKmsKeyId: String?

        public init(instanceCount: Int32, instanceType: TrainingInstanceType, volumeKmsKeyId: String? = nil, volumeSizeInGB: Int32) {
            self.instanceType = instanceType
            self.volumeSizeInGB = volumeSizeInGB
            self.instanceCount = instanceCount
            self.volumeKmsKeyId = volumeKmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case volumeSizeInGB = "VolumeSizeInGB"
            case instanceCount = "InstanceCount"
            case volumeKmsKeyId = "VolumeKmsKeyId"
        }
    }

    public enum CompilationJobStatus: String, CustomStringConvertible, Codable {
        case inprogress = "INPROGRESS"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case starting = "STARTING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public struct DescribeAlgorithmOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InferenceSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "ProductId", required: false, type: .string), 
            AWSShapeMember(label: "CertifyForMarketplace", required: false, type: .boolean), 
            AWSShapeMember(label: "AlgorithmArn", required: true, type: .string), 
            AWSShapeMember(label: "ValidationSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "AlgorithmStatus", required: true, type: .enum), 
            AWSShapeMember(label: "AlgorithmName", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "TrainingSpecification", required: true, type: .structure), 
            AWSShapeMember(label: "AlgorithmDescription", required: false, type: .string), 
            AWSShapeMember(label: "AlgorithmStatusDetails", required: true, type: .structure)
        ]
        /// Details about inference jobs that the algorithm runs.
        public let inferenceSpecification: InferenceSpecification?
        /// The product identifier of the algorithm.
        public let productId: String?
        /// Whether the algorithm is certified to be listed in AWS Marektplace.
        public let certifyForMarketplace: Bool?
        /// The Amazon Resource Name (ARN) of the algorithm.&gt;
        public let algorithmArn: String
        /// Details about configurations for one or more training jobs that Amazon SageMaker runs to test the algorithm.
        public let validationSpecification: AlgorithmValidationSpecification?
        /// The current status of the algorithm.
        public let algorithmStatus: AlgorithmStatus
        /// The name of the algorithm being described.
        public let algorithmName: String
        /// A timestamp specifying when the algorithm was created.
        public let creationTime: TimeStamp
        /// Details about training jobs run by this algorithm.
        public let trainingSpecification: TrainingSpecification
        /// A brief summary about the algorithm.
        public let algorithmDescription: String?
        /// Details about the current status of the algorithm.
        public let algorithmStatusDetails: AlgorithmStatusDetails

        public init(algorithmArn: String, algorithmDescription: String? = nil, algorithmName: String, algorithmStatus: AlgorithmStatus, algorithmStatusDetails: AlgorithmStatusDetails, certifyForMarketplace: Bool? = nil, creationTime: TimeStamp, inferenceSpecification: InferenceSpecification? = nil, productId: String? = nil, trainingSpecification: TrainingSpecification, validationSpecification: AlgorithmValidationSpecification? = nil) {
            self.inferenceSpecification = inferenceSpecification
            self.productId = productId
            self.certifyForMarketplace = certifyForMarketplace
            self.algorithmArn = algorithmArn
            self.validationSpecification = validationSpecification
            self.algorithmStatus = algorithmStatus
            self.algorithmName = algorithmName
            self.creationTime = creationTime
            self.trainingSpecification = trainingSpecification
            self.algorithmDescription = algorithmDescription
            self.algorithmStatusDetails = algorithmStatusDetails
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceSpecification = "InferenceSpecification"
            case productId = "ProductId"
            case certifyForMarketplace = "CertifyForMarketplace"
            case algorithmArn = "AlgorithmArn"
            case validationSpecification = "ValidationSpecification"
            case algorithmStatus = "AlgorithmStatus"
            case algorithmName = "AlgorithmName"
            case creationTime = "CreationTime"
            case trainingSpecification = "TrainingSpecification"
            case algorithmDescription = "AlgorithmDescription"
            case algorithmStatusDetails = "AlgorithmStatusDetails"
        }
    }

    public enum TrainingInstanceType: String, CustomStringConvertible, Codable {
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        public var description: String { return self.rawValue }
    }

    public struct SourceAlgorithm: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmName", required: true, type: .string), 
            AWSShapeMember(label: "ModelDataUrl", required: false, type: .string)
        ]
        /// The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        public let algorithmName: String
        /// The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        public let modelDataUrl: String?

        public init(algorithmName: String, modelDataUrl: String? = nil) {
            self.algorithmName = algorithmName
            self.modelDataUrl = modelDataUrl
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case modelDataUrl = "ModelDataUrl"
        }
    }

    public struct CodeRepositorySummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GitConfig", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CodeRepositoryArn", required: true, type: .string), 
            AWSShapeMember(label: "CodeRepositoryName", required: true, type: .string)
        ]
        /// Configuration details for the git repository, including the URL where it is located and the ARN of the AWS Secrets Manager secret that contains the credentials used to access the repository.
        public let gitConfig: GitConfig?
        /// The date and time that the git repository was last modified.
        public let lastModifiedTime: TimeStamp
        /// The date and time that the git repository was created.
        public let creationTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the git repository.
        public let codeRepositoryArn: String
        /// The name of the git repository.
        public let codeRepositoryName: String

        public init(codeRepositoryArn: String, codeRepositoryName: String, creationTime: TimeStamp, gitConfig: GitConfig? = nil, lastModifiedTime: TimeStamp) {
            self.gitConfig = gitConfig
            self.lastModifiedTime = lastModifiedTime
            self.creationTime = creationTime
            self.codeRepositoryArn = codeRepositoryArn
            self.codeRepositoryName = codeRepositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case gitConfig = "GitConfig"
            case lastModifiedTime = "LastModifiedTime"
            case creationTime = "CreationTime"
            case codeRepositoryArn = "CodeRepositoryArn"
            case codeRepositoryName = "CodeRepositoryName"
        }
    }

    public struct DescribeAlgorithmInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmName", required: true, type: .string)
        ]
        /// The name of the algorithm to describe.
        public let algorithmName: String

        public init(algorithmName: String) {
            self.algorithmName = algorithmName
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
        }
    }

    public struct CreateCompilationJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "InputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "StoppingCondition", required: true, type: .structure), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "CompilationJobName", required: true, type: .string)
        ]
        /// Provides information about the output location for the compiled model and the target device the model runs on.
        public let outputConfig: OutputConfig
        /// Provides information about the location of input model artifacts, the name and shape of the expected data inputs, and the framework in which the model was trained.
        public let inputConfig: InputConfig
        /// The duration allowed for model compilation.
        public let stoppingCondition: StoppingCondition
        /// The Amazon Resource Name (ARN) of an IIAMAM role that enables Amazon SageMaker to perform tasks on your behalf.  During model compilation, Amazon SageMaker needs your permission to:   Read input data from an S3 bucket   Write model artifacts to an S3 bucket   Write logs to Amazon CloudWatch Logs   Publish metrics to Amazon CloudWatch   You grant permissions for all of these tasks to an IAM role. To pass this role to Amazon SageMaker, the caller of this API must have the iam:PassRole permission. For more information, see Amazon SageMaker Roles. 
        public let roleArn: String
        /// A name for the model compilation job. The name must be unique within the AWS Region and within your AWS account. 
        public let compilationJobName: String

        public init(compilationJobName: String, inputConfig: InputConfig, outputConfig: OutputConfig, roleArn: String, stoppingCondition: StoppingCondition) {
            self.outputConfig = outputConfig
            self.inputConfig = inputConfig
            self.stoppingCondition = stoppingCondition
            self.roleArn = roleArn
            self.compilationJobName = compilationJobName
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfig = "OutputConfig"
            case inputConfig = "InputConfig"
            case stoppingCondition = "StoppingCondition"
            case roleArn = "RoleArn"
            case compilationJobName = "CompilationJobName"
        }
    }

    public struct InferenceSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SupportedContentTypes", required: true, type: .list), 
            AWSShapeMember(label: "SupportedRealtimeInferenceInstanceTypes", required: true, type: .list), 
            AWSShapeMember(label: "SupportedResponseMIMETypes", required: true, type: .list), 
            AWSShapeMember(label: "Containers", required: true, type: .list), 
            AWSShapeMember(label: "SupportedTransformInstanceTypes", required: true, type: .list)
        ]
        /// The supported MIME types for the input data.
        public let supportedContentTypes: [String]
        /// A list of the instance types that are used to generate inferences in real-time.
        public let supportedRealtimeInferenceInstanceTypes: [ProductionVariantInstanceType]
        /// The supported MIME types for the output data.
        public let supportedResponseMIMETypes: [String]
        /// The Amazon ECR registry path of the Docker image that contains the inference code.
        public let containers: [ModelPackageContainerDefinition]
        /// A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        public let supportedTransformInstanceTypes: [TransformInstanceType]

        public init(containers: [ModelPackageContainerDefinition], supportedContentTypes: [String], supportedRealtimeInferenceInstanceTypes: [ProductionVariantInstanceType], supportedResponseMIMETypes: [String], supportedTransformInstanceTypes: [TransformInstanceType]) {
            self.supportedContentTypes = supportedContentTypes
            self.supportedRealtimeInferenceInstanceTypes = supportedRealtimeInferenceInstanceTypes
            self.supportedResponseMIMETypes = supportedResponseMIMETypes
            self.containers = containers
            self.supportedTransformInstanceTypes = supportedTransformInstanceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case supportedContentTypes = "SupportedContentTypes"
            case supportedRealtimeInferenceInstanceTypes = "SupportedRealtimeInferenceInstanceTypes"
            case supportedResponseMIMETypes = "SupportedResponseMIMETypes"
            case containers = "Containers"
            case supportedTransformInstanceTypes = "SupportedTransformInstanceTypes"
        }
    }

    public struct DescribeTrainingJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelArtifacts", required: true, type: .structure), 
            AWSShapeMember(label: "ResourceConfig", required: true, type: .structure), 
            AWSShapeMember(label: "TrainingEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TrainingJobName", required: true, type: .string), 
            AWSShapeMember(label: "StoppingCondition", required: true, type: .structure), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "HyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "AlgorithmSpecification", required: true, type: .structure), 
            AWSShapeMember(label: "InputDataConfig", required: false, type: .list), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SecondaryStatus", required: true, type: .enum), 
            AWSShapeMember(label: "TrainingJobArn", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobArn", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TrainingStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TrainingJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "EnableNetworkIsolation", required: false, type: .boolean), 
            AWSShapeMember(label: "TuningJobArn", required: false, type: .string), 
            AWSShapeMember(label: "FinalMetricDataList", required: false, type: .list), 
            AWSShapeMember(label: "SecondaryStatusTransitions", required: false, type: .list), 
            AWSShapeMember(label: "OutputDataConfig", required: false, type: .structure)
        ]
        /// Information about the Amazon S3 location that is configured for storing model artifacts. 
        public let modelArtifacts: ModelArtifacts
        /// Resources, including ML compute instances and ML storage volumes, that are configured for model training. 
        public let resourceConfig: ResourceConfig
        /// Indicates the time when the training job ends on training instances. You are billed for the time interval between the value of TrainingStartTime and this time. For successful jobs and stopped jobs, this is the time after model artifacts are uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.
        public let trainingEndTime: TimeStamp?
        ///  Name of the model training job. 
        public let trainingJobName: String
        /// The condition under which to stop the training job. 
        public let stoppingCondition: StoppingCondition
        /// A VpcConfig object that specifies the VPC that this training job has access to. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?
        /// Algorithm-specific parameters. 
        public let hyperParameters: [String: String]?
        /// If the training job failed, the reason it failed. 
        public let failureReason: String?
        /// Information about the algorithm used for training, and algorithm metadata. 
        public let algorithmSpecification: AlgorithmSpecification
        /// An array of Channel objects that describes each data input channel. 
        public let inputDataConfig: [Channel]?
        /// A timestamp that indicates when the training job was created.
        public let creationTime: TimeStamp
        /// The AWS Identity and Access Management (IAM) role configured for the training job. 
        public let roleArn: String?
        ///  Provides detailed information about the state of the training job. For detailed information on the secondary status of the training job, see StatusMessage under SecondaryStatusTransition. Amazon SageMaker provides primary statuses and secondary statuses that apply to each of them:  InProgress     Starting - Starting the training job.    Downloading - An optional stage for algorithms that support File training input mode. It indicates that data is being downloaded to the ML storage volumes.    Training - Training is in progress.    Uploading - Training is complete and the model artifacts are being uploaded to the S3 location.    Completed     Completed - The training job has completed.    Failed     Failed - The training job has failed. The reason for the failure is returned in the FailureReason field of DescribeTrainingJobResponse.    Stopped     MaxRuntimeExceeded - The job stopped because it exceeded the maximum allowed runtime.    Stopped - The training job has stopped.    Stopping     Stopping - Stopping the training job.      Valid values for SecondaryStatus are subject to change.   We no longer support the following secondary statuses:    LaunchingMLInstances     PreparingTrainingStack     DownloadingTrainingImage   
        public let secondaryStatus: SecondaryStatus
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String
        /// The Amazon Resource Name (ARN) of the Amazon SageMaker Ground Truth labeling job that created the transform or training job.
        public let labelingJobArn: String?
        /// A timestamp that indicates when the status of the training job was last modified.
        public let lastModifiedTime: TimeStamp?
        /// Indicates the time when the training job starts on training instances. You are billed for the time interval between this time and the value of TrainingEndTime. The start time in CloudWatch Logs might be later than this time. The difference is due to the time it takes to download the training data and to the size of the training container.
        public let trainingStartTime: TimeStamp?
        /// The status of the training job. Amazon SageMaker provides the following training job statuses:    InProgress - The training is in progress.    Completed - The training job has completed.    Failed - The training job has failed. To see the reason for the failure, see the FailureReason field in the response to a DescribeTrainingJobResponse call.    Stopping - The training job is stopping.    Stopped - The training job has stopped.   For more detailed information, see SecondaryStatus. 
        public let trainingJobStatus: TrainingJobStatus
        /// If True, inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, Amazon SageMaker downloads and uploads customer data and model artifacts through the specifed VPC, but the training container does not have network access.  The Semantic Segmentation built-in algorithm does not support network isolation. 
        public let enableNetworkIsolation: Bool?
        /// The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the training job was launched by a hyperparameter tuning job.
        public let tuningJobArn: String?
        /// A collection of MetricData objects that specify the names, values, and dates and times that the training algorithm emitted to Amazon CloudWatch.
        public let finalMetricDataList: [MetricData]?
        /// A history of all of the secondary statuses that the training job has transitioned through.
        public let secondaryStatusTransitions: [SecondaryStatusTransition]?
        /// The S3 path where model artifacts that you configured when creating the job are stored. Amazon SageMaker creates subfolders for model artifacts. 
        public let outputDataConfig: OutputDataConfig?

        public init(algorithmSpecification: AlgorithmSpecification, creationTime: TimeStamp, enableNetworkIsolation: Bool? = nil, failureReason: String? = nil, finalMetricDataList: [MetricData]? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [Channel]? = nil, labelingJobArn: String? = nil, lastModifiedTime: TimeStamp? = nil, modelArtifacts: ModelArtifacts, outputDataConfig: OutputDataConfig? = nil, resourceConfig: ResourceConfig, roleArn: String? = nil, secondaryStatus: SecondaryStatus, secondaryStatusTransitions: [SecondaryStatusTransition]? = nil, stoppingCondition: StoppingCondition, trainingEndTime: TimeStamp? = nil, trainingJobArn: String, trainingJobName: String, trainingJobStatus: TrainingJobStatus, trainingStartTime: TimeStamp? = nil, tuningJobArn: String? = nil, vpcConfig: VpcConfig? = nil) {
            self.modelArtifacts = modelArtifacts
            self.resourceConfig = resourceConfig
            self.trainingEndTime = trainingEndTime
            self.trainingJobName = trainingJobName
            self.stoppingCondition = stoppingCondition
            self.vpcConfig = vpcConfig
            self.hyperParameters = hyperParameters
            self.failureReason = failureReason
            self.algorithmSpecification = algorithmSpecification
            self.inputDataConfig = inputDataConfig
            self.creationTime = creationTime
            self.roleArn = roleArn
            self.secondaryStatus = secondaryStatus
            self.trainingJobArn = trainingJobArn
            self.labelingJobArn = labelingJobArn
            self.lastModifiedTime = lastModifiedTime
            self.trainingStartTime = trainingStartTime
            self.trainingJobStatus = trainingJobStatus
            self.enableNetworkIsolation = enableNetworkIsolation
            self.tuningJobArn = tuningJobArn
            self.finalMetricDataList = finalMetricDataList
            self.secondaryStatusTransitions = secondaryStatusTransitions
            self.outputDataConfig = outputDataConfig
        }

        private enum CodingKeys: String, CodingKey {
            case modelArtifacts = "ModelArtifacts"
            case resourceConfig = "ResourceConfig"
            case trainingEndTime = "TrainingEndTime"
            case trainingJobName = "TrainingJobName"
            case stoppingCondition = "StoppingCondition"
            case vpcConfig = "VpcConfig"
            case hyperParameters = "HyperParameters"
            case failureReason = "FailureReason"
            case algorithmSpecification = "AlgorithmSpecification"
            case inputDataConfig = "InputDataConfig"
            case creationTime = "CreationTime"
            case roleArn = "RoleArn"
            case secondaryStatus = "SecondaryStatus"
            case trainingJobArn = "TrainingJobArn"
            case labelingJobArn = "LabelingJobArn"
            case lastModifiedTime = "LastModifiedTime"
            case trainingStartTime = "TrainingStartTime"
            case trainingJobStatus = "TrainingJobStatus"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case tuningJobArn = "TuningJobArn"
            case finalMetricDataList = "FinalMetricDataList"
            case secondaryStatusTransitions = "SecondaryStatusTransitions"
            case outputDataConfig = "OutputDataConfig"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]
        /// The tag key.
        public let key: String
        /// The tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ContinuousParameterRangeSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxValue", required: true, type: .string), 
            AWSShapeMember(label: "MinValue", required: true, type: .string)
        ]
        /// The maximum floating-point value allowed.
        public let maxValue: String
        /// The minimum floating-point value allowed.
        public let minValue: String

        public init(maxValue: String, minValue: String) {
            self.maxValue = maxValue
            self.minValue = minValue
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public enum TrainingJobStatus: String, CustomStringConvertible, Codable {
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        case stopping = "Stopping"
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public struct LabelingJobResourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VolumeKmsKeyId", required: false, type: .string)
        ]
        /// The AWS Key Management Service key ID for the key used to encrypt the output data, if any.
        public let volumeKmsKeyId: String?

        public init(volumeKmsKeyId: String? = nil) {
            self.volumeKmsKeyId = volumeKmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case volumeKmsKeyId = "VolumeKmsKeyId"
        }
    }

    public struct UpdateNotebookInstanceLifecycleConfigOutput: AWSShape {

        public init() {
        }

    }

    public struct ObjectiveStatusCounters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Pending", required: false, type: .integer), 
            AWSShapeMember(label: "Failed", required: false, type: .integer), 
            AWSShapeMember(label: "Succeeded", required: false, type: .integer)
        ]
        /// The number of training jobs that are in progress and pending evaluation of their final objective metric.
        public let pending: Int32?
        /// The number of training jobs whose final objective metric was not evaluated and used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.
        public let failed: Int32?
        /// The number of training jobs whose final objective metric was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.
        public let succeeded: Int32?

        public init(failed: Int32? = nil, pending: Int32? = nil, succeeded: Int32? = nil) {
            self.pending = pending
            self.failed = failed
            self.succeeded = succeeded
        }

        private enum CodingKeys: String, CodingKey {
            case pending = "Pending"
            case failed = "Failed"
            case succeeded = "Succeeded"
        }
    }

    public struct TransformResources: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceType", required: true, type: .enum), 
            AWSShapeMember(label: "VolumeKmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "InstanceCount", required: true, type: .integer)
        ]
        /// The ML compute instance type for the transform job. For using built-in algorithms to transform moderately sized datasets, ml.m4.xlarge or ml.m5.large should suffice. There is no default value for InstanceType.
        public let instanceType: TransformInstanceType
        /// The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the batch transform job. The VolumeKmsKeyId can be any of the following formats:   // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"   
        public let volumeKmsKeyId: String?
        /// The number of ML compute instances to use in the transform job. For distributed transform, provide a value greater than 1. The default value is 1.
        public let instanceCount: Int32

        public init(instanceCount: Int32, instanceType: TransformInstanceType, volumeKmsKeyId: String? = nil) {
            self.instanceType = instanceType
            self.volumeKmsKeyId = volumeKmsKeyId
            self.instanceCount = instanceCount
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case volumeKmsKeyId = "VolumeKmsKeyId"
            case instanceCount = "InstanceCount"
        }
    }

    public struct MemberDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CognitoMemberDefinition", required: false, type: .structure)
        ]
        /// The Amazon Cognito user group that is part of the work team.
        public let cognitoMemberDefinition: CognitoMemberDefinition?

        public init(cognitoMemberDefinition: CognitoMemberDefinition? = nil) {
            self.cognitoMemberDefinition = cognitoMemberDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case cognitoMemberDefinition = "CognitoMemberDefinition"
        }
    }

    public struct UpdateNotebookInstanceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VolumeSizeInGB", required: false, type: .integer), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "AdditionalCodeRepositories", required: false, type: .list), 
            AWSShapeMember(label: "DisassociateAdditionalCodeRepositories", required: false, type: .boolean), 
            AWSShapeMember(label: "AcceleratorTypes", required: false, type: .list), 
            AWSShapeMember(label: "DisassociateLifecycleConfig", required: false, type: .boolean), 
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string), 
            AWSShapeMember(label: "DefaultCodeRepository", required: false, type: .string), 
            AWSShapeMember(label: "LifecycleConfigName", required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", required: false, type: .enum), 
            AWSShapeMember(label: "DisassociateAcceleratorTypes", required: false, type: .boolean), 
            AWSShapeMember(label: "DisassociateDefaultCodeRepository", required: false, type: .boolean)
        ]
        /// The size, in GB, of the ML storage volume to attach to the notebook instance. The default value is 5 GB.
        public let volumeSizeInGB: Int32?
        /// The Amazon Resource Name (ARN) of the IAM role that Amazon SageMaker can assume to access the notebook instance. For more information, see Amazon SageMaker Roles.   To be able to pass this role to Amazon SageMaker, the caller of this API must have the iam:PassRole permission. 
        public let roleArn: String?
        /// An array of up to 3 git repositories to associate with the notebook instance. These can be either the names of git repositories stored as resources in your account, or the URL of git repositories in AWS CodeCommit or in any other git repository.. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// A list of names or URLs of the default git repositories to remove from this notebook instance.
        public let disassociateAdditionalCodeRepositories: Bool?
        /// A list of the Elastic Inference (EI) instance types to associate with this notebook instance. Currently only one EI instance type can be associated with a notebook instance. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorTypes: [NotebookInstanceAcceleratorType]?
        /// Set to true to remove the notebook instance lifecycle configuration currently associated with the notebook instance.
        public let disassociateLifecycleConfig: Bool?
        /// The name of the notebook instance to update.
        public let notebookInstanceName: String
        /// The git repository to associate with the notebook instance as its default code repository. This can be either the name of a git repository stored as a resource in your account, or the URL of a git repository in AWS CodeCommit or in any other git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// The name of a lifecycle configuration to associate with the notebook instance. For information about lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
        public let lifecycleConfigName: String?
        /// The Amazon ML compute instance type.
        public let instanceType: InstanceType?
        /// A list of the Elastic Inference (EI) instance types to remove from this notebook instance.
        public let disassociateAcceleratorTypes: Bool?
        /// The name or URL of the default git repository to remove from this notebook instance.
        public let disassociateDefaultCodeRepository: Bool?

        public init(acceleratorTypes: [NotebookInstanceAcceleratorType]? = nil, additionalCodeRepositories: [String]? = nil, defaultCodeRepository: String? = nil, disassociateAcceleratorTypes: Bool? = nil, disassociateAdditionalCodeRepositories: Bool? = nil, disassociateDefaultCodeRepository: Bool? = nil, disassociateLifecycleConfig: Bool? = nil, instanceType: InstanceType? = nil, lifecycleConfigName: String? = nil, notebookInstanceName: String, roleArn: String? = nil, volumeSizeInGB: Int32? = nil) {
            self.volumeSizeInGB = volumeSizeInGB
            self.roleArn = roleArn
            self.additionalCodeRepositories = additionalCodeRepositories
            self.disassociateAdditionalCodeRepositories = disassociateAdditionalCodeRepositories
            self.acceleratorTypes = acceleratorTypes
            self.disassociateLifecycleConfig = disassociateLifecycleConfig
            self.notebookInstanceName = notebookInstanceName
            self.defaultCodeRepository = defaultCodeRepository
            self.lifecycleConfigName = lifecycleConfigName
            self.instanceType = instanceType
            self.disassociateAcceleratorTypes = disassociateAcceleratorTypes
            self.disassociateDefaultCodeRepository = disassociateDefaultCodeRepository
        }

        private enum CodingKeys: String, CodingKey {
            case volumeSizeInGB = "VolumeSizeInGB"
            case roleArn = "RoleArn"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case disassociateAdditionalCodeRepositories = "DisassociateAdditionalCodeRepositories"
            case acceleratorTypes = "AcceleratorTypes"
            case disassociateLifecycleConfig = "DisassociateLifecycleConfig"
            case notebookInstanceName = "NotebookInstanceName"
            case defaultCodeRepository = "DefaultCodeRepository"
            case lifecycleConfigName = "LifecycleConfigName"
            case instanceType = "InstanceType"
            case disassociateAcceleratorTypes = "DisassociateAcceleratorTypes"
            case disassociateDefaultCodeRepository = "DisassociateDefaultCodeRepository"
        }
    }

    public struct SuggestionQuery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PropertyNameQuery", required: false, type: .structure)
        ]
        /// Defines a property name hint. Only property names that match the specified hint are included in the response.
        public let propertyNameQuery: PropertyNameQuery?

        public init(propertyNameQuery: PropertyNameQuery? = nil) {
            self.propertyNameQuery = propertyNameQuery
        }

        private enum CodingKeys: String, CodingKey {
            case propertyNameQuery = "PropertyNameQuery"
        }
    }

    public struct ListHyperParameterTuningJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "HyperParameterTuningJobSummaries", required: true, type: .list)
        ]
        /// If the result of this ListHyperParameterTuningJobs request was truncated, the response includes a NextToken. To retrieve the next set of tuning jobs, use the token in the next request.
        public let nextToken: String?
        /// A list of HyperParameterTuningJobSummary objects that describe the tuning jobs that the ListHyperParameterTuningJobs request returned.
        public let hyperParameterTuningJobSummaries: [HyperParameterTuningJobSummary]

        public init(hyperParameterTuningJobSummaries: [HyperParameterTuningJobSummary], nextToken: String? = nil) {
            self.nextToken = nextToken
            self.hyperParameterTuningJobSummaries = hyperParameterTuningJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case hyperParameterTuningJobSummaries = "HyperParameterTuningJobSummaries"
        }
    }

    public struct EndpointConfigSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string), 
            AWSShapeMember(label: "EndpointConfigArn", required: true, type: .string)
        ]
        /// A timestamp that shows when the endpoint configuration was created.
        public let creationTime: TimeStamp
        /// The name of the endpoint configuration.
        public let endpointConfigName: String
        /// The Amazon Resource Name (ARN) of the endpoint configuration.
        public let endpointConfigArn: String

        public init(creationTime: TimeStamp, endpointConfigArn: String, endpointConfigName: String) {
            self.creationTime = creationTime
            self.endpointConfigName = endpointConfigName
            self.endpointConfigArn = endpointConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case endpointConfigName = "EndpointConfigName"
            case endpointConfigArn = "EndpointConfigArn"
        }
    }

    public struct HyperParameterAlgorithmSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricDefinitions", required: false, type: .list), 
            AWSShapeMember(label: "AlgorithmName", required: false, type: .string), 
            AWSShapeMember(label: "TrainingInputMode", required: true, type: .enum), 
            AWSShapeMember(label: "TrainingImage", required: false, type: .string)
        ]
        /// An array of MetricDefinition objects that specify the metrics that the algorithm emits.
        public let metricDefinitions: [MetricDefinition]?
        /// The name of the resource algorithm to use for the hyperparameter tuning job. If you specify a value for this parameter, do not specify a value for TrainingImage.
        public let algorithmName: String?
        /// The input mode that the algorithm supports: File or Pipe. In File input mode, Amazon SageMaker downloads the training data from Amazon S3 to the storage volume that is attached to the training instance and mounts the directory to the Docker volume for the training container. In Pipe input mode, Amazon SageMaker streams data directly from Amazon S3 to the container.  If you specify File mode, make sure that you provision the storage volume that is attached to the training instance with enough capacity to accommodate the training data downloaded from Amazon S3, the model artifacts, and intermediate information.  For more information about input modes, see Algorithms. 
        public let trainingInputMode: TrainingInputMode
        ///  The registry path of the Docker image that contains the training algorithm. For information about Docker registry paths for built-in algorithms, see Algorithms Provided by Amazon SageMaker: Common Parameters.
        public let trainingImage: String?

        public init(algorithmName: String? = nil, metricDefinitions: [MetricDefinition]? = nil, trainingImage: String? = nil, trainingInputMode: TrainingInputMode) {
            self.metricDefinitions = metricDefinitions
            self.algorithmName = algorithmName
            self.trainingInputMode = trainingInputMode
            self.trainingImage = trainingImage
        }

        private enum CodingKeys: String, CodingKey {
            case metricDefinitions = "MetricDefinitions"
            case algorithmName = "AlgorithmName"
            case trainingInputMode = "TrainingInputMode"
            case trainingImage = "TrainingImage"
        }
    }

    public struct CreateWorkteamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamName", required: true, type: .string), 
            AWSShapeMember(label: "MemberDefinitions", required: true, type: .list), 
            AWSShapeMember(label: "Description", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]
        /// The name of the work team. Use this name to identify the work team.
        public let workteamName: String
        /// A list of MemberDefinition objects that contains objects that identify the Amazon Cognito user pool that makes up the work team. For more information, see Amazon Cognito User Pools. All of the CognitoMemberDefinition objects that make up the member definition must have the same ClientId and UserPool values.
        public let memberDefinitions: [MemberDefinition]
        /// A description of the work team.
        public let description: String
        public let tags: [Tag]?

        public init(description: String, memberDefinitions: [MemberDefinition], tags: [Tag]? = nil, workteamName: String) {
            self.workteamName = workteamName
            self.memberDefinitions = memberDefinitions
            self.description = description
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case workteamName = "WorkteamName"
            case memberDefinitions = "MemberDefinitions"
            case description = "Description"
            case tags = "Tags"
        }
    }

    public struct DescribeSubscribedWorkteamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubscribedWorkteam", required: true, type: .structure)
        ]
        /// A Workteam instance that contains information about the work team.
        public let subscribedWorkteam: SubscribedWorkteam

        public init(subscribedWorkteam: SubscribedWorkteam) {
            self.subscribedWorkteam = subscribedWorkteam
        }

        private enum CodingKeys: String, CodingKey {
            case subscribedWorkteam = "SubscribedWorkteam"
        }
    }

    public struct DescribeNotebookInstanceLifecycleConfigOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: false, type: .string), 
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigArn", required: false, type: .string), 
            AWSShapeMember(label: "OnCreate", required: false, type: .list), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "OnStart", required: false, type: .list), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp)
        ]
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String?
        /// The Amazon Resource Name (ARN) of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigArn: String?
        /// The shell script that runs only once, when you create a notebook instance.
        public let onCreate: [NotebookInstanceLifecycleHook]?
        /// A timestamp that tells when the lifecycle configuration was created.
        public let creationTime: TimeStamp?
        /// The shell script that runs every time you start a notebook instance, including when you create the notebook instance.
        public let onStart: [NotebookInstanceLifecycleHook]?
        /// A timestamp that tells when the lifecycle configuration was last modified.
        public let lastModifiedTime: TimeStamp?

        public init(creationTime: TimeStamp? = nil, lastModifiedTime: TimeStamp? = nil, notebookInstanceLifecycleConfigArn: String? = nil, notebookInstanceLifecycleConfigName: String? = nil, onCreate: [NotebookInstanceLifecycleHook]? = nil, onStart: [NotebookInstanceLifecycleHook]? = nil) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceLifecycleConfigArn = notebookInstanceLifecycleConfigArn
            self.onCreate = onCreate
            self.creationTime = creationTime
            self.onStart = onStart
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case notebookInstanceLifecycleConfigArn = "NotebookInstanceLifecycleConfigArn"
            case onCreate = "OnCreate"
            case creationTime = "CreationTime"
            case onStart = "OnStart"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public enum TransformJobStatus: String, CustomStringConvertible, Codable {
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        case stopping = "Stopping"
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public struct HyperParameterTuningJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ObjectiveStatusCounters", required: true, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "HyperParameterTuningEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TrainingJobStatusCounters", required: true, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningJobName", required: true, type: .string), 
            AWSShapeMember(label: "HyperParameterTuningJobArn", required: true, type: .string), 
            AWSShapeMember(label: "ResourceLimits", required: false, type: .structure), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Strategy", required: true, type: .enum)
        ]
        /// The ObjectiveStatusCounters object that specifies the numbers of training jobs, categorized by objective metric status, that this tuning job launched.
        public let objectiveStatusCounters: ObjectiveStatusCounters
        /// The status of the tuning job.
        public let hyperParameterTuningJobStatus: HyperParameterTuningJobStatus
        /// The date and time that the tuning job ended.
        public let hyperParameterTuningEndTime: TimeStamp?
        /// The TrainingJobStatusCounters object that specifies the numbers of training jobs, categorized by status, that this tuning job launched.
        public let trainingJobStatusCounters: TrainingJobStatusCounters
        /// The name of the tuning job.
        public let hyperParameterTuningJobName: String
        /// The Amazon Resource Name (ARN) of the tuning job.
        public let hyperParameterTuningJobArn: String
        /// The ResourceLimits object that specifies the maximum number of training jobs and parallel training jobs allowed for this tuning job.
        public let resourceLimits: ResourceLimits?
        /// The date and time that the tuning job was created.
        public let creationTime: TimeStamp
        /// The date and time that the tuning job was modified.
        public let lastModifiedTime: TimeStamp?
        /// Specifies the search strategy hyperparameter tuning uses to choose which hyperparameters to use for each iteration. Currently, the only valid value is Bayesian.
        public let strategy: HyperParameterTuningJobStrategyType

        public init(creationTime: TimeStamp, hyperParameterTuningEndTime: TimeStamp? = nil, hyperParameterTuningJobArn: String, hyperParameterTuningJobName: String, hyperParameterTuningJobStatus: HyperParameterTuningJobStatus, lastModifiedTime: TimeStamp? = nil, objectiveStatusCounters: ObjectiveStatusCounters, resourceLimits: ResourceLimits? = nil, strategy: HyperParameterTuningJobStrategyType, trainingJobStatusCounters: TrainingJobStatusCounters) {
            self.objectiveStatusCounters = objectiveStatusCounters
            self.hyperParameterTuningJobStatus = hyperParameterTuningJobStatus
            self.hyperParameterTuningEndTime = hyperParameterTuningEndTime
            self.trainingJobStatusCounters = trainingJobStatusCounters
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
            self.resourceLimits = resourceLimits
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.strategy = strategy
        }

        private enum CodingKeys: String, CodingKey {
            case objectiveStatusCounters = "ObjectiveStatusCounters"
            case hyperParameterTuningJobStatus = "HyperParameterTuningJobStatus"
            case hyperParameterTuningEndTime = "HyperParameterTuningEndTime"
            case trainingJobStatusCounters = "TrainingJobStatusCounters"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
            case resourceLimits = "ResourceLimits"
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case strategy = "Strategy"
        }
    }

    public enum NotebookInstanceSortOrder: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public struct LabelingJobDataAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContentClassifiers", required: false, type: .list)
        ]
        /// Declares that your content is free of personally identifiable information or adult content. Amazon SageMaker may restrict the Amazon Mechanical Turk workers that can view your task based on this information.
        public let contentClassifiers: [ContentClassifier]?

        public init(contentClassifiers: [ContentClassifier]? = nil) {
            self.contentClassifiers = contentClassifiers
        }

        private enum CodingKeys: String, CodingKey {
            case contentClassifiers = "ContentClassifiers"
        }
    }

    public enum HyperParameterTuningJobWarmStartType: String, CustomStringConvertible, Codable {
        case identicaldataandalgorithm = "IdenticalDataAndAlgorithm"
        case transferlearning = "TransferLearning"
        public var description: String { return self.rawValue }
    }

    public enum ContentClassifier: String, CustomStringConvertible, Codable {
        case freeofpersonallyidentifiableinformation = "FreeOfPersonallyIdentifiableInformation"
        case freeofadultcontent = "FreeOfAdultContent"
        public var description: String { return self.rawValue }
    }

    public struct LabelingJobOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputDatasetS3Uri", required: true, type: .string), 
            AWSShapeMember(label: "FinalActiveLearningModelArn", required: false, type: .string)
        ]
        /// The Amazon S3 bucket location of the manifest file for labeled data. 
        public let outputDatasetS3Uri: String
        /// The Amazon Resource Name (ARN) for the most recent Amazon SageMaker model trained as part of automated data labeling. 
        public let finalActiveLearningModelArn: String?

        public init(finalActiveLearningModelArn: String? = nil, outputDatasetS3Uri: String) {
            self.outputDatasetS3Uri = outputDatasetS3Uri
            self.finalActiveLearningModelArn = finalActiveLearningModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case outputDatasetS3Uri = "OutputDatasetS3Uri"
            case finalActiveLearningModelArn = "FinalActiveLearningModelArn"
        }
    }

    public struct CategoricalParameterRangeSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]
        /// The allowed categories for the hyperparameter.
        public let values: [String]

        public init(values: [String]) {
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct UpdateEndpointInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string)
        ]
        /// The name of the endpoint whose configuration you want to update.
        public let endpointName: String
        /// The name of the new endpoint configuration.
        public let endpointConfigName: String

        public init(endpointConfigName: String, endpointName: String) {
            self.endpointName = endpointName
            self.endpointConfigName = endpointConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
            case endpointConfigName = "EndpointConfigName"
        }
    }

    public struct DescribeHyperParameterTuningJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "HyperParameterTuningJobConfig", required: true, type: .structure), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "WarmStartConfig", required: false, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "BestTrainingJob", required: false, type: .structure), 
            AWSShapeMember(label: "ObjectiveStatusCounters", required: true, type: .structure), 
            AWSShapeMember(label: "TrainingJobDefinition", required: true, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningJobArn", required: true, type: .string), 
            AWSShapeMember(label: "OverallBestTrainingJob", required: false, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "HyperParameterTuningJobName", required: true, type: .string), 
            AWSShapeMember(label: "TrainingJobStatusCounters", required: true, type: .structure)
        ]
        /// The date and time that the status of the tuning job was modified. 
        public let lastModifiedTime: TimeStamp?
        /// The HyperParameterTuningJobConfig object that specifies the configuration of the tuning job.
        public let hyperParameterTuningJobConfig: HyperParameterTuningJobConfig
        /// The date and time that the tuning job started.
        public let creationTime: TimeStamp
        /// The configuration for starting the hyperparameter parameter tuning job using one or more previous tuning jobs as a starting point. The results of previous tuning jobs are used to inform which combinations of hyperparameters to search over in the new tuning job.
        public let warmStartConfig: HyperParameterTuningJobWarmStartConfig?
        /// The date and time that the tuning job ended.
        public let hyperParameterTuningEndTime: TimeStamp?
        /// If the tuning job failed, the reason it failed.
        public let failureReason: String?
        /// A TrainingJobSummary object that describes the training job that completed with the best current HyperParameterTuningJobObjective.
        public let bestTrainingJob: HyperParameterTrainingJobSummary?
        /// The ObjectiveStatusCounters object that specifies the number of training jobs, categorized by the status of their final objective metric, that this tuning job launched.
        public let objectiveStatusCounters: ObjectiveStatusCounters
        /// The HyperParameterTrainingJobDefinition object that specifies the definition of the training jobs that this tuning job launches.
        public let trainingJobDefinition: HyperParameterTrainingJobDefinition
        /// The Amazon Resource Name (ARN) of the tuning job.
        public let hyperParameterTuningJobArn: String
        /// If the hyperparameter tuning job is an warm start tuning job with a WarmStartType of IDENTICAL_DATA_AND_ALGORITHM, this is the TrainingJobSummary for the training job with the best objective metric value of all training jobs launched by this tuning job and all parent jobs specified for the warm start tuning job.
        public let overallBestTrainingJob: HyperParameterTrainingJobSummary?
        /// The status of the tuning job: InProgress, Completed, Failed, Stopping, or Stopped.
        public let hyperParameterTuningJobStatus: HyperParameterTuningJobStatus
        /// The name of the tuning job.
        public let hyperParameterTuningJobName: String
        /// The TrainingJobStatusCounters object that specifies the number of training jobs, categorized by status, that this tuning job launched.
        public let trainingJobStatusCounters: TrainingJobStatusCounters

        public init(bestTrainingJob: HyperParameterTrainingJobSummary? = nil, creationTime: TimeStamp, failureReason: String? = nil, hyperParameterTuningEndTime: TimeStamp? = nil, hyperParameterTuningJobArn: String, hyperParameterTuningJobConfig: HyperParameterTuningJobConfig, hyperParameterTuningJobName: String, hyperParameterTuningJobStatus: HyperParameterTuningJobStatus, lastModifiedTime: TimeStamp? = nil, objectiveStatusCounters: ObjectiveStatusCounters, overallBestTrainingJob: HyperParameterTrainingJobSummary? = nil, trainingJobDefinition: HyperParameterTrainingJobDefinition, trainingJobStatusCounters: TrainingJobStatusCounters, warmStartConfig: HyperParameterTuningJobWarmStartConfig? = nil) {
            self.lastModifiedTime = lastModifiedTime
            self.hyperParameterTuningJobConfig = hyperParameterTuningJobConfig
            self.creationTime = creationTime
            self.warmStartConfig = warmStartConfig
            self.hyperParameterTuningEndTime = hyperParameterTuningEndTime
            self.failureReason = failureReason
            self.bestTrainingJob = bestTrainingJob
            self.objectiveStatusCounters = objectiveStatusCounters
            self.trainingJobDefinition = trainingJobDefinition
            self.hyperParameterTuningJobArn = hyperParameterTuningJobArn
            self.overallBestTrainingJob = overallBestTrainingJob
            self.hyperParameterTuningJobStatus = hyperParameterTuningJobStatus
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.trainingJobStatusCounters = trainingJobStatusCounters
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case hyperParameterTuningJobConfig = "HyperParameterTuningJobConfig"
            case creationTime = "CreationTime"
            case warmStartConfig = "WarmStartConfig"
            case hyperParameterTuningEndTime = "HyperParameterTuningEndTime"
            case failureReason = "FailureReason"
            case bestTrainingJob = "BestTrainingJob"
            case objectiveStatusCounters = "ObjectiveStatusCounters"
            case trainingJobDefinition = "TrainingJobDefinition"
            case hyperParameterTuningJobArn = "HyperParameterTuningJobArn"
            case overallBestTrainingJob = "OverallBestTrainingJob"
            case hyperParameterTuningJobStatus = "HyperParameterTuningJobStatus"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case trainingJobStatusCounters = "TrainingJobStatusCounters"
        }
    }

    public enum ModelSortKey: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public struct LabelingJobOutputConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3OutputPath", required: true, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string)
        ]
        /// The Amazon S3 location to write output data.
        public let s3OutputPath: String
        /// The AWS Key Management Service ID of the key used to encrypt the output data, if any.
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil, s3OutputPath: String) {
            self.s3OutputPath = s3OutputPath
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputPath = "S3OutputPath"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct ModelPackageValidationProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransformJobDefinition", required: true, type: .structure), 
            AWSShapeMember(label: "ProfileName", required: true, type: .string)
        ]
        /// The TransformJobDefinition object that describes the transform job used for the validation of the model package.
        public let transformJobDefinition: TransformJobDefinition
        /// The name of the profile for the model package.
        public let profileName: String

        public init(profileName: String, transformJobDefinition: TransformJobDefinition) {
            self.transformJobDefinition = transformJobDefinition
            self.profileName = profileName
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobDefinition = "TransformJobDefinition"
            case profileName = "ProfileName"
        }
    }

    public struct DeleteAlgorithmInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmName", required: true, type: .string)
        ]
        /// The name of the algorithm to delete.
        public let algorithmName: String

        public init(algorithmName: String) {
            self.algorithmName = algorithmName
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
        }
    }

    public struct HyperParameterTuningJobConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Strategy", required: true, type: .enum), 
            AWSShapeMember(label: "HyperParameterTuningJobObjective", required: true, type: .structure), 
            AWSShapeMember(label: "ResourceLimits", required: true, type: .structure), 
            AWSShapeMember(label: "ParameterRanges", required: true, type: .structure)
        ]
        /// Specifies the search strategy for hyperparameters. Currently, the only valid value is Bayesian.
        public let strategy: HyperParameterTuningJobStrategyType
        /// The HyperParameterTuningJobObjective object that specifies the objective metric for this tuning job.
        public let hyperParameterTuningJobObjective: HyperParameterTuningJobObjective
        /// The ResourceLimits object that specifies the maximum number of training jobs and parallel training jobs for this tuning job.
        public let resourceLimits: ResourceLimits
        /// The ParameterRanges object that specifies the ranges of hyperparameters that this tuning job searches.
        public let parameterRanges: ParameterRanges

        public init(hyperParameterTuningJobObjective: HyperParameterTuningJobObjective, parameterRanges: ParameterRanges, resourceLimits: ResourceLimits, strategy: HyperParameterTuningJobStrategyType) {
            self.strategy = strategy
            self.hyperParameterTuningJobObjective = hyperParameterTuningJobObjective
            self.resourceLimits = resourceLimits
            self.parameterRanges = parameterRanges
        }

        private enum CodingKeys: String, CodingKey {
            case strategy = "Strategy"
            case hyperParameterTuningJobObjective = "HyperParameterTuningJobObjective"
            case resourceLimits = "ResourceLimits"
            case parameterRanges = "ParameterRanges"
        }
    }

    public struct ParameterRanges: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CategoricalParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "ContinuousParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "IntegerParameterRanges", required: false, type: .list)
        ]
        /// The array of CategoricalParameterRange objects that specify ranges of categorical hyperparameters that a hyperparameter tuning job searches.
        public let categoricalParameterRanges: [CategoricalParameterRange]?
        /// The array of ContinuousParameterRange objects that specify ranges of continuous hyperparameters that a hyperparameter tuning job searches.
        public let continuousParameterRanges: [ContinuousParameterRange]?
        /// The array of IntegerParameterRange objects that specify ranges of integer hyperparameters that a hyperparameter tuning job searches.
        public let integerParameterRanges: [IntegerParameterRange]?

        public init(categoricalParameterRanges: [CategoricalParameterRange]? = nil, continuousParameterRanges: [ContinuousParameterRange]? = nil, integerParameterRanges: [IntegerParameterRange]? = nil) {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRanges = "CategoricalParameterRanges"
            case continuousParameterRanges = "ContinuousParameterRanges"
            case integerParameterRanges = "IntegerParameterRanges"
        }
    }

    public struct CategoricalParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Values", required: true, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A list of the categories for the hyperparameter.
        public let values: [String]
        /// The name of the categorical hyperparameter to tune.
        public let name: String

        public init(name: String, values: [String]) {
            self.values = values
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
            case name = "Name"
        }
    }

    public struct TrainingJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "TrainingJobName", required: true, type: .string), 
            AWSShapeMember(label: "TrainingJobArn", required: true, type: .string), 
            AWSShapeMember(label: "TrainingEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TrainingJobStatus", required: true, type: .enum)
        ]
        ///  Timestamp when the training job was last modified. 
        public let lastModifiedTime: TimeStamp?
        /// A timestamp that shows when the training job was created.
        public let creationTime: TimeStamp
        /// The name of the training job that you want a summary for.
        public let trainingJobName: String
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String
        /// A timestamp that shows when the training job ended. This field is set only if the training job has one of the terminal statuses (Completed, Failed, or Stopped). 
        public let trainingEndTime: TimeStamp?
        /// The status of the training job.
        public let trainingJobStatus: TrainingJobStatus

        public init(creationTime: TimeStamp, lastModifiedTime: TimeStamp? = nil, trainingEndTime: TimeStamp? = nil, trainingJobArn: String, trainingJobName: String, trainingJobStatus: TrainingJobStatus) {
            self.lastModifiedTime = lastModifiedTime
            self.creationTime = creationTime
            self.trainingJobName = trainingJobName
            self.trainingJobArn = trainingJobArn
            self.trainingEndTime = trainingEndTime
            self.trainingJobStatus = trainingJobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case creationTime = "CreationTime"
            case trainingJobName = "TrainingJobName"
            case trainingJobArn = "TrainingJobArn"
            case trainingEndTime = "TrainingEndTime"
            case trainingJobStatus = "TrainingJobStatus"
        }
    }

    public struct CreateModelOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelArn", required: true, type: .string)
        ]
        /// The ARN of the model created in Amazon SageMaker.
        public let modelArn: String

        public init(modelArn: String) {
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "ModelArn"
        }
    }

    public enum S3DataType: String, CustomStringConvertible, Codable {
        case manifestfile = "ManifestFile"
        case s3prefix = "S3Prefix"
        case augmentedmanifestfile = "AugmentedManifestFile"
        public var description: String { return self.rawValue }
    }

    public struct UpdateNotebookInstanceLifecycleConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: true, type: .string), 
            AWSShapeMember(label: "OnCreate", required: false, type: .list), 
            AWSShapeMember(label: "OnStart", required: false, type: .list)
        ]
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String
        /// The shell script that runs only once, when you create a notebook instance
        public let onCreate: [NotebookInstanceLifecycleHook]?
        /// The shell script that runs every time you start a notebook instance, including when you create the notebook instance.
        public let onStart: [NotebookInstanceLifecycleHook]?

        public init(notebookInstanceLifecycleConfigName: String, onCreate: [NotebookInstanceLifecycleHook]? = nil, onStart: [NotebookInstanceLifecycleHook]? = nil) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.onCreate = onCreate
            self.onStart = onStart
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case onCreate = "OnCreate"
            case onStart = "OnStart"
        }
    }

    public struct UpdateNotebookInstanceOutput: AWSShape {

        public init() {
        }

    }

    public struct ListNotebookInstanceLifecycleConfigsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A filter that returns only lifecycle configurations that were created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// A filter that returns only lifecycle configurations that were created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// A filter that returns only lifecycle configurations that were modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: TimeStamp?
        /// Sorts the list of results. The default is CreationTime.
        public let sortBy: NotebookInstanceLifecycleConfigSortKey?
        /// A filter that returns only lifecycle configurations that were modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: TimeStamp?
        /// The sort order for results.
        public let sortOrder: NotebookInstanceLifecycleConfigSortOrder?
        /// A string in the lifecycle configuration name. This filter returns only lifecycle configurations whose name contains the specified string.
        public let nameContains: String?
        /// The maximum number of lifecycle configurations to return in the response.
        public let maxResults: Int32?
        /// If the result of a ListNotebookInstanceLifecycleConfigs request was truncated, the response includes a NextToken. To get the next set of lifecycle configurations, use the token in the next request.
        public let nextToken: String?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: NotebookInstanceLifecycleConfigSortKey? = nil, sortOrder: NotebookInstanceLifecycleConfigSortOrder? = nil) {
            self.creationTimeBefore = creationTimeBefore
            self.creationTimeAfter = creationTimeAfter
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.sortBy = sortBy
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.sortOrder = sortOrder
            self.nameContains = nameContains
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeBefore = "CreationTimeBefore"
            case creationTimeAfter = "CreationTimeAfter"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case sortBy = "SortBy"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case sortOrder = "SortOrder"
            case nameContains = "NameContains"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public enum CompressionType: String, CustomStringConvertible, Codable {
        case none = "None"
        case gzip = "Gzip"
        public var description: String { return self.rawValue }
    }

    public struct DescribeModelInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelName", required: true, type: .string)
        ]
        /// The name of the model.
        public let modelName: String

        public init(modelName: String) {
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
        }
    }

    public struct ListNotebookInstancesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "DefaultCodeRepositoryContains", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigNameContains", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "AdditionalCodeRepositoryEquals", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum)
        ]
        ///  If the previous call to the ListNotebookInstances is truncated, the response includes a NextToken. You can use this token in your subsequent ListNotebookInstances request to fetch the next set of notebook instances.    You might specify a filter or a sort order in your request. When response is truncated, you must use the same values for the filer and sort order in the next request.  
        public let nextToken: String?
        /// A filter that returns only notebook instances with the specified status.
        public let statusEquals: NotebookInstanceStatus?
        /// The sort order for results. 
        public let sortOrder: NotebookInstanceSortOrder?
        /// A filter that returns only notebook instances that were modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: TimeStamp?
        /// A string in the name or URL of a git repository associated with this notebook instance. This filter returns only notebook instances associated with a git repository with a name that contains the specified string.
        public let defaultCodeRepositoryContains: String?
        /// A filter that returns only notebook instances that were created before the specified time (timestamp). 
        public let creationTimeBefore: TimeStamp?
        /// A filter that returns only notebook instances that were modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: TimeStamp?
        /// A string in the name of a notebook instances lifecycle configuration associated with this notebook instance. This filter returns only notebook instances associated with a lifecycle configuration with a name that contains the specified string.
        public let notebookInstanceLifecycleConfigNameContains: String?
        /// A filter that returns only notebook instances that were created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// A string in the notebook instances' name. This filter returns only notebook instances whose name contains the specified string.
        public let nameContains: String?
        /// A filter that returns only notebook instances with associated with the specified git respository.
        public let additionalCodeRepositoryEquals: String?
        /// The maximum number of notebook instances to return.
        public let maxResults: Int32?
        /// The field to sort results by. The default is Name.
        public let sortBy: NotebookInstanceSortKey?

        public init(additionalCodeRepositoryEquals: String? = nil, creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, defaultCodeRepositoryContains: String? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, notebookInstanceLifecycleConfigNameContains: String? = nil, sortBy: NotebookInstanceSortKey? = nil, sortOrder: NotebookInstanceSortOrder? = nil, statusEquals: NotebookInstanceStatus? = nil) {
            self.nextToken = nextToken
            self.statusEquals = statusEquals
            self.sortOrder = sortOrder
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.defaultCodeRepositoryContains = defaultCodeRepositoryContains
            self.creationTimeBefore = creationTimeBefore
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.notebookInstanceLifecycleConfigNameContains = notebookInstanceLifecycleConfigNameContains
            self.creationTimeAfter = creationTimeAfter
            self.nameContains = nameContains
            self.additionalCodeRepositoryEquals = additionalCodeRepositoryEquals
            self.maxResults = maxResults
            self.sortBy = sortBy
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case statusEquals = "StatusEquals"
            case sortOrder = "SortOrder"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case defaultCodeRepositoryContains = "DefaultCodeRepositoryContains"
            case creationTimeBefore = "CreationTimeBefore"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case notebookInstanceLifecycleConfigNameContains = "NotebookInstanceLifecycleConfigNameContains"
            case creationTimeAfter = "CreationTimeAfter"
            case nameContains = "NameContains"
            case additionalCodeRepositoryEquals = "AdditionalCodeRepositoryEquals"
            case maxResults = "MaxResults"
            case sortBy = "SortBy"
        }
    }

    public enum AlgorithmSortBy: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum TargetDevice: String, CustomStringConvertible, Codable {
        case mlM4 = "ml_m4"
        case mlM5 = "ml_m5"
        case mlC4 = "ml_c4"
        case mlC5 = "ml_c5"
        case mlP2 = "ml_p2"
        case mlP3 = "ml_p3"
        case jetsonTx1 = "jetson_tx1"
        case jetsonTx2 = "jetson_tx2"
        case rasp3b = "rasp3b"
        case deeplens = "deeplens"
        public var description: String { return self.rawValue }
    }

    public struct LabelingJobStoppingConditions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxPercentageOfInputDatasetLabeled", required: false, type: .integer), 
            AWSShapeMember(label: "MaxHumanLabeledObjectCount", required: false, type: .integer)
        ]
        /// The maximum number of input data objects that should be labeled.
        public let maxPercentageOfInputDatasetLabeled: Int32?
        /// The maximum number of objects that can be labeled by human workers.
        public let maxHumanLabeledObjectCount: Int32?

        public init(maxHumanLabeledObjectCount: Int32? = nil, maxPercentageOfInputDatasetLabeled: Int32? = nil) {
            self.maxPercentageOfInputDatasetLabeled = maxPercentageOfInputDatasetLabeled
            self.maxHumanLabeledObjectCount = maxHumanLabeledObjectCount
        }

        private enum CodingKeys: String, CodingKey {
            case maxPercentageOfInputDatasetLabeled = "MaxPercentageOfInputDatasetLabeled"
            case maxHumanLabeledObjectCount = "MaxHumanLabeledObjectCount"
        }
    }

    public struct SearchRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingJob", required: false, type: .structure)
        ]
        /// A TrainingJob object that is returned as part of a Search request.
        public let trainingJob: TrainingJob?

        public init(trainingJob: TrainingJob? = nil) {
            self.trainingJob = trainingJob
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJob = "TrainingJob"
        }
    }

    public struct DeleteTagsOutput: AWSShape {

        public init() {
        }

    }

    public struct TransformS3DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3DataType", required: true, type: .enum), 
            AWSShapeMember(label: "S3Uri", required: true, type: .string)
        ]
        /// If you choose S3Prefix, S3Uri identifies a key name prefix. Amazon SageMaker uses all objects with the specified key name prefix for batch transform.  If you choose ManifestFile, S3Uri identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch transform. 
        public let s3DataType: S3DataType
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest. For example:    A key name prefix might look like this: s3://bucketname/exampleprefix.     A manifest might look like this: s3://bucketname/example.manifest   The manifest is an S3 object which is a JSON file with the following format:   [    {"prefix": "s3://customer_bucket/some/prefix/"},    "relative/path/to/custdata-1",    "relative/path/custdata-2",    ...    ]   The preceding JSON matches the following S3Uris:   s3://customer_bucket/some/prefix/relative/path/to/custdata-1   s3://customer_bucket/some/prefix/relative/path/custdata-1   ...   The complete set of S3Uris in this manifest constitutes the input data for the channel for this datasource. The object that each S3Uris points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.  
        public let s3Uri: String

        public init(s3DataType: S3DataType, s3Uri: String) {
            self.s3DataType = s3DataType
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataType = "S3DataType"
            case s3Uri = "S3Uri"
        }
    }

    public enum ListLabelingJobsForWorkteamSortByOptions: String, CustomStringConvertible, Codable {
        case creationtime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public struct CompilationJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompilationJobName", required: true, type: .string), 
            AWSShapeMember(label: "CompilationTargetDevice", required: true, type: .enum), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CompilationEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CompilationJobArn", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CompilationJobStatus", required: true, type: .enum)
        ]
        /// The name of the model compilation job that you want a summary for.
        public let compilationJobName: String
        /// The type of device that the model will run on after compilation has completed.
        public let compilationTargetDevice: TargetDevice
        /// The time when the model compilation job was last modified.
        public let lastModifiedTime: TimeStamp?
        /// The time when the model compilation job completed.
        public let compilationEndTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the model compilation job.
        public let compilationJobArn: String
        /// The time when the model compilation job was created.
        public let creationTime: TimeStamp
        /// The status of the model compilation job.
        public let compilationJobStatus: CompilationJobStatus

        public init(compilationEndTime: TimeStamp? = nil, compilationJobArn: String, compilationJobName: String, compilationJobStatus: CompilationJobStatus, compilationTargetDevice: TargetDevice, creationTime: TimeStamp, lastModifiedTime: TimeStamp? = nil) {
            self.compilationJobName = compilationJobName
            self.compilationTargetDevice = compilationTargetDevice
            self.lastModifiedTime = lastModifiedTime
            self.compilationEndTime = compilationEndTime
            self.compilationJobArn = compilationJobArn
            self.creationTime = creationTime
            self.compilationJobStatus = compilationJobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
            case compilationTargetDevice = "CompilationTargetDevice"
            case lastModifiedTime = "LastModifiedTime"
            case compilationEndTime = "CompilationEndTime"
            case compilationJobArn = "CompilationJobArn"
            case creationTime = "CreationTime"
            case compilationJobStatus = "CompilationJobStatus"
        }
    }

    public struct CreateModelInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "ExecutionRoleArn", required: true, type: .string), 
            AWSShapeMember(label: "PrimaryContainer", required: false, type: .structure), 
            AWSShapeMember(label: "ModelName", required: true, type: .string), 
            AWSShapeMember(label: "EnableNetworkIsolation", required: false, type: .boolean), 
            AWSShapeMember(label: "Containers", required: false, type: .list)
        ]
        /// A VpcConfig object that specifies the VPC that you want your model to connect to. Control access to and from your model container by configuring the VPC. VpcConfig is used in hosting services and in batch transform. For more information, see Protect Endpoints by Using an Amazon Virtual Private Cloud and Protect Data in Batch Transform Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?
        /// An array of key-value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide. 
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the IAM role that Amazon SageMaker can assume to access model artifacts and docker image for deployment on ML compute instances or for batch transform jobs. Deploying on ML compute instances is part of model hosting. For more information, see Amazon SageMaker Roles.   To be able to pass this role to Amazon SageMaker, the caller of this API must have the iam:PassRole permission. 
        public let executionRoleArn: String
        /// The location of the primary docker image containing inference code, associated artifacts, and custom environment map that the inference code uses when the model is deployed for predictions. 
        public let primaryContainer: ContainerDefinition?
        /// The name of the new model.
        public let modelName: String
        /// Isolates the model container. No inbound or outbound network calls can be made to or from the model container.  The Semantic Segmentation built-in algorithm does not support network isolation. 
        public let enableNetworkIsolation: Bool?
        /// Specifies the containers in the inference pipeline.
        public let containers: [ContainerDefinition]?

        public init(containers: [ContainerDefinition]? = nil, enableNetworkIsolation: Bool? = nil, executionRoleArn: String, modelName: String, primaryContainer: ContainerDefinition? = nil, tags: [Tag]? = nil, vpcConfig: VpcConfig? = nil) {
            self.vpcConfig = vpcConfig
            self.tags = tags
            self.executionRoleArn = executionRoleArn
            self.primaryContainer = primaryContainer
            self.modelName = modelName
            self.enableNetworkIsolation = enableNetworkIsolation
            self.containers = containers
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConfig = "VpcConfig"
            case tags = "Tags"
            case executionRoleArn = "ExecutionRoleArn"
            case primaryContainer = "PrimaryContainer"
            case modelName = "ModelName"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case containers = "Containers"
        }
    }

    public struct RenderUiTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RenderedContent", required: true, type: .string), 
            AWSShapeMember(label: "Errors", required: true, type: .list)
        ]
        /// A Liquid template that renders the HTML for the worker UI.
        public let renderedContent: String
        /// A list of one or more RenderingError objects if any were encountered while rendering the template. If there were no errors, the list is empty.
        public let errors: [RenderingError]

        public init(errors: [RenderingError], renderedContent: String) {
            self.renderedContent = renderedContent
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case renderedContent = "RenderedContent"
            case errors = "Errors"
        }
    }

    public struct UpdateEndpointOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct UpdateWorkteamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamName", required: true, type: .string), 
            AWSShapeMember(label: "MemberDefinitions", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The name of the work team to update.
        public let workteamName: String
        /// A list of MemberDefinition objects that contain the updated work team members.
        public let memberDefinitions: [MemberDefinition]?
        /// An updated description for the work team.
        public let description: String?

        public init(description: String? = nil, memberDefinitions: [MemberDefinition]? = nil, workteamName: String) {
            self.workteamName = workteamName
            self.memberDefinitions = memberDefinitions
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case workteamName = "WorkteamName"
            case memberDefinitions = "MemberDefinitions"
            case description = "Description"
        }
    }

    public struct CreateAlgorithmOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the new algorithm.
        public let algorithmArn: String

        public init(algorithmArn: String) {
            self.algorithmArn = algorithmArn
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
        }
    }

    public struct CreateTrainingJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingJobArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String

        public init(trainingJobArn: String) {
            self.trainingJobArn = trainingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobArn = "TrainingJobArn"
        }
    }

    public struct ListSubscribedWorkteamsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The maximum number of work teams to return in each page of the response.
        public let maxResults: Int32?
        /// A string in the work team name. This filter returns only work teams whose name contains the specified string.
        public let nameContains: String?
        /// If the result of the previous ListSubscribedWorkteams request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeCompilationJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompilationJobName", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CompilationStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "InputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "CompilationEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ModelArtifacts", required: true, type: .structure), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CompilationJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "CompilationJobArn", required: true, type: .string), 
            AWSShapeMember(label: "StoppingCondition", required: true, type: .structure), 
            AWSShapeMember(label: "FailureReason", required: true, type: .string), 
            AWSShapeMember(label: "OutputConfig", required: true, type: .structure)
        ]
        /// The name of the model compilation job.
        public let compilationJobName: String
        /// The Amazon Resource Name (ARN) of the model compilation job.
        public let roleArn: String
        /// The time that the status of the model compilation job was last modified.
        public let lastModifiedTime: TimeStamp
        /// The time when the model compilation job started the CompilationJob instances.  You are billed for the time between this timestamp and the timestamp in the DescribeCompilationJobResponse$CompilationEndTime field. In Amazon CloudWatch Logs, the start time might be later than this time. That's because it takes time to download the compilation job, which depends on the size of the compilation job container. 
        public let compilationStartTime: TimeStamp?
        /// Information about the location in Amazon S3 of the input model artifacts, the name and shape of the expected data inputs, and the framework in which the model was trained.
        public let inputConfig: InputConfig
        /// The time when the model compilation job on a compilation job instance ended. For a successful or stopped job, this is when the job's model artifacts have finished uploading. For a failed job, this is when Amazon SageMaker detected that the job failed. 
        public let compilationEndTime: TimeStamp?
        /// Information about the location in Amazon S3 that has been configured for storing the model artifacts used in the compilation job.
        public let modelArtifacts: ModelArtifacts
        /// The time that the model compilation job was created.
        public let creationTime: TimeStamp
        /// The status of the model compilation job.
        public let compilationJobStatus: CompilationJobStatus
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker assumes to perform the model compilation job.
        public let compilationJobArn: String
        /// The duration allowed for model compilation.
        public let stoppingCondition: StoppingCondition
        /// If a model compilation job failed, the reason it failed. 
        public let failureReason: String
        /// Information about the output location for the compiled model and the target device that the model runs on.
        public let outputConfig: OutputConfig

        public init(compilationEndTime: TimeStamp? = nil, compilationJobArn: String, compilationJobName: String, compilationJobStatus: CompilationJobStatus, compilationStartTime: TimeStamp? = nil, creationTime: TimeStamp, failureReason: String, inputConfig: InputConfig, lastModifiedTime: TimeStamp, modelArtifacts: ModelArtifacts, outputConfig: OutputConfig, roleArn: String, stoppingCondition: StoppingCondition) {
            self.compilationJobName = compilationJobName
            self.roleArn = roleArn
            self.lastModifiedTime = lastModifiedTime
            self.compilationStartTime = compilationStartTime
            self.inputConfig = inputConfig
            self.compilationEndTime = compilationEndTime
            self.modelArtifacts = modelArtifacts
            self.creationTime = creationTime
            self.compilationJobStatus = compilationJobStatus
            self.compilationJobArn = compilationJobArn
            self.stoppingCondition = stoppingCondition
            self.failureReason = failureReason
            self.outputConfig = outputConfig
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
            case roleArn = "RoleArn"
            case lastModifiedTime = "LastModifiedTime"
            case compilationStartTime = "CompilationStartTime"
            case inputConfig = "InputConfig"
            case compilationEndTime = "CompilationEndTime"
            case modelArtifacts = "ModelArtifacts"
            case creationTime = "CreationTime"
            case compilationJobStatus = "CompilationJobStatus"
            case compilationJobArn = "CompilationJobArn"
            case stoppingCondition = "StoppingCondition"
            case failureReason = "FailureReason"
            case outputConfig = "OutputConfig"
        }
    }

    public struct DeleteEndpointConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string)
        ]
        /// The name of the endpoint configuration that you want to delete.
        public let endpointConfigName: String

        public init(endpointConfigName: String) {
            self.endpointConfigName = endpointConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigName = "EndpointConfigName"
        }
    }

    public struct UiTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Content", required: true, type: .string)
        ]
        /// The content of the Liquid template for the worker user interface.
        public let content: String

        public init(content: String) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct CreateNotebookInstanceOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the notebook instance. 
        public let notebookInstanceArn: String?

        public init(notebookInstanceArn: String? = nil) {
            self.notebookInstanceArn = notebookInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceArn = "NotebookInstanceArn"
        }
    }

    public struct CreateNotebookInstanceLifecycleConfigOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigArn: String?

        public init(notebookInstanceLifecycleConfigArn: String? = nil) {
            self.notebookInstanceLifecycleConfigArn = notebookInstanceLifecycleConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigArn = "NotebookInstanceLifecycleConfigArn"
        }
    }

    public struct CreateEndpointConfigOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the endpoint configuration. 
        public let endpointConfigArn: String

        public init(endpointConfigArn: String) {
            self.endpointConfigArn = endpointConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigArn = "EndpointConfigArn"
        }
    }

    public enum HyperParameterTuningJobSortByOptions: String, CustomStringConvertible, Codable {
        case name = "Name"
        case status = "Status"
        case creationtime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public struct CreateEndpointConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "ProductionVariants", required: true, type: .list)
        ]
        /// An array of key-value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide. 
        public let tags: [Tag]?
        /// The name of the endpoint configuration. You specify this name in a CreateEndpoint request. 
        public let endpointConfigName: String
        /// The Amazon Resource Name (ARN) of a AWS Key Management Service key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance that hosts the endpoint.
        public let kmsKeyId: String?
        /// An array of ProductionVariant objects, one for each model that you want to host at this endpoint.
        public let productionVariants: [ProductionVariant]

        public init(endpointConfigName: String, kmsKeyId: String? = nil, productionVariants: [ProductionVariant], tags: [Tag]? = nil) {
            self.tags = tags
            self.endpointConfigName = endpointConfigName
            self.kmsKeyId = kmsKeyId
            self.productionVariants = productionVariants
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case endpointConfigName = "EndpointConfigName"
            case kmsKeyId = "KmsKeyId"
            case productionVariants = "ProductionVariants"
        }
    }

    public struct DescribeCodeRepositoryOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CodeRepositoryName", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "CodeRepositoryArn", required: true, type: .string), 
            AWSShapeMember(label: "GitConfig", required: false, type: .structure)
        ]
        /// The date and time that the repository was last changed.
        public let lastModifiedTime: TimeStamp
        /// The name of the git repository.
        public let codeRepositoryName: String
        /// The date and time that the repository was created.
        public let creationTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the git repository.
        public let codeRepositoryArn: String
        /// Configuration details about the repository, including the URL where the repository is located, the default branch, and the Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the repository.
        public let gitConfig: GitConfig?

        public init(codeRepositoryArn: String, codeRepositoryName: String, creationTime: TimeStamp, gitConfig: GitConfig? = nil, lastModifiedTime: TimeStamp) {
            self.lastModifiedTime = lastModifiedTime
            self.codeRepositoryName = codeRepositoryName
            self.creationTime = creationTime
            self.codeRepositoryArn = codeRepositoryArn
            self.gitConfig = gitConfig
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case codeRepositoryName = "CodeRepositoryName"
            case creationTime = "CreationTime"
            case codeRepositoryArn = "CodeRepositoryArn"
            case gitConfig = "GitConfig"
        }
    }

    public enum S3DataDistribution: String, CustomStringConvertible, Codable {
        case fullyreplicated = "FullyReplicated"
        case shardedbys3key = "ShardedByS3Key"
        public var description: String { return self.rawValue }
    }

    public struct DescribeNotebookInstanceOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DefaultCodeRepository", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "NotebookInstanceStatus", required: false, type: .enum), 
            AWSShapeMember(label: "DirectInternetAccess", required: false, type: .enum), 
            AWSShapeMember(label: "VolumeSizeInGB", required: false, type: .integer), 
            AWSShapeMember(label: "InstanceType", required: false, type: .enum), 
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: false, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "NotebookInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "AcceleratorTypes", required: false, type: .list), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroups", required: false, type: .list), 
            AWSShapeMember(label: "AdditionalCodeRepositories", required: false, type: .list), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "NotebookInstanceName", required: false, type: .string), 
            AWSShapeMember(label: "NetworkInterfaceId", required: false, type: .string)
        ]
        /// A timestamp. Use this parameter to retrieve the time when the notebook instance was last modified. 
        public let lastModifiedTime: TimeStamp?
        /// The git repository associated with the notebook instance as its default code repository. This can be either the name of a git repository stored as a resource in your account, or the URL of a git repository in AWS CodeCommit or in any other git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// The URL that you use to connect to the Jupyter notebook that is running in your notebook instance. 
        public let url: String?
        /// The status of the notebook instance.
        public let notebookInstanceStatus: NotebookInstanceStatus?
        /// Describes whether Amazon SageMaker provides internet access to the notebook instance. If this value is set to Disabled, he notebook instance does not have internet access, and cannot connect to Amazon SageMaker training and endpoint services. For more information, see Notebook Instances Are Internet-Enabled by Default.
        public let directInternetAccess: DirectInternetAccess?
        /// The size, in GB, of the ML storage volume attached to the notebook instance.
        public let volumeSizeInGB: Int32?
        /// The type of ML compute instance running on the notebook instance.
        public let instanceType: InstanceType?
        /// Returns the name of a notebook instance lifecycle configuration. For information about notebook instance lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance 
        public let notebookInstanceLifecycleConfigName: String?
        /// If status is failed, the reason it failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String?
        ///  AWS KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage volume attached to the instance. 
        public let kmsKeyId: String?
        /// A list of the Elastic Inference (EI) instance types associated with this notebook instance. Currently only one EI instance type can be associated with a notebook instance. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorTypes: [NotebookInstanceAcceleratorType]?
        ///  Amazon Resource Name (ARN) of the IAM role associated with the instance. 
        public let roleArn: String?
        /// The IDs of the VPC security groups.
        public let securityGroups: [String]?
        /// An array of up to 3 git repositories associated with the notebook instance. These can be either the names of git repositories stored as resources in your account, or the URL of git repositories in AWS CodeCommit or in any other git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// The ID of the VPC subnet.
        public let subnetId: String?
        /// A timestamp. Use this parameter to return the time when the notebook instance was created
        public let creationTime: TimeStamp?
        ///  Name of the Amazon SageMaker notebook instance. 
        public let notebookInstanceName: String?
        ///  Network interface IDs that Amazon SageMaker created at the time of creating the instance. 
        public let networkInterfaceId: String?

        public init(acceleratorTypes: [NotebookInstanceAcceleratorType]? = nil, additionalCodeRepositories: [String]? = nil, creationTime: TimeStamp? = nil, defaultCodeRepository: String? = nil, directInternetAccess: DirectInternetAccess? = nil, failureReason: String? = nil, instanceType: InstanceType? = nil, kmsKeyId: String? = nil, lastModifiedTime: TimeStamp? = nil, networkInterfaceId: String? = nil, notebookInstanceArn: String? = nil, notebookInstanceLifecycleConfigName: String? = nil, notebookInstanceName: String? = nil, notebookInstanceStatus: NotebookInstanceStatus? = nil, roleArn: String? = nil, securityGroups: [String]? = nil, subnetId: String? = nil, url: String? = nil, volumeSizeInGB: Int32? = nil) {
            self.lastModifiedTime = lastModifiedTime
            self.defaultCodeRepository = defaultCodeRepository
            self.url = url
            self.notebookInstanceStatus = notebookInstanceStatus
            self.directInternetAccess = directInternetAccess
            self.volumeSizeInGB = volumeSizeInGB
            self.instanceType = instanceType
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.failureReason = failureReason
            self.notebookInstanceArn = notebookInstanceArn
            self.kmsKeyId = kmsKeyId
            self.acceleratorTypes = acceleratorTypes
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.additionalCodeRepositories = additionalCodeRepositories
            self.subnetId = subnetId
            self.creationTime = creationTime
            self.notebookInstanceName = notebookInstanceName
            self.networkInterfaceId = networkInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case defaultCodeRepository = "DefaultCodeRepository"
            case url = "Url"
            case notebookInstanceStatus = "NotebookInstanceStatus"
            case directInternetAccess = "DirectInternetAccess"
            case volumeSizeInGB = "VolumeSizeInGB"
            case instanceType = "InstanceType"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case failureReason = "FailureReason"
            case notebookInstanceArn = "NotebookInstanceArn"
            case kmsKeyId = "KmsKeyId"
            case acceleratorTypes = "AcceleratorTypes"
            case roleArn = "RoleArn"
            case securityGroups = "SecurityGroups"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case subnetId = "SubnetId"
            case creationTime = "CreationTime"
            case notebookInstanceName = "NotebookInstanceName"
            case networkInterfaceId = "NetworkInterfaceId"
        }
    }

    public enum TransformInstanceType: String, CustomStringConvertible, Codable {
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        public var description: String { return self.rawValue }
    }

    public struct SearchRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "SortBy", required: false, type: .string), 
            AWSShapeMember(label: "Resource", required: true, type: .enum), 
            AWSShapeMember(label: "SearchExpression", required: false, type: .structure), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// If more than MaxResults resource objects match the specified SearchExpression, the SearchResponse includes a NextToken. The NextToken can be passed to the next SearchRequest to continue retrieving results for the specified SearchExpression and Sort parameters.
        public let nextToken: String?
        /// How SearchResults are ordered. Valid values are Ascending or Descending.
        public let sortOrder: SearchSortOrder?
        /// The name of the resource property used to sort the SearchResults.
        public let sortBy: String?
        /// The name of the Amazon SageMaker resource to search for. Currently, the only valid Resource value is TrainingJob.
        public let resource: ResourceType
        /// A Boolean conditional statement. Resource objects must satisfy this condition to be included in search results.
        public let searchExpression: SearchExpression?
        /// The maximum number of results to return in a SearchResponse.
        public let maxResults: Int32?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, resource: ResourceType, searchExpression: SearchExpression? = nil, sortBy: String? = nil, sortOrder: SearchSortOrder? = nil) {
            self.nextToken = nextToken
            self.sortOrder = sortOrder
            self.sortBy = sortBy
            self.resource = resource
            self.searchExpression = searchExpression
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sortOrder = "SortOrder"
            case sortBy = "SortBy"
            case resource = "Resource"
            case searchExpression = "SearchExpression"
            case maxResults = "MaxResults"
        }
    }

    public enum Framework: String, CustomStringConvertible, Codable {
        case tensorflow = "TENSORFLOW"
        case mxnet = "MXNET"
        case onnx = "ONNX"
        case pytorch = "PYTORCH"
        case xgboost = "XGBOOST"
        public var description: String { return self.rawValue }
    }

    public struct DescribeLabelingJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LabelingJobName", required: true, type: .string)
        ]
        /// The name of the labeling job to return information for.
        public let labelingJobName: String

        public init(labelingJobName: String) {
            self.labelingJobName = labelingJobName
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobName = "LabelingJobName"
        }
    }

    public struct StopCompilationJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompilationJobName", required: true, type: .string)
        ]
        /// The name of the model compilation job to stop.
        public let compilationJobName: String

        public init(compilationJobName: String) {
            self.compilationJobName = compilationJobName
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
        }
    }

    public struct CreateEndpointOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct NotebookInstanceLifecycleConfigSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigArn", required: true, type: .string)
        ]
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String
        /// A timestamp that tells when the lifecycle configuration was created.
        public let creationTime: TimeStamp?
        /// A timestamp that tells when the lifecycle configuration was last modified.
        public let lastModifiedTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigArn: String

        public init(creationTime: TimeStamp? = nil, lastModifiedTime: TimeStamp? = nil, notebookInstanceLifecycleConfigArn: String, notebookInstanceLifecycleConfigName: String) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.notebookInstanceLifecycleConfigArn = notebookInstanceLifecycleConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case creationTime = "CreationTime"
            case lastModifiedTime = "LastModifiedTime"
            case notebookInstanceLifecycleConfigArn = "NotebookInstanceLifecycleConfigArn"
        }
    }

    public struct DescribeLabelingJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "OutputConfig", required: true, type: .structure), 
            AWSShapeMember(label: "StoppingConditions", required: false, type: .structure), 
            AWSShapeMember(label: "LabelingJobOutput", required: false, type: .structure), 
            AWSShapeMember(label: "LabelCategoryConfigS3Uri", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "LabelAttributeName", required: false, type: .string), 
            AWSShapeMember(label: "LabelCounters", required: true, type: .structure), 
            AWSShapeMember(label: "JobReferenceCode", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "LabelingJobArn", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobName", required: true, type: .string), 
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "HumanTaskConfig", required: true, type: .structure), 
            AWSShapeMember(label: "LabelingJobAlgorithmsConfig", required: false, type: .structure)
        ]
        /// Input configuration information for the labeling job, such as the Amazon S3 location of the data objects and the location of the manifest file that describes the data objects.
        public let inputConfig: LabelingJobInputConfig
        /// The location of the job's output data and the AWS Key Management Service key ID for the key used to encrypt the output data, if any.
        public let outputConfig: LabelingJobOutputConfig
        /// A set of conditions for stopping a labeling job. If any of the conditions are met, the job is automatically stopped.
        public let stoppingConditions: LabelingJobStoppingConditions?
        /// The location of the output produced by the labeling job.
        public let labelingJobOutput: LabelingJobOutput?
        /// The S3 location of the JSON file that defines the categories used to label data objects.
        public let labelCategoryConfigS3Uri: String?
        /// The Amazon Resource Name (ARN) that Amazon SageMaker assumes to perform tasks on your behalf during data labeling.
        public let roleArn: String
        /// If the job failed, the reason that it failed. 
        public let failureReason: String?
        /// An array of key/value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide.
        public let tags: [Tag]?
        /// The attribute used as the label in the output manifest file.
        public let labelAttributeName: String?
        /// Provides a breakdown of the number of data objects labeled by humans, the number of objects labeled by machine, the number of objects than couldn't be labeled, and the total number of objects labeled. 
        public let labelCounters: LabelCounters
        /// A unique identifier for work done as part of a labeling job.
        public let jobReferenceCode: String
        /// The processing status of the labeling job. 
        public let labelingJobStatus: LabelingJobStatus
        /// The date and time that the labeling job was created.
        public let creationTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the labeling job.
        public let labelingJobArn: String
        /// The name assigned to the labeling job when it was created.
        public let labelingJobName: String
        /// The date and time that the labeling job was last updated.
        public let lastModifiedTime: TimeStamp
        /// Configuration information required for human workers to complete a labeling task.
        public let humanTaskConfig: HumanTaskConfig
        /// Configuration information for automated data labeling.
        public let labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig?

        public init(creationTime: TimeStamp, failureReason: String? = nil, humanTaskConfig: HumanTaskConfig, inputConfig: LabelingJobInputConfig, jobReferenceCode: String, labelAttributeName: String? = nil, labelCategoryConfigS3Uri: String? = nil, labelCounters: LabelCounters, labelingJobAlgorithmsConfig: LabelingJobAlgorithmsConfig? = nil, labelingJobArn: String, labelingJobName: String, labelingJobOutput: LabelingJobOutput? = nil, labelingJobStatus: LabelingJobStatus, lastModifiedTime: TimeStamp, outputConfig: LabelingJobOutputConfig, roleArn: String, stoppingConditions: LabelingJobStoppingConditions? = nil, tags: [Tag]? = nil) {
            self.inputConfig = inputConfig
            self.outputConfig = outputConfig
            self.stoppingConditions = stoppingConditions
            self.labelingJobOutput = labelingJobOutput
            self.labelCategoryConfigS3Uri = labelCategoryConfigS3Uri
            self.roleArn = roleArn
            self.failureReason = failureReason
            self.tags = tags
            self.labelAttributeName = labelAttributeName
            self.labelCounters = labelCounters
            self.jobReferenceCode = jobReferenceCode
            self.labelingJobStatus = labelingJobStatus
            self.creationTime = creationTime
            self.labelingJobArn = labelingJobArn
            self.labelingJobName = labelingJobName
            self.lastModifiedTime = lastModifiedTime
            self.humanTaskConfig = humanTaskConfig
            self.labelingJobAlgorithmsConfig = labelingJobAlgorithmsConfig
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfig = "InputConfig"
            case outputConfig = "OutputConfig"
            case stoppingConditions = "StoppingConditions"
            case labelingJobOutput = "LabelingJobOutput"
            case labelCategoryConfigS3Uri = "LabelCategoryConfigS3Uri"
            case roleArn = "RoleArn"
            case failureReason = "FailureReason"
            case tags = "Tags"
            case labelAttributeName = "LabelAttributeName"
            case labelCounters = "LabelCounters"
            case jobReferenceCode = "JobReferenceCode"
            case labelingJobStatus = "LabelingJobStatus"
            case creationTime = "CreationTime"
            case labelingJobArn = "LabelingJobArn"
            case labelingJobName = "LabelingJobName"
            case lastModifiedTime = "LastModifiedTime"
            case humanTaskConfig = "HumanTaskConfig"
            case labelingJobAlgorithmsConfig = "LabelingJobAlgorithmsConfig"
        }
    }

    public enum HyperParameterTuningJobObjectiveType: String, CustomStringConvertible, Codable {
        case maximize = "Maximize"
        case minimize = "Minimize"
        public var description: String { return self.rawValue }
    }

    public struct TrainingSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingImageDigest", required: false, type: .string), 
            AWSShapeMember(label: "TrainingImage", required: true, type: .string), 
            AWSShapeMember(label: "TrainingChannels", required: true, type: .list), 
            AWSShapeMember(label: "SupportsDistributedTraining", required: false, type: .boolean), 
            AWSShapeMember(label: "SupportedHyperParameters", required: false, type: .list), 
            AWSShapeMember(label: "SupportedTuningJobObjectiveMetrics", required: false, type: .list), 
            AWSShapeMember(label: "MetricDefinitions", required: false, type: .list), 
            AWSShapeMember(label: "SupportedTrainingInstanceTypes", required: true, type: .list)
        ]
        /// An MD5 hash of the training algorithm that identifies the Docker image used for training.
        public let trainingImageDigest: String?
        /// The Amazon Amazon ECR registry path of the Docker image that contains the training algorithm.
        public let trainingImage: String
        /// A list of ChannelSpecification objects, which specify the input sources to be used by the algorithm.
        public let trainingChannels: [ChannelSpecification]
        /// Indicates whether the algorithm supports distributed training. If set to false, buyers cant request more than one instance during training.
        public let supportsDistributedTraining: Bool?
        /// A list of the HyperParameterSpecification objects, that define the supported hyperparameters. This is required if the algorithm supports automatic model tuning.&gt;
        public let supportedHyperParameters: [HyperParameterSpecification]?
        /// A list of the metrics that the alogorithm emits that can be used as the objective metric in a hyperparameter tuning job.
        public let supportedTuningJobObjectiveMetrics: [HyperParameterTuningJobObjective]?
        /// A list of MetricDefinition objects, which are used for parsing metrics generated by the algorithm.
        public let metricDefinitions: [MetricDefinition]?
        /// A list of the instance types that this algorithm can use for training.
        public let supportedTrainingInstanceTypes: [TrainingInstanceType]

        public init(metricDefinitions: [MetricDefinition]? = nil, supportedHyperParameters: [HyperParameterSpecification]? = nil, supportedTrainingInstanceTypes: [TrainingInstanceType], supportedTuningJobObjectiveMetrics: [HyperParameterTuningJobObjective]? = nil, supportsDistributedTraining: Bool? = nil, trainingChannels: [ChannelSpecification], trainingImage: String, trainingImageDigest: String? = nil) {
            self.trainingImageDigest = trainingImageDigest
            self.trainingImage = trainingImage
            self.trainingChannels = trainingChannels
            self.supportsDistributedTraining = supportsDistributedTraining
            self.supportedHyperParameters = supportedHyperParameters
            self.supportedTuningJobObjectiveMetrics = supportedTuningJobObjectiveMetrics
            self.metricDefinitions = metricDefinitions
            self.supportedTrainingInstanceTypes = supportedTrainingInstanceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case trainingImageDigest = "TrainingImageDigest"
            case trainingImage = "TrainingImage"
            case trainingChannels = "TrainingChannels"
            case supportsDistributedTraining = "SupportsDistributedTraining"
            case supportedHyperParameters = "SupportedHyperParameters"
            case supportedTuningJobObjectiveMetrics = "SupportedTuningJobObjectiveMetrics"
            case metricDefinitions = "MetricDefinitions"
            case supportedTrainingInstanceTypes = "SupportedTrainingInstanceTypes"
        }
    }

    public struct UpdateEndpointWeightsAndCapacitiesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DesiredWeightsAndCapacities", required: true, type: .list), 
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]
        /// An object that provides new capacity and weight values for a variant.
        public let desiredWeightsAndCapacities: [DesiredWeightAndCapacity]
        /// The name of an existing Amazon SageMaker endpoint.
        public let endpointName: String

        public init(desiredWeightsAndCapacities: [DesiredWeightAndCapacity], endpointName: String) {
            self.desiredWeightsAndCapacities = desiredWeightsAndCapacities
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case desiredWeightsAndCapacities = "DesiredWeightsAndCapacities"
            case endpointName = "EndpointName"
        }
    }

    public struct ModelPackageStatusDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ValidationStatuses", required: true, type: .list), 
            AWSShapeMember(label: "ImageScanStatuses", required: false, type: .list)
        ]
        /// The status of the validation of the model package.
        public let validationStatuses: [ModelPackageStatusItem]
        /// The status of the scan of the Docker image container for the model package.
        public let imageScanStatuses: [ModelPackageStatusItem]?

        public init(imageScanStatuses: [ModelPackageStatusItem]? = nil, validationStatuses: [ModelPackageStatusItem]) {
            self.validationStatuses = validationStatuses
            self.imageScanStatuses = imageScanStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case validationStatuses = "ValidationStatuses"
            case imageScanStatuses = "ImageScanStatuses"
        }
    }

    public struct NotebookInstanceSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string), 
            AWSShapeMember(label: "AdditionalCodeRepositories", required: false, type: .list), 
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", required: false, type: .enum), 
            AWSShapeMember(label: "NotebookInstanceStatus", required: false, type: .enum), 
            AWSShapeMember(label: "DefaultCodeRepository", required: false, type: .string), 
            AWSShapeMember(label: "NotebookInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string)
        ]
        /// A timestamp that shows when the notebook instance was last modified.
        public let lastModifiedTime: TimeStamp?
        /// A timestamp that shows when the notebook instance was created.
        public let creationTime: TimeStamp?
        /// The name of the notebook instance that you want a summary for.
        public let notebookInstanceName: String
        /// An array of up to 3 git repositories associated with the notebook instance. These can be either the names of git repositories stored as resources in your account, or the URL of git repositories in AWS CodeCommit or in any other git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// The name of a notebook instance lifecycle configuration associated with this notebook instance. For information about notebook instance lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
        public let notebookInstanceLifecycleConfigName: String?
        /// The type of ML compute instance that the notebook instance is running on.
        public let instanceType: InstanceType?
        /// The status of the notebook instance.
        public let notebookInstanceStatus: NotebookInstanceStatus?
        /// The git repository associated with the notebook instance as its default code repository. This can be either the name of a git repository stored as a resource in your account, or the URL of a git repository in AWS CodeCommit or in any other git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String
        /// The URL that you use to connect to the Jupyter instance running in your notebook instance. 
        public let url: String?

        public init(additionalCodeRepositories: [String]? = nil, creationTime: TimeStamp? = nil, defaultCodeRepository: String? = nil, instanceType: InstanceType? = nil, lastModifiedTime: TimeStamp? = nil, notebookInstanceArn: String, notebookInstanceLifecycleConfigName: String? = nil, notebookInstanceName: String, notebookInstanceStatus: NotebookInstanceStatus? = nil, url: String? = nil) {
            self.lastModifiedTime = lastModifiedTime
            self.creationTime = creationTime
            self.notebookInstanceName = notebookInstanceName
            self.additionalCodeRepositories = additionalCodeRepositories
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.instanceType = instanceType
            self.notebookInstanceStatus = notebookInstanceStatus
            self.defaultCodeRepository = defaultCodeRepository
            self.notebookInstanceArn = notebookInstanceArn
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case creationTime = "CreationTime"
            case notebookInstanceName = "NotebookInstanceName"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case instanceType = "InstanceType"
            case notebookInstanceStatus = "NotebookInstanceStatus"
            case defaultCodeRepository = "DefaultCodeRepository"
            case notebookInstanceArn = "NotebookInstanceArn"
            case url = "Url"
        }
    }

    public struct ListModelPackagesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelPackageSummaryList", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of ModelPackageSummary objects, each of which lists a model package.
        public let modelPackageSummaryList: [ModelPackageSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of model packages, use it in the subsequent request.
        public let nextToken: String?

        public init(modelPackageSummaryList: [ModelPackageSummary], nextToken: String? = nil) {
            self.modelPackageSummaryList = modelPackageSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageSummaryList = "ModelPackageSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ModelSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "ModelArn", required: true, type: .string), 
            AWSShapeMember(label: "ModelName", required: true, type: .string)
        ]
        /// A timestamp that indicates when the model was created.
        public let creationTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String
        /// The name of the model that you want a summary for.
        public let modelName: String

        public init(creationTime: TimeStamp, modelArn: String, modelName: String) {
            self.creationTime = creationTime
            self.modelArn = modelArn
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case modelArn = "ModelArn"
            case modelName = "ModelName"
        }
    }

    public struct DesiredWeightAndCapacity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DesiredInstanceCount", required: false, type: .integer), 
            AWSShapeMember(label: "VariantName", required: true, type: .string), 
            AWSShapeMember(label: "DesiredWeight", required: false, type: .float)
        ]
        /// The variant's capacity.
        public let desiredInstanceCount: Int32?
        /// The name of the variant to update.
        public let variantName: String
        /// The variant's weight.
        public let desiredWeight: Float?

        public init(desiredInstanceCount: Int32? = nil, desiredWeight: Float? = nil, variantName: String) {
            self.desiredInstanceCount = desiredInstanceCount
            self.variantName = variantName
            self.desiredWeight = desiredWeight
        }

        private enum CodingKeys: String, CodingKey {
            case desiredInstanceCount = "DesiredInstanceCount"
            case variantName = "VariantName"
            case desiredWeight = "DesiredWeight"
        }
    }

    public struct CreateTrainingJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "StoppingCondition", required: true, type: .structure), 
            AWSShapeMember(label: "ResourceConfig", required: true, type: .structure), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "AlgorithmSpecification", required: true, type: .structure), 
            AWSShapeMember(label: "OutputDataConfig", required: true, type: .structure), 
            AWSShapeMember(label: "EnableNetworkIsolation", required: false, type: .boolean), 
            AWSShapeMember(label: "InputDataConfig", required: false, type: .list), 
            AWSShapeMember(label: "TrainingJobName", required: true, type: .string)
        ]
        /// Algorithm-specific parameters that influence the quality of the model. You set hyperparameters before you start the learning process. For a list of hyperparameters for each training algorithm provided by Amazon SageMaker, see Algorithms.  You can specify a maximum of 100 hyperparameters. Each hyperparameter is a key-value pair. Each key and value is limited to 256 characters, as specified by the Length Constraint. 
        public let hyperParameters: [String: String]?
        /// Sets a duration for training. Use this parameter to cap model training costs. To stop a job, Amazon SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms might use this 120-second window to save the model artifacts.  When Amazon SageMaker terminates a job because the stopping condition has been met, training algorithms provided by Amazon SageMaker save the intermediate results of the job. This intermediate data is a valid model artifact. You can use it to create a model using the CreateModel API. 
        public let stoppingCondition: StoppingCondition
        /// The resources, including the ML compute instances and ML storage volumes, to use for model training.  ML storage volumes store model artifacts and incremental states. Training algorithms might also use ML storage volumes for scratch space. If you want Amazon SageMaker to use the ML storage volume to store the training data, choose File as the TrainingInputMode in the algorithm specification. For distributed training algorithms, specify an instance count greater than 1.
        public let resourceConfig: ResourceConfig
        /// A VpcConfig object that specifies the VPC that you want your training job to connect to. Control access to and from your training container by configuring the VPC. For more information, see Protect Training Jobs by Using an Amazon Virtual Private Cloud.
        public let vpcConfig: VpcConfig?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker assumes to perform tasks on your behalf.  During model training, Amazon SageMaker needs your permission to read input data from an S3 bucket, download a Docker image that contains training code, write model artifacts to an S3 bucket, write logs to Amazon CloudWatch Logs, and publish metrics to Amazon CloudWatch. You grant permissions for all of these tasks to an IAM role. For more information, see Amazon SageMaker Roles.   To be able to pass this role to Amazon SageMaker, the caller of this API must have the iam:PassRole permission. 
        public let roleArn: String
        /// An array of key-value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide. 
        public let tags: [Tag]?
        /// The registry path of the Docker image that contains the training algorithm and algorithm-specific metadata, including the input mode. For more information about algorithms provided by Amazon SageMaker, see Algorithms. For information about providing your own algorithms, see Using Your Own Algorithms with Amazon SageMaker. 
        public let algorithmSpecification: AlgorithmSpecification
        /// Specifies the path to the S3 bucket where you want to store model artifacts. Amazon SageMaker creates subfolders for the artifacts. 
        public let outputDataConfig: OutputDataConfig
        /// Isolates the training container. No inbound or outbound network calls can be made, except for calls between peers within a training cluster for distributed training. If network isolation is used for training jobs that are configured to use a VPC, Amazon SageMaker downloads and uploads customer data and model artifacts through the specifed VPC, but the training container does not have network access.  The Semantic Segmentation built-in algorithm does not support network isolation. 
        public let enableNetworkIsolation: Bool?
        /// An array of Channel objects. Each channel is a named input source. InputDataConfig describes the input data and its location.  Algorithms can accept input data from one or more channels. For example, an algorithm might have two channels of input data, training_data and validation_data. The configuration for each channel provides the S3 location where the input data is stored. It also provides information about the stored data: the MIME type, compression method, and whether the data is wrapped in RecordIO format.  Depending on the input mode that the algorithm supports, Amazon SageMaker either copies input data files from an S3 bucket to a local directory in the Docker container, or makes it available as input streams. 
        public let inputDataConfig: [Channel]?
        /// The name of the training job. The name must be unique within an AWS Region in an AWS account. 
        public let trainingJobName: String

        public init(algorithmSpecification: AlgorithmSpecification, enableNetworkIsolation: Bool? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [Channel]? = nil, outputDataConfig: OutputDataConfig, resourceConfig: ResourceConfig, roleArn: String, stoppingCondition: StoppingCondition, tags: [Tag]? = nil, trainingJobName: String, vpcConfig: VpcConfig? = nil) {
            self.hyperParameters = hyperParameters
            self.stoppingCondition = stoppingCondition
            self.resourceConfig = resourceConfig
            self.vpcConfig = vpcConfig
            self.roleArn = roleArn
            self.tags = tags
            self.algorithmSpecification = algorithmSpecification
            self.outputDataConfig = outputDataConfig
            self.enableNetworkIsolation = enableNetworkIsolation
            self.inputDataConfig = inputDataConfig
            self.trainingJobName = trainingJobName
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameters = "HyperParameters"
            case stoppingCondition = "StoppingCondition"
            case resourceConfig = "ResourceConfig"
            case vpcConfig = "VpcConfig"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case algorithmSpecification = "AlgorithmSpecification"
            case outputDataConfig = "OutputDataConfig"
            case enableNetworkIsolation = "EnableNetworkIsolation"
            case inputDataConfig = "InputDataConfig"
            case trainingJobName = "TrainingJobName"
        }
    }

    public struct AnnotationConsolidationConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnnotationConsolidationLambdaArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of a Lambda function implements the logic for annotation consolidation. Amazon SageMaker Ground Truth provides three annotation consolidation functions that you can choose to use. They are:    Bounding box - Finds the most similar boxes from different workers based on the Jaccard index of the boxes.  arn:aws:lambda:region:432418664414:function:ACS-BoundingBox     Image classification - Uses a variant of the Expectation Maximization approach to estimate the true class of an image based on annotations from individual workers.  arn:aws:lambda:region:432418664414:function:ACS-ImageMultiClass     Text classification - Uses a variant of the Expectation Maximization approach to estimate the true class of text based on annotations from individual workers.  arn:aws:lambda:region:432418664414:function:ACS-TextMultiClass    For more information, see Annotation Consolidation.
        public let annotationConsolidationLambdaArn: String

        public init(annotationConsolidationLambdaArn: String) {
            self.annotationConsolidationLambdaArn = annotationConsolidationLambdaArn
        }

        private enum CodingKeys: String, CodingKey {
            case annotationConsolidationLambdaArn = "AnnotationConsolidationLambdaArn"
        }
    }

    public enum LabelingJobStatus: String, CustomStringConvertible, Codable {
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        case stopping = "Stopping"
        case stopped = "Stopped"
        public var description: String { return self.rawValue }
    }

    public struct DeleteTagsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagKeys", required: true, type: .list), 
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// An array or one or more tag keys to delete.
        public let tagKeys: [String]
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to delete.
        public let resourceArn: String

        public init(resourceArn: String, tagKeys: [String]) {
            self.tagKeys = tagKeys
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
            case resourceArn = "ResourceArn"
        }
    }

    public struct CreateModelPackageInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelPackageDescription", required: false, type: .string), 
            AWSShapeMember(label: "SourceAlgorithmSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "ValidationSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "ModelPackageName", required: true, type: .string), 
            AWSShapeMember(label: "InferenceSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "CertifyForMarketplace", required: false, type: .boolean)
        ]
        /// A description of the model package.
        public let modelPackageDescription: String?
        /// Details about the algorithm that was used to create the model package.
        public let sourceAlgorithmSpecification: SourceAlgorithmSpecification?
        /// Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
        public let validationSpecification: ModelPackageValidationSpecification?
        /// The name of the model package. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let modelPackageName: String
        /// Specifies details about inference jobs that can be run with models based on this model package, including the following:   The Amazon ECR paths of containers that contain the inference code and model artifacts.   The instance types that the model package supports for transform jobs and real-time endpoints used for inference.   The input and output content formats that the model package supports for inference.  
        public let inferenceSpecification: InferenceSpecification?
        /// Whether to certify the model package for listing on AWS Marketplace.
        public let certifyForMarketplace: Bool?

        public init(certifyForMarketplace: Bool? = nil, inferenceSpecification: InferenceSpecification? = nil, modelPackageDescription: String? = nil, modelPackageName: String, sourceAlgorithmSpecification: SourceAlgorithmSpecification? = nil, validationSpecification: ModelPackageValidationSpecification? = nil) {
            self.modelPackageDescription = modelPackageDescription
            self.sourceAlgorithmSpecification = sourceAlgorithmSpecification
            self.validationSpecification = validationSpecification
            self.modelPackageName = modelPackageName
            self.inferenceSpecification = inferenceSpecification
            self.certifyForMarketplace = certifyForMarketplace
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageDescription = "ModelPackageDescription"
            case sourceAlgorithmSpecification = "SourceAlgorithmSpecification"
            case validationSpecification = "ValidationSpecification"
            case modelPackageName = "ModelPackageName"
            case inferenceSpecification = "InferenceSpecification"
            case certifyForMarketplace = "CertifyForMarketplace"
        }
    }

    public struct AddTagsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// An array of Tag objects. Each tag is a key-value pair. Only the key parameter is required. If you don't specify a value, Amazon SageMaker sets the value to an empty string. 
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct RenderUiTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "Task", required: true, type: .structure), 
            AWSShapeMember(label: "UiTemplate", required: true, type: .structure)
        ]
        /// The Amazon Resource Name (ARN) that has access to the S3 objects that are used by the template.
        public let roleArn: String
        /// A RenderableTask object containing a representative task to render.
        public let task: RenderableTask
        /// A Tempateobject containing the worker UI template to render.
        public let uiTemplate: UiTemplate

        public init(roleArn: String, task: RenderableTask, uiTemplate: UiTemplate) {
            self.roleArn = roleArn
            self.task = task
            self.uiTemplate = uiTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case task = "Task"
            case uiTemplate = "UiTemplate"
        }
    }

    public struct CreateNotebookInstanceLifecycleConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: true, type: .string), 
            AWSShapeMember(label: "OnCreate", required: false, type: .list), 
            AWSShapeMember(label: "OnStart", required: false, type: .list)
        ]
        /// The name of the lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String
        /// A shell script that runs only once, when you create a notebook instance. The shell script must be a base64-encoded string.
        public let onCreate: [NotebookInstanceLifecycleHook]?
        /// A shell script that runs every time you start a notebook instance, including when you create the notebook instance. The shell script must be a base64-encoded string.
        public let onStart: [NotebookInstanceLifecycleHook]?

        public init(notebookInstanceLifecycleConfigName: String, onCreate: [NotebookInstanceLifecycleHook]? = nil, onStart: [NotebookInstanceLifecycleHook]? = nil) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.onCreate = onCreate
            self.onStart = onStart
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case onCreate = "OnCreate"
            case onStart = "OnStart"
        }
    }

    public struct DeleteModelPackageInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelPackageName", required: true, type: .string)
        ]
        /// The name of the model package. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let modelPackageName: String

        public init(modelPackageName: String) {
            self.modelPackageName = modelPackageName
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageName = "ModelPackageName"
        }
    }

    public struct DescribeTransformJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransformJobName", required: true, type: .string)
        ]
        /// The name of the transform job that you want to view details of.
        public let transformJobName: String

        public init(transformJobName: String) {
            self.transformJobName = transformJobName
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobName = "TransformJobName"
        }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case trainingjob = "TrainingJob"
        public var description: String { return self.rawValue }
    }

    public enum HyperParameterTuningJobStatus: String, CustomStringConvertible, Codable {
        case completed = "Completed"
        case inprogress = "InProgress"
        case failed = "Failed"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public struct ContinuousParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "MaxValue", required: true, type: .string), 
            AWSShapeMember(label: "MinValue", required: true, type: .string)
        ]
        /// The name of the continuous hyperparameter to tune.
        public let name: String
        /// The maximum value for the hyperparameter. The tuning job uses floating-point values between MinValue value and this value for tuning.
        public let maxValue: String
        /// The minimum value for the hyperparameter. The tuning job uses floating-point values between this value and MaxValuefor tuning.
        public let minValue: String

        public init(maxValue: String, minValue: String, name: String) {
            self.name = name
            self.maxValue = maxValue
            self.minValue = minValue
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public enum ObjectiveStatus: String, CustomStringConvertible, Codable {
        case succeeded = "Succeeded"
        case pending = "Pending"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct StartNotebookInstanceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string)
        ]
        /// The name of the notebook instance to start.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct SecondaryStatusTransition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: true, type: .enum), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp)
        ]
        /// A timestamp that shows when the training job transitioned to the current secondary status state.
        public let startTime: TimeStamp
        /// A detailed description of the progress within a secondary status.  Amazon SageMaker provides secondary statuses and status messages that apply to each of them:  Starting    Starting the training job.   Launching requested ML instances.   Insufficient capacity error from EC2 while launching instances, retrying!   Launched instance was unhealthy, replacing it!   Preparing the instances for training.    Training    Downloading the training image.   Training image download completed. Training in progress.      Status messages are subject to change. Therefore, we recommend not including them in code that programmatically initiates actions. For examples, don't use status messages in if statements.  To have an overview of your training job's progress, view TrainingJobStatus and SecondaryStatus in DescribeTrainingJobResponse, and StatusMessage together. For example, at the start of a training job, you might see the following:    TrainingJobStatus - InProgress    SecondaryStatus - Training    StatusMessage - Downloading the training image  
        public let statusMessage: String?
        /// Contains a secondary status information from a training job. Status might be one of the following secondary statuses:  InProgress     Starting - Starting the training job.    Downloading - An optional stage for algorithms that support File training input mode. It indicates that data is being downloaded to the ML storage volumes.    Training - Training is in progress.    Uploading - Training is complete and the model artifacts are being uploaded to the S3 location.    Completed     Completed - The training job has completed.    Failed     Failed - The training job has failed. The reason for the failure is returned in the FailureReason field of DescribeTrainingJobResponse.    Stopped     MaxRuntimeExceeded - The job stopped because it exceeded the maximum allowed runtime.    Stopped - The training job has stopped.    Stopping     Stopping - Stopping the training job.     We no longer support the following secondary statuses:    LaunchingMLInstances     PreparingTrainingStack     DownloadingTrainingImage   
        public let status: SecondaryStatus
        /// A timestamp that shows when the training job transitioned out of this secondary status state into another secondary status state or when the training job has ended.
        public let endTime: TimeStamp?

        public init(endTime: TimeStamp? = nil, startTime: TimeStamp, status: SecondaryStatus, statusMessage: String? = nil) {
            self.startTime = startTime
            self.statusMessage = statusMessage
            self.status = status
            self.endTime = endTime
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case statusMessage = "StatusMessage"
            case status = "Status"
            case endTime = "EndTime"
        }
    }

    public struct PropertyNameQuery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PropertyNameHint", required: true, type: .string)
        ]
        /// The hyperparameter, metric, and tag key property names that begin with the specified hint.
        public let propertyNameHint: String

        public init(propertyNameHint: String) {
            self.propertyNameHint = propertyNameHint
        }

        private enum CodingKeys: String, CodingKey {
            case propertyNameHint = "PropertyNameHint"
        }
    }

    public struct ListCodeRepositoriesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp)
        ]
        /// A filter that returns only git repositories that were last modified after the specified time.
        public let lastModifiedTimeAfter: TimeStamp?
        /// If the result of a ListCodeRepositoriesOutput request was truncated, the response includes a NextToken. To get the next set of git repositories, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only git repositories that were created before the specified time.
        public let creationTimeBefore: TimeStamp?
        /// The maximum number of git repositories to return in the response.
        public let maxResults: Int32?
        /// The field to sort results by. The default is Name.
        public let sortBy: CodeRepositorySortBy?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: CodeRepositorySortOrder?
        /// A filter that returns only git repositories that were created after the specified time.
        public let creationTimeAfter: TimeStamp?
        /// A string in the git repositories name. This filter returns only repositories whose name contains the specified string.
        public let nameContains: String?
        /// A filter that returns only git repositories that were last modified before the specified time.
        public let lastModifiedTimeBefore: TimeStamp?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: CodeRepositorySortBy? = nil, sortOrder: CodeRepositorySortOrder? = nil) {
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.nextToken = nextToken
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.creationTimeAfter = creationTimeAfter
            self.nameContains = nameContains
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case nextToken = "NextToken"
            case creationTimeBefore = "CreationTimeBefore"
            case maxResults = "MaxResults"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case creationTimeAfter = "CreationTimeAfter"
            case nameContains = "NameContains"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
        }
    }

    public struct DescribeTransformJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransformStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LabelingJobArn", required: false, type: .string), 
            AWSShapeMember(label: "Environment", required: false, type: .map), 
            AWSShapeMember(label: "MaxPayloadInMB", required: false, type: .integer), 
            AWSShapeMember(label: "MaxConcurrentTransforms", required: false, type: .integer), 
            AWSShapeMember(label: "ModelName", required: true, type: .string), 
            AWSShapeMember(label: "TransformInput", required: true, type: .structure), 
            AWSShapeMember(label: "TransformEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TransformOutput", required: false, type: .structure), 
            AWSShapeMember(label: "TransformJobName", required: true, type: .string), 
            AWSShapeMember(label: "TransformJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "TransformResources", required: true, type: .structure), 
            AWSShapeMember(label: "BatchStrategy", required: false, type: .enum), 
            AWSShapeMember(label: "TransformJobArn", required: true, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string)
        ]
        /// Indicates when the transform job starts on ML instances. You are billed for the time interval between this time and the value of TransformEndTime.
        public let transformStartTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the Amazon SageMaker Ground Truth labeling job that created the transform or training job.
        public let labelingJobArn: String?
        public let environment: [String: String]?
        /// The maximum payload size , in MB used in the transform job.
        public let maxPayloadInMB: Int32?
        /// The maximum number of parallel requests on each instance node that can be launched in a transform job. The default value is 1.
        public let maxConcurrentTransforms: Int32?
        /// The name of the model used in the transform job.
        public let modelName: String
        /// Describes the dataset to be transformed and the Amazon S3 location where it is stored.
        public let transformInput: TransformInput
        /// Indicates when the transform job is Completed, Stopped, or Failed. You are billed for the time interval between this time and the value of TransformStartTime.
        public let transformEndTime: TimeStamp?
        /// Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        public let transformOutput: TransformOutput?
        /// The name of the transform job.
        public let transformJobName: String
        /// The status of the transform job. If the transform job failed, the reason is returned in the FailureReason field.
        public let transformJobStatus: TransformJobStatus
        /// A timestamp that shows when the transform Job was created.
        public let creationTime: TimeStamp
        /// Describes the resources, including ML instance types and ML instance count, to use for the transform job.
        public let transformResources: TransformResources
        /// SingleRecord means only one record was used per a batch. MultiRecord means batches contained as many records that could possibly fit within the MaxPayloadInMB limit.
        public let batchStrategy: BatchStrategy?
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String
        /// If the transform job failed, the reason that it failed.
        public let failureReason: String?

        public init(batchStrategy: BatchStrategy? = nil, creationTime: TimeStamp, environment: [String: String]? = nil, failureReason: String? = nil, labelingJobArn: String? = nil, maxConcurrentTransforms: Int32? = nil, maxPayloadInMB: Int32? = nil, modelName: String, transformEndTime: TimeStamp? = nil, transformInput: TransformInput, transformJobArn: String, transformJobName: String, transformJobStatus: TransformJobStatus, transformOutput: TransformOutput? = nil, transformResources: TransformResources, transformStartTime: TimeStamp? = nil) {
            self.transformStartTime = transformStartTime
            self.labelingJobArn = labelingJobArn
            self.environment = environment
            self.maxPayloadInMB = maxPayloadInMB
            self.maxConcurrentTransforms = maxConcurrentTransforms
            self.modelName = modelName
            self.transformInput = transformInput
            self.transformEndTime = transformEndTime
            self.transformOutput = transformOutput
            self.transformJobName = transformJobName
            self.transformJobStatus = transformJobStatus
            self.creationTime = creationTime
            self.transformResources = transformResources
            self.batchStrategy = batchStrategy
            self.transformJobArn = transformJobArn
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case transformStartTime = "TransformStartTime"
            case labelingJobArn = "LabelingJobArn"
            case environment = "Environment"
            case maxPayloadInMB = "MaxPayloadInMB"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
            case modelName = "ModelName"
            case transformInput = "TransformInput"
            case transformEndTime = "TransformEndTime"
            case transformOutput = "TransformOutput"
            case transformJobName = "TransformJobName"
            case transformJobStatus = "TransformJobStatus"
            case creationTime = "CreationTime"
            case transformResources = "TransformResources"
            case batchStrategy = "BatchStrategy"
            case transformJobArn = "TransformJobArn"
            case failureReason = "FailureReason"
        }
    }

    public struct StopHyperParameterTuningJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HyperParameterTuningJobName", required: true, type: .string)
        ]
        /// The name of the tuning job to stop.
        public let hyperParameterTuningJobName: String

        public init(hyperParameterTuningJobName: String) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
        }
    }

    public enum OrderKey: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public struct CreateEndpointInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]
        /// The name of the endpoint. The name must be unique within an AWS Region in your AWS account.
        public let endpointName: String
        /// The name of an endpoint configuration. For more information, see CreateEndpointConfig. 
        public let endpointConfigName: String
        /// An array of key-value pairs. For more information, see Using Cost Allocation Tagsin the AWS Billing and Cost Management User Guide. 
        public let tags: [Tag]?

        public init(endpointConfigName: String, endpointName: String, tags: [Tag]? = nil) {
            self.endpointName = endpointName
            self.endpointConfigName = endpointConfigName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
            case endpointConfigName = "EndpointConfigName"
            case tags = "Tags"
        }
    }

    public struct GitConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecretArn", required: false, type: .string), 
            AWSShapeMember(label: "RepositoryUrl", required: true, type: .string), 
            AWSShapeMember(label: "Branch", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format:  {"username": UserName, "password": Password} 
        public let secretArn: String?
        /// The URL where the git repository is located.
        public let repositoryUrl: String
        /// The default brach for the git repository.
        public let branch: String?

        public init(branch: String? = nil, repositoryUrl: String, secretArn: String? = nil) {
            self.secretArn = secretArn
            self.repositoryUrl = repositoryUrl
            self.branch = branch
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "SecretArn"
            case repositoryUrl = "RepositoryUrl"
            case branch = "Branch"
        }
    }

    public enum BatchStrategy: String, CustomStringConvertible, Codable {
        case multirecord = "MultiRecord"
        case singlerecord = "SingleRecord"
        public var description: String { return self.rawValue }
    }

    public struct DescribeCodeRepositoryInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodeRepositoryName", required: true, type: .string)
        ]
        /// The name of the git repository to describe.
        public let codeRepositoryName: String

        public init(codeRepositoryName: String) {
            self.codeRepositoryName = codeRepositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
        }
    }

    public struct OutputDataConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3OutputPath", required: true, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string)
        ]
        /// Identifies the S3 path where you want Amazon SageMaker to store the model artifacts. For example, s3://bucket-name/key-name-prefix. 
        public let s3OutputPath: String
        /// The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The KmsKeyId can be any of the following formats:    // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"    // KMS Key Alias  "alias/ExampleAlias"    // Amazon Resource Name (ARN) of a KMS Key Alias  "arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"    If you don't provide the KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see KMS-Managed Encryption Keys in Amazon Simple Storage Service Developer Guide.   The KMS key policy must grant permission to the IAM role that you specify in your CreateTrainingJob request. Using Key Policies in AWS KMS in the AWS Key Management Service Developer Guide.  
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil, s3OutputPath: String) {
            self.s3OutputPath = s3OutputPath
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputPath = "S3OutputPath"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public enum RecordWrapper: String, CustomStringConvertible, Codable {
        case none = "None"
        case recordio = "RecordIO"
        public var description: String { return self.rawValue }
    }

    public struct ListTagsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]
        ///  If response is truncated, Amazon SageMaker includes a token in the response. You can use this token in your subsequent request to fetch next set of tokens. 
        public let nextToken: String?
        /// An array of Tag objects, each with a tag key and a value.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListCompilationJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string)
        ]
        /// The maximum number of model compilation jobs to return in the response.
        public let maxResults: Int32?
        /// If the result of the previous ListCompilationJobs request was truncated, the response includes a NextToken. To retrieve the next set of model compilation jobs, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns the model compilation jobs that were modified after a specified time.
        public let lastModifiedTimeAfter: TimeStamp?
        /// A filter that returns the model compilation jobs that were created after a specified time. 
        public let creationTimeAfter: TimeStamp?
        /// A filter that returns the model compilation jobs that were modified before a specified time.
        public let lastModifiedTimeBefore: TimeStamp?
        /// A filter that retrieves model compilation jobs with a specific DescribeCompilationJobResponse$CompilationJobStatus status.
        public let statusEquals: CompilationJobStatus?
        /// A filter that returns the model compilation jobs that were created before a specified time.
        public let creationTimeBefore: TimeStamp?
        /// A filter that returns the model compilation jobs whose name contains a specified string.
        public let nameContains: String?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, statusEquals: CompilationJobStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.creationTimeAfter = creationTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.statusEquals = statusEquals
            self.creationTimeBefore = creationTimeBefore
            self.nameContains = nameContains
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case creationTimeAfter = "CreationTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case statusEquals = "StatusEquals"
            case creationTimeBefore = "CreationTimeBefore"
            case nameContains = "NameContains"
        }
    }

    public struct ResourceLimits: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxParallelTrainingJobs", required: true, type: .integer), 
            AWSShapeMember(label: "MaxNumberOfTrainingJobs", required: true, type: .integer)
        ]
        /// The maximum number of concurrent training jobs that a hyperparameter tuning job can launch.
        public let maxParallelTrainingJobs: Int32
        /// The maximum number of training jobs that a hyperparameter tuning job can launch.
        public let maxNumberOfTrainingJobs: Int32

        public init(maxNumberOfTrainingJobs: Int32, maxParallelTrainingJobs: Int32) {
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
        }

        private enum CodingKeys: String, CodingKey {
            case maxParallelTrainingJobs = "MaxParallelTrainingJobs"
            case maxNumberOfTrainingJobs = "MaxNumberOfTrainingJobs"
        }
    }

    public struct ShuffleConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Seed", required: true, type: .long)
        ]
        /// Determines the shuffling order in ShuffleConfig. value.
        public let seed: Int64

        public init(seed: Int64) {
            self.seed = seed
        }

        private enum CodingKeys: String, CodingKey {
            case seed = "Seed"
        }
    }

    public enum NotebookInstanceStatus: String, CustomStringConvertible, Codable {
        case pending = "Pending"
        case inservice = "InService"
        case stopping = "Stopping"
        case stopped = "Stopped"
        case failed = "Failed"
        case deleting = "Deleting"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public struct UpdateEndpointWeightsAndCapacitiesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the updated endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct LabelingJobDataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3DataSource", required: true, type: .structure)
        ]
        /// The Amazon S3 location of the input data objects.
        public let s3DataSource: LabelingJobS3DataSource

        public init(s3DataSource: LabelingJobS3DataSource) {
            self.s3DataSource = s3DataSource
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "S3DataSource"
        }
    }

    public struct Workteam: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamArn", required: true, type: .string), 
            AWSShapeMember(label: "CreateDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "SubDomain", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: true, type: .string), 
            AWSShapeMember(label: "WorkteamName", required: true, type: .string), 
            AWSShapeMember(label: "ProductListingIds", required: false, type: .list), 
            AWSShapeMember(label: "MemberDefinitions", required: true, type: .list), 
            AWSShapeMember(label: "LastUpdatedDate", required: false, type: .timestamp)
        ]
        /// The Amazon Resource Name (ARN) that identifies the work team.
        public let workteamArn: String
        /// The date and time that the work team was created (timestamp).
        public let createDate: TimeStamp?
        /// The URI of the labeling job's user interface. Workers open this URI to start labeling your data objects.
        public let subDomain: String?
        /// A description of the work team.
        public let description: String
        /// The name of the work team.
        public let workteamName: String
        /// The Amazon Marketplace identifier for a vendor's work team.
        public let productListingIds: [String]?
        /// The Amazon Cognito user groups that make up the work team.
        public let memberDefinitions: [MemberDefinition]
        /// The date and time that the work team was last updated (timestamp).
        public let lastUpdatedDate: TimeStamp?

        public init(createDate: TimeStamp? = nil, description: String, lastUpdatedDate: TimeStamp? = nil, memberDefinitions: [MemberDefinition], productListingIds: [String]? = nil, subDomain: String? = nil, workteamArn: String, workteamName: String) {
            self.workteamArn = workteamArn
            self.createDate = createDate
            self.subDomain = subDomain
            self.description = description
            self.workteamName = workteamName
            self.productListingIds = productListingIds
            self.memberDefinitions = memberDefinitions
            self.lastUpdatedDate = lastUpdatedDate
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
            case createDate = "CreateDate"
            case subDomain = "SubDomain"
            case description = "Description"
            case workteamName = "WorkteamName"
            case productListingIds = "ProductListingIds"
            case memberDefinitions = "MemberDefinitions"
            case lastUpdatedDate = "LastUpdatedDate"
        }
    }

    public struct ListAlgorithmsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "NameContains", required: false, type: .string)
        ]
        /// A filter that returns only algorithms created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// If the response to a previous ListAlgorithms request was truncated, the response includes a NextToken. To retrieve the next set of algorithms, use the token in the next request.
        public let nextToken: String?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// A filter that returns only algorithms created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// The maximum number of algorithms to return in the response.
        public let maxResults: Int32?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: AlgorithmSortBy?
        /// A string in the algorithm name. This filter returns only algorithms whose name contains the specified string.
        public let nameContains: String?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: AlgorithmSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeBefore = creationTimeBefore
            self.nextToken = nextToken
            self.sortOrder = sortOrder
            self.creationTimeAfter = creationTimeAfter
            self.maxResults = maxResults
            self.sortBy = sortBy
            self.nameContains = nameContains
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeBefore = "CreationTimeBefore"
            case nextToken = "NextToken"
            case sortOrder = "SortOrder"
            case creationTimeAfter = "CreationTimeAfter"
            case maxResults = "MaxResults"
            case sortBy = "SortBy"
            case nameContains = "NameContains"
        }
    }

    public struct ListTrainingJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TrainingJobSummaries", required: true, type: .list)
        ]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of training jobs, use it in the subsequent request.
        public let nextToken: String?
        /// An array of TrainingJobSummary objects, each listing a training job.
        public let trainingJobSummaries: [TrainingJobSummary]

        public init(nextToken: String? = nil, trainingJobSummaries: [TrainingJobSummary]) {
            self.nextToken = nextToken
            self.trainingJobSummaries = trainingJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trainingJobSummaries = "TrainingJobSummaries"
        }
    }

    public struct IntegerParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MinValue", required: true, type: .string), 
            AWSShapeMember(label: "MaxValue", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The minimum value of the hyperparameter to search.
        public let minValue: String
        /// The maximum value of the hyperparameter to search.
        public let maxValue: String
        /// The name of the hyperparameter to search.
        public let name: String

        public init(maxValue: String, minValue: String, name: String) {
            self.minValue = minValue
            self.maxValue = maxValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case minValue = "MinValue"
            case maxValue = "MaxValue"
            case name = "Name"
        }
    }

    public struct ContainerDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelDataUrl", required: false, type: .string), 
            AWSShapeMember(label: "Image", required: false, type: .string), 
            AWSShapeMember(label: "Environment", required: false, type: .map), 
            AWSShapeMember(label: "ModelPackageName", required: false, type: .string), 
            AWSShapeMember(label: "ContainerHostname", required: false, type: .string)
        ]
        /// The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).  If you provide a value for this parameter, Amazon SageMaker uses AWS Security Token Service to download model artifacts from the S3 path you provide. AWS STS is activated in your IAM user account by default. If you previously deactivated AWS STS for a region, you need to reactivate AWS STS for that region. For more information, see Activating and Deactivating AWS STS i an AWS Region in the AWS Identity and Access Management User Guide.
        public let modelDataUrl: String?
        /// The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored. If you are using your own custom algorithm instead of an algorithm provided by Amazon SageMaker, the inference code must meet Amazon SageMaker requirements. Amazon SageMaker supports both registry/repository[:tag] and registry/repository[@digest] image path formats. For more information, see Using Your Own Algorithms with Amazon SageMaker 
        public let image: String?
        /// The environment variables to set in the Docker container. Each key and value in the Environment string to string map can have length of up to 1024. We support up to 16 entries in the map. 
        public let environment: [String: String]?
        /// The name of the model package in this container.
        public let modelPackageName: String?
        /// The DNS host name for the container after Amazon SageMaker deploys it.
        public let containerHostname: String?

        public init(containerHostname: String? = nil, environment: [String: String]? = nil, image: String? = nil, modelDataUrl: String? = nil, modelPackageName: String? = nil) {
            self.modelDataUrl = modelDataUrl
            self.image = image
            self.environment = environment
            self.modelPackageName = modelPackageName
            self.containerHostname = containerHostname
        }

        private enum CodingKeys: String, CodingKey {
            case modelDataUrl = "ModelDataUrl"
            case image = "Image"
            case environment = "Environment"
            case modelPackageName = "ModelPackageName"
            case containerHostname = "ContainerHostname"
        }
    }

    public struct GetSearchSuggestionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Resource", required: true, type: .enum), 
            AWSShapeMember(label: "SuggestionQuery", required: false, type: .structure)
        ]
        /// The name of the Amazon SageMaker resource to Search for. The only valid Resource value is TrainingJob.
        public let resource: ResourceType
        /// Limits the property names that are included in the response.
        public let suggestionQuery: SuggestionQuery?

        public init(resource: ResourceType, suggestionQuery: SuggestionQuery? = nil) {
            self.resource = resource
            self.suggestionQuery = suggestionQuery
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "Resource"
            case suggestionQuery = "SuggestionQuery"
        }
    }

    public struct DescribeNotebookInstanceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string)
        ]
        /// The name of the notebook instance that you want information about.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct CreateHyperParameterTuningJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WarmStartConfig", required: false, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningJobConfig", required: true, type: .structure), 
            AWSShapeMember(label: "TrainingJobDefinition", required: true, type: .structure), 
            AWSShapeMember(label: "HyperParameterTuningJobName", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]
        /// Specifies configuration for starting the hyperparameter tuning job using one or more previous tuning jobs as a starting point. The results of previous tuning jobs are used to inform which combinations of hyperparameters to search over in the new tuning job. All training jobs launched by the new hyperparameter tuning job are evaluated by using the objective metric. If you specify IDENTICAL_DATA_AND_ALGORITHM as the WarmStartType for the warm start configuration, the training job that performs the best in the new tuning job is compared to the best training jobs from the parent tuning jobs. From these, the training job that performs the best as measured by the objective metric is returned as the overall best training job.  All training jobs launched by parent hyperparameter tuning jobs and the new hyperparameter tuning jobs count against the limit of training jobs for the tuning job. 
        public let warmStartConfig: HyperParameterTuningJobWarmStartConfig?
        /// The HyperParameterTuningJobConfig object that describes the tuning job, including the search strategy, the objective metric used to evaluate training jobs, ranges of parameters to search, and resource limits for the tuning job. For more information, see automatic-model-tuning 
        public let hyperParameterTuningJobConfig: HyperParameterTuningJobConfig
        /// The HyperParameterTrainingJobDefinition object that describes the training jobs that this tuning job launches, including static hyperparameters, input data configuration, output data configuration, resource configuration, and stopping condition.
        public let trainingJobDefinition: HyperParameterTrainingJobDefinition
        /// The name of the tuning job. This name is the prefix for the names of all training jobs that this tuning job launches. The name must be unique within the same AWS account and AWS Region. The name must have { } to { } characters. Valid characters are a-z, A-Z, 0-9, and : + = @ _ % - (hyphen). The name is not case sensitive.
        public let hyperParameterTuningJobName: String
        /// An array of key-value pairs. You can use tags to categorize your AWS resources in different ways, for example, by purpose, owner, or environment. For more information, see AWS Tagging Strategies. Tags that you specify for the tuning job are also added to all training jobs that the tuning job launches.
        public let tags: [Tag]?

        public init(hyperParameterTuningJobConfig: HyperParameterTuningJobConfig, hyperParameterTuningJobName: String, tags: [Tag]? = nil, trainingJobDefinition: HyperParameterTrainingJobDefinition, warmStartConfig: HyperParameterTuningJobWarmStartConfig? = nil) {
            self.warmStartConfig = warmStartConfig
            self.hyperParameterTuningJobConfig = hyperParameterTuningJobConfig
            self.trainingJobDefinition = trainingJobDefinition
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case warmStartConfig = "WarmStartConfig"
            case hyperParameterTuningJobConfig = "HyperParameterTuningJobConfig"
            case trainingJobDefinition = "TrainingJobDefinition"
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
            case tags = "Tags"
        }
    }

    public struct CreateCodeRepositoryInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodeRepositoryName", required: true, type: .string), 
            AWSShapeMember(label: "GitConfig", required: true, type: .structure)
        ]
        /// The name of the git repository. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let codeRepositoryName: String
        /// Specifies details about the repository, including the URL where the repository is located, the default branch, and credentials to use to access the repository.
        public let gitConfig: GitConfig

        public init(codeRepositoryName: String, gitConfig: GitConfig) {
            self.codeRepositoryName = codeRepositoryName
            self.gitConfig = gitConfig
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
            case gitConfig = "GitConfig"
        }
    }

    public struct CreatePresignedNotebookInstanceUrlOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthorizedUrl", required: false, type: .string)
        ]
        /// A JSON object that contains the URL string. 
        public let authorizedUrl: String?

        public init(authorizedUrl: String? = nil) {
            self.authorizedUrl = authorizedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedUrl = "AuthorizedUrl"
        }
    }

    public struct HyperParameterTuningJobWarmStartConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WarmStartType", required: true, type: .enum), 
            AWSShapeMember(label: "ParentHyperParameterTuningJobs", required: true, type: .list)
        ]
        /// Specifies one of the following:  IDENTICAL_DATA_AND_ALGORITHM  The new hyperparameter tuning job uses the same input data and training image as the parent tuning jobs. You can change the hyperparameter ranges to search and the maximum number of training jobs that the hyperparameter tuning job launches. You cannot use a new version of the training algorithm, unless the changes in the new version do not affect the algorithm itself. For example, changes that improve logging or adding support for a different data format are allowed. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.  TRANSFER_LEARNING  The new hyperparameter tuning job can include input data, hyperparameter ranges, maximum number of concurrent training jobs, and maximum number of training jobs that are different than those of its parent hyperparameter tuning jobs. The training image can also be a different version from the version used in the parent hyperparameter tuning job. You can also change hyperparameters from tunable to static, and from static to tunable, but the total number of static plus tunable hyperparameters must remain the same as it is in all parent jobs. The objective metric for the new tuning job must be the same as for all parent jobs.  
        public let warmStartType: HyperParameterTuningJobWarmStartType
        /// An array of hyperparameter tuning jobs that are used as the starting point for the new hyperparameter tuning job. For more information about warm starting a hyperparameter tuning job, see Using a Previous Hyperparameter Tuning Job as a Starting Point. Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent jobs for warm start tuning jobs.
        public let parentHyperParameterTuningJobs: [ParentHyperParameterTuningJob]

        public init(parentHyperParameterTuningJobs: [ParentHyperParameterTuningJob], warmStartType: HyperParameterTuningJobWarmStartType) {
            self.warmStartType = warmStartType
            self.parentHyperParameterTuningJobs = parentHyperParameterTuningJobs
        }

        private enum CodingKeys: String, CodingKey {
            case warmStartType = "WarmStartType"
            case parentHyperParameterTuningJobs = "ParentHyperParameterTuningJobs"
        }
    }

    public struct ListTransformJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp)
        ]
        /// The maximum number of transform jobs to return in the response. The default value is 10.
        public let maxResults: Int32?
        /// A filter that retrieves only transform jobs with a specific status.
        public let statusEquals: TransformJobStatus?
        /// A filter that returns only transform jobs modified before the specified time.
        public let lastModifiedTimeBefore: TimeStamp?
        /// A filter that returns only transform jobs created before the specified time.
        public let creationTimeBefore: TimeStamp?
        /// The sort order for results. The default is Descending.
        public let sortOrder: SortOrder?
        /// A filter that returns only transform jobs modified after the specified time.
        public let lastModifiedTimeAfter: TimeStamp?
        /// A string in the transform job name. This filter returns only transform jobs whose name contains the specified string.
        public let nameContains: String?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// If the result of the previous ListTransformJobs request was truncated, the response includes a NextToken. To retrieve the next set of transform jobs, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only transform jobs created after the specified time.
        public let creationTimeAfter: TimeStamp?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: TransformJobStatus? = nil) {
            self.maxResults = maxResults
            self.statusEquals = statusEquals
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.creationTimeBefore = creationTimeBefore
            self.sortOrder = sortOrder
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.nameContains = nameContains
            self.sortBy = sortBy
            self.nextToken = nextToken
            self.creationTimeAfter = creationTimeAfter
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case statusEquals = "StatusEquals"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case creationTimeBefore = "CreationTimeBefore"
            case sortOrder = "SortOrder"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case nameContains = "NameContains"
            case sortBy = "SortBy"
            case nextToken = "NextToken"
            case creationTimeAfter = "CreationTimeAfter"
        }
    }

    public enum `Operator`: String, CustomStringConvertible, Codable {
        case equals = "Equals"
        case notequals = "NotEquals"
        case greaterthan = "GreaterThan"
        case greaterthanorequalto = "GreaterThanOrEqualTo"
        case lessthan = "LessThan"
        case lessthanorequalto = "LessThanOrEqualTo"
        case contains = "Contains"
        public var description: String { return self.rawValue }
    }

    public struct DescribeNotebookInstanceLifecycleConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: true, type: .string)
        ]
        /// The name of the lifecycle configuration to describe.
        public let notebookInstanceLifecycleConfigName: String

        public init(notebookInstanceLifecycleConfigName: String) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
        }
    }

    public enum AlgorithmStatus: String, CustomStringConvertible, Codable {
        case pending = "Pending"
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        case deleting = "Deleting"
        public var description: String { return self.rawValue }
    }

    public struct AlgorithmSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingImage", required: false, type: .string), 
            AWSShapeMember(label: "TrainingInputMode", required: true, type: .enum), 
            AWSShapeMember(label: "MetricDefinitions", required: false, type: .list), 
            AWSShapeMember(label: "AlgorithmName", required: false, type: .string)
        ]
        /// The registry path of the Docker image that contains the training algorithm. For information about docker registry paths for built-in algorithms, see Algorithms Provided by Amazon SageMaker: Common Parameters.
        public let trainingImage: String?
        /// The input mode that the algorithm supports. For the input modes that Amazon SageMaker algorithms support, see Algorithms. If an algorithm supports the File input mode, Amazon SageMaker downloads the training data from S3 to the provisioned ML storage Volume, and mounts the directory to docker volume for training container. If an algorithm supports the Pipe input mode, Amazon SageMaker streams data directly from S3 to the container.   In File mode, make sure you provision ML storage volume with sufficient capacity to accommodate the data download from S3. In addition to the training data, the ML storage volume also stores the output model. The algorithm container use ML storage volume to also store intermediate information, if any.   For distributed algorithms using File mode, training data is distributed uniformly, and your training duration is predictable if the input data objects size is approximately same. Amazon SageMaker does not split the files any further for model training. If the object sizes are skewed, training won't be optimal as the data distribution is also skewed where one host in a training cluster is overloaded, thus becoming bottleneck in training. 
        public let trainingInputMode: TrainingInputMode
        /// A list of metric definition objects. Each object specifies the metric name and regular expressions used to parse algorithm logs. Amazon SageMaker publishes each metric to Amazon CloudWatch.
        public let metricDefinitions: [MetricDefinition]?
        /// The name of the algorithm resource to use for the training job. This must be an algorithm resource that you created or subscribe to on AWS Marketplace. If you specify a value for this parameter, you can't specify a value for TrainingImage.
        public let algorithmName: String?

        public init(algorithmName: String? = nil, metricDefinitions: [MetricDefinition]? = nil, trainingImage: String? = nil, trainingInputMode: TrainingInputMode) {
            self.trainingImage = trainingImage
            self.trainingInputMode = trainingInputMode
            self.metricDefinitions = metricDefinitions
            self.algorithmName = algorithmName
        }

        private enum CodingKeys: String, CodingKey {
            case trainingImage = "TrainingImage"
            case trainingInputMode = "TrainingInputMode"
            case metricDefinitions = "MetricDefinitions"
            case algorithmName = "AlgorithmName"
        }
    }

    public struct TransformOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3OutputPath", required: true, type: .string), 
            AWSShapeMember(label: "Accept", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "AssembleWith", required: false, type: .enum)
        ]
        /// The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For example, s3://bucket-name/key-name-prefix. For every S3 object used as input for the transform job, the transformed data is stored in a corresponding subfolder in the location under the output prefix. For example, the input data s3://bucket-name/input-name-prefix/dataset01/data.csv will have the transformed data stored at s3://bucket-name/key-name-prefix/dataset01/, based on the original name, as a series of .part files (.part0001, part0002, etc).
        public let s3OutputPath: String
        /// The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
        public let accept: String?
        /// The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption. The KmsKeyId can be any of the following formats:    // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"    // KMS Key Alias  "alias/ExampleAlias"    // Amazon Resource Name (ARN) of a KMS Key Alias  "arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"    If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. For more information, see KMS-Managed Encryption Keys in the Amazon Simple Storage Service Developer Guide.  The KMS key policy must grant permission to the IAM role that you specify in your CreateTramsformJob request. For more information, see Using Key Policies in AWS KMS in the AWS Key Management Service Developer Guide.
        public let kmsKeyId: String?
        /// Defines how to assemble the results of the transform job as a single S3 object. You should select a format that is most convenient to you. To concatenate the results in binary format, specify None. To add a newline character at the end of every transformed record, specify Line.
        public let assembleWith: AssemblyType?

        public init(accept: String? = nil, assembleWith: AssemblyType? = nil, kmsKeyId: String? = nil, s3OutputPath: String) {
            self.s3OutputPath = s3OutputPath
            self.accept = accept
            self.kmsKeyId = kmsKeyId
            self.assembleWith = assembleWith
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputPath = "S3OutputPath"
            case accept = "Accept"
            case kmsKeyId = "KmsKeyId"
            case assembleWith = "AssembleWith"
        }
    }

    public class SearchExpression: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NestedFilters", required: false, type: .list), 
            AWSShapeMember(label: "Operator", required: false, type: .enum), 
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "SubExpressions", required: false, type: .list)
        ]
        /// A list of nested filter objects.
        public let nestedFilters: [NestedFilters]?
        /// A Boolean operator used to evaluate the search expression. If you want every conditional statement in all lists to be satisfied for the entire search expression to be true, specify And. If only a single conditional statement needs to be true for the entire search expression to be true, specify Or.
        public let `operator`: BooleanOperator?
        /// A list of filter objects.
        public let filters: [Filter]?
        /// A list of search expression objects.
        public let subExpressions: [SearchExpression]?

        public init(filters: [Filter]? = nil, nestedFilters: [NestedFilters]? = nil, operator: BooleanOperator? = nil, subExpressions: [SearchExpression]? = nil) {
            self.nestedFilters = nestedFilters
            self.`operator` = `operator`
            self.filters = filters
            self.subExpressions = subExpressions
        }

        private enum CodingKeys: String, CodingKey {
            case nestedFilters = "NestedFilters"
            case `operator` = "Operator"
            case filters = "Filters"
            case subExpressions = "SubExpressions"
        }
    }

    public struct DeleteNotebookInstanceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string)
        ]
        /// The name of the Amazon SageMaker notebook instance to delete.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct ModelPackageContainerDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerHostname", required: false, type: .string), 
            AWSShapeMember(label: "Image", required: true, type: .string), 
            AWSShapeMember(label: "ProductId", required: false, type: .string), 
            AWSShapeMember(label: "ImageDigest", required: false, type: .string), 
            AWSShapeMember(label: "ModelDataUrl", required: false, type: .string)
        ]
        /// The DNS host name for the Docker container.
        public let containerHostname: String?
        /// The Amazon EC2 Container Registry path where inference code is stored. If you are using your own custom algorithm instead of an algorithm provided by Amazon SageMaker, the inference code must meet Amazon SageMaker requirements. Amazon SageMaker supports both registry/repository[:tag] and registry/repository[@digest] image path formats. For more information, see Using Your Own Algorithms with Amazon SageMaker.
        public let image: String
        /// The ID of the model package.
        public let productId: String?
        /// An MD5 hash of the training algorithm that identifies the Docker image used for training.
        public let imageDigest: String?
        /// The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        public let modelDataUrl: String?

        public init(containerHostname: String? = nil, image: String, imageDigest: String? = nil, modelDataUrl: String? = nil, productId: String? = nil) {
            self.containerHostname = containerHostname
            self.image = image
            self.productId = productId
            self.imageDigest = imageDigest
            self.modelDataUrl = modelDataUrl
        }

        private enum CodingKeys: String, CodingKey {
            case containerHostname = "ContainerHostname"
            case image = "Image"
            case productId = "ProductId"
            case imageDigest = "ImageDigest"
            case modelDataUrl = "ModelDataUrl"
        }
    }

    public enum CodeRepositorySortOrder: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public struct TrainingJobDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingInputMode", required: true, type: .enum), 
            AWSShapeMember(label: "OutputDataConfig", required: true, type: .structure), 
            AWSShapeMember(label: "HyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "ResourceConfig", required: true, type: .structure), 
            AWSShapeMember(label: "InputDataConfig", required: true, type: .list), 
            AWSShapeMember(label: "StoppingCondition", required: true, type: .structure)
        ]
        /// The input mode used by the algorithm for the training job. For the input modes that Amazon SageMaker algorithms support, see Algorithms. If an algorithm supports the File input mode, Amazon SageMaker downloads the training data from S3 to the provisioned ML storage Volume, and mounts the directory to docker volume for training container. If an algorithm supports the Pipe input mode, Amazon SageMaker streams data directly from S3 to the container.
        public let trainingInputMode: TrainingInputMode
        /// the path to the S3 bucket where you want to store model artifacts. Amazon SageMaker creates subfolders for the artifacts.
        public let outputDataConfig: OutputDataConfig
        /// The hyperparameters used for the training job.
        public let hyperParameters: [String: String]?
        /// The resources, including the ML compute instances and ML storage volumes, to use for model training.
        public let resourceConfig: ResourceConfig
        /// An array of Channel objects, each of which specifies an input source.
        public let inputDataConfig: [Channel]
        /// Sets a duration for training. Use this parameter to cap model training costs. To stop a job, Amazon SageMaker sends the algorithm the SIGTERM signal, which delays job termination for 120 seconds. Algorithms might use this 120-second window to save the model artifacts.
        public let stoppingCondition: StoppingCondition

        public init(hyperParameters: [String: String]? = nil, inputDataConfig: [Channel], outputDataConfig: OutputDataConfig, resourceConfig: ResourceConfig, stoppingCondition: StoppingCondition, trainingInputMode: TrainingInputMode) {
            self.trainingInputMode = trainingInputMode
            self.outputDataConfig = outputDataConfig
            self.hyperParameters = hyperParameters
            self.resourceConfig = resourceConfig
            self.inputDataConfig = inputDataConfig
            self.stoppingCondition = stoppingCondition
        }

        private enum CodingKeys: String, CodingKey {
            case trainingInputMode = "TrainingInputMode"
            case outputDataConfig = "OutputDataConfig"
            case hyperParameters = "HyperParameters"
            case resourceConfig = "ResourceConfig"
            case inputDataConfig = "InputDataConfig"
            case stoppingCondition = "StoppingCondition"
        }
    }

    public struct UpdateWorkteamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Workteam", required: true, type: .structure)
        ]
        /// A Workteam object that describes the updated work team.
        public let workteam: Workteam

        public init(workteam: Workteam) {
            self.workteam = workteam
        }

        private enum CodingKeys: String, CodingKey {
            case workteam = "Workteam"
        }
    }

    public struct CreateAlgorithmInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InferenceSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "AlgorithmDescription", required: false, type: .string), 
            AWSShapeMember(label: "ValidationSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "TrainingSpecification", required: true, type: .structure), 
            AWSShapeMember(label: "CertifyForMarketplace", required: false, type: .boolean), 
            AWSShapeMember(label: "AlgorithmName", required: true, type: .string)
        ]
        /// Specifies details about inference jobs that the algorithm runs, including the following:   The Amazon ECR paths of containers that contain the inference code and model artifacts.   The instance types that the algorithm supports for transform jobs and real-time endpoints used for inference.   The input and output content formats that the algorithm supports for inference.  
        public let inferenceSpecification: InferenceSpecification?
        /// A description of the algorithm.
        public let algorithmDescription: String?
        /// Specifies configurations for one or more training jobs and that Amazon SageMaker runs to test the algorithm's training code and, optionally, one or more batch transform jobs that Amazon SageMaker runs to test the algorithm's inference code.
        public let validationSpecification: AlgorithmValidationSpecification?
        /// Specifies details about training jobs run by this algorithm, including the following:   The Amazon ECR path of the container and the version digest of the algorithm.   The hyperparameters that the algorithm supports.   The instance types that the algorithm supports for training.   Whether the algorithm supports distributed training.   The metrics that the algorithm emits to Amazon CloudWatch.   Which metrics that the algorithm emits can be used as the objective metric for hyperparameter tuning jobs.   The input channels that the algorithm supports for training data. For example, an algorithm might support train, validation, and test channels.  
        public let trainingSpecification: TrainingSpecification
        /// Whether to certify the algorithm so that it can be listed in AWS Marektplace.
        public let certifyForMarketplace: Bool?
        /// The name of the algorithm. The name must have 1 to 63 characters. Valid characters are a-z, A-Z, 0-9, and - (hyphen).
        public let algorithmName: String

        public init(algorithmDescription: String? = nil, algorithmName: String, certifyForMarketplace: Bool? = nil, inferenceSpecification: InferenceSpecification? = nil, trainingSpecification: TrainingSpecification, validationSpecification: AlgorithmValidationSpecification? = nil) {
            self.inferenceSpecification = inferenceSpecification
            self.algorithmDescription = algorithmDescription
            self.validationSpecification = validationSpecification
            self.trainingSpecification = trainingSpecification
            self.certifyForMarketplace = certifyForMarketplace
            self.algorithmName = algorithmName
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceSpecification = "InferenceSpecification"
            case algorithmDescription = "AlgorithmDescription"
            case validationSpecification = "ValidationSpecification"
            case trainingSpecification = "TrainingSpecification"
            case certifyForMarketplace = "CertifyForMarketplace"
            case algorithmName = "AlgorithmName"
        }
    }

    public struct CreateTransformJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxPayloadInMB", required: false, type: .integer), 
            AWSShapeMember(label: "Environment", required: false, type: .map), 
            AWSShapeMember(label: "ModelName", required: true, type: .string), 
            AWSShapeMember(label: "MaxConcurrentTransforms", required: false, type: .integer), 
            AWSShapeMember(label: "TransformInput", required: true, type: .structure), 
            AWSShapeMember(label: "TransformResources", required: true, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "TransformOutput", required: true, type: .structure), 
            AWSShapeMember(label: "BatchStrategy", required: false, type: .enum), 
            AWSShapeMember(label: "TransformJobName", required: true, type: .string)
        ]
        /// The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata). The value in MaxPayloadInMB must be greater or equal to the size of a single record. You can approximate the size of a record by dividing the size of your dataset by the number of records. Then multiply this value by the number of records you want in a mini-batch. We recommend to enter a slightly larger value than this to ensure the records fit within the maximum payload size. The default value is 6 MB.  For cases where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding, set the value to 0. This feature only works in supported algorithms. Currently, Amazon SageMaker built-in algorithms do not support this feature.
        public let maxPayloadInMB: Int32?
        /// The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        public let environment: [String: String]?
        /// The name of the model that you want to use for the transform job. ModelName must be the name of an existing Amazon SageMaker model within an AWS Region in an AWS account.
        public let modelName: String
        /// The maximum number of parallel requests that can be sent to each instance in a transform job. This is good for algorithms that implement multiple workers on larger instances . The default value is 1. To allow Amazon SageMaker to determine the appropriate number for MaxConcurrentTransforms, set the value to 0.
        public let maxConcurrentTransforms: Int32?
        /// Describes the input source and the way the transform job consumes it.
        public let transformInput: TransformInput
        /// Describes the resources, including ML instance types and ML instance count, to use for the transform job.
        public let transformResources: TransformResources
        /// An array of key-value pairs. Adding tags is optional. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide.
        public let tags: [Tag]?
        /// Describes the results of the transform job.
        public let transformOutput: TransformOutput
        /// Determines the number of records included in a single mini-batch. SingleRecord means only one record is used per mini-batch. MultiRecord means a mini-batch is set to contain as many records that can fit within the MaxPayloadInMB limit. Batch transform will automatically split your input data into whatever payload size is specified if you set SplitType to Line and BatchStrategy to MultiRecord. There's no need to split the dataset into smaller files or to use larger payload sizes unless the records in your dataset are very large.
        public let batchStrategy: BatchStrategy?
        /// The name of the transform job. The name must be unique within an AWS Region in an AWS account. 
        public let transformJobName: String

        public init(batchStrategy: BatchStrategy? = nil, environment: [String: String]? = nil, maxConcurrentTransforms: Int32? = nil, maxPayloadInMB: Int32? = nil, modelName: String, tags: [Tag]? = nil, transformInput: TransformInput, transformJobName: String, transformOutput: TransformOutput, transformResources: TransformResources) {
            self.maxPayloadInMB = maxPayloadInMB
            self.environment = environment
            self.modelName = modelName
            self.maxConcurrentTransforms = maxConcurrentTransforms
            self.transformInput = transformInput
            self.transformResources = transformResources
            self.tags = tags
            self.transformOutput = transformOutput
            self.batchStrategy = batchStrategy
            self.transformJobName = transformJobName
        }

        private enum CodingKeys: String, CodingKey {
            case maxPayloadInMB = "MaxPayloadInMB"
            case environment = "Environment"
            case modelName = "ModelName"
            case maxConcurrentTransforms = "MaxConcurrentTransforms"
            case transformInput = "TransformInput"
            case transformResources = "TransformResources"
            case tags = "Tags"
            case transformOutput = "TransformOutput"
            case batchStrategy = "BatchStrategy"
            case transformJobName = "TransformJobName"
        }
    }

    public struct DeleteNotebookInstanceLifecycleConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceLifecycleConfigName", required: true, type: .string)
        ]
        /// The name of the lifecycle configuration to delete.
        public let notebookInstanceLifecycleConfigName: String

        public init(notebookInstanceLifecycleConfigName: String) {
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
        }
    }

    public enum TrainingJobSortByOptions: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        case status = "Status"
        case finalobjectivemetricvalue = "FinalObjectiveMetricValue"
        public var description: String { return self.rawValue }
    }

    public struct DescribeCompilationJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompilationJobName", required: true, type: .string)
        ]
        /// The name of the model compilation job that you want information about.
        public let compilationJobName: String

        public init(compilationJobName: String) {
            self.compilationJobName = compilationJobName
        }

        private enum CodingKeys: String, CodingKey {
            case compilationJobName = "CompilationJobName"
        }
    }

    public struct AlgorithmSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmDescription", required: false, type: .string), 
            AWSShapeMember(label: "AlgorithmArn", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "AlgorithmStatus", required: true, type: .enum), 
            AWSShapeMember(label: "AlgorithmName", required: true, type: .string)
        ]
        /// A brief statement describing the algorithm.
        public let algorithmDescription: String?
        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String
        /// A timestamp that shows when the algorithm was created.
        public let creationTime: TimeStamp
        /// The overall status of the algorithm.
        public let algorithmStatus: AlgorithmStatus
        /// The name of the algorithm which is described by the summary.
        public let algorithmName: String

        public init(algorithmArn: String, algorithmDescription: String? = nil, algorithmName: String, algorithmStatus: AlgorithmStatus, creationTime: TimeStamp) {
            self.algorithmDescription = algorithmDescription
            self.algorithmArn = algorithmArn
            self.creationTime = creationTime
            self.algorithmStatus = algorithmStatus
            self.algorithmName = algorithmName
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmDescription = "AlgorithmDescription"
            case algorithmArn = "AlgorithmArn"
            case creationTime = "CreationTime"
            case algorithmStatus = "AlgorithmStatus"
            case algorithmName = "AlgorithmName"
        }
    }

    public struct DescribeHyperParameterTuningJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HyperParameterTuningJobName", required: true, type: .string)
        ]
        /// The name of the tuning job to describe.
        public let hyperParameterTuningJobName: String

        public init(hyperParameterTuningJobName: String) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
        }
    }

    public struct CreateTransformJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransformJobArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String

        public init(transformJobArn: String) {
            self.transformJobArn = transformJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobArn = "TransformJobArn"
        }
    }

    public struct DescribeModelPackageInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelPackageName", required: true, type: .string)
        ]
        /// The name of the model package to describe.
        public let modelPackageName: String

        public init(modelPackageName: String) {
            self.modelPackageName = modelPackageName
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageName = "ModelPackageName"
        }
    }

    public struct DeleteWorkteamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamName", required: true, type: .string)
        ]
        /// The name of the work team to delete.
        public let workteamName: String

        public init(workteamName: String) {
            self.workteamName = workteamName
        }

        private enum CodingKeys: String, CodingKey {
            case workteamName = "WorkteamName"
        }
    }

    public struct ListModelsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Models", required: true, type: .list)
        ]
        ///  If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of models, use it in the subsequent request. 
        public let nextToken: String?
        /// An array of ModelSummary objects, each of which lists a model.
        public let models: [ModelSummary]

        public init(models: [ModelSummary], nextToken: String? = nil) {
            self.nextToken = nextToken
            self.models = models
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case models = "Models"
        }
    }

    public struct HyperParameterSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "IsTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "IsRequired", required: false, type: .boolean), 
            AWSShapeMember(label: "Range", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A brief description of the hyperparameter.
        public let description: String?
        /// Indicates whether this hyperparameter is tunable in a hyperparameter tuning job.
        public let isTunable: Bool?
        /// The type of this hyperparameter. The valid types are Integer, Continuous, Categorical, and FreeText.
        public let `type`: ParameterType
        /// Indicates whether this hyperparameter is required.
        public let isRequired: Bool?
        /// The allowed range for this hyperparameter.
        public let range: ParameterRange?
        /// The default value for this hyperparameter. If a default value is specified, a hyperparameter cannot be required.
        public let defaultValue: String?
        /// The name of this hyperparameter. The name must be unique.
        public let name: String

        public init(defaultValue: String? = nil, description: String? = nil, isRequired: Bool? = nil, isTunable: Bool? = nil, name: String, range: ParameterRange? = nil, type: ParameterType) {
            self.description = description
            self.isTunable = isTunable
            self.`type` = `type`
            self.isRequired = isRequired
            self.range = range
            self.defaultValue = defaultValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case isTunable = "IsTunable"
            case `type` = "Type"
            case isRequired = "IsRequired"
            case range = "Range"
            case defaultValue = "DefaultValue"
            case name = "Name"
        }
    }

    public struct GitConfigForUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecretArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the credentials used to access the git repository. The secret must have a staging label of AWSCURRENT and must be in the following format:  {"username": UserName, "password": Password} 
        public let secretArn: String?

        public init(secretArn: String? = nil) {
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "SecretArn"
        }
    }

    public enum EndpointConfigSortKey: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SplitType: String, CustomStringConvertible, Codable {
        case none = "None"
        case line = "Line"
        case recordio = "RecordIO"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSubscribedWorkteamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the subscribed work team to describe.
        public let workteamArn: String

        public init(workteamArn: String) {
            self.workteamArn = workteamArn
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
        }
    }

    public struct DescribeModelPackageOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "ModelPackageArn", required: true, type: .string), 
            AWSShapeMember(label: "ModelPackageStatus", required: true, type: .enum), 
            AWSShapeMember(label: "ModelPackageName", required: true, type: .string), 
            AWSShapeMember(label: "ValidationSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "SourceAlgorithmSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "ModelPackageStatusDetails", required: true, type: .structure), 
            AWSShapeMember(label: "CertifyForMarketplace", required: false, type: .boolean), 
            AWSShapeMember(label: "InferenceSpecification", required: false, type: .structure), 
            AWSShapeMember(label: "ModelPackageDescription", required: false, type: .string)
        ]
        /// A timestamp specifying when the model package was created.
        public let creationTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the model package.
        public let modelPackageArn: String
        /// The current status of the model package.
        public let modelPackageStatus: ModelPackageStatus
        /// The name of the model package being described.
        public let modelPackageName: String
        /// Configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
        public let validationSpecification: ModelPackageValidationSpecification?
        /// Details about the algorithm that was used to create the model package.
        public let sourceAlgorithmSpecification: SourceAlgorithmSpecification?
        /// Details about the current status of the model package.
        public let modelPackageStatusDetails: ModelPackageStatusDetails
        /// Whether the model package is certified for listing on AWS Marketplace.
        public let certifyForMarketplace: Bool?
        /// Details about inference jobs that can be run with models based on this model package.
        public let inferenceSpecification: InferenceSpecification?
        /// A brief summary about the model package.
        public let modelPackageDescription: String?

        public init(certifyForMarketplace: Bool? = nil, creationTime: TimeStamp, inferenceSpecification: InferenceSpecification? = nil, modelPackageArn: String, modelPackageDescription: String? = nil, modelPackageName: String, modelPackageStatus: ModelPackageStatus, modelPackageStatusDetails: ModelPackageStatusDetails, sourceAlgorithmSpecification: SourceAlgorithmSpecification? = nil, validationSpecification: ModelPackageValidationSpecification? = nil) {
            self.creationTime = creationTime
            self.modelPackageArn = modelPackageArn
            self.modelPackageStatus = modelPackageStatus
            self.modelPackageName = modelPackageName
            self.validationSpecification = validationSpecification
            self.sourceAlgorithmSpecification = sourceAlgorithmSpecification
            self.modelPackageStatusDetails = modelPackageStatusDetails
            self.certifyForMarketplace = certifyForMarketplace
            self.inferenceSpecification = inferenceSpecification
            self.modelPackageDescription = modelPackageDescription
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case modelPackageArn = "ModelPackageArn"
            case modelPackageStatus = "ModelPackageStatus"
            case modelPackageName = "ModelPackageName"
            case validationSpecification = "ValidationSpecification"
            case sourceAlgorithmSpecification = "SourceAlgorithmSpecification"
            case modelPackageStatusDetails = "ModelPackageStatusDetails"
            case certifyForMarketplace = "CertifyForMarketplace"
            case inferenceSpecification = "InferenceSpecification"
            case modelPackageDescription = "ModelPackageDescription"
        }
    }

    public struct PublicWorkforceTaskPrice: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AmountInUsd", required: false, type: .structure)
        ]
        /// Defines the amount of money paid to a worker in United States dollars.
        public let amountInUsd: USD?

        public init(amountInUsd: USD? = nil) {
            self.amountInUsd = amountInUsd
        }

        private enum CodingKeys: String, CodingKey {
            case amountInUsd = "AmountInUsd"
        }
    }

    public struct ListModelsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum)
        ]
        /// Sorts the list of results. The default is CreationTime.
        public let sortBy: ModelSortKey?
        /// A filter that returns only models created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// A string in the training job name. This filter returns only models in the training job whose name contains the specified string.
        public let nameContains: String?
        /// The maximum number of models to return in the response.
        public let maxResults: Int32?
        /// If the response to a previous ListModels request was truncated, the response includes a NextToken. To retrieve the next set of models, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only models created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: OrderKey?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ModelSortKey? = nil, sortOrder: OrderKey? = nil) {
            self.sortBy = sortBy
            self.creationTimeAfter = creationTimeAfter
            self.nameContains = nameContains
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.creationTimeBefore = creationTimeBefore
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "SortBy"
            case creationTimeAfter = "CreationTimeAfter"
            case nameContains = "NameContains"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case creationTimeBefore = "CreationTimeBefore"
            case sortOrder = "SortOrder"
        }
    }

    public enum DirectInternetAccess: String, CustomStringConvertible, Codable {
        case enabled = "Enabled"
        case disabled = "Disabled"
        public var description: String { return self.rawValue }
    }

    public struct LabelingJobS3DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ManifestS3Uri", required: true, type: .string)
        ]
        /// The Amazon S3 location of the manifest file that describes the input data objects.
        public let manifestS3Uri: String

        public init(manifestS3Uri: String) {
            self.manifestS3Uri = manifestS3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case manifestS3Uri = "ManifestS3Uri"
        }
    }

    public enum NotebookInstanceLifecycleConfigSortKey: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        case lastmodifiedtime = "LastModifiedTime"
        public var description: String { return self.rawValue }
    }

    public struct ListEndpointsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp)
        ]
        ///  A filter that returns only endpoints with the specified status.
        public let statusEquals: EndpointStatus?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: OrderKey?
        /// The maximum number of endpoints to return in the response.
        public let maxResults: Int32?
        /// A string in endpoint names. This filter returns only endpoints whose name contains the specified string.
        public let nameContains: String?
        /// A filter that returns only endpoints that were created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        ///  A filter that returns only endpoints that were modified after the specified timestamp. 
        public let lastModifiedTimeAfter: TimeStamp?
        ///  A filter that returns only endpoints that were modified before the specified timestamp. 
        public let lastModifiedTimeBefore: TimeStamp?
        /// Sorts the list of results. The default is CreationTime.
        public let sortBy: EndpointSortKey?
        /// If the result of a ListEndpoints request was truncated, the response includes a NextToken. To retrieve the next set of endpoints, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only endpoints that were created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: EndpointSortKey? = nil, sortOrder: OrderKey? = nil, statusEquals: EndpointStatus? = nil) {
            self.statusEquals = statusEquals
            self.sortOrder = sortOrder
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.creationTimeAfter = creationTimeAfter
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.sortBy = sortBy
            self.nextToken = nextToken
            self.creationTimeBefore = creationTimeBefore
        }

        private enum CodingKeys: String, CodingKey {
            case statusEquals = "StatusEquals"
            case sortOrder = "SortOrder"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case creationTimeAfter = "CreationTimeAfter"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case sortBy = "SortBy"
            case nextToken = "NextToken"
            case creationTimeBefore = "CreationTimeBefore"
        }
    }

    public struct Channel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputMode", required: false, type: .enum), 
            AWSShapeMember(label: "CompressionType", required: false, type: .enum), 
            AWSShapeMember(label: "ChannelName", required: true, type: .string), 
            AWSShapeMember(label: "ContentType", required: false, type: .string), 
            AWSShapeMember(label: "DataSource", required: true, type: .structure), 
            AWSShapeMember(label: "ShuffleConfig", required: false, type: .structure), 
            AWSShapeMember(label: "RecordWrapperType", required: false, type: .enum)
        ]
        /// (Optional) The input mode to use for the data channel in a training job. If you don't set a value for InputMode, Amazon SageMaker uses the value set for TrainingInputMode. Use this parameter to override the TrainingInputMode setting in a AlgorithmSpecification request when you have a channel that needs a different input mode from the training job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML storage volume, and mount the directory to a Docker volume, use File input mode. To stream data directly from Amazon S3 to the container, choose Pipe input mode. To use a model for incremental training, choose File input model.
        public let inputMode: TrainingInputMode?
        /// If training data is compressed, the compression type. The default value is None. CompressionType is used only in Pipe input mode. In File mode, leave this field unset or set it to None.
        public let compressionType: CompressionType?
        /// The name of the channel. 
        public let channelName: String
        /// The MIME type of the data.
        public let contentType: String?
        /// The location of the channel data.
        public let dataSource: DataSource
        /// A configuration for a shuffle option for input data in a channel. If you use S3Prefix for S3DataType, this shuffles the results of the S3 key prefix matches. If you use ManifestFile, the order of the S3 object references in the ManifestFile is shuffled. If you use AugmentedManifestFile, the order of the JSON lines in the AugmentedManifestFile is shuffled. The shuffling order is determined using the Seed value. For Pipe input mode, shuffling is done at the start of every epoch. With large datasets this ensures that the order of the training data is different for each epoch, it helps reduce bias and possible overfitting. In a multi-node training job when ShuffleConfig is combined with S3DataDistributionType of ShardedByS3Key, the data is shuffled across nodes so that the content sent to a particular node on the first epoch might be sent to a different node on the second epoch.
        public let shuffleConfig: ShuffleConfig?
        ///  Specify RecordIO as the value when input data is in raw format but the training algorithm requires the RecordIO format. In this case, Amazon SageMaker wraps each individual S3 object in a RecordIO record. If the input data is already in RecordIO format, you don't need to set this attribute. For more information, see Create a Dataset Using RecordIO.  In File mode, leave this field unset or set it to None.
        public let recordWrapperType: RecordWrapper?

        public init(channelName: String, compressionType: CompressionType? = nil, contentType: String? = nil, dataSource: DataSource, inputMode: TrainingInputMode? = nil, recordWrapperType: RecordWrapper? = nil, shuffleConfig: ShuffleConfig? = nil) {
            self.inputMode = inputMode
            self.compressionType = compressionType
            self.channelName = channelName
            self.contentType = contentType
            self.dataSource = dataSource
            self.shuffleConfig = shuffleConfig
            self.recordWrapperType = recordWrapperType
        }

        private enum CodingKeys: String, CodingKey {
            case inputMode = "InputMode"
            case compressionType = "CompressionType"
            case channelName = "ChannelName"
            case contentType = "ContentType"
            case dataSource = "DataSource"
            case shuffleConfig = "ShuffleConfig"
            case recordWrapperType = "RecordWrapperType"
        }
    }

    public struct NotebookInstanceLifecycleHook: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Content", required: false, type: .string)
        ]
        /// A base64-encoded string that contains a shell script for a notebook instance lifecycle configuration.
        public let content: String?

        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct DescribeEndpointInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]
        /// The name of the endpoint.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct UiConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UiTemplateS3Uri", required: true, type: .string)
        ]
        /// The Amazon S3 bucket location of the UI template.
        public let uiTemplateS3Uri: String

        public init(uiTemplateS3Uri: String) {
            self.uiTemplateS3Uri = uiTemplateS3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case uiTemplateS3Uri = "UiTemplateS3Uri"
        }
    }

    public struct ModelArtifacts: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3ModelArtifacts", required: true, type: .string)
        ]
        /// The path of the S3 object that contains the model artifacts. For example, s3://bucket-name/keynameprefix/model.tar.gz.
        public let s3ModelArtifacts: String

        public init(s3ModelArtifacts: String) {
            self.s3ModelArtifacts = s3ModelArtifacts
        }

        private enum CodingKeys: String, CodingKey {
            case s3ModelArtifacts = "S3ModelArtifacts"
        }
    }

    public struct LabelingJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LabelingJobOutput", required: false, type: .structure), 
            AWSShapeMember(label: "LabelingJobName", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "InputConfig", required: false, type: .structure), 
            AWSShapeMember(label: "AnnotationConsolidationLambdaArn", required: false, type: .string), 
            AWSShapeMember(label: "PreHumanTaskLambdaArn", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "LabelCounters", required: true, type: .structure), 
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "WorkteamArn", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobArn", required: true, type: .string)
        ]
        /// The location of the output produced by the labeling job.
        public let labelingJobOutput: LabelingJobOutput?
        /// The name of the labeling job.
        public let labelingJobName: String
        /// The current status of the labeling job. 
        public let labelingJobStatus: LabelingJobStatus
        /// Input configuration for the labeling job.
        public let inputConfig: LabelingJobInputConfig?
        /// The Amazon Resource Name (ARN) of the Lambda function used to consolidate the annotations from individual workers into a label for a data object. For more information, see Annotation Consolidation.
        public let annotationConsolidationLambdaArn: String?
        /// The Amazon Resource Name (ARN) of a Lambda function. The function is run before each data object is sent to a worker.
        public let preHumanTaskLambdaArn: String
        /// The date and time that the job was created (timestamp).
        public let creationTime: TimeStamp
        /// If the LabelingJobStatus field is Failed, this field contains a description of the error.
        public let failureReason: String?
        /// Counts showing the progress of the labeling job.
        public let labelCounters: LabelCounters
        /// The date and time that the job was last modified (timestamp).
        public let lastModifiedTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the work team assigned to the job.
        public let workteamArn: String
        /// The Amazon Resource Name (ARN) assigned to the labeling job when it was created.
        public let labelingJobArn: String

        public init(annotationConsolidationLambdaArn: String? = nil, creationTime: TimeStamp, failureReason: String? = nil, inputConfig: LabelingJobInputConfig? = nil, labelCounters: LabelCounters, labelingJobArn: String, labelingJobName: String, labelingJobOutput: LabelingJobOutput? = nil, labelingJobStatus: LabelingJobStatus, lastModifiedTime: TimeStamp, preHumanTaskLambdaArn: String, workteamArn: String) {
            self.labelingJobOutput = labelingJobOutput
            self.labelingJobName = labelingJobName
            self.labelingJobStatus = labelingJobStatus
            self.inputConfig = inputConfig
            self.annotationConsolidationLambdaArn = annotationConsolidationLambdaArn
            self.preHumanTaskLambdaArn = preHumanTaskLambdaArn
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.labelCounters = labelCounters
            self.lastModifiedTime = lastModifiedTime
            self.workteamArn = workteamArn
            self.labelingJobArn = labelingJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobOutput = "LabelingJobOutput"
            case labelingJobName = "LabelingJobName"
            case labelingJobStatus = "LabelingJobStatus"
            case inputConfig = "InputConfig"
            case annotationConsolidationLambdaArn = "AnnotationConsolidationLambdaArn"
            case preHumanTaskLambdaArn = "PreHumanTaskLambdaArn"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case labelCounters = "LabelCounters"
            case lastModifiedTime = "LastModifiedTime"
            case workteamArn = "WorkteamArn"
            case labelingJobArn = "LabelingJobArn"
        }
    }

    public enum ProductionVariantAcceleratorType: String, CustomStringConvertible, Codable {
        case mlEia1Medium = "ml.eia1.medium"
        case mlEia1Large = "ml.eia1.large"
        case mlEia1Xlarge = "ml.eia1.xlarge"
        public var description: String { return self.rawValue }
    }

    public struct ListTagsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// Maximum number of tags to return.
        public let maxResults: Int32?
        ///  If the response to the previous ListTags request is truncated, Amazon SageMaker returns this token. To retrieve the next set of tags, use it in the subsequent request. 
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
        public let resourceArn: String

        public init(maxResults: Int32? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceArn = "ResourceArn"
        }
    }

    public struct AlgorithmStatusDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ValidationStatuses", required: false, type: .list), 
            AWSShapeMember(label: "ImageScanStatuses", required: false, type: .list)
        ]
        /// The status of the validation of the algorithm.
        public let validationStatuses: [AlgorithmStatusItem]?
        /// The status of the scan of the algorithm's Docker image container.
        public let imageScanStatuses: [AlgorithmStatusItem]?

        public init(imageScanStatuses: [AlgorithmStatusItem]? = nil, validationStatuses: [AlgorithmStatusItem]? = nil) {
            self.validationStatuses = validationStatuses
            self.imageScanStatuses = imageScanStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case validationStatuses = "ValidationStatuses"
            case imageScanStatuses = "ImageScanStatuses"
        }
    }

    public struct PropertyNameSuggestion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PropertyName", required: false, type: .string)
        ]
        /// A suggested property name.
        public let propertyName: String?

        public init(propertyName: String? = nil) {
            self.propertyName = propertyName
        }

        private enum CodingKeys: String, CodingKey {
            case propertyName = "PropertyName"
        }
    }

    public struct StopNotebookInstanceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string)
        ]
        /// The name of the notebook instance to terminate.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String) {
            self.notebookInstanceName = notebookInstanceName
        }

        private enum CodingKeys: String, CodingKey {
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct SubscribedWorkteam: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamArn", required: true, type: .string), 
            AWSShapeMember(label: "SellerName", required: false, type: .string), 
            AWSShapeMember(label: "MarketplaceDescription", required: false, type: .string), 
            AWSShapeMember(label: "MarketplaceTitle", required: false, type: .string), 
            AWSShapeMember(label: "ListingId", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the vendor that you have subscribed.
        public let workteamArn: String
        /// The name of the vendor in the Amazon Marketplace.
        public let sellerName: String?
        /// The description of the vendor from the Amazon Marketplace.
        public let marketplaceDescription: String?
        /// The title of the service provided by the vendor in the Amazon Marketplace.
        public let marketplaceTitle: String?
        public let listingId: String?

        public init(listingId: String? = nil, marketplaceDescription: String? = nil, marketplaceTitle: String? = nil, sellerName: String? = nil, workteamArn: String) {
            self.workteamArn = workteamArn
            self.sellerName = sellerName
            self.marketplaceDescription = marketplaceDescription
            self.marketplaceTitle = marketplaceTitle
            self.listingId = listingId
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
            case sellerName = "SellerName"
            case marketplaceDescription = "MarketplaceDescription"
            case marketplaceTitle = "MarketplaceTitle"
            case listingId = "ListingId"
        }
    }

    public struct ListModelPackagesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp)
        ]
        /// A filter that returns only model packages created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// The parameter by which to sort the results. The default is CreationTime.
        public let sortBy: ModelPackageSortBy?
        /// The maximum number of model packages to return in the response.
        public let maxResults: Int32?
        /// A string in the model package name. This filter returns only model packages whose name contains the specified string.
        public let nameContains: String?
        /// The sort order for the results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// If the response to a previous ListModelPackages request was truncated, the response includes a NextToken. To retrieve the next set of model packages, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only model packages created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ModelPackageSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeBefore = creationTimeBefore
            self.sortBy = sortBy
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.sortOrder = sortOrder
            self.nextToken = nextToken
            self.creationTimeAfter = creationTimeAfter
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeBefore = "CreationTimeBefore"
            case sortBy = "SortBy"
            case maxResults = "MaxResults"
            case nameContains = "NameContains"
            case sortOrder = "SortOrder"
            case nextToken = "NextToken"
            case creationTimeAfter = "CreationTimeAfter"
        }
    }

    public struct AddTagsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]
        /// A list of tags associated with the Amazon SageMaker resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct DescribeTrainingJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingJobName", required: true, type: .string)
        ]
        /// The name of the training job.
        public let trainingJobName: String

        public init(trainingJobName: String) {
            self.trainingJobName = trainingJobName
        }

        private enum CodingKeys: String, CodingKey {
            case trainingJobName = "TrainingJobName"
        }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable {
        case integer = "Integer"
        case continuous = "Continuous"
        case categorical = "Categorical"
        case freetext = "FreeText"
        public var description: String { return self.rawValue }
    }

    public enum ProductionVariantInstanceType: String, CustomStringConvertible, Codable {
        case mlT2Medium = "ml.t2.medium"
        case mlT2Large = "ml.t2.large"
        case mlT2Xlarge = "ml.t2.xlarge"
        case mlT22Xlarge = "ml.t2.2xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlC4Large = "ml.c4.large"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlC5Large = "ml.c5.large"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackageStatus: String, CustomStringConvertible, Codable {
        case pending = "Pending"
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        case deleting = "Deleting"
        public var description: String { return self.rawValue }
    }

    public struct GetSearchSuggestionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PropertyNameSuggestions", required: false, type: .list)
        ]
        /// A list of property names for a Resource that match a SuggestionQuery.
        public let propertyNameSuggestions: [PropertyNameSuggestion]?

        public init(propertyNameSuggestions: [PropertyNameSuggestion]? = nil) {
            self.propertyNameSuggestions = propertyNameSuggestions
        }

        private enum CodingKeys: String, CodingKey {
            case propertyNameSuggestions = "PropertyNameSuggestions"
        }
    }

    public struct CreatePresignedNotebookInstanceUrlInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SessionExpirationDurationInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string)
        ]
        /// The duration of the session, in seconds. The default is 12 hours.
        public let sessionExpirationDurationInSeconds: Int32?
        /// The name of the notebook instance.
        public let notebookInstanceName: String

        public init(notebookInstanceName: String, sessionExpirationDurationInSeconds: Int32? = nil) {
            self.sessionExpirationDurationInSeconds = sessionExpirationDurationInSeconds
            self.notebookInstanceName = notebookInstanceName
        }

        private enum CodingKeys: String, CodingKey {
            case sessionExpirationDurationInSeconds = "SessionExpirationDurationInSeconds"
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct ListSubscribedWorkteamsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SubscribedWorkteams", required: true, type: .list)
        ]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of work teams, use it in the subsequent request.
        public let nextToken: String?
        /// An array of Workteam objects, each describing a work team.
        public let subscribedWorkteams: [SubscribedWorkteam]

        public init(nextToken: String? = nil, subscribedWorkteams: [SubscribedWorkteam]) {
            self.nextToken = nextToken
            self.subscribedWorkteams = subscribedWorkteams
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case subscribedWorkteams = "SubscribedWorkteams"
        }
    }

    public struct S3DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributeNames", required: false, type: .list), 
            AWSShapeMember(label: "S3DataDistributionType", required: false, type: .enum), 
            AWSShapeMember(label: "S3Uri", required: true, type: .string), 
            AWSShapeMember(label: "S3DataType", required: true, type: .enum)
        ]
        /// A list of one or more attribute names to use that are found in a specified augmented manifest file.
        public let attributeNames: [String]?
        /// If you want Amazon SageMaker to replicate the entire dataset on each ML compute instance that is launched for model training, specify FullyReplicated.  If you want Amazon SageMaker to replicate a subset of data on each ML compute instance that is launched for model training, specify ShardedByS3Key. If there are n ML compute instances launched for a training job, each instance gets approximately 1/n of the number of S3 objects. In this case, model training on each machine uses only the subset of training data.  Don't choose more ML compute instances for training than available S3 objects. If you do, some nodes won't get any data and you will pay for nodes that aren't getting any training data. This applies in both File and Pipemodes. Keep this in mind when developing algorithms.  In distributed training, where you use multiple ML compute EC2 instances, you might choose ShardedByS3Key. If the algorithm requires copying training data to the ML storage volume (when TrainingInputMode is set to File), this copies 1/n of the number of objects. 
        public let s3DataDistributionType: S3DataDistribution?
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest. For example:     A key name prefix might look like this: s3://bucketname/exampleprefix.     A manifest might look like this: s3://bucketname/example.manifest   The manifest is an S3 object which is a JSON file with the following format:   [    {"prefix": "s3://customer_bucket/some/prefix/"},    "relative/path/to/custdata-1",    "relative/path/custdata-2",    ...    ]   The preceding JSON matches the following s3Uris:   s3://customer_bucket/some/prefix/relative/path/to/custdata-1   s3://customer_bucket/some/prefix/relative/path/custdata-1   ...  The complete set of s3uris in this manifest is the input data for the channel for this datasource. The object that each s3uris points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on your behalf.   
        public let s3Uri: String
        /// If you choose S3Prefix, S3Uri identifies a key name prefix. Amazon SageMaker uses all objects that match the specified key name prefix for model training.  If you choose ManifestFile, S3Uri identifies an object that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for model training.  If you choose AugmentedManifestFile, S3Uri identifies an object that is an augmented manifest file in JSON lines format. This file contains the data you want to use for model training. AugmentedManifestFile can only be used if the Channel's input mode is Pipe.
        public let s3DataType: S3DataType

        public init(attributeNames: [String]? = nil, s3DataDistributionType: S3DataDistribution? = nil, s3DataType: S3DataType, s3Uri: String) {
            self.attributeNames = attributeNames
            self.s3DataDistributionType = s3DataDistributionType
            self.s3Uri = s3Uri
            self.s3DataType = s3DataType
        }

        private enum CodingKeys: String, CodingKey {
            case attributeNames = "AttributeNames"
            case s3DataDistributionType = "S3DataDistributionType"
            case s3Uri = "S3Uri"
            case s3DataType = "S3DataType"
        }
    }

    public struct UpdateCodeRepositoryOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodeRepositoryArn", required: true, type: .string)
        ]
        /// The ARN of the git repository.
        public let codeRepositoryArn: String

        public init(codeRepositoryArn: String) {
            self.codeRepositoryArn = codeRepositoryArn
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryArn = "CodeRepositoryArn"
        }
    }

    public struct DeleteWorkteamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Success", required: true, type: .boolean)
        ]
        /// Returns true if the work team was successfully deleted; otherwise, returns false.
        public let success: Bool

        public init(success: Bool) {
            self.success = success
        }

        private enum CodingKeys: String, CodingKey {
            case success = "Success"
        }
    }

    public struct ListEndpointConfigsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigs", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of endpoint configurations.
        public let endpointConfigs: [EndpointConfigSummary]
        ///  If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of endpoint configurations, use it in the subsequent request 
        public let nextToken: String?

        public init(endpointConfigs: [EndpointConfigSummary], nextToken: String? = nil) {
            self.endpointConfigs = endpointConfigs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigs = "EndpointConfigs"
            case nextToken = "NextToken"
        }
    }

    public struct LabelCountersForWorkteam: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HumanLabeled", required: false, type: .integer), 
            AWSShapeMember(label: "Total", required: false, type: .integer), 
            AWSShapeMember(label: "PendingHuman", required: false, type: .integer)
        ]
        /// The total number of data objects labeled by a human worker.
        public let humanLabeled: Int32?
        /// The total number of tasks in the labeling job.
        public let total: Int32?
        /// The total number of data objects that need to be labeled by a human worker.
        public let pendingHuman: Int32?

        public init(humanLabeled: Int32? = nil, pendingHuman: Int32? = nil, total: Int32? = nil) {
            self.humanLabeled = humanLabeled
            self.total = total
            self.pendingHuman = pendingHuman
        }

        private enum CodingKeys: String, CodingKey {
            case humanLabeled = "HumanLabeled"
            case total = "Total"
            case pendingHuman = "PendingHuman"
        }
    }

    public struct CreateModelPackageOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelPackageArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the new model package.
        public let modelPackageArn: String

        public init(modelPackageArn: String) {
            self.modelPackageArn = modelPackageArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackageArn = "ModelPackageArn"
        }
    }

    public struct ListAlgorithmsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmSummaryList", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// &gt;An array of AlgorithmSummary objects, each of which lists an algorithm.
        public let algorithmSummaryList: [AlgorithmSummary]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of algorithms, use it in the subsequent request.
        public let nextToken: String?

        public init(algorithmSummaryList: [AlgorithmSummary], nextToken: String? = nil) {
            self.algorithmSummaryList = algorithmSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSummaryList = "AlgorithmSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3DataSource", required: true, type: .structure)
        ]
        /// The S3 location of the data source that is associated with a channel.
        public let s3DataSource: S3DataSource

        public init(s3DataSource: S3DataSource) {
            self.s3DataSource = s3DataSource
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "S3DataSource"
        }
    }

    public struct AlgorithmStatusItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: true, type: .enum)
        ]
        /// The name of the algorithm for which the overall status is being repoorted.
        public let name: String
        /// The reason for failure, if the overall status is a failed state.
        public let failureReason: String?
        /// The current status.
        public let status: DetailedAlgorithmStatus

        public init(failureReason: String? = nil, name: String, status: DetailedAlgorithmStatus) {
            self.name = name
            self.failureReason = failureReason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case failureReason = "FailureReason"
            case status = "Status"
        }
    }

    public struct InputConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Framework", required: true, type: .enum), 
            AWSShapeMember(label: "DataInputConfig", required: true, type: .string), 
            AWSShapeMember(label: "S3Uri", required: true, type: .string)
        ]
        /// Identifies the framework in which the model was trained. For example: TENSORFLOW.
        public let framework: Framework
        /// Specifies the name and shape of the expected data inputs for your trained model with a JSON dictionary form. The data inputs are InputConfig$Framework specific.     TENSORFLOW, MXNET and ONNX: You must specify the name and shape of the expected data inputs in order using a dictionary format for your trained model.   Example of one input: {data:[1,3,1024,1024]}}    Example for two inputs: {var1: [1,1,28,28], var2:[1,1,28,28]}       PYTORCH: You can either specify the name and shape of expected data inputs in order using a dictionary format for your trained model or you can specify the shape only using a list format.   Example of one input in dictionary format: {input0:[1,3,224,234]}    Example of one input in list format: [1,3,224,224]    Example of two inputs in dictionary format: {input0:[1,3,224,234], 'input1':[1,3,224,224]}    Example of two inputs in list format: [[1,3,224,224], [1,3,224,224]]       XGBOOST: input data name and shape are not needed.  
        public let dataInputConfig: String
        /// The S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        public let s3Uri: String

        public init(dataInputConfig: String, framework: Framework, s3Uri: String) {
            self.framework = framework
            self.dataInputConfig = dataInputConfig
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case framework = "Framework"
            case dataInputConfig = "DataInputConfig"
            case s3Uri = "S3Uri"
        }
    }

    public struct VpcConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecurityGroupIds", required: true, type: .list), 
            AWSShapeMember(label: "Subnets", required: true, type: .list)
        ]
        /// The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        public let securityGroupIds: [String]
        /// The ID of the subnets in the VPC to which you want to connect your training job or model. 
        public let subnets: [String]

        public init(securityGroupIds: [String], subnets: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
        }
    }

    public struct DescribeEndpointConfigInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string)
        ]
        /// The name of the endpoint configuration.
        public let endpointConfigName: String

        public init(endpointConfigName: String) {
            self.endpointConfigName = endpointConfigName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigName = "EndpointConfigName"
        }
    }

    public struct StopTransformJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TransformJobName", required: true, type: .string)
        ]
        /// The name of the transform job to stop.
        public let transformJobName: String

        public init(transformJobName: String) {
            self.transformJobName = transformJobName
        }

        private enum CodingKeys: String, CodingKey {
            case transformJobName = "TransformJobName"
        }
    }

    public struct HyperParameterTrainingJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TrainingStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "FinalHyperParameterTuningJobObjectiveMetric", required: false, type: .structure), 
            AWSShapeMember(label: "ObjectiveStatus", required: false, type: .enum), 
            AWSShapeMember(label: "TrainingJobName", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "TrainingJobArn", required: true, type: .string), 
            AWSShapeMember(label: "TrainingJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "TrainingEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TuningJobName", required: false, type: .string), 
            AWSShapeMember(label: "TunedHyperParameters", required: true, type: .map)
        ]
        /// The date and time that the training job started.
        public let trainingStartTime: TimeStamp?
        /// The FinalHyperParameterTuningJobObjectiveMetric object that specifies the value of the objective metric of the tuning job that launched this training job.
        public let finalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric?
        /// The status of the objective metric for the training job:   Succeeded: The final objective metric for the training job was evaluated by the hyperparameter tuning job and used in the hyperparameter tuning process.     Pending: The training job is in progress and evaluation of its final objective metric is pending.     Failed: The final objective metric for the training job was not evaluated, and was not used in the hyperparameter tuning process. This typically occurs when the training job failed or did not emit an objective metric.  
        public let objectiveStatus: ObjectiveStatus?
        /// The name of the training job.
        public let trainingJobName: String
        /// The date and time that the training job was created.
        public let creationTime: TimeStamp
        /// The reason that the training job failed. 
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the training job.
        public let trainingJobArn: String
        /// The status of the training job.
        public let trainingJobStatus: TrainingJobStatus
        /// The date and time that the training job ended.
        public let trainingEndTime: TimeStamp?
        /// The name of the hyperparameter tuning job that launched this training job.
        public let tuningJobName: String?
        /// A list of the hyperparameters for which you specified ranges to search.
        public let tunedHyperParameters: [String: String]

        public init(creationTime: TimeStamp, failureReason: String? = nil, finalHyperParameterTuningJobObjectiveMetric: FinalHyperParameterTuningJobObjectiveMetric? = nil, objectiveStatus: ObjectiveStatus? = nil, trainingEndTime: TimeStamp? = nil, trainingJobArn: String, trainingJobName: String, trainingJobStatus: TrainingJobStatus, trainingStartTime: TimeStamp? = nil, tunedHyperParameters: [String: String], tuningJobName: String? = nil) {
            self.trainingStartTime = trainingStartTime
            self.finalHyperParameterTuningJobObjectiveMetric = finalHyperParameterTuningJobObjectiveMetric
            self.objectiveStatus = objectiveStatus
            self.trainingJobName = trainingJobName
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.trainingJobArn = trainingJobArn
            self.trainingJobStatus = trainingJobStatus
            self.trainingEndTime = trainingEndTime
            self.tuningJobName = tuningJobName
            self.tunedHyperParameters = tunedHyperParameters
        }

        private enum CodingKeys: String, CodingKey {
            case trainingStartTime = "TrainingStartTime"
            case finalHyperParameterTuningJobObjectiveMetric = "FinalHyperParameterTuningJobObjectiveMetric"
            case objectiveStatus = "ObjectiveStatus"
            case trainingJobName = "TrainingJobName"
            case creationTime = "CreationTime"
            case failureReason = "FailureReason"
            case trainingJobArn = "TrainingJobArn"
            case trainingJobStatus = "TrainingJobStatus"
            case trainingEndTime = "TrainingEndTime"
            case tuningJobName = "TuningJobName"
            case tunedHyperParameters = "TunedHyperParameters"
        }
    }

    public enum AssemblyType: String, CustomStringConvertible, Codable {
        case none = "None"
        case line = "Line"
        public var description: String { return self.rawValue }
    }

    public struct MetricData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .float), 
            AWSShapeMember(label: "Timestamp", required: false, type: .timestamp)
        ]
        /// The name of the metric.
        public let metricName: String?
        /// The value of the metric.
        public let value: Float?
        /// The date and time that the algorithm emitted the metric.
        public let timestamp: TimeStamp?

        public init(metricName: String? = nil, timestamp: TimeStamp? = nil, value: Float? = nil) {
            self.metricName = metricName
            self.value = value
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case value = "Value"
            case timestamp = "Timestamp"
        }
    }

    public enum NotebookInstanceSortKey: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public struct CreateCodeRepositoryOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodeRepositoryArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the new repository.
        public let codeRepositoryArn: String

        public init(codeRepositoryArn: String) {
            self.codeRepositoryArn = codeRepositoryArn
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryArn = "CodeRepositoryArn"
        }
    }

    public struct MetricDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Regex", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A regular expression that searches the output of a training job and gets the value of the metric. For more information about using regular expressions to define metrics, see Defining Objective Metrics.
        public let regex: String
        /// The name of the metric.
        public let name: String

        public init(name: String, regex: String) {
            self.regex = regex
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case regex = "Regex"
            case name = "Name"
        }
    }

    public enum DetailedAlgorithmStatus: String, CustomStringConvertible, Codable {
        case notstarted = "NotStarted"
        case inprogress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct ListWorkteamsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Workteams", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of Workteam objects, each describing a work team.
        public let workteams: [Workteam]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of work teams, use it in the subsequent request.
        public let nextToken: String?

        public init(nextToken: String? = nil, workteams: [Workteam]) {
            self.workteams = workteams
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case workteams = "Workteams"
            case nextToken = "NextToken"
        }
    }

    public struct DeleteCodeRepositoryInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodeRepositoryName", required: true, type: .string)
        ]
        /// The name of the git repository to delete.
        public let codeRepositoryName: String

        public init(codeRepositoryName: String) {
            self.codeRepositoryName = codeRepositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case codeRepositoryName = "CodeRepositoryName"
        }
    }

    public struct HyperParameterTuningJobObjective: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: true, type: .string), 
            AWSShapeMember(label: "Type", required: true, type: .enum)
        ]
        /// The name of the metric to use for the objective metric.
        public let metricName: String
        /// Whether to minimize or maximize the objective metric.
        public let `type`: HyperParameterTuningJobObjectiveType

        public init(metricName: String, type: HyperParameterTuningJobObjectiveType) {
            self.metricName = metricName
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case `type` = "Type"
        }
    }

    public struct TransformJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "TransformJobStatus", required: true, type: .enum), 
            AWSShapeMember(label: "TransformEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TransformJobName", required: true, type: .string), 
            AWSShapeMember(label: "TransformJobArn", required: true, type: .string)
        ]
        /// If the transform job failed, the reason it failed.
        public let failureReason: String?
        /// Indicates when the transform job was last modified.
        public let lastModifiedTime: TimeStamp?
        /// A timestamp that shows when the transform Job was created.
        public let creationTime: TimeStamp
        /// The status of the transform job.
        public let transformJobStatus: TransformJobStatus
        /// Indicates when the transform job ends on compute instances. For successful jobs and stopped jobs, this is the exact time recorded after the results are uploaded. For failed jobs, this is when Amazon SageMaker detected that the job failed.
        public let transformEndTime: TimeStamp?
        /// The name of the transform job.
        public let transformJobName: String
        /// The Amazon Resource Name (ARN) of the transform job.
        public let transformJobArn: String

        public init(creationTime: TimeStamp, failureReason: String? = nil, lastModifiedTime: TimeStamp? = nil, transformEndTime: TimeStamp? = nil, transformJobArn: String, transformJobName: String, transformJobStatus: TransformJobStatus) {
            self.failureReason = failureReason
            self.lastModifiedTime = lastModifiedTime
            self.creationTime = creationTime
            self.transformJobStatus = transformJobStatus
            self.transformEndTime = transformEndTime
            self.transformJobName = transformJobName
            self.transformJobArn = transformJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case lastModifiedTime = "LastModifiedTime"
            case creationTime = "CreationTime"
            case transformJobStatus = "TransformJobStatus"
            case transformEndTime = "TransformEndTime"
            case transformJobName = "TransformJobName"
            case transformJobArn = "TransformJobArn"
        }
    }

    public struct HumanTaskConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TaskDescription", required: true, type: .string), 
            AWSShapeMember(label: "AnnotationConsolidationConfig", required: true, type: .structure), 
            AWSShapeMember(label: "PublicWorkforceTaskPrice", required: false, type: .structure), 
            AWSShapeMember(label: "PreHumanTaskLambdaArn", required: true, type: .string), 
            AWSShapeMember(label: "TaskKeywords", required: false, type: .list), 
            AWSShapeMember(label: "WorkteamArn", required: true, type: .string), 
            AWSShapeMember(label: "TaskTitle", required: true, type: .string), 
            AWSShapeMember(label: "TaskAvailabilityLifetimeInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "MaxConcurrentTaskCount", required: false, type: .integer), 
            AWSShapeMember(label: "UiConfig", required: true, type: .structure), 
            AWSShapeMember(label: "NumberOfHumanWorkersPerDataObject", required: true, type: .integer), 
            AWSShapeMember(label: "TaskTimeLimitInSeconds", required: true, type: .integer)
        ]
        /// A description of the task for your human workers.
        public let taskDescription: String
        /// Configures how labels are consolidated across human workers.
        public let annotationConsolidationConfig: AnnotationConsolidationConfig
        /// The price that you pay for each task performed by a public worker.
        public let publicWorkforceTaskPrice: PublicWorkforceTaskPrice?
        /// The Amazon Resource Name (ARN) of a Lambda function that is run before a data object is sent to a human worker. Use this function to provide input to a custom labeling job.
        public let preHumanTaskLambdaArn: String
        /// Keywords used to describe the task so that workers on Amazon Mechanical Turk can discover the task.
        public let taskKeywords: [String]?
        /// The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.
        public let workteamArn: String
        /// A title for the task for your human workers.
        public let taskTitle: String
        /// The length of time that a task remains available for labelling by human workers.
        public let taskAvailabilityLifetimeInSeconds: Int32?
        /// Defines the maximum number of data objects that can be labeled by human workers at the same time. Each object may have more than one worker at one time.
        public let maxConcurrentTaskCount: Int32?
        /// Information about the user interface that workers use to complete the labeling task.
        public let uiConfig: UiConfig
        /// The number of human workers that will label an object. 
        public let numberOfHumanWorkersPerDataObject: Int32
        /// The amount of time that a worker has to complete a task.
        public let taskTimeLimitInSeconds: Int32

        public init(annotationConsolidationConfig: AnnotationConsolidationConfig, maxConcurrentTaskCount: Int32? = nil, numberOfHumanWorkersPerDataObject: Int32, preHumanTaskLambdaArn: String, publicWorkforceTaskPrice: PublicWorkforceTaskPrice? = nil, taskAvailabilityLifetimeInSeconds: Int32? = nil, taskDescription: String, taskKeywords: [String]? = nil, taskTimeLimitInSeconds: Int32, taskTitle: String, uiConfig: UiConfig, workteamArn: String) {
            self.taskDescription = taskDescription
            self.annotationConsolidationConfig = annotationConsolidationConfig
            self.publicWorkforceTaskPrice = publicWorkforceTaskPrice
            self.preHumanTaskLambdaArn = preHumanTaskLambdaArn
            self.taskKeywords = taskKeywords
            self.workteamArn = workteamArn
            self.taskTitle = taskTitle
            self.taskAvailabilityLifetimeInSeconds = taskAvailabilityLifetimeInSeconds
            self.maxConcurrentTaskCount = maxConcurrentTaskCount
            self.uiConfig = uiConfig
            self.numberOfHumanWorkersPerDataObject = numberOfHumanWorkersPerDataObject
            self.taskTimeLimitInSeconds = taskTimeLimitInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case taskDescription = "TaskDescription"
            case annotationConsolidationConfig = "AnnotationConsolidationConfig"
            case publicWorkforceTaskPrice = "PublicWorkforceTaskPrice"
            case preHumanTaskLambdaArn = "PreHumanTaskLambdaArn"
            case taskKeywords = "TaskKeywords"
            case workteamArn = "WorkteamArn"
            case taskTitle = "TaskTitle"
            case taskAvailabilityLifetimeInSeconds = "TaskAvailabilityLifetimeInSeconds"
            case maxConcurrentTaskCount = "MaxConcurrentTaskCount"
            case uiConfig = "UiConfig"
            case numberOfHumanWorkersPerDataObject = "NumberOfHumanWorkersPerDataObject"
            case taskTimeLimitInSeconds = "TaskTimeLimitInSeconds"
        }
    }

    public enum SecondaryStatus: String, CustomStringConvertible, Codable {
        case starting = "Starting"
        case launchingmlinstances = "LaunchingMLInstances"
        case preparingtrainingstack = "PreparingTrainingStack"
        case downloading = "Downloading"
        case downloadingtrainingimage = "DownloadingTrainingImage"
        case training = "Training"
        case uploading = "Uploading"
        case stopping = "Stopping"
        case stopped = "Stopped"
        case maxruntimeexceeded = "MaxRuntimeExceeded"
        case completed = "Completed"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct EndpointSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndpointStatus", required: true, type: .enum)
        ]
        /// A timestamp that shows when the endpoint was last modified.
        public let lastModifiedTime: TimeStamp
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The name of the endpoint.
        public let endpointName: String
        /// A timestamp that shows when the endpoint was created.
        public let creationTime: TimeStamp
        /// The status of the endpoint.    OutOfService: Endpoint is not available to take incoming requests.    Creating: CreateEndpoint is executing.    Updating: UpdateEndpoint or UpdateEndpointWeightsAndCapacities is executing.    SystemUpdating: Endpoint is undergoing maintenance and cannot be updated or deleted or re-scaled until it has completed. This mainenance operation does not change any customer-specified values such as VPC config, KMS encryption, model, instance type, or instance count.    RollingBack: Endpoint fails to scale up or down or change its variant weight and is in the process of rolling back to its previous configuration. Once the rollback completes, endpoint returns to an InService status. This transitional status only applies to an endpoint that has autoscaling enabled and is undergoing variant weight or capacity changes as part of an UpdateEndpointWeightsAndCapacities call or when the UpdateEndpointWeightsAndCapacities operation is called explicitly.    InService: Endpoint is available to process incoming requests.    Deleting: DeleteEndpoint is executing.    Failed: Endpoint could not be created, updated, or re-scaled. Use DescribeEndpointOutput$FailureReason for information about the failure. DeleteEndpoint is the only operation that can be performed on a failed endpoint.   To get a list of endpoints with a specified status, use the ListEndpointsInput$StatusEquals filter.
        public let endpointStatus: EndpointStatus

        public init(creationTime: TimeStamp, endpointArn: String, endpointName: String, endpointStatus: EndpointStatus, lastModifiedTime: TimeStamp) {
            self.lastModifiedTime = lastModifiedTime
            self.endpointArn = endpointArn
            self.endpointName = endpointName
            self.creationTime = creationTime
            self.endpointStatus = endpointStatus
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedTime = "LastModifiedTime"
            case endpointArn = "EndpointArn"
            case endpointName = "EndpointName"
            case creationTime = "CreationTime"
            case endpointStatus = "EndpointStatus"
        }
    }

    public struct ParentHyperParameterTuningJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HyperParameterTuningJobName", required: false, type: .string)
        ]
        /// The name of the hyperparameter tuning job to be used as a starting point for a new hyperparameter tuning job.
        public let hyperParameterTuningJobName: String?

        public init(hyperParameterTuningJobName: String? = nil) {
            self.hyperParameterTuningJobName = hyperParameterTuningJobName
        }

        private enum CodingKeys: String, CodingKey {
            case hyperParameterTuningJobName = "HyperParameterTuningJobName"
        }
    }

    public struct StopLabelingJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LabelingJobName", required: true, type: .string)
        ]
        /// The name of the labeling job to stop.
        public let labelingJobName: String

        public init(labelingJobName: String) {
            self.labelingJobName = labelingJobName
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobName = "LabelingJobName"
        }
    }

    public struct ListEndpointsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Endpoints", required: true, type: .list)
        ]
        ///  If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of training jobs, use it in the subsequent request. 
        public let nextToken: String?
        ///  An array or endpoint objects. 
        public let endpoints: [EndpointSummary]

        public init(endpoints: [EndpointSummary], nextToken: String? = nil) {
            self.nextToken = nextToken
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case endpoints = "Endpoints"
        }
    }

    public struct IntegerParameterRangeSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxValue", required: true, type: .string), 
            AWSShapeMember(label: "MinValue", required: true, type: .string)
        ]
        /// The maximum integer value allowed.
        public let maxValue: String
        /// The minimum integer value allowed.
        public let minValue: String

        public init(maxValue: String, minValue: String) {
            self.maxValue = maxValue
            self.minValue = minValue
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public struct DeployedImage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResolvedImage", required: false, type: .string), 
            AWSShapeMember(label: "ResolutionTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "SpecifiedImage", required: false, type: .string)
        ]
        /// The specific digest path of the image hosted in this ProductionVariant.
        public let resolvedImage: String?
        /// The date and time when the image path for the model resolved to the ResolvedImage 
        public let resolutionTime: TimeStamp?
        /// The image path you specified when you created the model.
        public let specifiedImage: String?

        public init(resolutionTime: TimeStamp? = nil, resolvedImage: String? = nil, specifiedImage: String? = nil) {
            self.resolvedImage = resolvedImage
            self.resolutionTime = resolutionTime
            self.specifiedImage = specifiedImage
        }

        private enum CodingKeys: String, CodingKey {
            case resolvedImage = "ResolvedImage"
            case resolutionTime = "ResolutionTime"
            case specifiedImage = "SpecifiedImage"
        }
    }

    public struct ListTransformJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TransformJobSummaries", required: true, type: .list)
        ]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of transform jobs, use it in the next request.
        public let nextToken: String?
        /// An array of TransformJobSummary objects.
        public let transformJobSummaries: [TransformJobSummary]

        public init(nextToken: String? = nil, transformJobSummaries: [TransformJobSummary]) {
            self.nextToken = nextToken
            self.transformJobSummaries = transformJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transformJobSummaries = "TransformJobSummaries"
        }
    }

    public struct ListWorkteamsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: ListWorkteamsSortByOptions?
        /// A string in the work team's name. This filter returns only work teams whose name contains the specified string.
        public let nameContains: String?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?
        /// If the result of the previous ListWorkteams request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?
        /// The maximum number of work teams to return in each page of the response.
        public let maxResults: Int32?

        public init(maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: ListWorkteamsSortByOptions? = nil, sortOrder: SortOrder? = nil) {
            self.sortBy = sortBy
            self.nameContains = nameContains
            self.sortOrder = sortOrder
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "SortBy"
            case nameContains = "NameContains"
            case sortOrder = "SortOrder"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct NestedFilters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NestedPropertyName", required: true, type: .string), 
            AWSShapeMember(label: "Filters", required: true, type: .list)
        ]
        /// .The name of the property used in the nested filters.
        public let nestedPropertyName: String
        /// A list of filters. Each filter acts on a property. For example, a NestedFilters call might include a filter on the PropertyName parameter fof the InputDataConfig property: InputDataConfig.DataSource.S3DataSource.S3Uri.
        public let filters: [Filter]

        public init(filters: [Filter], nestedPropertyName: String) {
            self.nestedPropertyName = nestedPropertyName
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case nestedPropertyName = "NestedPropertyName"
            case filters = "Filters"
        }
    }

    public enum ListWorkteamsSortByOptions: String, CustomStringConvertible, Codable {
        case name = "Name"
        case createdate = "CreateDate"
        public var description: String { return self.rawValue }
    }

    public struct DeleteModelInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelName", required: true, type: .string)
        ]
        /// The name of the model to delete.
        public let modelName: String

        public init(modelName: String) {
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
        }
    }

    public struct ListLabelingJobsForWorkteamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamArn", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "JobReferenceCodeContains", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum)
        ]
        /// The Amazon Resource Name (ARN) of the work team for which you want to see labeling jobs for.
        public let workteamArn: String
        /// The maximum number of labeling jobs to return in each page of the response.
        public let maxResults: Int32?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: ListLabelingJobsForWorkteamSortByOptions?
        /// A filter the limits jobs to only the ones whose job reference code contains the specified string.
        public let jobReferenceCodeContains: String?
        /// A filter that returns only labeling jobs created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// If the result of the previous ListLabelingJobsForWorkteam request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only labeling jobs created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, jobReferenceCodeContains: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil, sortBy: ListLabelingJobsForWorkteamSortByOptions? = nil, sortOrder: SortOrder? = nil, workteamArn: String) {
            self.workteamArn = workteamArn
            self.maxResults = maxResults
            self.sortBy = sortBy
            self.jobReferenceCodeContains = jobReferenceCodeContains
            self.creationTimeAfter = creationTimeAfter
            self.nextToken = nextToken
            self.creationTimeBefore = creationTimeBefore
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
            case maxResults = "MaxResults"
            case sortBy = "SortBy"
            case jobReferenceCodeContains = "JobReferenceCodeContains"
            case creationTimeAfter = "CreationTimeAfter"
            case nextToken = "NextToken"
            case creationTimeBefore = "CreationTimeBefore"
            case sortOrder = "SortOrder"
        }
    }

    public struct ListLabelingJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "SortBy", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastModifiedTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "StatusEquals", required: false, type: .enum), 
            AWSShapeMember(label: "NameContains", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimeAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CreationTimeBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "SortOrder", required: false, type: .enum)
        ]
        /// The maximum number of labeling jobs to return in each page of the response.
        public let maxResults: Int32?
        /// The field to sort results by. The default is CreationTime.
        public let sortBy: SortBy?
        /// A filter that returns only labeling jobs created after the specified time (timestamp).
        public let creationTimeAfter: TimeStamp?
        /// A filter that returns only labeling jobs modified before the specified time (timestamp).
        public let lastModifiedTimeBefore: TimeStamp?
        /// A filter that retrieves only labeling jobs with a specific status.
        public let statusEquals: LabelingJobStatus?
        /// A string in the labeling job name. This filter returns only labeling jobs whose name contains the specified string.
        public let nameContains: String?
        /// A filter that returns only labeling jobs modified after the specified time (timestamp).
        public let lastModifiedTimeAfter: TimeStamp?
        /// If the result of the previous ListLabelingJobs request was truncated, the response includes a NextToken. To retrieve the next set of labeling jobs, use the token in the next request.
        public let nextToken: String?
        /// A filter that returns only labeling jobs created before the specified time (timestamp).
        public let creationTimeBefore: TimeStamp?
        /// The sort order for results. The default is Ascending.
        public let sortOrder: SortOrder?

        public init(creationTimeAfter: TimeStamp? = nil, creationTimeBefore: TimeStamp? = nil, lastModifiedTimeAfter: TimeStamp? = nil, lastModifiedTimeBefore: TimeStamp? = nil, maxResults: Int32? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortBy? = nil, sortOrder: SortOrder? = nil, statusEquals: LabelingJobStatus? = nil) {
            self.maxResults = maxResults
            self.sortBy = sortBy
            self.creationTimeAfter = creationTimeAfter
            self.lastModifiedTimeBefore = lastModifiedTimeBefore
            self.statusEquals = statusEquals
            self.nameContains = nameContains
            self.lastModifiedTimeAfter = lastModifiedTimeAfter
            self.nextToken = nextToken
            self.creationTimeBefore = creationTimeBefore
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case sortBy = "SortBy"
            case creationTimeAfter = "CreationTimeAfter"
            case lastModifiedTimeBefore = "LastModifiedTimeBefore"
            case statusEquals = "StatusEquals"
            case nameContains = "NameContains"
            case lastModifiedTimeAfter = "LastModifiedTimeAfter"
            case nextToken = "NextToken"
            case creationTimeBefore = "CreationTimeBefore"
            case sortOrder = "SortOrder"
        }
    }

    public struct ProductionVariant: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ModelName", required: true, type: .string), 
            AWSShapeMember(label: "InitialVariantWeight", required: false, type: .float), 
            AWSShapeMember(label: "AcceleratorType", required: false, type: .enum), 
            AWSShapeMember(label: "InstanceType", required: true, type: .enum), 
            AWSShapeMember(label: "VariantName", required: true, type: .string), 
            AWSShapeMember(label: "InitialInstanceCount", required: true, type: .integer)
        ]
        /// The name of the model that you want to host. This is the name that you specified when creating the model.
        public let modelName: String
        /// Determines initial traffic distribution among all of the models that you specify in the endpoint configuration. The traffic to a production variant is determined by the ratio of the VariantWeight to the sum of all VariantWeight values across all ProductionVariants. If unspecified, it defaults to 1.0. 
        public let initialVariantWeight: Float?
        /// The size of the Elastic Inference (EI) instance to use for the production variant. EI instances provide on-demand GPU computing for inference. For more information, see Using Elastic Inference in Amazon SageMaker. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorType: ProductionVariantAcceleratorType?
        /// The ML compute instance type.
        public let instanceType: ProductionVariantInstanceType
        /// The name of the production variant.
        public let variantName: String
        /// Number of instances to launch initially.
        public let initialInstanceCount: Int32

        public init(acceleratorType: ProductionVariantAcceleratorType? = nil, initialInstanceCount: Int32, initialVariantWeight: Float? = nil, instanceType: ProductionVariantInstanceType, modelName: String, variantName: String) {
            self.modelName = modelName
            self.initialVariantWeight = initialVariantWeight
            self.acceleratorType = acceleratorType
            self.instanceType = instanceType
            self.variantName = variantName
            self.initialInstanceCount = initialInstanceCount
        }

        private enum CodingKeys: String, CodingKey {
            case modelName = "ModelName"
            case initialVariantWeight = "InitialVariantWeight"
            case acceleratorType = "AcceleratorType"
            case instanceType = "InstanceType"
            case variantName = "VariantName"
            case initialInstanceCount = "InitialInstanceCount"
        }
    }

    public struct LabelingJobForWorkteamSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobReferenceCode", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobName", required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "WorkRequesterAccountId", required: true, type: .string), 
            AWSShapeMember(label: "LabelCounters", required: false, type: .structure)
        ]
        /// A unique identifier for a labeling job. You can use this to refer to a specific labeling job.
        public let jobReferenceCode: String
        /// The name of the labeling job that the work team is assigned to.
        public let labelingJobName: String?
        /// The date and time that the labeling job was created.
        public let creationTime: TimeStamp
        public let workRequesterAccountId: String
        /// Provides information about the progress of a labeling job.
        public let labelCounters: LabelCountersForWorkteam?

        public init(creationTime: TimeStamp, jobReferenceCode: String, labelCounters: LabelCountersForWorkteam? = nil, labelingJobName: String? = nil, workRequesterAccountId: String) {
            self.jobReferenceCode = jobReferenceCode
            self.labelingJobName = labelingJobName
            self.creationTime = creationTime
            self.workRequesterAccountId = workRequesterAccountId
            self.labelCounters = labelCounters
        }

        private enum CodingKeys: String, CodingKey {
            case jobReferenceCode = "JobReferenceCode"
            case labelingJobName = "LabelingJobName"
            case creationTime = "CreationTime"
            case workRequesterAccountId = "WorkRequesterAccountId"
            case labelCounters = "LabelCounters"
        }
    }

    public enum ModelPackageSortBy: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEndpointConfigOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigArn", required: true, type: .string), 
            AWSShapeMember(label: "EndpointConfigName", required: true, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "ProductionVariants", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the endpoint configuration.
        public let endpointConfigArn: String
        /// Name of the Amazon SageMaker endpoint configuration.
        public let endpointConfigName: String
        /// AWS KMS key ID Amazon SageMaker uses to encrypt data when storing it on the ML storage volume attached to the instance.
        public let kmsKeyId: String?
        /// A timestamp that shows when the endpoint configuration was created.
        public let creationTime: TimeStamp
        /// An array of ProductionVariant objects, one for each model that you want to host at this endpoint.
        public let productionVariants: [ProductionVariant]

        public init(creationTime: TimeStamp, endpointConfigArn: String, endpointConfigName: String, kmsKeyId: String? = nil, productionVariants: [ProductionVariant]) {
            self.endpointConfigArn = endpointConfigArn
            self.endpointConfigName = endpointConfigName
            self.kmsKeyId = kmsKeyId
            self.creationTime = creationTime
            self.productionVariants = productionVariants
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigArn = "EndpointConfigArn"
            case endpointConfigName = "EndpointConfigName"
            case kmsKeyId = "KmsKeyId"
            case creationTime = "CreationTime"
            case productionVariants = "ProductionVariants"
        }
    }

    public enum EndpointStatus: String, CustomStringConvertible, Codable {
        case outofservice = "OutOfService"
        case creating = "Creating"
        case updating = "Updating"
        case systemupdating = "SystemUpdating"
        case rollingback = "RollingBack"
        case inservice = "InService"
        case deleting = "Deleting"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public struct OutputConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3OutputLocation", required: true, type: .string), 
            AWSShapeMember(label: "TargetDevice", required: true, type: .enum)
        ]
        /// Identifies the S3 path where you want Amazon SageMaker to store the model artifacts. For example, s3://bucket-name/key-name-prefix.
        public let s3OutputLocation: String
        /// Identifies the device that you want to run your model on after it has been compiled. For example: ml_c5.
        public let targetDevice: TargetDevice

        public init(s3OutputLocation: String, targetDevice: TargetDevice) {
            self.s3OutputLocation = s3OutputLocation
            self.targetDevice = targetDevice
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputLocation = "S3OutputLocation"
            case targetDevice = "TargetDevice"
        }
    }

    public struct ListLabelingJobsForWorkteamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "LabelingJobSummaryList", required: true, type: .list)
        ]
        /// If the response is truncated, Amazon SageMaker returns this token. To retrieve the next set of labeling jobs, use it in the subsequent request.
        public let nextToken: String?
        /// An array of LabelingJobSummary objects, each describing a labeling job.
        public let labelingJobSummaryList: [LabelingJobForWorkteamSummary]

        public init(labelingJobSummaryList: [LabelingJobForWorkteamSummary], nextToken: String? = nil) {
            self.nextToken = nextToken
            self.labelingJobSummaryList = labelingJobSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case labelingJobSummaryList = "LabelingJobSummaryList"
        }
    }

    public struct LabelingJobInputConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DataAttributes", required: false, type: .structure), 
            AWSShapeMember(label: "DataSource", required: true, type: .structure)
        ]
        /// Attributes of the data specified by the customer.
        public let dataAttributes: LabelingJobDataAttributes?
        /// The location of the input data.
        public let dataSource: LabelingJobDataSource

        public init(dataAttributes: LabelingJobDataAttributes? = nil, dataSource: LabelingJobDataSource) {
            self.dataAttributes = dataAttributes
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataAttributes = "DataAttributes"
            case dataSource = "DataSource"
        }
    }

    public struct LabelingJobAlgorithmsConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LabelingJobAlgorithmSpecificationArn", required: true, type: .string), 
            AWSShapeMember(label: "LabelingJobResourceConfig", required: false, type: .structure), 
            AWSShapeMember(label: "InitialActiveLearningModelArn", required: false, type: .string)
        ]
        /// Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You must select one of the following ARNs:    Image classification   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/image-classification     Text classification   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/text-classification     Object detection   arn:aws:sagemaker:region:027400017018:labeling-job-algorithm-specification/object-detection   
        public let labelingJobAlgorithmSpecificationArn: String
        /// Provides configuration information for a labeling job.
        public let labelingJobResourceConfig: LabelingJobResourceConfig?
        /// At the end of an auto-label job Amazon SageMaker Ground Truth sends the Amazon Resource Nam (ARN) of the final model used for auto-labeling. You can use this model as the starting point for subsequent similar jobs by providing the ARN of the model here. 
        public let initialActiveLearningModelArn: String?

        public init(initialActiveLearningModelArn: String? = nil, labelingJobAlgorithmSpecificationArn: String, labelingJobResourceConfig: LabelingJobResourceConfig? = nil) {
            self.labelingJobAlgorithmSpecificationArn = labelingJobAlgorithmSpecificationArn
            self.labelingJobResourceConfig = labelingJobResourceConfig
            self.initialActiveLearningModelArn = initialActiveLearningModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case labelingJobAlgorithmSpecificationArn = "LabelingJobAlgorithmSpecificationArn"
            case labelingJobResourceConfig = "LabelingJobResourceConfig"
            case initialActiveLearningModelArn = "InitialActiveLearningModelArn"
        }
    }

    public struct CognitoMemberDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserGroup", required: true, type: .string), 
            AWSShapeMember(label: "ClientId", required: true, type: .string), 
            AWSShapeMember(label: "UserPool", required: true, type: .string)
        ]
        /// An identifier for a user group.
        public let userGroup: String
        /// An identifier for an application client. You must create the app client ID using Amazon Cognito.
        public let clientId: String
        /// An identifier for a user pool. The user pool must be in the same region as the service that you are calling.
        public let userPool: String

        public init(clientId: String, userGroup: String, userPool: String) {
            self.userGroup = userGroup
            self.clientId = clientId
            self.userPool = userPool
        }

        private enum CodingKeys: String, CodingKey {
            case userGroup = "UserGroup"
            case clientId = "ClientId"
            case userPool = "UserPool"
        }
    }

    public enum EndpointSortKey: String, CustomStringConvertible, Codable {
        case name = "Name"
        case creationtime = "CreationTime"
        case status = "Status"
        public var description: String { return self.rawValue }
    }

    public struct CreateNotebookInstanceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorTypes", required: false, type: .list), 
            AWSShapeMember(label: "AdditionalCodeRepositories", required: false, type: .list), 
            AWSShapeMember(label: "DirectInternetAccess", required: false, type: .enum), 
            AWSShapeMember(label: "DefaultCodeRepository", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "VolumeSizeInGB", required: false, type: .integer), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "InstanceType", required: true, type: .enum), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "LifecycleConfigName", required: false, type: .string), 
            AWSShapeMember(label: "NotebookInstanceName", required: true, type: .string)
        ]
        /// A list of Elastic Inference (EI) instance types to associate with this notebook instance. Currently, only one instance type can be associated with a notebook intance. For more information, see Using Elastic Inference in Amazon SageMaker.
        public let acceleratorTypes: [NotebookInstanceAcceleratorType]?
        /// An array of up to 3 git repositories to associate with the notebook instance. These can be either the names of git repositories stored as resources in your account, or the URL of git repositories in AWS CodeCommit or in any other git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let additionalCodeRepositories: [String]?
        /// Sets whether Amazon SageMaker provides internet access to the notebook instance. If you set this to Disabled this notebook instance will be able to access resources only in your VPC, and will not be able to connect to Amazon SageMaker training and endpoint services unless your configure a NAT Gateway in your VPC. For more information, see Notebook Instances Are Internet-Enabled by Default. You can set the value of this parameter to Disabled only if you set a value for the SubnetId parameter.
        public let directInternetAccess: DirectInternetAccess?
        /// A git repository to associate with the notebook instance as its default code repository. This can be either the name of a git repository stored as a resource in your account, or the URL of a git repository in AWS CodeCommit or in any other git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git Repositories with Amazon SageMaker Notebook Instances.
        public let defaultCodeRepository: String?
        /// A list of tags to associate with the notebook instance. You can add tags later by using the CreateTags API.
        public let tags: [Tag]?
        /// The size, in GB, of the ML storage volume to attach to the notebook instance. The default value is 5 GB.
        public let volumeSizeInGB: Int32?
        ///  If you provide a AWS KMS key ID, Amazon SageMaker uses it to encrypt data at rest on the ML storage volume that is attached to your notebook instance. 
        public let kmsKeyId: String?
        /// The VPC security group IDs, in the form sg-xxxxxxxx. The security groups must be for the same VPC as specified in the subnet. 
        public let securityGroupIds: [String]?
        /// The type of ML compute instance to launch for the notebook instance.
        public let instanceType: InstanceType
        /// The ID of the subnet in a VPC to which you would like to have a connectivity from your ML compute instance. 
        public let subnetId: String?
        ///  When you send any requests to AWS resources from the notebook instance, Amazon SageMaker assumes this role to perform tasks on your behalf. You must grant this role necessary permissions so Amazon SageMaker can perform these tasks. The policy must allow the Amazon SageMaker service principal (sagemaker.amazonaws.com) permissions to assume this role. For more information, see Amazon SageMaker Roles.   To be able to pass this role to Amazon SageMaker, the caller of this API must have the iam:PassRole permission. 
        public let roleArn: String
        /// The name of a lifecycle configuration to associate with the notebook instance. For information about lifestyle configurations, see Step 2.1: (Optional) Customize a Notebook Instance.
        public let lifecycleConfigName: String?
        /// The name of the new notebook instance.
        public let notebookInstanceName: String

        public init(acceleratorTypes: [NotebookInstanceAcceleratorType]? = nil, additionalCodeRepositories: [String]? = nil, defaultCodeRepository: String? = nil, directInternetAccess: DirectInternetAccess? = nil, instanceType: InstanceType, kmsKeyId: String? = nil, lifecycleConfigName: String? = nil, notebookInstanceName: String, roleArn: String, securityGroupIds: [String]? = nil, subnetId: String? = nil, tags: [Tag]? = nil, volumeSizeInGB: Int32? = nil) {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.directInternetAccess = directInternetAccess
            self.defaultCodeRepository = defaultCodeRepository
            self.tags = tags
            self.volumeSizeInGB = volumeSizeInGB
            self.kmsKeyId = kmsKeyId
            self.securityGroupIds = securityGroupIds
            self.instanceType = instanceType
            self.subnetId = subnetId
            self.roleArn = roleArn
            self.lifecycleConfigName = lifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorTypes = "AcceleratorTypes"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case directInternetAccess = "DirectInternetAccess"
            case defaultCodeRepository = "DefaultCodeRepository"
            case tags = "Tags"
            case volumeSizeInGB = "VolumeSizeInGB"
            case kmsKeyId = "KmsKeyId"
            case securityGroupIds = "SecurityGroupIds"
            case instanceType = "InstanceType"
            case subnetId = "SubnetId"
            case roleArn = "RoleArn"
            case lifecycleConfigName = "LifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
        }
    }

    public struct RenderableTask: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Input", required: true, type: .string)
        ]
        /// A JSON object that contains values for the variables defined in the template. It is made available to the template under the substitution variable task.input. For example, if you define a variable task.input.text in your template, you can supply the variable in the JSON object as "text": "sample text".
        public let input: String

        public init(input: String) {
            self.input = input
        }

        private enum CodingKeys: String, CodingKey {
            case input = "Input"
        }
    }

    public struct AlgorithmValidationSpecification: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ValidationProfiles", required: true, type: .list), 
            AWSShapeMember(label: "ValidationRole", required: true, type: .string)
        ]
        /// An array of AlgorithmValidationProfile objects, each of which specifies a training job and batch transform job that Amazon SageMaker runs to validate your algorithm.
        public let validationProfiles: [AlgorithmValidationProfile]
        /// The IAM roles that Amazon SageMaker uses to run the training jobs.
        public let validationRole: String

        public init(validationProfiles: [AlgorithmValidationProfile], validationRole: String) {
            self.validationProfiles = validationProfiles
            self.validationRole = validationRole
        }

        private enum CodingKeys: String, CodingKey {
            case validationProfiles = "ValidationProfiles"
            case validationRole = "ValidationRole"
        }
    }

    public struct CreateWorkteamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkteamArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the work team. You can use this ARN to identify the work team.
        public let workteamArn: String?

        public init(workteamArn: String? = nil) {
            self.workteamArn = workteamArn
        }

        private enum CodingKeys: String, CodingKey {
            case workteamArn = "WorkteamArn"
        }
    }

    public struct DeleteEndpointInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]
        /// The name of the endpoint that you want to delete.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

}