//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

@_exported import AWSSDKSwiftCore
import NIO

/**
Client object for interacting with AWS Greengrass service.

AWS IoT Greengrass seamlessly extends AWS onto physical devices so they can act locally on the data they generate, while still using the cloud for management, analytics, and durable storage. AWS IoT Greengrass ensures your devices can respond quickly to local events and operate with intermittent connectivity. AWS IoT Greengrass minimizes the cost of transmitting data to the cloud by allowing you to author AWS Lambda functions that execute locally.
*/
public struct Greengrass {

    //MARK: Member variables

    public let client: AWSClient

    //MARK: Initialization

    /// Initialize the Greengrass client
    /// - parameters:
    ///     - accessKeyId: Public access key provided by AWS
    ///     - secretAccessKey: Private access key provided by AWS
    ///     - sessionToken: Token provided by STS.AssumeRole() which allows access to another AWS account
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - retryPolicy: Object returning whether retries should be attempted. Possible options are NoRetry(), ExponentialRetry() or JitterRetry()
    ///     - middlewares: Array of middlewares to apply to requests and responses
    ///     - httpClientProvider: HTTPClient to use. Use `createNew` if the client should manage its own HTTPClient.
    public init(
        accessKeyId: String? = nil,
        secretAccessKey: String? = nil,
        sessionToken: String? = nil,
        region: AWSSDKSwiftCore.Region? = nil,
        partition: AWSSDKSwiftCore.Partition = .aws,
        endpoint: String? = nil,
        retryPolicy: RetryPolicy = JitterRetry(),
        middlewares: [AWSServiceMiddleware] = [],
        httpClientProvider: AWSClient.HTTPClientProvider = .createNew
    ) {
        self.client = AWSClient(
            accessKeyId: accessKeyId,
            secretAccessKey: secretAccessKey,
            sessionToken: sessionToken,
            region: region,
            partition: region?.partition ?? partition,
            service: "greengrass",
            serviceProtocol: .restjson,
            apiVersion: "2017-06-07",
            endpoint: endpoint,
            serviceEndpoints: ["us-gov-west-1": "greengrass.us-gov-west-1.amazonaws.com"],
            retryPolicy: retryPolicy,
            middlewares: middlewares,
            possibleErrorTypes: [GreengrassErrorType.self],
            httpClientProvider: httpClientProvider
        )
    }
    
    func syncShutdown() throws {
        try client.syncShutdown()
    }
    
    //MARK: API Calls

    ///  Associates a role with a group. Your Greengrass core will use the role to access AWS cloud services. The role's permissions should allow Greengrass core Lambda functions to perform actions against the cloud.
    public func associateRoleToGroup(_ input: AssociateRoleToGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateRoleToGroupResponse> {
        return client.send(operation: "AssociateRoleToGroup", path: "/greengrass/groups/{GroupId}/role", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Associates a role with your account. AWS IoT Greengrass will use the role to access your Lambda functions and AWS IoT resources. This is necessary for deployments to succeed. The role must have at least minimum permissions in the policy ''AWSGreengrassResourceAccessRolePolicy''.
    public func associateServiceRoleToAccount(_ input: AssociateServiceRoleToAccountRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociateServiceRoleToAccountResponse> {
        return client.send(operation: "AssociateServiceRoleToAccount", path: "/greengrass/servicerole", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Creates a connector definition. You may provide the initial version of the connector definition now or use ''CreateConnectorDefinitionVersion'' at a later time.
    public func createConnectorDefinition(_ input: CreateConnectorDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConnectorDefinitionResponse> {
        return client.send(operation: "CreateConnectorDefinition", path: "/greengrass/definition/connectors", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a connector definition which has already been defined.
    public func createConnectorDefinitionVersion(_ input: CreateConnectorDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConnectorDefinitionVersionResponse> {
        return client.send(operation: "CreateConnectorDefinitionVersion", path: "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a core definition. You may provide the initial version of the core definition now or use ''CreateCoreDefinitionVersion'' at a later time. Greengrass groups must each contain exactly one Greengrass core.
    public func createCoreDefinition(_ input: CreateCoreDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCoreDefinitionResponse> {
        return client.send(operation: "CreateCoreDefinition", path: "/greengrass/definition/cores", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a core definition that has already been defined. Greengrass groups must each contain exactly one Greengrass core.
    public func createCoreDefinitionVersion(_ input: CreateCoreDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCoreDefinitionVersionResponse> {
        return client.send(operation: "CreateCoreDefinitionVersion", path: "/greengrass/definition/cores/{CoreDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a deployment. ''CreateDeployment'' requests are idempotent with respect to the ''X-Amzn-Client-Token'' token and the request parameters.
    public func createDeployment(_ input: CreateDeploymentRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDeploymentResponse> {
        return client.send(operation: "CreateDeployment", path: "/greengrass/groups/{GroupId}/deployments", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a device definition. You may provide the initial version of the device definition now or use ''CreateDeviceDefinitionVersion'' at a later time.
    public func createDeviceDefinition(_ input: CreateDeviceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDeviceDefinitionResponse> {
        return client.send(operation: "CreateDeviceDefinition", path: "/greengrass/definition/devices", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a device definition that has already been defined.
    public func createDeviceDefinitionVersion(_ input: CreateDeviceDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDeviceDefinitionVersionResponse> {
        return client.send(operation: "CreateDeviceDefinitionVersion", path: "/greengrass/definition/devices/{DeviceDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a Lambda function definition which contains a list of Lambda functions and their configurations to be used in a group. You can create an initial version of the definition by providing a list of Lambda functions and their configurations now, or use ''CreateFunctionDefinitionVersion'' later.
    public func createFunctionDefinition(_ input: CreateFunctionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateFunctionDefinitionResponse> {
        return client.send(operation: "CreateFunctionDefinition", path: "/greengrass/definition/functions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a Lambda function definition that has already been defined.
    public func createFunctionDefinitionVersion(_ input: CreateFunctionDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateFunctionDefinitionVersionResponse> {
        return client.send(operation: "CreateFunctionDefinitionVersion", path: "/greengrass/definition/functions/{FunctionDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a group. You may provide the initial version of the group or use ''CreateGroupVersion'' at a later time. Tip: You can use the ''gg_group_setup'' package (https://github.com/awslabs/aws-greengrass-group-setup) as a library or command-line application to create and deploy Greengrass groups.
    public func createGroup(_ input: CreateGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGroupResponse> {
        return client.send(operation: "CreateGroup", path: "/greengrass/groups", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a CA for the group. If a CA already exists, it will rotate the existing CA.
    public func createGroupCertificateAuthority(_ input: CreateGroupCertificateAuthorityRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGroupCertificateAuthorityResponse> {
        return client.send(operation: "CreateGroupCertificateAuthority", path: "/greengrass/groups/{GroupId}/certificateauthorities", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a group which has already been defined.
    public func createGroupVersion(_ input: CreateGroupVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGroupVersionResponse> {
        return client.send(operation: "CreateGroupVersion", path: "/greengrass/groups/{GroupId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a logger definition. You may provide the initial version of the logger definition now or use ''CreateLoggerDefinitionVersion'' at a later time.
    public func createLoggerDefinition(_ input: CreateLoggerDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateLoggerDefinitionResponse> {
        return client.send(operation: "CreateLoggerDefinition", path: "/greengrass/definition/loggers", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a logger definition that has already been defined.
    public func createLoggerDefinitionVersion(_ input: CreateLoggerDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateLoggerDefinitionVersionResponse> {
        return client.send(operation: "CreateLoggerDefinitionVersion", path: "/greengrass/definition/loggers/{LoggerDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a resource definition which contains a list of resources to be used in a group. You can create an initial version of the definition by providing a list of resources now, or use ''CreateResourceDefinitionVersion'' later.
    public func createResourceDefinition(_ input: CreateResourceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateResourceDefinitionResponse> {
        return client.send(operation: "CreateResourceDefinition", path: "/greengrass/definition/resources", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a resource definition that has already been defined.
    public func createResourceDefinitionVersion(_ input: CreateResourceDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateResourceDefinitionVersionResponse> {
        return client.send(operation: "CreateResourceDefinitionVersion", path: "/greengrass/definition/resources/{ResourceDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a software update for a core or group of cores (specified as an IoT thing group.) Use this to update the OTA Agent as well as the Greengrass core software. It makes use of the IoT Jobs feature which provides additional commands to manage a Greengrass core software update job.
    public func createSoftwareUpdateJob(_ input: CreateSoftwareUpdateJobRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSoftwareUpdateJobResponse> {
        return client.send(operation: "CreateSoftwareUpdateJob", path: "/greengrass/updates", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a subscription definition. You may provide the initial version of the subscription definition now or use ''CreateSubscriptionDefinitionVersion'' at a later time.
    public func createSubscriptionDefinition(_ input: CreateSubscriptionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSubscriptionDefinitionResponse> {
        return client.send(operation: "CreateSubscriptionDefinition", path: "/greengrass/definition/subscriptions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Creates a version of a subscription definition which has already been defined.
    public func createSubscriptionDefinitionVersion(_ input: CreateSubscriptionDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSubscriptionDefinitionVersionResponse> {
        return client.send(operation: "CreateSubscriptionDefinitionVersion", path: "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Deletes a connector definition.
    public func deleteConnectorDefinition(_ input: DeleteConnectorDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConnectorDefinitionResponse> {
        return client.send(operation: "DeleteConnectorDefinition", path: "/greengrass/definition/connectors/{ConnectorDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a core definition.
    public func deleteCoreDefinition(_ input: DeleteCoreDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteCoreDefinitionResponse> {
        return client.send(operation: "DeleteCoreDefinition", path: "/greengrass/definition/cores/{CoreDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a device definition.
    public func deleteDeviceDefinition(_ input: DeleteDeviceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDeviceDefinitionResponse> {
        return client.send(operation: "DeleteDeviceDefinition", path: "/greengrass/definition/devices/{DeviceDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a Lambda function definition.
    public func deleteFunctionDefinition(_ input: DeleteFunctionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteFunctionDefinitionResponse> {
        return client.send(operation: "DeleteFunctionDefinition", path: "/greengrass/definition/functions/{FunctionDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a group.
    public func deleteGroup(_ input: DeleteGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteGroupResponse> {
        return client.send(operation: "DeleteGroup", path: "/greengrass/groups/{GroupId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a logger definition.
    public func deleteLoggerDefinition(_ input: DeleteLoggerDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteLoggerDefinitionResponse> {
        return client.send(operation: "DeleteLoggerDefinition", path: "/greengrass/definition/loggers/{LoggerDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a resource definition.
    public func deleteResourceDefinition(_ input: DeleteResourceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteResourceDefinitionResponse> {
        return client.send(operation: "DeleteResourceDefinition", path: "/greengrass/definition/resources/{ResourceDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Deletes a subscription definition.
    public func deleteSubscriptionDefinition(_ input: DeleteSubscriptionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteSubscriptionDefinitionResponse> {
        return client.send(operation: "DeleteSubscriptionDefinition", path: "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Disassociates the role from a group.
    public func disassociateRoleFromGroup(_ input: DisassociateRoleFromGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateRoleFromGroupResponse> {
        return client.send(operation: "DisassociateRoleFromGroup", path: "/greengrass/groups/{GroupId}/role", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Disassociates the service role from your account. Without a service role, deployments will not work.
    public func disassociateServiceRoleFromAccount(_ input: DisassociateServiceRoleFromAccountRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociateServiceRoleFromAccountResponse> {
        return client.send(operation: "DisassociateServiceRoleFromAccount", path: "/greengrass/servicerole", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Retrieves the role associated with a particular group.
    public func getAssociatedRole(_ input: GetAssociatedRoleRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAssociatedRoleResponse> {
        return client.send(operation: "GetAssociatedRole", path: "/greengrass/groups/{GroupId}/role", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Returns the status of a bulk deployment.
    public func getBulkDeploymentStatus(_ input: GetBulkDeploymentStatusRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetBulkDeploymentStatusResponse> {
        return client.send(operation: "GetBulkDeploymentStatus", path: "/greengrass/bulk/deployments/{BulkDeploymentId}/status", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves the connectivity information for a core.
    public func getConnectivityInfo(_ input: GetConnectivityInfoRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConnectivityInfoResponse> {
        return client.send(operation: "GetConnectivityInfo", path: "/greengrass/things/{ThingName}/connectivityInfo", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a connector definition.
    public func getConnectorDefinition(_ input: GetConnectorDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConnectorDefinitionResponse> {
        return client.send(operation: "GetConnectorDefinition", path: "/greengrass/definition/connectors/{ConnectorDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a connector definition version, including the connectors that the version contains. Connectors are prebuilt modules that interact with local infrastructure, device protocols, AWS, and other cloud services.
    public func getConnectorDefinitionVersion(_ input: GetConnectorDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConnectorDefinitionVersionResponse> {
        return client.send(operation: "GetConnectorDefinitionVersion", path: "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions/{ConnectorDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a core definition version.
    public func getCoreDefinition(_ input: GetCoreDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCoreDefinitionResponse> {
        return client.send(operation: "GetCoreDefinition", path: "/greengrass/definition/cores/{CoreDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a core definition version.
    public func getCoreDefinitionVersion(_ input: GetCoreDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCoreDefinitionVersionResponse> {
        return client.send(operation: "GetCoreDefinitionVersion", path: "/greengrass/definition/cores/{CoreDefinitionId}/versions/{CoreDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Returns the status of a deployment.
    public func getDeploymentStatus(_ input: GetDeploymentStatusRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDeploymentStatusResponse> {
        return client.send(operation: "GetDeploymentStatus", path: "/greengrass/groups/{GroupId}/deployments/{DeploymentId}/status", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a device definition.
    public func getDeviceDefinition(_ input: GetDeviceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDeviceDefinitionResponse> {
        return client.send(operation: "GetDeviceDefinition", path: "/greengrass/definition/devices/{DeviceDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a device definition version.
    public func getDeviceDefinitionVersion(_ input: GetDeviceDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDeviceDefinitionVersionResponse> {
        return client.send(operation: "GetDeviceDefinitionVersion", path: "/greengrass/definition/devices/{DeviceDefinitionId}/versions/{DeviceDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a Lambda function definition, including its creation time and latest version.
    public func getFunctionDefinition(_ input: GetFunctionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetFunctionDefinitionResponse> {
        return client.send(operation: "GetFunctionDefinition", path: "/greengrass/definition/functions/{FunctionDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a Lambda function definition version, including which Lambda functions are included in the version and their configurations.
    public func getFunctionDefinitionVersion(_ input: GetFunctionDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetFunctionDefinitionVersionResponse> {
        return client.send(operation: "GetFunctionDefinitionVersion", path: "/greengrass/definition/functions/{FunctionDefinitionId}/versions/{FunctionDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a group.
    public func getGroup(_ input: GetGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGroupResponse> {
        return client.send(operation: "GetGroup", path: "/greengrass/groups/{GroupId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retreives the CA associated with a group. Returns the public key of the CA.
    public func getGroupCertificateAuthority(_ input: GetGroupCertificateAuthorityRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGroupCertificateAuthorityResponse> {
        return client.send(operation: "GetGroupCertificateAuthority", path: "/greengrass/groups/{GroupId}/certificateauthorities/{CertificateAuthorityId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves the current configuration for the CA used by the group.
    public func getGroupCertificateConfiguration(_ input: GetGroupCertificateConfigurationRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGroupCertificateConfigurationResponse> {
        return client.send(operation: "GetGroupCertificateConfiguration", path: "/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a group version.
    public func getGroupVersion(_ input: GetGroupVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGroupVersionResponse> {
        return client.send(operation: "GetGroupVersion", path: "/greengrass/groups/{GroupId}/versions/{GroupVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a logger definition.
    public func getLoggerDefinition(_ input: GetLoggerDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetLoggerDefinitionResponse> {
        return client.send(operation: "GetLoggerDefinition", path: "/greengrass/definition/loggers/{LoggerDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a logger definition version.
    public func getLoggerDefinitionVersion(_ input: GetLoggerDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetLoggerDefinitionVersionResponse> {
        return client.send(operation: "GetLoggerDefinitionVersion", path: "/greengrass/definition/loggers/{LoggerDefinitionId}/versions/{LoggerDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a resource definition, including its creation time and latest version.
    public func getResourceDefinition(_ input: GetResourceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetResourceDefinitionResponse> {
        return client.send(operation: "GetResourceDefinition", path: "/greengrass/definition/resources/{ResourceDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a resource definition version, including which resources are included in the version.
    public func getResourceDefinitionVersion(_ input: GetResourceDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetResourceDefinitionVersionResponse> {
        return client.send(operation: "GetResourceDefinitionVersion", path: "/greengrass/definition/resources/{ResourceDefinitionId}/versions/{ResourceDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves the service role that is attached to your account.
    public func getServiceRoleForAccount(_ input: GetServiceRoleForAccountRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetServiceRoleForAccountResponse> {
        return client.send(operation: "GetServiceRoleForAccount", path: "/greengrass/servicerole", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a subscription definition.
    public func getSubscriptionDefinition(_ input: GetSubscriptionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSubscriptionDefinitionResponse> {
        return client.send(operation: "GetSubscriptionDefinition", path: "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves information about a subscription definition version.
    public func getSubscriptionDefinitionVersion(_ input: GetSubscriptionDefinitionVersionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSubscriptionDefinitionVersionResponse> {
        return client.send(operation: "GetSubscriptionDefinitionVersion", path: "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions/{SubscriptionDefinitionVersionId}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Gets a paginated list of the deployments that have been started in a bulk deployment operation, and their current deployment status.
    public func listBulkDeploymentDetailedReports(_ input: ListBulkDeploymentDetailedReportsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListBulkDeploymentDetailedReportsResponse> {
        return client.send(operation: "ListBulkDeploymentDetailedReports", path: "/greengrass/bulk/deployments/{BulkDeploymentId}/detailed-reports", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Returns a list of bulk deployments.
    public func listBulkDeployments(_ input: ListBulkDeploymentsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListBulkDeploymentsResponse> {
        return client.send(operation: "ListBulkDeployments", path: "/greengrass/bulk/deployments", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a connector definition, which are containers for connectors. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    public func listConnectorDefinitionVersions(_ input: ListConnectorDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConnectorDefinitionVersionsResponse> {
        return client.send(operation: "ListConnectorDefinitionVersions", path: "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of connector definitions.
    public func listConnectorDefinitions(_ input: ListConnectorDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConnectorDefinitionsResponse> {
        return client.send(operation: "ListConnectorDefinitions", path: "/greengrass/definition/connectors", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a core definition.
    public func listCoreDefinitionVersions(_ input: ListCoreDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCoreDefinitionVersionsResponse> {
        return client.send(operation: "ListCoreDefinitionVersions", path: "/greengrass/definition/cores/{CoreDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of core definitions.
    public func listCoreDefinitions(_ input: ListCoreDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCoreDefinitionsResponse> {
        return client.send(operation: "ListCoreDefinitions", path: "/greengrass/definition/cores", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Returns a history of deployments for the group.
    public func listDeployments(_ input: ListDeploymentsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDeploymentsResponse> {
        return client.send(operation: "ListDeployments", path: "/greengrass/groups/{GroupId}/deployments", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a device definition.
    public func listDeviceDefinitionVersions(_ input: ListDeviceDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDeviceDefinitionVersionsResponse> {
        return client.send(operation: "ListDeviceDefinitionVersions", path: "/greengrass/definition/devices/{DeviceDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of device definitions.
    public func listDeviceDefinitions(_ input: ListDeviceDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDeviceDefinitionsResponse> {
        return client.send(operation: "ListDeviceDefinitions", path: "/greengrass/definition/devices", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a Lambda function definition.
    public func listFunctionDefinitionVersions(_ input: ListFunctionDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListFunctionDefinitionVersionsResponse> {
        return client.send(operation: "ListFunctionDefinitionVersions", path: "/greengrass/definition/functions/{FunctionDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of Lambda function definitions.
    public func listFunctionDefinitions(_ input: ListFunctionDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListFunctionDefinitionsResponse> {
        return client.send(operation: "ListFunctionDefinitions", path: "/greengrass/definition/functions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves the current CAs for a group.
    public func listGroupCertificateAuthorities(_ input: ListGroupCertificateAuthoritiesRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListGroupCertificateAuthoritiesResponse> {
        return client.send(operation: "ListGroupCertificateAuthorities", path: "/greengrass/groups/{GroupId}/certificateauthorities", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a group.
    public func listGroupVersions(_ input: ListGroupVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListGroupVersionsResponse> {
        return client.send(operation: "ListGroupVersions", path: "/greengrass/groups/{GroupId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of groups.
    public func listGroups(_ input: ListGroupsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListGroupsResponse> {
        return client.send(operation: "ListGroups", path: "/greengrass/groups", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a logger definition.
    public func listLoggerDefinitionVersions(_ input: ListLoggerDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListLoggerDefinitionVersionsResponse> {
        return client.send(operation: "ListLoggerDefinitionVersions", path: "/greengrass/definition/loggers/{LoggerDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of logger definitions.
    public func listLoggerDefinitions(_ input: ListLoggerDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListLoggerDefinitionsResponse> {
        return client.send(operation: "ListLoggerDefinitions", path: "/greengrass/definition/loggers", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a resource definition.
    public func listResourceDefinitionVersions(_ input: ListResourceDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListResourceDefinitionVersionsResponse> {
        return client.send(operation: "ListResourceDefinitionVersions", path: "/greengrass/definition/resources/{ResourceDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of resource definitions.
    public func listResourceDefinitions(_ input: ListResourceDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListResourceDefinitionsResponse> {
        return client.send(operation: "ListResourceDefinitions", path: "/greengrass/definition/resources", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Lists the versions of a subscription definition.
    public func listSubscriptionDefinitionVersions(_ input: ListSubscriptionDefinitionVersionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSubscriptionDefinitionVersionsResponse> {
        return client.send(operation: "ListSubscriptionDefinitionVersions", path: "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of subscription definitions.
    public func listSubscriptionDefinitions(_ input: ListSubscriptionDefinitionsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSubscriptionDefinitionsResponse> {
        return client.send(operation: "ListSubscriptionDefinitions", path: "/greengrass/definition/subscriptions", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Retrieves a list of resource tags for a resource arn.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return client.send(operation: "ListTagsForResource", path: "/tags/{resource-arn}", httpMethod: "GET", input: input, on: eventLoop)
    }

    ///  Resets a group's deployments.
    public func resetDeployments(_ input: ResetDeploymentsRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ResetDeploymentsResponse> {
        return client.send(operation: "ResetDeployments", path: "/greengrass/groups/{GroupId}/deployments/$reset", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Deploys multiple groups in one operation. This action starts the bulk deployment of a specified set of group versions. Each group version deployment will be triggered with an adaptive rate that has a fixed upper limit. We recommend that you include an ''X-Amzn-Client-Token'' token in every ''StartBulkDeployment'' request. These requests are idempotent with respect to the token and the request parameters.
    public func startBulkDeployment(_ input: StartBulkDeploymentRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartBulkDeploymentResponse> {
        return client.send(operation: "StartBulkDeployment", path: "/greengrass/bulk/deployments", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Stops the execution of a bulk deployment. This action returns a status of ''Stopping'' until the deployment is stopped. You cannot start a new bulk deployment while a previous deployment is in the ''Stopping'' state. This action doesn't rollback completed deployments or cancel pending deployments.
    public func stopBulkDeployment(_ input: StopBulkDeploymentRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StopBulkDeploymentResponse> {
        return client.send(operation: "StopBulkDeployment", path: "/greengrass/bulk/deployments/{BulkDeploymentId}/$stop", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Adds tags to a Greengrass resource. Valid resources are 'Group', 'ConnectorDefinition', 'CoreDefinition', 'DeviceDefinition', 'FunctionDefinition', 'LoggerDefinition', 'SubscriptionDefinition', 'ResourceDefinition', and 'BulkDeployment'.
    @discardableResult public func tagResource(_ input: TagResourceRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return client.send(operation: "TagResource", path: "/tags/{resource-arn}", httpMethod: "POST", input: input, on: eventLoop)
    }

    ///  Remove resource tags from a Greengrass Resource.
    @discardableResult public func untagResource(_ input: UntagResourceRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return client.send(operation: "UntagResource", path: "/tags/{resource-arn}", httpMethod: "DELETE", input: input, on: eventLoop)
    }

    ///  Updates the connectivity information for the core. Any devices that belong to the group which has this core will receive this information in order to find the location of the core and connect to it.
    public func updateConnectivityInfo(_ input: UpdateConnectivityInfoRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConnectivityInfoResponse> {
        return client.send(operation: "UpdateConnectivityInfo", path: "/greengrass/things/{ThingName}/connectivityInfo", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a connector definition.
    public func updateConnectorDefinition(_ input: UpdateConnectorDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConnectorDefinitionResponse> {
        return client.send(operation: "UpdateConnectorDefinition", path: "/greengrass/definition/connectors/{ConnectorDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a core definition.
    public func updateCoreDefinition(_ input: UpdateCoreDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateCoreDefinitionResponse> {
        return client.send(operation: "UpdateCoreDefinition", path: "/greengrass/definition/cores/{CoreDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a device definition.
    public func updateDeviceDefinition(_ input: UpdateDeviceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDeviceDefinitionResponse> {
        return client.send(operation: "UpdateDeviceDefinition", path: "/greengrass/definition/devices/{DeviceDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a Lambda function definition.
    public func updateFunctionDefinition(_ input: UpdateFunctionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateFunctionDefinitionResponse> {
        return client.send(operation: "UpdateFunctionDefinition", path: "/greengrass/definition/functions/{FunctionDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a group.
    public func updateGroup(_ input: UpdateGroupRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateGroupResponse> {
        return client.send(operation: "UpdateGroup", path: "/greengrass/groups/{GroupId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates the Certificate expiry time for a group.
    public func updateGroupCertificateConfiguration(_ input: UpdateGroupCertificateConfigurationRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateGroupCertificateConfigurationResponse> {
        return client.send(operation: "UpdateGroupCertificateConfiguration", path: "/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a logger definition.
    public func updateLoggerDefinition(_ input: UpdateLoggerDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateLoggerDefinitionResponse> {
        return client.send(operation: "UpdateLoggerDefinition", path: "/greengrass/definition/loggers/{LoggerDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a resource definition.
    public func updateResourceDefinition(_ input: UpdateResourceDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateResourceDefinitionResponse> {
        return client.send(operation: "UpdateResourceDefinition", path: "/greengrass/definition/resources/{ResourceDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }

    ///  Updates a subscription definition.
    public func updateSubscriptionDefinition(_ input: UpdateSubscriptionDefinitionRequest, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSubscriptionDefinitionResponse> {
        return client.send(operation: "UpdateSubscriptionDefinition", path: "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}", httpMethod: "PUT", input: input, on: eventLoop)
    }
}
