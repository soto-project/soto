// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension CodeArtifact {
    //MARK: Enums

    public enum DomainStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case deleted = "Deleted"
        public var description: String { return self.rawValue }
    }

    public enum ExternalConnectionStatus: String, CustomStringConvertible, Codable {
        case available = "Available"
        public var description: String { return self.rawValue }
    }

    public enum HashAlgorithm: String, CustomStringConvertible, Codable {
        case md5 = "MD5"
        case sha1 = "SHA-1"
        case sha256 = "SHA-256"
        case sha512 = "SHA-512"
        public var description: String { return self.rawValue }
    }

    public enum PackageFormat: String, CustomStringConvertible, Codable {
        case npm = "npm"
        case pypi = "pypi"
        case maven = "maven"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionErrorCode: String, CustomStringConvertible, Codable {
        case alreadyExists = "ALREADY_EXISTS"
        case mismatchedRevision = "MISMATCHED_REVISION"
        case mismatchedStatus = "MISMATCHED_STATUS"
        case notAllowed = "NOT_ALLOWED"
        case notFound = "NOT_FOUND"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionSortType: String, CustomStringConvertible, Codable {
        case publishedTime = "PUBLISHED_TIME"
        public var description: String { return self.rawValue }
    }

    public enum PackageVersionStatus: String, CustomStringConvertible, Codable {
        case published = "Published"
        case unfinished = "Unfinished"
        case unlisted = "Unlisted"
        case archived = "Archived"
        case disposed = "Disposed"
        case deleted = "Deleted"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AssetSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "hashes", required: false, type: .map), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "size", required: false, type: .long)
        ]

        ///  The hashes of the asset. 
        public let hashes: [HashAlgorithm: String]?
        ///  The name of the asset. 
        public let name: String
        ///  The size of the asset. 
        public let size: Int64?

        public init(hashes: [HashAlgorithm: String]? = nil, name: String, size: Int64? = nil) {
            self.hashes = hashes
            self.name = name
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case hashes = "hashes"
            case name = "name"
            case size = "size"
        }
    }

    public struct AssociateExternalConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "externalConnection", location: .querystring(locationName: "external-connection"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        /// The name of the domain that contains the repository.
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The name of the external connection to add to the repository. The following values are supported:     public:npmjs - for the npm public repository.     public:pypi - for the Python Package Index.     public:maven-central - for Maven Central.     public:maven-googleandroid - for the Google Android repository.     public:maven-gradleplugins - for the Gradle plugins repository.     public:maven-commonsware - for the CommonsWare Android repository.   
        public let externalConnection: String
        ///  The name of the repository to which the external connection is added. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, externalConnection: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.externalConnection = externalConnection
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.externalConnection, name:"externalConnection", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-:]{1,99}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case externalConnection = "external-connection"
            case repository = "repository"
        }
    }

    public struct AssociateExternalConnectionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]

        ///  Information about the connected repository after processing the request. 
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct CopyPackageVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "allowOverwrite", required: false, type: .boolean), 
            AWSShapeMember(label: "destinationRepository", location: .querystring(locationName: "destination-repository"), required: true, type: .string), 
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "includeFromUpstream", required: false, type: .boolean), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "sourceRepository", location: .querystring(locationName: "source-repository"), required: true, type: .string), 
            AWSShapeMember(label: "versionRevisions", required: false, type: .map), 
            AWSShapeMember(label: "versions", required: false, type: .list)
        ]

        ///  Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the failedVersions field of the response with an ALREADY_EXISTS error code. 
        public let allowOverwrite: Bool?
        ///  The name of the repository into which package versions are copied. 
        public let destinationRepository: String
        ///  The name of the domain that contains the source and destination repositories. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The format of the package that is copied. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let format: PackageFormat
        ///  Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see Working with upstream repositories. 
        public let includeFromUpstream: Bool?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package that is copied. 
        public let package: String
        ///  The name of the repository that contains the package versions to copy. 
        public let sourceRepository: String
        ///  A list of key-value pairs. The keys are package versions and the values are package version revisions. A CopyPackageVersion operation succeeds if the specified versions in the source repository match the specified package version revision.    You must specify versions or versionRevisions. You cannot specify both.  
        public let versionRevisions: [String: String]?
        ///  The versions of the package to copy.    You must specify versions or versionRevisions. You cannot specify both.  
        public let versions: [String]?

        public init(allowOverwrite: Bool? = nil, destinationRepository: String, domain: String, domainOwner: String? = nil, format: PackageFormat, includeFromUpstream: Bool? = nil, namespace: String? = nil, package: String, sourceRepository: String, versionRevisions: [String: String]? = nil, versions: [String]? = nil) {
            self.allowOverwrite = allowOverwrite
            self.destinationRepository = destinationRepository
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.includeFromUpstream = includeFromUpstream
            self.namespace = namespace
            self.package = package
            self.sourceRepository = sourceRepository
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func validate(name: String) throws {
            try validate(self.destinationRepository, name:"destinationRepository", parent: name, max: 100)
            try validate(self.destinationRepository, name:"destinationRepository", parent: name, min: 2)
            try validate(self.destinationRepository, name:"destinationRepository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.sourceRepository, name:"sourceRepository", parent: name, max: 100)
            try validate(self.sourceRepository, name:"sourceRepository", parent: name, min: 2)
            try validate(self.sourceRepository, name:"sourceRepository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versionRevisions?.forEach {
                try validate($0.key, name:"versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name:"versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name:"versionRevisions.key", parent: name, pattern: "[^!#/\\s]+")
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, pattern: "\\S+")
            }
            try self.versions?.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowOverwrite = "allowOverwrite"
            case destinationRepository = "destination-repository"
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case includeFromUpstream = "includeFromUpstream"
            case namespace = "namespace"
            case package = "package"
            case sourceRepository = "source-repository"
            case versionRevisions = "versionRevisions"
            case versions = "versions"
        }
    }

    public struct CopyPackageVersionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "failedVersions", required: false, type: .map), 
            AWSShapeMember(label: "successfulVersions", required: false, type: .map)
        ]

        ///  A map of package versions that failed to copy and their error codes. The possible error codes are in the PackageVersionError data type. They are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED   
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully copied to your repository. 
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct CreateDomainRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "encryptionKey", required: false, type: .string)
        ]

        ///  The name of the domain to create. All domain names in an AWS Region that are in the same AWS account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable. 
        public let domain: String
        ///  The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an encryptionKey, your IAM role must have kms:DescribeKey and kms:CreateGrant permissions on the encryption key that is used. For more information, see DescribeKey in the AWS Key Management Service API Reference and AWS KMS API Permissions Reference in the AWS Key Management Service Developer Guide.    CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see Using symmetric and asymmetric keys in the AWS Key Management Service Developer Guide.  
        public let encryptionKey: String?

        public init(domain: String, encryptionKey: String? = nil) {
            self.domain = domain
            self.encryptionKey = encryptionKey
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.encryptionKey, name:"encryptionKey", parent: name, max: 2048)
            try validate(self.encryptionKey, name:"encryptionKey", parent: name, min: 1)
            try validate(self.encryptionKey, name:"encryptionKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case encryptionKey = "encryptionKey"
        }
    }

    public struct CreateDomainResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", required: false, type: .structure)
        ]

        ///  Contains information about the created domain after processing the request. 
        public let domain: DomainDescription?

        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct CreateRepositoryRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string), 
            AWSShapeMember(label: "upstreams", required: false, type: .list)
        ]

        ///  A description of the created repository. 
        public let description: String?
        ///  The domain that contains the created repository. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The name of the repository to create. 
        public let repository: String
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see Working with upstream repositories. 
        public let upstreams: [UpstreamRepository]?

        public init(description: String? = nil, domain: String, domainOwner: String? = nil, repository: String, upstreams: [UpstreamRepository]? = nil) {
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
            self.upstreams = upstreams
        }

        public func validate(name: String) throws {
            try validate(self.description, name:"description", parent: name, max: 1000)
            try validate(self.description, name:"description", parent: name, pattern: "\\P{C}+")
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.upstreams?.forEach {
                try $0.validate(name: "\(name).upstreams[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domain = "domain"
            case domainOwner = "domain-owner"
            case repository = "repository"
            case upstreams = "upstreams"
        }
    }

    public struct CreateRepositoryResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]

        ///  Information about the created repository after processing the request. 
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DeleteDomainPermissionsPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "policyRevision", location: .querystring(locationName: "policy-revision"), required: false, type: .string)
        ]

        ///  The name of the domain associated with the resource policy to be deleted. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. 
        public let policyRevision: String?

        public init(domain: String, domainOwner: String? = nil, policyRevision: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyRevision = policyRevision
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.policyRevision, name:"policyRevision", parent: name, max: 100)
            try validate(self.policyRevision, name:"policyRevision", parent: name, min: 1)
            try validate(self.policyRevision, name:"policyRevision", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case policyRevision = "policy-revision"
        }
    }

    public struct DeleteDomainPermissionsPolicyResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policy", required: false, type: .structure)
        ]

        ///  Information about the deleted resource policy after processing the request. 
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct DeleteDomainRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string)
        ]

        ///  The name of the domain to delete. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?

        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
        }
    }

    public struct DeleteDomainResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", required: false, type: .structure)
        ]

        ///  Contains information about the deleted domain after processing the request. 
        public let domain: DomainDescription?

        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct DeletePackageVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "expectedStatus", required: false, type: .enum), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string), 
            AWSShapeMember(label: "versions", required: true, type: .list)
        ]

        ///  The name of the domain that contains the package to delete. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The expected status of the package version to delete. Valid values are:     Published     Unfinished     Unlisted     Archived     Disposed   
        public let expectedStatus: PackageVersionStatus?
        ///  The format of the package versions to delete. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package with the versions to delete. 
        public let package: String
        ///  The name of the repository that contains the package versions to delete. 
        public let repository: String
        ///  An array of strings that specify the versions of the package to delete. 
        public let versions: [String]

        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.versions = versions
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case expectedStatus = "expectedStatus"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case repository = "repository"
            case versions = "versions"
        }
    }

    public struct DeletePackageVersionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "failedVersions", required: false, type: .map), 
            AWSShapeMember(label: "successfulVersions", required: false, type: .map)
        ]

        ///  A PackageVersionError object that contains a map of errors codes for the deleted package that failed. The possible error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED   
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully deleted. 
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct DeleteRepositoryPermissionsPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "policyRevision", location: .querystring(locationName: "policy-revision"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository associated with the resource policy to be deleted. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy. 
        public let policyRevision: String?
        ///  The name of the repository that is associated with the resource policy to be deleted 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, policyRevision: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyRevision = policyRevision
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.policyRevision, name:"policyRevision", parent: name, max: 100)
            try validate(self.policyRevision, name:"policyRevision", parent: name, min: 1)
            try validate(self.policyRevision, name:"policyRevision", parent: name, pattern: "\\S+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case policyRevision = "policy-revision"
            case repository = "repository"
        }
    }

    public struct DeleteRepositoryPermissionsPolicyResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policy", required: false, type: .structure)
        ]

        ///  Information about the deleted policy after processing the request. 
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct DeleteRepositoryRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository to delete. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The name of the repository to delete. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case repository = "repository"
        }
    }

    public struct DeleteRepositoryResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]

        ///  Information about the deleted repository after processing the request. 
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DescribeDomainRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string)
        ]

        ///  A string that specifies the name of the requested domain. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?

        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
        }
    }

    public struct DescribeDomainResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", required: false, type: .structure)
        ]

        public let domain: DomainDescription?

        public init(domain: DomainDescription? = nil) {
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
        }
    }

    public struct DescribePackageVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "packageVersion", location: .querystring(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository that contains the package version. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  A format that specifies the type of the requested package version. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the requested package version. 
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2). 
        public let packageVersion: String
        ///  The name of the repository that contains the package version. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.packageVersion, name:"packageVersion", parent: name, max: 255)
            try validate(self.packageVersion, name:"packageVersion", parent: name, min: 1)
            try validate(self.packageVersion, name:"packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case packageVersion = "version"
            case repository = "repository"
        }
    }

    public struct DescribePackageVersionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "packageVersion", required: true, type: .structure)
        ]

        ///  A  PackageVersionDescription  object that contains information about the requested package version. 
        public let packageVersion: PackageVersionDescription

        public init(packageVersion: PackageVersionDescription) {
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageVersion = "packageVersion"
        }
    }

    public struct DescribeRepositoryRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository to describe. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  A string that specifies the name of the requested repository. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case repository = "repository"
        }
    }

    public struct DescribeRepositoryResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]

        ///  A RepositoryDescription object that contains the requested repository information. 
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DisassociateExternalConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "externalConnection", location: .querystring(locationName: "external-connection"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        /// The name of the domain that contains the repository from which to remove the external repository. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        /// The name of the external connection to be removed from the repository. 
        public let externalConnection: String
        /// The name of the repository from which the external connection will be removed. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, externalConnection: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.externalConnection = externalConnection
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.externalConnection, name:"externalConnection", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-:]{1,99}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case externalConnection = "external-connection"
            case repository = "repository"
        }
    }

    public struct DisassociateExternalConnectionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]

        ///  The repository associated with the removed external connection. 
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DisposePackageVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "expectedStatus", required: false, type: .enum), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string), 
            AWSShapeMember(label: "versionRevisions", required: false, type: .map), 
            AWSShapeMember(label: "versions", required: true, type: .list)
        ]

        ///  The name of the domain that contains the repository you want to dispose. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The expected status of the package version to dispose. Valid values are:     Published     Unfinished     Unlisted     Archived     Disposed   
        public let expectedStatus: PackageVersionStatus?
        ///  A format that specifies the type of package versions you want to dispose. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package with the versions you want to dispose. 
        public let package: String
        ///  The name of the repository that contains the package versions you want to dispose. 
        public let repository: String
        ///  The revisions of the package versions you want to dispose. 
        public let versionRevisions: [String: String]?
        ///  The versions of the package you want to dispose. 
        public let versions: [String]

        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, versionRevisions: [String: String]? = nil, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versionRevisions?.forEach {
                try validate($0.key, name:"versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name:"versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name:"versionRevisions.key", parent: name, pattern: "[^!#/\\s]+")
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, pattern: "\\S+")
            }
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case expectedStatus = "expectedStatus"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case repository = "repository"
            case versionRevisions = "versionRevisions"
            case versions = "versions"
        }
    }

    public struct DisposePackageVersionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "failedVersions", required: false, type: .map), 
            AWSShapeMember(label: "successfulVersions", required: false, type: .map)
        ]

        ///  A PackageVersionError object that contains a map of errors codes for the disposed package versions that failed. The possible error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED   
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of the package versions that were successfully disposed. 
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct DomainDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "assetSizeBytes", required: false, type: .long), 
            AWSShapeMember(label: "createdTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "encryptionKey", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "owner", required: false, type: .string), 
            AWSShapeMember(label: "repositoryCount", required: false, type: .integer), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]

        ///  The Amazon Resource Name (ARN) of the domain. 
        public let arn: String?
        ///  The total size of all assets in the domain. 
        public let assetSizeBytes: Int64?
        ///  A timestamp that represents the date and time the domain was created. 
        public let createdTime: TimeStamp?
        ///  The ARN of an AWS Key Management Service (AWS KMS) key associated with a domain. 
        public let encryptionKey: String?
        ///  The name of the domain. 
        public let name: String?
        ///  The AWS account ID that owns the domain. 
        public let owner: String?
        ///  The number of repositories in the domain. 
        public let repositoryCount: Int?
        ///  The current status of a domain. The valid values are     Active     Deleted   
        public let status: DomainStatus?

        public init(arn: String? = nil, assetSizeBytes: Int64? = nil, createdTime: TimeStamp? = nil, encryptionKey: String? = nil, name: String? = nil, owner: String? = nil, repositoryCount: Int? = nil, status: DomainStatus? = nil) {
            self.arn = arn
            self.assetSizeBytes = assetSizeBytes
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.repositoryCount = repositoryCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetSizeBytes = "assetSizeBytes"
            case createdTime = "createdTime"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case owner = "owner"
            case repositoryCount = "repositoryCount"
            case status = "status"
        }
    }

    public struct DomainSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "createdTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "encryptionKey", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "owner", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]

        ///  The ARN of the domain. 
        public let arn: String?
        ///  A timestamp that contains the date and time the domain was created. 
        public let createdTime: TimeStamp?
        ///  The key used to encrypt the domain. 
        public let encryptionKey: String?
        ///  The name of the domain. 
        public let name: String?
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let owner: String?
        ///  A string that contains the status of the domain. The valid values are:     Active     Deleted   
        public let status: DomainStatus?

        public init(arn: String? = nil, createdTime: TimeStamp? = nil, encryptionKey: String? = nil, name: String? = nil, owner: String? = nil, status: DomainStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdTime = "createdTime"
            case encryptionKey = "encryptionKey"
            case name = "name"
            case owner = "owner"
            case status = "status"
        }
    }

    public struct GetAuthorizationTokenRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "durationSeconds", location: .querystring(locationName: "duration"), required: false, type: .long)
        ]

        ///  The name of the domain that is in scope for the generated authorization token. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        /// The time, in seconds, that the generated authorization token is valid.
        public let durationSeconds: Int64?

        public init(domain: String, domainOwner: String? = nil, durationSeconds: Int64? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.durationSeconds = durationSeconds
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.durationSeconds, name:"durationSeconds", parent: name, max: 43200)
            try validate(self.durationSeconds, name:"durationSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case durationSeconds = "duration"
        }
    }

    public struct GetAuthorizationTokenResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "authorizationToken", required: false, type: .string), 
            AWSShapeMember(label: "expiration", required: false, type: .timestamp)
        ]

        ///  The returned authentication token. 
        public let authorizationToken: String?
        ///  A timestamp that specifies the date and time the authorization token expires. 
        public let expiration: TimeStamp?

        public init(authorizationToken: String? = nil, expiration: TimeStamp? = nil) {
            self.authorizationToken = authorizationToken
            self.expiration = expiration
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken = "authorizationToken"
            case expiration = "expiration"
        }
    }

    public struct GetDomainPermissionsPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string)
        ]

        ///  The name of the domain to which the resource policy is attached. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?

        public init(domain: String, domainOwner: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
        }
    }

    public struct GetDomainPermissionsPolicyResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policy", required: false, type: .structure)
        ]

        ///  The returned resource policy. 
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GetPackageVersionAssetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "asset", location: .querystring(locationName: "asset"), required: true, type: .string), 
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "packageVersion", location: .querystring(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "packageVersionRevision", location: .querystring(locationName: "revision"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the requested asset. 
        public let asset: String
        ///  The domain that contains the repository that contains the package version with the requested asset. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  A format that specifies the type of the package version with the requested asset file. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package that contains the requested asset. 
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2). 
        public let packageVersion: String
        ///  The name of the package version revision that contains the requested asset. 
        public let packageVersionRevision: String?
        ///  The repository that contains the package version with the requested asset. 
        public let repository: String

        public init(asset: String, domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, packageVersionRevision: String? = nil, repository: String) {
            self.asset = asset
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.packageVersionRevision = packageVersionRevision
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.asset, name:"asset", parent: name, max: 255)
            try validate(self.asset, name:"asset", parent: name, min: 1)
            try validate(self.asset, name:"asset", parent: name, pattern: "\\P{C}+")
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.packageVersion, name:"packageVersion", parent: name, max: 255)
            try validate(self.packageVersion, name:"packageVersion", parent: name, min: 1)
            try validate(self.packageVersion, name:"packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.packageVersionRevision, name:"packageVersionRevision", parent: name, max: 50)
            try validate(self.packageVersionRevision, name:"packageVersionRevision", parent: name, min: 1)
            try validate(self.packageVersionRevision, name:"packageVersionRevision", parent: name, pattern: "\\S+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case asset = "asset"
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case packageVersion = "version"
            case packageVersionRevision = "revision"
            case repository = "repository"
        }
    }

    public struct GetPackageVersionAssetResult: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "asset"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "asset", required: false, type: .blob), 
            AWSShapeMember(label: "assetName", location: .header(locationName: "X-AssetName"), required: false, type: .string), 
            AWSShapeMember(label: "packageVersion", location: .header(locationName: "X-PackageVersion"), required: false, type: .string), 
            AWSShapeMember(label: "packageVersionRevision", location: .header(locationName: "X-PackageVersionRevision"), required: false, type: .string)
        ]

        ///  The binary file, or asset, that is downloaded.
        public let asset: Data?
        ///  The name of the asset that is downloaded. 
        public let assetName: String?
        ///  A string that contains the package version (for example, 3.5.2). 
        public let packageVersion: String?
        ///  The name of the package version revision that contains the downloaded asset. 
        public let packageVersionRevision: String?

        public init(asset: Data? = nil, assetName: String? = nil, packageVersion: String? = nil, packageVersionRevision: String? = nil) {
            self.asset = asset
            self.assetName = assetName
            self.packageVersion = packageVersion
            self.packageVersionRevision = packageVersionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case asset = "asset"
            case assetName = "X-AssetName"
            case packageVersion = "X-PackageVersion"
            case packageVersionRevision = "X-PackageVersionRevision"
        }
    }

    public struct GetPackageVersionReadmeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "packageVersion", location: .querystring(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository that contains the package version with the requested readme file. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  A format that specifies the type of the package version with the requested readme file. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package version that contains the requested readme file. 
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2). 
        public let packageVersion: String
        ///  The repository that contains the package with the requested readme file. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.packageVersion, name:"packageVersion", parent: name, max: 255)
            try validate(self.packageVersion, name:"packageVersion", parent: name, min: 1)
            try validate(self.packageVersion, name:"packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case packageVersion = "version"
            case repository = "repository"
        }
    }

    public struct GetPackageVersionReadmeResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "package", required: false, type: .string), 
            AWSShapeMember(label: "readme", required: false, type: .string), 
            AWSShapeMember(label: "version", required: false, type: .string), 
            AWSShapeMember(label: "versionRevision", required: false, type: .string)
        ]

        ///  The format of the package with the requested readme file. Valid format types are:     npm     pypi     maven   
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package that contains the returned readme file. 
        public let package: String?
        ///  The text of the returned readme file. 
        public let readme: String?
        ///  The version of the package with the requested readme file. 
        public let version: String?
        ///  The current revision associated with the package version. 
        public let versionRevision: String?

        public init(format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil, readme: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.format = format
            self.namespace = namespace
            self.package = package
            self.readme = readme
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case readme = "readme"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct GetRepositoryEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  Returns which endpoint of a repository to return. A repository has one endpoint for each package format:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The name of the repository. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case repository = "repository"
        }
    }

    public struct GetRepositoryEndpointResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryEndpoint", required: false, type: .string)
        ]

        ///  A string that specifies the URL of the returned endpoint. 
        public let repositoryEndpoint: String?

        public init(repositoryEndpoint: String? = nil) {
            self.repositoryEndpoint = repositoryEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryEndpoint = "repositoryEndpoint"
        }
    }

    public struct GetRepositoryPermissionsPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain containing the repository whose associated resource policy is to be retrieved. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The name of the repository whose associated resource policy is to be retrieved. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case repository = "repository"
        }
    }

    public struct GetRepositoryPermissionsPolicyResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policy", required: false, type: .structure)
        ]

        ///  The returned resource policy. 
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct LicenseInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "url", required: false, type: .string)
        ]

        ///  Name of the license. 
        public let name: String?
        ///  The URL for license data. 
        public let url: String?

        public init(name: String? = nil, url: String? = nil) {
            self.name = name
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case url = "url"
        }
    }

    public struct ListDomainsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The maximum number of results to return per page. 
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domains", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The returned list of  DomainSummary  objects. 
        public let domains: [DomainSummary]?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?

        public init(domains: [DomainSummary]? = nil, nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "domains"
            case nextToken = "nextToken"
        }
    }

    public struct ListPackageVersionAssetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "max-results"), required: false, type: .integer), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "next-token"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "packageVersion", location: .querystring(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain that contains the repository associated with the package version assets. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The format of the package that contains the returned package version assets. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let format: PackageFormat
        ///  The maximum number of results to return per page. 
        public let maxResults: Int?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  The name of the package that contains the returned package version assets. 
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2). 
        public let packageVersion: String
        ///  The name of the repository that contains the package that contains the returned package version assets. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.packageVersion, name:"packageVersion", parent: name, max: 255)
            try validate(self.packageVersion, name:"packageVersion", parent: name, min: 1)
            try validate(self.packageVersion, name:"packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case maxResults = "max-results"
            case namespace = "namespace"
            case nextToken = "next-token"
            case package = "package"
            case packageVersion = "version"
            case repository = "repository"
        }
    }

    public struct ListPackageVersionAssetsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "assets", required: false, type: .list), 
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "package", required: false, type: .string), 
            AWSShapeMember(label: "version", required: false, type: .string), 
            AWSShapeMember(label: "versionRevision", required: false, type: .string)
        ]

        ///  The returned list of  AssetSummary  objects. 
        public let assets: [AssetSummary]?
        ///  The format of the package that contains the returned package version assets. 
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  If there are additional results, this is the token for the next set of results. 
        public let nextToken: String?
        ///  The name of the package that contains the returned package version assets. 
        public let package: String?
        ///  The version of the package associated with the returned assets. 
        public let version: String?
        ///  The current revision associated with the package version. 
        public let versionRevision: String?

        public init(assets: [AssetSummary]? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.assets = assets
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case package = "package"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct ListPackageVersionDependenciesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "next-token"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "packageVersion", location: .querystring(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The domain that contains the repository that contains the requested package version dependencies. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The format of the package with the requested dependencies. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  The name of the package versions' package. 
        public let package: String
        ///  A string that contains the package version (for example, 3.5.2). 
        public let packageVersion: String
        ///  The name of the repository that contains the requested package version. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, namespace: String? = nil, nextToken: String? = nil, package: String, packageVersion: String, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.packageVersion = packageVersion
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.packageVersion, name:"packageVersion", parent: name, max: 255)
            try validate(self.packageVersion, name:"packageVersion", parent: name, min: 1)
            try validate(self.packageVersion, name:"packageVersion", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "next-token"
            case package = "package"
            case packageVersion = "version"
            case repository = "repository"
        }
    }

    public struct ListPackageVersionDependenciesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dependencies", required: false, type: .list), 
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "package", required: false, type: .string), 
            AWSShapeMember(label: "version", required: false, type: .string), 
            AWSShapeMember(label: "versionRevision", required: false, type: .string)
        ]

        ///  The returned list of  PackageDependency  objects. 
        public let dependencies: [PackageDependency]?
        ///  A format that specifies the type of the package that contains the returned dependencies. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  The name of the package that contains the returned package versions dependencies. 
        public let package: String?
        ///  The version of the package that is specified in the request. 
        public let version: String?
        ///  The current revision associated with the package version. 
        public let versionRevision: String?

        public init(dependencies: [PackageDependency]? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, version: String? = nil, versionRevision: String? = nil) {
            self.dependencies = dependencies
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.version = version
            self.versionRevision = versionRevision
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies = "dependencies"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case package = "package"
            case version = "version"
            case versionRevision = "versionRevision"
        }
    }

    public struct ListPackageVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "max-results"), required: false, type: .integer), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "next-token"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string), 
            AWSShapeMember(label: "sortBy", location: .querystring(locationName: "sortBy"), required: false, type: .enum), 
            AWSShapeMember(label: "status", location: .querystring(locationName: "status"), required: false, type: .enum)
        ]

        ///  The name of the domain that contains the repository that contains the returned package versions. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The format of the returned packages. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let format: PackageFormat
        ///  The maximum number of results to return per page. 
        public let maxResults: Int?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  The name of the package for which you want to return a list of package versions. 
        public let package: String
        ///  The name of the repository that contains the package. 
        public let repository: String
        ///  How to sort the returned list of package versions. 
        public let sortBy: PackageVersionSortType?
        ///  A string that specifies the status of the package versions to include in the returned list. It can be one of the following:     Published     Unfinished     Unlisted     Archived     Disposed   
        public let status: PackageVersionStatus?

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, package: String, repository: String, sortBy: PackageVersionSortType? = nil, status: PackageVersionStatus? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.repository = repository
            self.sortBy = sortBy
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case maxResults = "max-results"
            case namespace = "namespace"
            case nextToken = "next-token"
            case package = "package"
            case repository = "repository"
            case sortBy = "sortBy"
            case status = "status"
        }
    }

    public struct ListPackageVersionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultDisplayVersion", required: false, type: .string), 
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "package", required: false, type: .string), 
            AWSShapeMember(label: "versions", required: false, type: .list)
        ]

        ///  The default package version to display. This depends on the package format:     For Maven and PyPI packages, it's the most recently published package version.     For npm packages, it's the version referenced by the latest tag. If the latest tag is not set, it's the most recently published package version.   
        public let defaultDisplayVersion: String?
        ///  A format of the package. Valid package format values are:     npm     pypi     maven   
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  If there are additional results, this is the token for the next set of results. 
        public let nextToken: String?
        ///  The name of the package. 
        public let package: String?
        ///  The returned list of  PackageVersionSummary  objects. 
        public let versions: [PackageVersionSummary]?

        public init(defaultDisplayVersion: String? = nil, format: PackageFormat? = nil, namespace: String? = nil, nextToken: String? = nil, package: String? = nil, versions: [PackageVersionSummary]? = nil) {
            self.defaultDisplayVersion = defaultDisplayVersion
            self.format = format
            self.namespace = namespace
            self.nextToken = nextToken
            self.package = package
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case defaultDisplayVersion = "defaultDisplayVersion"
            case format = "format"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case package = "package"
            case versions = "versions"
        }
    }

    public struct ListPackagesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: false, type: .enum), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "max-results"), required: false, type: .integer), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "next-token"), required: false, type: .string), 
            AWSShapeMember(label: "packagePrefix", location: .querystring(locationName: "package-prefix"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The domain that contains the repository that contains the requested list of packages. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The format of the packages. The valid package types are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let format: PackageFormat?
        ///  The maximum number of results to return per page. 
        public let maxResults: Int?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned. 
        public let packagePrefix: String?
        ///  The name of the repository from which packages are to be listed. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, format: PackageFormat? = nil, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, packagePrefix: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.format = format
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.packagePrefix = packagePrefix
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
            try validate(self.packagePrefix, name:"packagePrefix", parent: name, max: 255)
            try validate(self.packagePrefix, name:"packagePrefix", parent: name, min: 1)
            try validate(self.packagePrefix, name:"packagePrefix", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case format = "format"
            case maxResults = "max-results"
            case namespace = "namespace"
            case nextToken = "next-token"
            case packagePrefix = "package-prefix"
            case repository = "repository"
        }
    }

    public struct ListPackagesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "packages", required: false, type: .list)
        ]

        ///  If there are additional results, this is the token for the next set of results. 
        public let nextToken: String?
        ///  The list of returned  PackageSummary  objects. 
        public let packages: [PackageSummary]?

        public init(nextToken: String? = nil, packages: [PackageSummary]? = nil) {
            self.nextToken = nextToken
            self.packages = packages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packages = "packages"
        }
    }

    public struct ListRepositoriesInDomainRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "administratorAccount", location: .querystring(locationName: "administrator-account"), required: false, type: .string), 
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "max-results"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "next-token"), required: false, type: .string), 
            AWSShapeMember(label: "repositoryPrefix", location: .querystring(locationName: "repository-prefix"), required: false, type: .string)
        ]

        ///  Filter the list of repositories to only include those that are managed by the AWS account ID. 
        public let administratorAccount: String?
        ///  The name of the domain that contains the returned list of repositories. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The maximum number of results to return per page. 
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned. 
        public let repositoryPrefix: String?

        public init(administratorAccount: String? = nil, domain: String, domainOwner: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, repositoryPrefix: String? = nil) {
            self.administratorAccount = administratorAccount
            self.domain = domain
            self.domainOwner = domainOwner
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.repositoryPrefix = repositoryPrefix
        }

        public func validate(name: String) throws {
            try validate(self.administratorAccount, name:"administratorAccount", parent: name, max: 12)
            try validate(self.administratorAccount, name:"administratorAccount", parent: name, min: 12)
            try validate(self.administratorAccount, name:"administratorAccount", parent: name, pattern: "[0-9]{12}")
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
            try validate(self.repositoryPrefix, name:"repositoryPrefix", parent: name, max: 100)
            try validate(self.repositoryPrefix, name:"repositoryPrefix", parent: name, min: 2)
            try validate(self.repositoryPrefix, name:"repositoryPrefix", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount = "administrator-account"
            case domain = "domain"
            case domainOwner = "domain-owner"
            case maxResults = "max-results"
            case nextToken = "next-token"
            case repositoryPrefix = "repository-prefix"
        }
    }

    public struct ListRepositoriesInDomainResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "repositories", required: false, type: .list)
        ]

        ///  If there are additional results, this is the token for the next set of results. 
        public let nextToken: String?
        ///  The returned list of repositories. 
        public let repositories: [RepositorySummary]?

        public init(nextToken: String? = nil, repositories: [RepositorySummary]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct ListRepositoriesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "max-results"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "next-token"), required: false, type: .string), 
            AWSShapeMember(label: "repositoryPrefix", location: .querystring(locationName: "repository-prefix"), required: false, type: .string)
        ]

        ///  The maximum number of results to return per page. 
        public let maxResults: Int?
        ///  The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. 
        public let nextToken: String?
        ///  A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
        public let repositoryPrefix: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, repositoryPrefix: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.repositoryPrefix = repositoryPrefix
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
            try validate(self.repositoryPrefix, name:"repositoryPrefix", parent: name, max: 100)
            try validate(self.repositoryPrefix, name:"repositoryPrefix", parent: name, min: 2)
            try validate(self.repositoryPrefix, name:"repositoryPrefix", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "max-results"
            case nextToken = "next-token"
            case repositoryPrefix = "repository-prefix"
        }
    }

    public struct ListRepositoriesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "repositories", required: false, type: .list)
        ]

        ///  If there are additional results, this is the token for the next set of results. 
        public let nextToken: String?
        ///  The returned list of  RepositorySummary  objects. 
        public let repositories: [RepositorySummary]?

        public init(nextToken: String? = nil, repositories: [RepositorySummary]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct PackageDependency: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dependencyType", required: false, type: .string), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "package", required: false, type: .string), 
            AWSShapeMember(label: "versionRequirement", required: false, type: .string)
        ]

        ///  The type of a package dependency. The possible values depend on the package type. Example types are compile, runtime, and test for Maven packages, and dev, prod, and optional for npm packages. 
        public let dependencyType: String?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package that this package depends on. 
        public let package: String?
        ///  The required version, or version range, of the package that this package depends on. The version format is specific to the package type. For example, the following are possible valid required versions: 1.2.3, ^2.3.4, or 4.x. 
        public let versionRequirement: String?

        public init(dependencyType: String? = nil, namespace: String? = nil, package: String? = nil, versionRequirement: String? = nil) {
            self.dependencyType = dependencyType
            self.namespace = namespace
            self.package = package
            self.versionRequirement = versionRequirement
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyType = "dependencyType"
            case namespace = "namespace"
            case package = "package"
            case versionRequirement = "versionRequirement"
        }
    }

    public struct PackageSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "package", required: false, type: .string)
        ]

        ///  The format of the package. Valid values are:     npm     pypi     maven   
        public let format: PackageFormat?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package. 
        public let package: String?

        public init(format: PackageFormat? = nil, namespace: String? = nil, package: String? = nil) {
            self.format = format
            self.namespace = namespace
            self.package = package
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case namespace = "namespace"
            case package = "package"
        }
    }

    public struct PackageVersionDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "displayName", required: false, type: .string), 
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "homePage", required: false, type: .string), 
            AWSShapeMember(label: "licenses", required: false, type: .list), 
            AWSShapeMember(label: "namespace", required: false, type: .string), 
            AWSShapeMember(label: "packageName", required: false, type: .string), 
            AWSShapeMember(label: "publishedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "revision", required: false, type: .string), 
            AWSShapeMember(label: "sourceCodeRepository", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "summary", required: false, type: .string), 
            AWSShapeMember(label: "version", required: false, type: .string)
        ]

        ///  The name of the package that is displayed. The displayName varies depending on the package version's format. For example, if an npm package is named ui, is in the namespace vue, and has the format npm, then the displayName is @vue/ui. 
        public let displayName: String?
        ///  The format of the package version. The valid package formats are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let format: PackageFormat?
        ///  The homepage associated with the package. 
        public let homePage: String?
        ///  Information about licenses associated with the package version. 
        public let licenses: [LicenseInfo]?
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the requested package. 
        public let packageName: String?
        ///  A timestamp that contains the date and time the package version was published. 
        public let publishedTime: TimeStamp?
        ///  The revision of the package version. 
        public let revision: String?
        ///  The repository for the source code in the package version, or the source code used to build it. 
        public let sourceCodeRepository: String?
        ///  A string that contains the status of the package version. It can be one of the following:     Published     Unfinished     Unlisted     Archived     Disposed   
        public let status: PackageVersionStatus?
        ///  A summary of the package version. The summary is extracted from the package. The information in and detail level of the summary depends on the package version's format. 
        public let summary: String?
        ///  The version of the package. 
        public let version: String?

        public init(displayName: String? = nil, format: PackageFormat? = nil, homePage: String? = nil, licenses: [LicenseInfo]? = nil, namespace: String? = nil, packageName: String? = nil, publishedTime: TimeStamp? = nil, revision: String? = nil, sourceCodeRepository: String? = nil, status: PackageVersionStatus? = nil, summary: String? = nil, version: String? = nil) {
            self.displayName = displayName
            self.format = format
            self.homePage = homePage
            self.licenses = licenses
            self.namespace = namespace
            self.packageName = packageName
            self.publishedTime = publishedTime
            self.revision = revision
            self.sourceCodeRepository = sourceCodeRepository
            self.status = status
            self.summary = summary
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case format = "format"
            case homePage = "homePage"
            case licenses = "licenses"
            case namespace = "namespace"
            case packageName = "packageName"
            case publishedTime = "publishedTime"
            case revision = "revision"
            case sourceCodeRepository = "sourceCodeRepository"
            case status = "status"
            case summary = "summary"
            case version = "version"
        }
    }

    public struct PackageVersionError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "errorCode", required: false, type: .enum), 
            AWSShapeMember(label: "errorMessage", required: false, type: .string)
        ]

        ///  The error code associated with the error. Valid error codes are:     ALREADY_EXISTS     MISMATCHED_REVISION     MISMATCHED_STATUS     NOT_ALLOWED     NOT_FOUND     SKIPPED   
        public let errorCode: PackageVersionErrorCode?
        ///  The error message associated with the error. 
        public let errorMessage: String?

        public init(errorCode: PackageVersionErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct PackageVersionSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "revision", required: false, type: .string), 
            AWSShapeMember(label: "status", required: true, type: .enum), 
            AWSShapeMember(label: "version", required: true, type: .string)
        ]

        ///  The revision associated with a package version. 
        public let revision: String?
        ///  A string that contains the status of the package version. It can be one of the following:     Published     Unfinished     Unlisted     Archived     Disposed   
        public let status: PackageVersionStatus
        ///  Information about a package version. 
        public let version: String

        public init(revision: String? = nil, status: PackageVersionStatus, version: String) {
            self.revision = revision
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case revision = "revision"
            case status = "status"
            case version = "version"
        }
    }

    public struct PutDomainPermissionsPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", required: false, type: .string), 
            AWSShapeMember(label: "policyDocument", required: true, type: .string), 
            AWSShapeMember(label: "policyRevision", required: false, type: .string)
        ]

        ///  The name of the domain on which to set the resource policy. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain. 
        public let policyDocument: String
        ///  The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. 
        public let policyRevision: String?

        public init(domain: String, domainOwner: String? = nil, policyDocument: String, policyRevision: String? = nil) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyDocument = policyDocument
            self.policyRevision = policyRevision
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.policyDocument, name:"policyDocument", parent: name, max: 5120)
            try validate(self.policyDocument, name:"policyDocument", parent: name, min: 1)
            try validate(self.policyRevision, name:"policyRevision", parent: name, max: 100)
            try validate(self.policyRevision, name:"policyRevision", parent: name, min: 1)
            try validate(self.policyRevision, name:"policyRevision", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domainOwner"
            case policyDocument = "policyDocument"
            case policyRevision = "policyRevision"
        }
    }

    public struct PutDomainPermissionsPolicyResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policy", required: false, type: .structure)
        ]

        ///  The resource policy that was set after processing the request. 
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutRepositoryPermissionsPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "policyDocument", required: true, type: .string), 
            AWSShapeMember(label: "policyRevision", required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string)
        ]

        ///  The name of the domain containing the repository to set the resource policy on. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository. 
        public let policyDocument: String
        ///  Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy. 
        public let policyRevision: String?
        ///  The name of the repository to set the resource policy on. 
        public let repository: String

        public init(domain: String, domainOwner: String? = nil, policyDocument: String, policyRevision: String? = nil, repository: String) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.policyDocument = policyDocument
            self.policyRevision = policyRevision
            self.repository = repository
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.policyDocument, name:"policyDocument", parent: name, max: 5120)
            try validate(self.policyDocument, name:"policyDocument", parent: name, min: 1)
            try validate(self.policyRevision, name:"policyRevision", parent: name, max: 100)
            try validate(self.policyRevision, name:"policyRevision", parent: name, min: 1)
            try validate(self.policyRevision, name:"policyRevision", parent: name, pattern: "\\S+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case policyDocument = "policyDocument"
            case policyRevision = "policyRevision"
            case repository = "repository"
        }
    }

    public struct PutRepositoryPermissionsPolicyResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policy", required: false, type: .structure)
        ]

        ///  The resource policy that was set after processing the request. 
        public let policy: ResourcePolicy?

        public init(policy: ResourcePolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct RepositoryDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "administratorAccount", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "domainName", required: false, type: .string), 
            AWSShapeMember(label: "domainOwner", required: false, type: .string), 
            AWSShapeMember(label: "externalConnections", required: false, type: .list), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "upstreams", required: false, type: .list)
        ]

        ///  The 12-digit account number of the AWS account that manages the repository. 
        public let administratorAccount: String?
        ///  The Amazon Resource Name (ARN) of the repository. 
        public let arn: String?
        ///  A text description of the repository. 
        public let description: String?
        ///  The name of the domain that contains the repository. 
        public let domainName: String?
        ///  The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  An array of external connections associated with the repository. 
        public let externalConnections: [RepositoryExternalConnectionInfo]?
        ///  The name of the repository. 
        public let name: String?
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see Working with upstream repositories. 
        public let upstreams: [UpstreamRepositoryInfo]?

        public init(administratorAccount: String? = nil, arn: String? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, externalConnections: [RepositoryExternalConnectionInfo]? = nil, name: String? = nil, upstreams: [UpstreamRepositoryInfo]? = nil) {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.externalConnections = externalConnections
            self.name = name
            self.upstreams = upstreams
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount = "administratorAccount"
            case arn = "arn"
            case description = "description"
            case domainName = "domainName"
            case domainOwner = "domainOwner"
            case externalConnections = "externalConnections"
            case name = "name"
            case upstreams = "upstreams"
        }
    }

    public struct RepositoryExternalConnectionInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "externalConnectionName", required: false, type: .string), 
            AWSShapeMember(label: "packageFormat", required: false, type: .enum), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]

        ///  The name of the external connection associated with a repository. 
        public let externalConnectionName: String?
        ///  The package format associated with a repository's external connection. The valid package formats are:     npm: A Node Package Manager (npm) package.     pypi: A Python Package Index (PyPI) package.     maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.   
        public let packageFormat: PackageFormat?
        ///  The status of the external connection of a repository. There is one valid value, Available. 
        public let status: ExternalConnectionStatus?

        public init(externalConnectionName: String? = nil, packageFormat: PackageFormat? = nil, status: ExternalConnectionStatus? = nil) {
            self.externalConnectionName = externalConnectionName
            self.packageFormat = packageFormat
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case externalConnectionName = "externalConnectionName"
            case packageFormat = "packageFormat"
            case status = "status"
        }
    }

    public struct RepositorySummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "administratorAccount", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "domainName", required: false, type: .string), 
            AWSShapeMember(label: "domainOwner", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        ///  The AWS account ID that manages the repository. 
        public let administratorAccount: String?
        ///  The ARN of the repository. 
        public let arn: String?
        ///  The description of the repository. 
        public let description: String?
        ///  The name of the domain that contains the repository. 
        public let domainName: String?
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The name of the repository. 
        public let name: String?

        public init(administratorAccount: String? = nil, arn: String? = nil, description: String? = nil, domainName: String? = nil, domainOwner: String? = nil, name: String? = nil) {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccount = "administratorAccount"
            case arn = "arn"
            case description = "description"
            case domainName = "domainName"
            case domainOwner = "domainOwner"
            case name = "name"
        }
    }

    public struct ResourcePolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "document", required: false, type: .string), 
            AWSShapeMember(label: "resourceArn", required: false, type: .string), 
            AWSShapeMember(label: "revision", required: false, type: .string)
        ]

        ///  The resource policy formatted in JSON. 
        public let document: String?
        ///  The ARN of the resource associated with the resource policy 
        public let resourceArn: String?
        ///  The current revision of the resource policy. 
        public let revision: String?

        public init(document: String? = nil, resourceArn: String? = nil, revision: String? = nil) {
            self.document = document
            self.resourceArn = resourceArn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
            case resourceArn = "resourceArn"
            case revision = "revision"
        }
    }

    public struct SuccessfulPackageVersionInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "revision", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]

        ///  The revision of a package version. 
        public let revision: String?
        ///  The status of a package version. Valid statuses are:     Published     Unfinished     Unlisted     Archived     Disposed   
        public let status: PackageVersionStatus?

        public init(revision: String? = nil, status: PackageVersionStatus? = nil) {
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case revision = "revision"
            case status = "status"
        }
    }

    public struct UpdatePackageVersionsStatusRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "expectedStatus", required: false, type: .enum), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum), 
            AWSShapeMember(label: "namespace", location: .querystring(locationName: "namespace"), required: false, type: .string), 
            AWSShapeMember(label: "package", location: .querystring(locationName: "package"), required: true, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string), 
            AWSShapeMember(label: "targetStatus", required: true, type: .enum), 
            AWSShapeMember(label: "versionRevisions", required: false, type: .map), 
            AWSShapeMember(label: "versions", required: true, type: .list)
        ]

        ///  The domain that contains the repository that contains the package versions with a status to be updated. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The package versions expected status before it is updated. If expectedStatus is provided, the package version's status is updated only if its status at the time UpdatePackageVersionsStatus is called matches expectedStatus. 
        public let expectedStatus: PackageVersionStatus?
        ///  A format that specifies the type of the package with the statuses to update. The valid values are:     npm     pypi     maven   
        public let format: PackageFormat
        ///  The namespace of the package. The package component that specifies its namespace depends on its type. For example:     The namespace of a Maven package is its groupId.     The namespace of an npm package is its scope.     A Python package does not contain a corresponding component, so Python packages do not have a namespace.   
        public let namespace: String?
        ///  The name of the package with the version statuses to update. 
        public let package: String
        ///  The repository that contains the package versions with the status you want to update. 
        public let repository: String
        ///  The status you want to change the package version status to. 
        public let targetStatus: PackageVersionStatus
        ///  A map of package versions and package version revisions. The map key is the package version (for example, 3.5.2), and the map value is the package version revision. 
        public let versionRevisions: [String: String]?
        ///  An array of strings that specify the versions of the package with the statuses to update. 
        public let versions: [String]

        public init(domain: String, domainOwner: String? = nil, expectedStatus: PackageVersionStatus? = nil, format: PackageFormat, namespace: String? = nil, package: String, repository: String, targetStatus: PackageVersionStatus, versionRevisions: [String: String]? = nil, versions: [String]) {
            self.domain = domain
            self.domainOwner = domainOwner
            self.expectedStatus = expectedStatus
            self.format = format
            self.namespace = namespace
            self.package = package
            self.repository = repository
            self.targetStatus = targetStatus
            self.versionRevisions = versionRevisions
            self.versions = versions
        }

        public func validate(name: String) throws {
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.namespace, name:"namespace", parent: name, max: 255)
            try validate(self.namespace, name:"namespace", parent: name, min: 1)
            try validate(self.namespace, name:"namespace", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.package, name:"package", parent: name, max: 255)
            try validate(self.package, name:"package", parent: name, min: 1)
            try validate(self.package, name:"package", parent: name, pattern: "[^!#/\\s]+")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.versionRevisions?.forEach {
                try validate($0.key, name:"versionRevisions.key", parent: name, max: 255)
                try validate($0.key, name:"versionRevisions.key", parent: name, min: 1)
                try validate($0.key, name:"versionRevisions.key", parent: name, pattern: "[^!#/\\s]+")
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, max: 50)
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name:"versionRevisions[\"\($0.key)\"]", parent: name, pattern: "\\S+")
            }
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 255)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "[^!#/\\s]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case domainOwner = "domain-owner"
            case expectedStatus = "expectedStatus"
            case format = "format"
            case namespace = "namespace"
            case package = "package"
            case repository = "repository"
            case targetStatus = "targetStatus"
            case versionRevisions = "versionRevisions"
            case versions = "versions"
        }
    }

    public struct UpdatePackageVersionsStatusResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "failedVersions", required: false, type: .map), 
            AWSShapeMember(label: "successfulVersions", required: false, type: .map)
        ]

        ///  A list of SuccessfulPackageVersionInfo objects, one for each package version with a status that successfully updated. 
        public let failedVersions: [String: PackageVersionError]?
        ///  A list of PackageVersionError objects, one for each package version with a status that failed to update. 
        public let successfulVersions: [String: SuccessfulPackageVersionInfo]?

        public init(failedVersions: [String: PackageVersionError]? = nil, successfulVersions: [String: SuccessfulPackageVersionInfo]? = nil) {
            self.failedVersions = failedVersions
            self.successfulVersions = successfulVersions
        }

        private enum CodingKeys: String, CodingKey {
            case failedVersions = "failedVersions"
            case successfulVersions = "successfulVersions"
        }
    }

    public struct UpdateRepositoryRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "domain", location: .querystring(locationName: "domain"), required: true, type: .string), 
            AWSShapeMember(label: "domainOwner", location: .querystring(locationName: "domain-owner"), required: false, type: .string), 
            AWSShapeMember(label: "repository", location: .querystring(locationName: "repository"), required: true, type: .string), 
            AWSShapeMember(label: "upstreams", required: false, type: .list)
        ]

        ///  An updated repository description. 
        public let description: String?
        ///  The name of the domain associated with the repository to update. 
        public let domain: String
        ///  The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces. 
        public let domainOwner: String?
        ///  The name of the repository to update. 
        public let repository: String
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more information, see Working with upstream repositories. 
        public let upstreams: [UpstreamRepository]?

        public init(description: String? = nil, domain: String, domainOwner: String? = nil, repository: String, upstreams: [UpstreamRepository]? = nil) {
            self.description = description
            self.domain = domain
            self.domainOwner = domainOwner
            self.repository = repository
            self.upstreams = upstreams
        }

        public func validate(name: String) throws {
            try validate(self.description, name:"description", parent: name, max: 1000)
            try validate(self.description, name:"description", parent: name, pattern: "\\P{C}+")
            try validate(self.domain, name:"domain", parent: name, max: 50)
            try validate(self.domain, name:"domain", parent: name, min: 2)
            try validate(self.domain, name:"domain", parent: name, pattern: "[a-z][a-z0-9\\-]{0,48}[a-z0-9]")
            try validate(self.domainOwner, name:"domainOwner", parent: name, max: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, min: 12)
            try validate(self.domainOwner, name:"domainOwner", parent: name, pattern: "[0-9]{12}")
            try validate(self.repository, name:"repository", parent: name, max: 100)
            try validate(self.repository, name:"repository", parent: name, min: 2)
            try validate(self.repository, name:"repository", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
            try self.upstreams?.forEach {
                try $0.validate(name: "\(name).upstreams[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domain = "domain"
            case domainOwner = "domain-owner"
            case repository = "repository"
            case upstreams = "upstreams"
        }
    }

    public struct UpdateRepositoryResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]

        ///  The updated repository. 
        public let repository: RepositoryDescription?

        public init(repository: RepositoryDescription? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct UpstreamRepository: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]

        ///  The name of an upstream repository. 
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try validate(self.repositoryName, name:"repositoryName", parent: name, max: 100)
            try validate(self.repositoryName, name:"repositoryName", parent: name, min: 2)
            try validate(self.repositoryName, name:"repositoryName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9._\\-]{1,99}")
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct UpstreamRepositoryInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]

        ///  The name of an upstream repository. 
        public let repositoryName: String?

        public init(repositoryName: String? = nil) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }
}
