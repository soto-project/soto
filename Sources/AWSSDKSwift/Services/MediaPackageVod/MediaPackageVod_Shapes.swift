// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaPackageVod {

    public enum AdMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case scte35Enhanced = "SCTE35_ENHANCED"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public struct AssetShallow: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: false, type: .string), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: false, type: .string), 
            AWSShapeMember(label: "SourceArn", location: .body(locationName: "sourceArn"), required: false, type: .string), 
            AWSShapeMember(label: "SourceRoleArn", location: .body(locationName: "sourceRoleArn"), required: false, type: .string)
        ]

        /// The ARN of the Asset.
        public let arn: String?
        /// The unique identifier for the Asset.
        public let id: String?
        /// The ID of the PackagingGroup for the Asset.
        public let packagingGroupId: String?
        /// The resource ID to include in SPEKE key requests.
        public let resourceId: String?
        /// ARN of the source object in S3.
        public let sourceArn: String?
        /// The IAM role ARN used to access the source S3 bucket.
        public let sourceRoleArn: String?

        public init(arn: String? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil) {
            self.arn = arn
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
        }
    }

    public struct CmafEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]

        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct CmafPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsManifests", location: .body(locationName: "hlsManifests"), required: true, type: .list), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer)
        ]

        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations.
        public let hlsManifests: [HlsManifest]
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest], segmentDurationSeconds: Int? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
        }
    }

    public struct CreateAssetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: true, type: .string), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: false, type: .string), 
            AWSShapeMember(label: "SourceArn", location: .body(locationName: "sourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "SourceRoleArn", location: .body(locationName: "sourceRoleArn"), required: true, type: .string)
        ]

        public let id: String
        public let packagingGroupId: String
        public let resourceId: String?
        public let sourceArn: String
        public let sourceRoleArn: String

        public init(id: String, packagingGroupId: String, resourceId: String? = nil, sourceArn: String, sourceRoleArn: String) {
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
        }
    }

    public struct CreateAssetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "EgressEndpoints", location: .body(locationName: "egressEndpoints"), required: false, type: .list), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: false, type: .string), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: false, type: .string), 
            AWSShapeMember(label: "SourceArn", location: .body(locationName: "sourceArn"), required: false, type: .string), 
            AWSShapeMember(label: "SourceRoleArn", location: .body(locationName: "sourceRoleArn"), required: false, type: .string)
        ]

        public let arn: String?
        public let egressEndpoints: [EgressEndpoint]?
        public let id: String?
        public let packagingGroupId: String?
        public let resourceId: String?
        public let sourceArn: String?
        public let sourceRoleArn: String?

        public init(arn: String? = nil, egressEndpoints: [EgressEndpoint]? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil) {
            self.arn = arn
            self.egressEndpoints = egressEndpoints
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case egressEndpoints = "egressEndpoints"
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
        }
    }

    public struct CreatePackagingConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: true, type: .string)
        ]

        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        public let id: String
        public let mssPackage: MssPackage?
        public let packagingGroupId: String

        public init(cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String, mssPackage: MssPackage? = nil, packagingGroupId: String) {
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
        }
    }

    public struct CreatePackagingConfigurationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: false, type: .string)
        ]

        public let arn: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let mssPackage: MssPackage?
        public let packagingGroupId: String?

        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
        }
    }

    public struct CreatePackagingGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CreatePackagingGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string)
        ]

        public let arn: String?
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct DashEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]

        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct DashManifest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MinBufferTimeSeconds", location: .body(locationName: "minBufferTimeSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Profile", location: .body(locationName: "profile"), required: false, type: .enum), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure)
        ]

        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public let profile: Profile?
        public let streamSelection: StreamSelection?

        public init(manifestName: String? = nil, minBufferTimeSeconds: Int? = nil, profile: Profile? = nil, streamSelection: StreamSelection? = nil) {
            self.manifestName = manifestName
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.profile = profile
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "manifestName"
            case minBufferTimeSeconds = "minBufferTimeSeconds"
            case profile = "profile"
            case streamSelection = "streamSelection"
        }
    }

    public struct DashPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DashManifests", location: .body(locationName: "dashManifests"), required: true, type: .list), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer)
        ]

        /// A list of DASH manifest configurations.
        public let dashManifests: [DashManifest]
        public let encryption: DashEncryption?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?

        public init(dashManifests: [DashManifest], encryption: DashEncryption? = nil, segmentDurationSeconds: Int? = nil) {
            self.dashManifests = dashManifests
            self.encryption = encryption
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case dashManifests = "dashManifests"
            case encryption = "encryption"
            case segmentDurationSeconds = "segmentDurationSeconds"
        }
    }

    public struct DeleteAssetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteAssetResponse: AWSShape {


        public init() {
        }

    }

    public struct DeletePackagingConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeletePackagingConfigurationResponse: AWSShape {


        public init() {
        }

    }

    public struct DeletePackagingGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeletePackagingGroupResponse: AWSShape {


        public init() {
        }

    }

    public struct DescribeAssetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribeAssetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "EgressEndpoints", location: .body(locationName: "egressEndpoints"), required: false, type: .list), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: false, type: .string), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: false, type: .string), 
            AWSShapeMember(label: "SourceArn", location: .body(locationName: "sourceArn"), required: false, type: .string), 
            AWSShapeMember(label: "SourceRoleArn", location: .body(locationName: "sourceRoleArn"), required: false, type: .string)
        ]

        public let arn: String?
        public let egressEndpoints: [EgressEndpoint]?
        public let id: String?
        public let packagingGroupId: String?
        public let resourceId: String?
        public let sourceArn: String?
        public let sourceRoleArn: String?

        public init(arn: String? = nil, egressEndpoints: [EgressEndpoint]? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil) {
            self.arn = arn
            self.egressEndpoints = egressEndpoints
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case egressEndpoints = "egressEndpoints"
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
        }
    }

    public struct DescribePackagingConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribePackagingConfigurationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: false, type: .string)
        ]

        public let arn: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let mssPackage: MssPackage?
        public let packagingGroupId: String?

        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
        }
    }

    public struct DescribePackagingGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribePackagingGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string)
        ]

        public let arn: String?
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct EgressEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PackagingConfigurationId", location: .body(locationName: "packagingConfigurationId"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string)
        ]

        /// The ID of the PackagingConfiguration being applied to the Asset.
        public let packagingConfigurationId: String?
        /// The URL of the parent manifest for the repackaged Asset.
        public let url: String?

        public init(packagingConfigurationId: String? = nil, url: String? = nil) {
            self.packagingConfigurationId = packagingConfigurationId
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case packagingConfigurationId = "packagingConfigurationId"
            case url = "url"
        }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public struct HlsEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]

        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(encryptionMethod: EncryptionMethod? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.encryptionMethod = encryptionMethod
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionMethod = "encryptionMethod"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct HlsManifest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "IncludeIframeOnlyStream", location: .body(locationName: "includeIframeOnlyStream"), required: false, type: .boolean), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "ProgramDateTimeIntervalSeconds", location: .body(locationName: "programDateTimeIntervalSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "RepeatExtXKey", location: .body(locationName: "repeatExtXKey"), required: false, type: .boolean), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure)
        ]

        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let streamSelection: StreamSelection?

        public init(adMarkers: AdMarkers? = nil, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, programDateTimeIntervalSeconds: Int? = nil, repeatExtXKey: Bool? = nil, streamSelection: StreamSelection? = nil) {
            self.adMarkers = adMarkers
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case repeatExtXKey = "repeatExtXKey"
            case streamSelection = "streamSelection"
        }
    }

    public struct HlsPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsManifests", location: .body(locationName: "hlsManifests"), required: true, type: .list), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "UseAudioRenditionGroup", location: .body(locationName: "useAudioRenditionGroup"), required: false, type: .boolean)
        ]

        public let encryption: HlsEncryption?
        /// A list of HLS manifest configurations.
        public let hlsManifests: [HlsManifest]
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        public init(encryption: HlsEncryption? = nil, hlsManifests: [HlsManifest], segmentDurationSeconds: Int? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case useAudioRenditionGroup = "useAudioRenditionGroup"
        }
    }

    public struct ListAssetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingGroupId", location: .querystring(locationName: "packagingGroupId"), required: false, type: .string)
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let packagingGroupId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, packagingGroupId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packagingGroupId = packagingGroupId
        }

        public func validate(name: String) throws {
            try validate(maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case packagingGroupId = "packagingGroupId"
        }
    }

    public struct ListAssetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Assets", location: .body(locationName: "assets"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]

        public let assets: [AssetShallow]?
        public let nextToken: String?

        public init(assets: [AssetShallow]? = nil, nextToken: String? = nil) {
            self.assets = assets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case nextToken = "nextToken"
        }
    }

    public struct ListPackagingConfigurationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingGroupId", location: .querystring(locationName: "packagingGroupId"), required: false, type: .string)
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let packagingGroupId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, packagingGroupId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packagingGroupId = packagingGroupId
        }

        public func validate(name: String) throws {
            try validate(maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case packagingGroupId = "packagingGroupId"
        }
    }

    public struct ListPackagingConfigurationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingConfigurations", location: .body(locationName: "packagingConfigurations"), required: false, type: .list)
        ]

        public let nextToken: String?
        public let packagingConfigurations: [PackagingConfiguration]?

        public init(nextToken: String? = nil, packagingConfigurations: [PackagingConfiguration]? = nil) {
            self.nextToken = nextToken
            self.packagingConfigurations = packagingConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packagingConfigurations = "packagingConfigurations"
        }
    }

    public struct ListPackagingGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListPackagingGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "PackagingGroups", location: .body(locationName: "packagingGroups"), required: false, type: .list)
        ]

        public let nextToken: String?
        public let packagingGroups: [PackagingGroup]?

        public init(nextToken: String? = nil, packagingGroups: [PackagingGroup]? = nil) {
            self.nextToken = nextToken
            self.packagingGroups = packagingGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packagingGroups = "packagingGroups"
        }
    }

    public struct MssEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]

        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct MssManifest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure)
        ]

        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        public let streamSelection: StreamSelection?

        public init(manifestName: String? = nil, streamSelection: StreamSelection? = nil) {
            self.manifestName = manifestName
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "manifestName"
            case streamSelection = "streamSelection"
        }
    }

    public struct MssPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "MssManifests", location: .body(locationName: "mssManifests"), required: true, type: .list), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer)
        ]

        public let encryption: MssEncryption?
        /// A list of MSS manifest configurations.
        public let mssManifests: [MssManifest]
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int?

        public init(encryption: MssEncryption? = nil, mssManifests: [MssManifest], segmentDurationSeconds: Int? = nil) {
            self.encryption = encryption
            self.mssManifests = mssManifests
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case mssManifests = "mssManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
        }
    }

    public struct PackagingConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "PackagingGroupId", location: .body(locationName: "packagingGroupId"), required: false, type: .string)
        ]

        /// The ARN of the PackagingConfiguration.
        public let arn: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        /// The ID of the PackagingConfiguration.
        public let id: String?
        public let mssPackage: MssPackage?
        /// The ID of a PackagingGroup.
        public let packagingGroupId: String?

        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
        }
    }

    public struct PackagingGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string)
        ]

        /// The ARN of the PackagingGroup.
        public let arn: String?
        /// The ID of the PackagingGroup.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public enum Profile: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case hbbtv15 = "HBBTV_1_5"
        public var description: String { return self.rawValue }
    }

    public struct SpekeKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RoleArn", location: .body(locationName: "roleArn"), required: true, type: .string), 
            AWSShapeMember(label: "SystemIds", location: .body(locationName: "systemIds"), required: true, type: .list), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: true, type: .string)
        ]

        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String
        /// The system IDs to include in key requests.
        public let systemIds: [String]
        /// The URL of the external key provider service.
        public let url: String

        public init(roleArn: String, systemIds: [String], url: String) {
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case systemIds = "systemIds"
            case url = "url"
        }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    public struct StreamSelection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxVideoBitsPerSecond", location: .body(locationName: "maxVideoBitsPerSecond"), required: false, type: .integer), 
            AWSShapeMember(label: "MinVideoBitsPerSecond", location: .body(locationName: "minVideoBitsPerSecond"), required: false, type: .integer), 
            AWSShapeMember(label: "StreamOrder", location: .body(locationName: "streamOrder"), required: false, type: .enum)
        ]

        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        public init(maxVideoBitsPerSecond: Int? = nil, minVideoBitsPerSecond: Int? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
            case minVideoBitsPerSecond = "minVideoBitsPerSecond"
            case streamOrder = "streamOrder"
        }
    }
}
