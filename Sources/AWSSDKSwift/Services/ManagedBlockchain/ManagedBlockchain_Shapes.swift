// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension ManagedBlockchain {

    public struct ApprovalThresholdPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProposalDurationInHours", required: false, type: .integer), 
            AWSShapeMember(label: "ThresholdComparator", required: false, type: .enum), 
            AWSShapeMember(label: "ThresholdPercentage", required: false, type: .integer)
        ]
        /// The duration from the time that a proposal is created until it expires. If members cast neither the required number of YES votes to approve the proposal nor the number of NO votes required to reject it before the duration expires, the proposal is EXPIRED and ProposalActions are not carried out.
        public let proposalDurationInHours: Int32?
        /// Determines whether the vote percentage must be greater than the ThresholdPercentage or must be greater than or equal to the ThreholdPercentage to be approved.
        public let thresholdComparator: ThresholdComparator?
        /// The percentage of votes among all members that must be YES for a proposal to be approved. For example, a ThresholdPercentage value of 50 indicates 50%. The ThresholdComparator determines the precise comparison. If a ThresholdPercentage value of 50 is specified on a network with 10 members, along with a ThresholdComparator value of GREATER_THAN, this indicates that 6 YES votes are required for the proposal to be approved.
        public let thresholdPercentage: Int32?

        public init(proposalDurationInHours: Int32? = nil, thresholdComparator: ThresholdComparator? = nil, thresholdPercentage: Int32? = nil) {
            self.proposalDurationInHours = proposalDurationInHours
            self.thresholdComparator = thresholdComparator
            self.thresholdPercentage = thresholdPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case proposalDurationInHours = "ProposalDurationInHours"
            case thresholdComparator = "ThresholdComparator"
            case thresholdPercentage = "ThresholdPercentage"
        }
    }

    public struct CreateMemberInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientRequestToken", required: true, type: .string), 
            AWSShapeMember(label: "InvitationId", required: true, type: .string), 
            AWSShapeMember(label: "MemberConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string)
        ]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// The unique identifier of the invitation that is sent to the member to join the network.
        public let invitationId: String
        /// Member configuration parameters.
        public let memberConfiguration: MemberConfiguration
        /// The unique identifier of the network in which the member is created.
        public let networkId: String

        public init(clientRequestToken: String, invitationId: String, memberConfiguration: MemberConfiguration, networkId: String) {
            self.clientRequestToken = clientRequestToken
            self.invitationId = invitationId
            self.memberConfiguration = memberConfiguration
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case invitationId = "InvitationId"
            case memberConfiguration = "MemberConfiguration"
            case networkId = "networkId"
        }
    }

    public struct CreateMemberOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", required: false, type: .string)
        ]
        /// The unique identifier of the member.
        public let memberId: String?

        public init(memberId: String? = nil) {
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
        }
    }

    public struct CreateNetworkInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientRequestToken", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Framework", required: true, type: .enum), 
            AWSShapeMember(label: "FrameworkConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "FrameworkVersion", required: true, type: .string), 
            AWSShapeMember(label: "MemberConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "VotingPolicy", required: true, type: .structure)
        ]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// An optional description for the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework
        ///  Configuration properties of the blockchain framework relevant to the network configuration. 
        public let frameworkConfiguration: NetworkFrameworkConfiguration?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String
        /// Configuration properties for the first member within the network.
        public let memberConfiguration: MemberConfiguration
        /// The name of the network.
        public let name: String
        ///  The voting rules used by the network to determine if a proposal is approved. 
        public let votingPolicy: VotingPolicy

        public init(clientRequestToken: String, description: String? = nil, framework: Framework, frameworkConfiguration: NetworkFrameworkConfiguration? = nil, frameworkVersion: String, memberConfiguration: MemberConfiguration, name: String, votingPolicy: VotingPolicy) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.framework = framework
            self.frameworkConfiguration = frameworkConfiguration
            self.frameworkVersion = frameworkVersion
            self.memberConfiguration = memberConfiguration
            self.name = name
            self.votingPolicy = votingPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case framework = "Framework"
            case frameworkConfiguration = "FrameworkConfiguration"
            case frameworkVersion = "FrameworkVersion"
            case memberConfiguration = "MemberConfiguration"
            case name = "Name"
            case votingPolicy = "VotingPolicy"
        }
    }

    public struct CreateNetworkOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", required: false, type: .string), 
            AWSShapeMember(label: "NetworkId", required: false, type: .string)
        ]
        /// The unique identifier for the first member within the network.
        public let memberId: String?
        /// The unique identifier for the network.
        public let networkId: String?

        public init(memberId: String? = nil, networkId: String? = nil) {
            self.memberId = memberId
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case networkId = "NetworkId"
        }
    }

    public struct CreateNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientRequestToken", required: true, type: .string), 
            AWSShapeMember(label: "MemberId", location: .uri(locationName: "memberId"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NodeConfiguration", required: true, type: .structure)
        ]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// The unique identifier of the member that owns this node.
        public let memberId: String
        /// The unique identifier of the network in which this node runs.
        public let networkId: String
        /// The properties of a node configuration.
        public let nodeConfiguration: NodeConfiguration

        public init(clientRequestToken: String, memberId: String, networkId: String, nodeConfiguration: NodeConfiguration) {
            self.clientRequestToken = clientRequestToken
            self.memberId = memberId
            self.networkId = networkId
            self.nodeConfiguration = nodeConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case memberId = "memberId"
            case networkId = "networkId"
            case nodeConfiguration = "NodeConfiguration"
        }
    }

    public struct CreateNodeOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NodeId", required: false, type: .string)
        ]
        /// The unique identifier of the node.
        public let nodeId: String?

        public init(nodeId: String? = nil) {
            self.nodeId = nodeId
        }

        private enum CodingKeys: String, CodingKey {
            case nodeId = "NodeId"
        }
    }

    public struct CreateProposalInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: true, type: .structure), 
            AWSShapeMember(label: "ClientRequestToken", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "MemberId", required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string)
        ]
        /// The type of actions proposed, such as inviting a member or removing a member. The types of Actions in a proposal are mutually exclusive. For example, a proposal with Invitations actions cannot also contain Removals actions.
        public let actions: ProposalActions
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the operation. An idempotent operation completes no more than one time. This identifier is required only if you make a service request directly using an HTTP client. It is generated automatically if you use an AWS SDK or the AWS CLI.
        public let clientRequestToken: String
        /// A description for the proposal that is visible to voting members, for example, "Proposal to add Example Corp. as member."
        public let description: String?
        /// The unique identifier of the member that is creating the proposal. This identifier is especially useful for identifying the member making the proposal when multiple members exist in a single AWS account.
        public let memberId: String
        ///  The unique identifier of the network for which the proposal is made.
        public let networkId: String

        public init(actions: ProposalActions, clientRequestToken: String, description: String? = nil, memberId: String, networkId: String) {
            self.actions = actions
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.memberId = memberId
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case memberId = "MemberId"
            case networkId = "networkId"
        }
    }

    public struct CreateProposalOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProposalId", required: false, type: .string)
        ]
        /// The unique identifier of the proposal.
        public let proposalId: String?

        public init(proposalId: String? = nil) {
            self.proposalId = proposalId
        }

        private enum CodingKeys: String, CodingKey {
            case proposalId = "ProposalId"
        }
    }

    public struct DeleteMemberInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", location: .uri(locationName: "memberId"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string)
        ]
        /// The unique identifier of the member to remove.
        public let memberId: String
        /// The unique identifier of the network from which the member is removed.
        public let networkId: String

        public init(memberId: String, networkId: String) {
            self.memberId = memberId
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "memberId"
            case networkId = "networkId"
        }
    }

    public struct DeleteMemberOutput: AWSShape {

        public init() {
        }

    }

    public struct DeleteNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", location: .uri(locationName: "memberId"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NodeId", location: .uri(locationName: "nodeId"), required: true, type: .string)
        ]
        /// The unique identifier of the member that owns this node.
        public let memberId: String
        /// The unique identifier of the network that the node belongs to.
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(memberId: String, networkId: String, nodeId: String) {
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "memberId"
            case networkId = "networkId"
            case nodeId = "nodeId"
        }
    }

    public struct DeleteNodeOutput: AWSShape {

        public init() {
        }

    }

    public enum Edition: String, CustomStringConvertible, Codable {
        case starter = "STARTER"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum Framework: String, CustomStringConvertible, Codable {
        case hyperledgerFabric = "HYPERLEDGER_FABRIC"
        public var description: String { return self.rawValue }
    }

    public struct GetMemberInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", location: .uri(locationName: "memberId"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string)
        ]
        /// The unique identifier of the member.
        public let memberId: String
        /// The unique identifier of the network to which the member belongs.
        public let networkId: String

        public init(memberId: String, networkId: String) {
            self.memberId = memberId
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "memberId"
            case networkId = "networkId"
        }
    }

    public struct GetMemberOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Member", required: false, type: .structure)
        ]
        /// The properties of a member.
        public let member: Member?

        public init(member: Member? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct GetNetworkInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string)
        ]
        /// The unique identifier of the network to get information about.
        public let networkId: String

        public init(networkId: String) {
            self.networkId = networkId
        }

        private enum CodingKeys: String, CodingKey {
            case networkId = "networkId"
        }
    }

    public struct GetNetworkOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Network", required: false, type: .structure)
        ]
        /// An object containing network configuration parameters.
        public let network: Network?

        public init(network: Network? = nil) {
            self.network = network
        }

        private enum CodingKeys: String, CodingKey {
            case network = "Network"
        }
    }

    public struct GetNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", location: .uri(locationName: "memberId"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NodeId", location: .uri(locationName: "nodeId"), required: true, type: .string)
        ]
        /// The unique identifier of the member that owns the node.
        public let memberId: String
        /// The unique identifier of the network to which the node belongs.
        public let networkId: String
        /// The unique identifier of the node.
        public let nodeId: String

        public init(memberId: String, networkId: String, nodeId: String) {
            self.memberId = memberId
            self.networkId = networkId
            self.nodeId = nodeId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "memberId"
            case networkId = "networkId"
            case nodeId = "nodeId"
        }
    }

    public struct GetNodeOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Node", required: false, type: .structure)
        ]
        /// Properties of the node configuration.
        public let node: Node?

        public init(node: Node? = nil) {
            self.node = node
        }

        private enum CodingKeys: String, CodingKey {
            case node = "Node"
        }
    }

    public struct GetProposalInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "ProposalId", location: .uri(locationName: "proposalId"), required: true, type: .string)
        ]
        /// The unique identifier of the network for which the proposal is made.
        public let networkId: String
        /// The unique identifier of the proposal.
        public let proposalId: String

        public init(networkId: String, proposalId: String) {
            self.networkId = networkId
            self.proposalId = proposalId
        }

        private enum CodingKeys: String, CodingKey {
            case networkId = "networkId"
            case proposalId = "proposalId"
        }
    }

    public struct GetProposalOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Proposal", required: false, type: .structure)
        ]
        /// Information about a proposal.
        public let proposal: Proposal?

        public init(proposal: Proposal? = nil) {
            self.proposal = proposal
        }

        private enum CodingKeys: String, CodingKey {
            case proposal = "Proposal"
        }
    }

    public struct Invitation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ExpirationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "InvitationId", required: false, type: .string), 
            AWSShapeMember(label: "NetworkSummary", required: false, type: .structure), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        /// The date and time that the invitation was created.
        public let creationDate: TimeStamp?
        /// The date and time that the invitation expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, the invitee can no longer create a member and join the network using this InvitationId.
        public let expirationDate: TimeStamp?
        /// The unique identifier for the invitation.
        public let invitationId: String?
        public let networkSummary: NetworkSummary?
        /// The status of the invitation:    PENDING - The invitee has not created a member to join the network, and the invitation has not yet expired.    ACCEPTING - The invitee has begun creating a member, and creation has not yet completed.    ACCEPTED - The invitee created a member and joined the network using the InvitationID.    REJECTED - The invitee rejected the invitation.    EXPIRED - The invitee neither created a member nor rejected the invitation before the ExpirationDate.  
        public let status: InvitationStatus?

        public init(creationDate: TimeStamp? = nil, expirationDate: TimeStamp? = nil, invitationId: String? = nil, networkSummary: NetworkSummary? = nil, status: InvitationStatus? = nil) {
            self.creationDate = creationDate
            self.expirationDate = expirationDate
            self.invitationId = invitationId
            self.networkSummary = networkSummary
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case expirationDate = "ExpirationDate"
            case invitationId = "InvitationId"
            case networkSummary = "NetworkSummary"
            case status = "Status"
        }
    }

    public enum InvitationStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case accepted = "ACCEPTED"
        case accepting = "ACCEPTING"
        case rejected = "REJECTED"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public struct InviteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Principal", required: true, type: .string)
        ]
        /// The AWS account ID to invite.
        public let principal: String

        public init(principal: String) {
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case principal = "Principal"
        }
    }

    public struct ListInvitationsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]
        /// The maximum number of invitations to return.
        public let maxResults: Int32?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListInvitationsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Invitations", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The invitations for the network.
        public let invitations: [Invitation]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IsOwned", location: .querystring(locationName: "isOwned"), required: false, type: .boolean), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Name", location: .querystring(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Status", location: .querystring(locationName: "status"), required: false, type: .enum)
        ]
        /// An optional Boolean value. If provided, the request is limited either to members that the current AWS account owns (true) or that other AWS accounts own (false). If omitted, all members are listed.
        public let isOwned: Bool?
        /// The maximum number of members to return in the request.
        public let maxResults: Int32?
        /// The optional name of the member to list.
        public let name: String?
        /// The unique identifier of the network for which to list members.
        public let networkId: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only members currently in this status are listed.
        public let status: MemberStatus?

        public init(isOwned: Bool? = nil, maxResults: Int32? = nil, name: String? = nil, networkId: String, nextToken: String? = nil, status: MemberStatus? = nil) {
            self.isOwned = isOwned
            self.maxResults = maxResults
            self.name = name
            self.networkId = networkId
            self.nextToken = nextToken
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case isOwned = "isOwned"
            case maxResults = "maxResults"
            case name = "name"
            case networkId = "networkId"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListMembersOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Members", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of MemberSummary objects. Each object contains details about a network member.
        public let members: [MemberSummary]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(members: [MemberSummary]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListNetworksInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Framework", location: .querystring(locationName: "framework"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Name", location: .querystring(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Status", location: .querystring(locationName: "status"), required: false, type: .enum)
        ]
        /// An optional framework specifier. If provided, only networks of this framework type are listed.
        public let framework: Framework?
        /// The maximum number of networks to list.
        public let maxResults: Int32?
        /// The name of the network.
        public let name: String?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only networks currently in this status are listed.
        public let status: NetworkStatus?

        public init(framework: Framework? = nil, maxResults: Int32? = nil, name: String? = nil, nextToken: String? = nil, status: NetworkStatus? = nil) {
            self.framework = framework
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case framework = "framework"
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListNetworksOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Networks", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// An array of NetworkSummary objects that contain configuration properties for each network.
        public let networks: [NetworkSummary]?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(networks: [NetworkSummary]? = nil, nextToken: String? = nil) {
            self.networks = networks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networks = "Networks"
            case nextToken = "NextToken"
        }
    }

    public struct ListNodesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "MemberId", location: .uri(locationName: "memberId"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Status", location: .querystring(locationName: "status"), required: false, type: .enum)
        ]
        /// The maximum number of nodes to list.
        public let maxResults: Int32?
        /// The unique identifier of the member who owns the nodes to list.
        public let memberId: String
        /// The unique identifier of the network for which to list nodes.
        public let networkId: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An optional status specifier. If provided, only nodes currently in this status are listed.
        public let status: NodeStatus?

        public init(maxResults: Int32? = nil, memberId: String, networkId: String, nextToken: String? = nil, status: NodeStatus? = nil) {
            self.maxResults = maxResults
            self.memberId = memberId
            self.networkId = networkId
            self.nextToken = nextToken
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case memberId = "memberId"
            case networkId = "networkId"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListNodesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Nodes", required: false, type: .list)
        ]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An array of NodeSummary objects that contain configuration properties for each node.
        public let nodes: [NodeSummary]?

        public init(nextToken: String? = nil, nodes: [NodeSummary]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case nodes = "Nodes"
        }
    }

    public struct ListProposalVotesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "ProposalId", location: .uri(locationName: "proposalId"), required: true, type: .string)
        ]
        ///  The maximum number of votes to return. 
        public let maxResults: Int32?
        ///  The unique identifier of the network. 
        public let networkId: String
        ///  The pagination token that indicates the next set of results to retrieve. 
        public let nextToken: String?
        ///  The unique identifier of the proposal. 
        public let proposalId: String

        public init(maxResults: Int32? = nil, networkId: String, nextToken: String? = nil, proposalId: String) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
            self.proposalId = proposalId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case networkId = "networkId"
            case nextToken = "nextToken"
            case proposalId = "proposalId"
        }
    }

    public struct ListProposalVotesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ProposalVotes", required: false, type: .list)
        ]
        ///  The pagination token that indicates the next set of results to retrieve. 
        public let nextToken: String?
        ///  The listing of votes. 
        public let proposalVotes: [VoteSummary]?

        public init(nextToken: String? = nil, proposalVotes: [VoteSummary]? = nil) {
            self.nextToken = nextToken
            self.proposalVotes = proposalVotes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proposalVotes = "ProposalVotes"
        }
    }

    public struct ListProposalsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]
        ///  The maximum number of proposals to return. 
        public let maxResults: Int32?
        ///  The unique identifier of the network. 
        public let networkId: String
        ///  The pagination token that indicates the next set of results to retrieve. 
        public let nextToken: String?

        public init(maxResults: Int32? = nil, networkId: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.networkId = networkId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case networkId = "networkId"
            case nextToken = "nextToken"
        }
    }

    public struct ListProposalsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Proposals", required: false, type: .list)
        ]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The summary of each proposal made on the network.
        public let proposals: [ProposalSummary]?

        public init(nextToken: String? = nil, proposals: [ProposalSummary]? = nil) {
            self.nextToken = nextToken
            self.proposals = proposals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case proposals = "Proposals"
        }
    }

    public struct Member: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "FrameworkAttributes", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "NetworkId", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        /// The date and time that the member was created.
        public let creationDate: TimeStamp?
        /// An optional description for the member.
        public let description: String?
        /// Attributes relevant to a member for the blockchain framework that the Managed Blockchain network uses.
        public let frameworkAttributes: MemberFrameworkAttributes?
        /// The unique identifier of the member.
        public let id: String?
        /// The name of the member.
        public let name: String?
        /// The unique identifier of the network to which the member belongs.
        public let networkId: String?
        /// The status of a member.    CREATING - The AWS account is in the process of creating a member.    AVAILABLE - The member has been created and can participate in the network.    CREATE_FAILED - The AWS account attempted to create a member and creation failed.    DELETING - The member and all associated resources are in the process of being deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    DELETED - The member can no longer participate on the network and all associated resources are deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.  
        public let status: MemberStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, frameworkAttributes: MemberFrameworkAttributes? = nil, id: String? = nil, name: String? = nil, networkId: String? = nil, status: MemberStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.frameworkAttributes = frameworkAttributes
            self.id = id
            self.name = name
            self.networkId = networkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case frameworkAttributes = "FrameworkAttributes"
            case id = "Id"
            case name = "Name"
            case networkId = "NetworkId"
            case status = "Status"
        }
    }

    public struct MemberConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "FrameworkConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// An optional description of the member.
        public let description: String?
        /// Configuration properties of the blockchain framework relevant to the member.
        public let frameworkConfiguration: MemberFrameworkConfiguration
        /// The name of the member.
        public let name: String

        public init(description: String? = nil, frameworkConfiguration: MemberFrameworkConfiguration, name: String) {
            self.description = description
            self.frameworkConfiguration = frameworkConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case frameworkConfiguration = "FrameworkConfiguration"
            case name = "Name"
        }
    }

    public struct MemberFabricAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdminUsername", required: false, type: .string), 
            AWSShapeMember(label: "CaEndpoint", required: false, type: .string)
        ]
        /// The user name for the initial administrator user for the member.
        public let adminUsername: String?
        /// The endpoint used to access the member's certificate authority.
        public let caEndpoint: String?

        public init(adminUsername: String? = nil, caEndpoint: String? = nil) {
            self.adminUsername = adminUsername
            self.caEndpoint = caEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case adminUsername = "AdminUsername"
            case caEndpoint = "CaEndpoint"
        }
    }

    public struct MemberFabricConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdminPassword", required: true, type: .string), 
            AWSShapeMember(label: "AdminUsername", required: true, type: .string)
        ]
        /// The password for the member's initial administrative user. The AdminPassword must be at least eight characters long and no more than 32 characters. It must contain at least one uppercase letter, one lowercase letter, and one digit. It cannot have a single quote(‘), double quote(“), forward slash(/), backward slash(\), @, or a space.
        public let adminPassword: String
        /// The user name for the member's initial administrative user.
        public let adminUsername: String

        public init(adminPassword: String, adminUsername: String) {
            self.adminPassword = adminPassword
            self.adminUsername = adminUsername
        }

        private enum CodingKeys: String, CodingKey {
            case adminPassword = "AdminPassword"
            case adminUsername = "AdminUsername"
        }
    }

    public struct MemberFrameworkAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fabric", required: false, type: .structure)
        ]
        /// Attributes of Hyperledger Fabric relevant to a member on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: MemberFabricAttributes?

        public init(fabric: MemberFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct MemberFrameworkConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fabric", required: false, type: .structure)
        ]
        /// Attributes of Hyperledger Fabric for a member on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: MemberFabricConfiguration?

        public init(fabric: MemberFabricConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public enum MemberStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case deleting = "DELETING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct MemberSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IsOwned", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        /// The date and time that the member was created.
        public let creationDate: TimeStamp?
        /// An optional description of the member.
        public let description: String?
        /// The unique identifier of the member.
        public let id: String?
        /// An indicator of whether the member is owned by your AWS account or a different AWS account.
        public let isOwned: Bool?
        /// The name of the member.
        public let name: String?
        /// The status of the member.    CREATING - The AWS account is in the process of creating a member.    AVAILABLE - The member has been created and can participate in the network.    CREATE_FAILED - The AWS account attempted to create a member and creation failed.    DELETING - The member and all associated resources are in the process of being deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.    DELETED - The member can no longer participate on the network and all associated resources are deleted. Either the AWS account that owns the member deleted it, or the member is being deleted as the result of an APPROVED PROPOSAL to remove the member.  
        public let status: MemberStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, id: String? = nil, isOwned: Bool? = nil, name: String? = nil, status: MemberStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.isOwned = isOwned
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case id = "Id"
            case isOwned = "IsOwned"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct Network: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Framework", required: false, type: .enum), 
            AWSShapeMember(label: "FrameworkAttributes", required: false, type: .structure), 
            AWSShapeMember(label: "FrameworkVersion", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "VotingPolicy", required: false, type: .structure), 
            AWSShapeMember(label: "VpcEndpointServiceName", required: false, type: .string)
        ]
        /// The date and time that the network was created.
        public let creationDate: TimeStamp?
        /// Attributes of the blockchain framework for the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework?
        /// Attributes of the blockchain framework that the network uses.
        public let frameworkAttributes: NetworkFrameworkAttributes?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String?
        /// The unique identifier of the network.
        public let id: String?
        /// The name of the network.
        public let name: String?
        /// The current status of the network.
        public let status: NetworkStatus?
        /// The voting rules for the network to decide if a proposal is accepted.
        public let votingPolicy: VotingPolicy?
        /// The VPC endpoint service name of the VPC endpoint service of the network. Members use the VPC endpoint service name to create a VPC endpoint to access network resources.
        public let vpcEndpointServiceName: String?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, framework: Framework? = nil, frameworkAttributes: NetworkFrameworkAttributes? = nil, frameworkVersion: String? = nil, id: String? = nil, name: String? = nil, status: NetworkStatus? = nil, votingPolicy: VotingPolicy? = nil, vpcEndpointServiceName: String? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.framework = framework
            self.frameworkAttributes = frameworkAttributes
            self.frameworkVersion = frameworkVersion
            self.id = id
            self.name = name
            self.status = status
            self.votingPolicy = votingPolicy
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case framework = "Framework"
            case frameworkAttributes = "FrameworkAttributes"
            case frameworkVersion = "FrameworkVersion"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case votingPolicy = "VotingPolicy"
            case vpcEndpointServiceName = "VpcEndpointServiceName"
        }
    }

    public struct NetworkFabricAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Edition", required: false, type: .enum), 
            AWSShapeMember(label: "OrderingServiceEndpoint", required: false, type: .string)
        ]
        /// The edition of Amazon Managed Blockchain that Hyperledger Fabric uses. For more information, see Amazon Managed Blockchain Pricing.
        public let edition: Edition?
        /// The endpoint of the ordering service for the network.
        public let orderingServiceEndpoint: String?

        public init(edition: Edition? = nil, orderingServiceEndpoint: String? = nil) {
            self.edition = edition
            self.orderingServiceEndpoint = orderingServiceEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
            case orderingServiceEndpoint = "OrderingServiceEndpoint"
        }
    }

    public struct NetworkFabricConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Edition", required: true, type: .enum)
        ]
        /// The edition of Amazon Managed Blockchain that the network uses. For more information, see Amazon Managed Blockchain Pricing.
        public let edition: Edition

        public init(edition: Edition) {
            self.edition = edition
        }

        private enum CodingKeys: String, CodingKey {
            case edition = "Edition"
        }
    }

    public struct NetworkFrameworkAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fabric", required: false, type: .structure)
        ]
        /// Attributes of Hyperledger Fabric for a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NetworkFabricAttributes?

        public init(fabric: NetworkFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public struct NetworkFrameworkConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fabric", required: false, type: .structure)
        ]
        ///  Hyperledger Fabric configuration properties for a Managed Blockchain network that uses Hyperledger Fabric. 
        public let fabric: NetworkFabricConfiguration?

        public init(fabric: NetworkFabricConfiguration? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public enum NetworkStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case deleting = "DELETING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct NetworkSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Framework", required: false, type: .enum), 
            AWSShapeMember(label: "FrameworkVersion", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        /// The date and time that the network was created.
        public let creationDate: TimeStamp?
        /// An optional description of the network.
        public let description: String?
        /// The blockchain framework that the network uses.
        public let framework: Framework?
        /// The version of the blockchain framework that the network uses.
        public let frameworkVersion: String?
        /// The unique identifier of the network.
        public let id: String?
        /// The name of the network.
        public let name: String?
        /// The current status of the network.
        public let status: NetworkStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, framework: Framework? = nil, frameworkVersion: String? = nil, id: String? = nil, name: String? = nil, status: NetworkStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.framework = framework
            self.frameworkVersion = frameworkVersion
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case framework = "Framework"
            case frameworkVersion = "FrameworkVersion"
            case id = "Id"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct Node: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "FrameworkAttributes", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", required: false, type: .string), 
            AWSShapeMember(label: "MemberId", required: false, type: .string), 
            AWSShapeMember(label: "NetworkId", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        /// The Availability Zone in which the node exists.
        public let availabilityZone: String?
        /// The date and time that the node was created.
        public let creationDate: TimeStamp?
        /// Attributes of the blockchain framework being used.
        public let frameworkAttributes: NodeFrameworkAttributes?
        /// The unique identifier of the node.
        public let id: String?
        /// The instance type of the node.
        public let instanceType: String?
        /// The unique identifier of the member to which the node belongs.
        public let memberId: String?
        /// The unique identifier of the network that the node is in.
        public let networkId: String?
        /// The status of the node.
        public let status: NodeStatus?

        public init(availabilityZone: String? = nil, creationDate: TimeStamp? = nil, frameworkAttributes: NodeFrameworkAttributes? = nil, id: String? = nil, instanceType: String? = nil, memberId: String? = nil, networkId: String? = nil, status: NodeStatus? = nil) {
            self.availabilityZone = availabilityZone
            self.creationDate = creationDate
            self.frameworkAttributes = frameworkAttributes
            self.id = id
            self.instanceType = instanceType
            self.memberId = memberId
            self.networkId = networkId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case creationDate = "CreationDate"
            case frameworkAttributes = "FrameworkAttributes"
            case id = "Id"
            case instanceType = "InstanceType"
            case memberId = "MemberId"
            case networkId = "NetworkId"
            case status = "Status"
        }
    }

    public struct NodeConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZone", required: true, type: .string), 
            AWSShapeMember(label: "InstanceType", required: true, type: .string)
        ]
        /// The Availability Zone in which the node exists.
        public let availabilityZone: String
        /// The Amazon Managed Blockchain instance type for the node.
        public let instanceType: String

        public init(availabilityZone: String, instanceType: String) {
            self.availabilityZone = availabilityZone
            self.instanceType = instanceType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case instanceType = "InstanceType"
        }
    }

    public struct NodeFabricAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PeerEndpoint", required: false, type: .string), 
            AWSShapeMember(label: "PeerEventEndpoint", required: false, type: .string)
        ]
        /// The endpoint that identifies the peer node for all services except peer channel-based event services.
        public let peerEndpoint: String?
        /// The endpoint that identifies the peer node for peer channel-based event services.
        public let peerEventEndpoint: String?

        public init(peerEndpoint: String? = nil, peerEventEndpoint: String? = nil) {
            self.peerEndpoint = peerEndpoint
            self.peerEventEndpoint = peerEventEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case peerEndpoint = "PeerEndpoint"
            case peerEventEndpoint = "PeerEventEndpoint"
        }
    }

    public struct NodeFrameworkAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fabric", required: false, type: .structure)
        ]
        /// Attributes of Hyperledger Fabric for a peer node on a Managed Blockchain network that uses Hyperledger Fabric.
        public let fabric: NodeFabricAttributes?

        public init(fabric: NodeFabricAttributes? = nil) {
            self.fabric = fabric
        }

        private enum CodingKeys: String, CodingKey {
            case fabric = "Fabric"
        }
    }

    public enum NodeStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case available = "AVAILABLE"
        case createFailed = "CREATE_FAILED"
        case deleting = "DELETING"
        case deleted = "DELETED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct NodeSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        /// The Availability Zone in which the node exists.
        public let availabilityZone: String?
        /// The date and time that the node was created.
        public let creationDate: TimeStamp?
        /// The unique identifier of the node.
        public let id: String?
        /// The EC2 instance type for the node.
        public let instanceType: String?
        /// The status of the node.
        public let status: NodeStatus?

        public init(availabilityZone: String? = nil, creationDate: TimeStamp? = nil, id: String? = nil, instanceType: String? = nil, status: NodeStatus? = nil) {
            self.availabilityZone = availabilityZone
            self.creationDate = creationDate
            self.id = id
            self.instanceType = instanceType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case creationDate = "CreationDate"
            case id = "Id"
            case instanceType = "InstanceType"
            case status = "Status"
        }
    }

    public struct Proposal: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: false, type: .structure), 
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ExpirationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "NetworkId", required: false, type: .string), 
            AWSShapeMember(label: "NoVoteCount", required: false, type: .integer), 
            AWSShapeMember(label: "OutstandingVoteCount", required: false, type: .integer), 
            AWSShapeMember(label: "ProposalId", required: false, type: .string), 
            AWSShapeMember(label: "ProposedByMemberId", required: false, type: .string), 
            AWSShapeMember(label: "ProposedByMemberName", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "YesVoteCount", required: false, type: .integer)
        ]
        /// The actions to perform on the network if the proposal is APPROVED.
        public let actions: ProposalActions?
        ///  The date and time that the proposal was created. 
        public let creationDate: TimeStamp?
        /// The description of the proposal.
        public let description: String?
        ///  The date and time that the proposal expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, if members have not cast enough votes to determine the outcome according to the voting policy, the proposal is EXPIRED and Actions are not carried out. 
        public let expirationDate: TimeStamp?
        /// The unique identifier of the network for which the proposal is made.
        public let networkId: String?
        ///  The current total of NO votes cast on the proposal by members. 
        public let noVoteCount: Int32?
        ///  The number of votes remaining to be cast on the proposal by members. In other words, the number of members minus the sum of YES votes and NO votes. 
        public let outstandingVoteCount: Int32?
        /// The unique identifier of the proposal.
        public let proposalId: String?
        /// The unique identifier of the member that created the proposal.
        public let proposedByMemberId: String?
        /// The name of the member that created the proposal.
        public let proposedByMemberName: String?
        /// The status of the proposal. Values are as follows:    IN_PROGRESS - The proposal is active and open for member voting.    APPROVED - The proposal was approved with sufficient YES votes among members according to the VotingPolicy specified for the Network. The specified proposal actions are carried out.    REJECTED - The proposal was rejected with insufficient YES votes among members according to the VotingPolicy specified for the Network. The specified ProposalActions are not carried out.    EXPIRED - Members did not cast the number of votes required to determine the proposal outcome before the proposal expired. The specified ProposalActions are not carried out.    ACTION_FAILED - One or more of the specified ProposalActions in a proposal that was approved could not be completed because of an error.  
        public let status: ProposalStatus?
        ///  The current total of YES votes cast on the proposal by members. 
        public let yesVoteCount: Int32?

        public init(actions: ProposalActions? = nil, creationDate: TimeStamp? = nil, description: String? = nil, expirationDate: TimeStamp? = nil, networkId: String? = nil, noVoteCount: Int32? = nil, outstandingVoteCount: Int32? = nil, proposalId: String? = nil, proposedByMemberId: String? = nil, proposedByMemberName: String? = nil, status: ProposalStatus? = nil, yesVoteCount: Int32? = nil) {
            self.actions = actions
            self.creationDate = creationDate
            self.description = description
            self.expirationDate = expirationDate
            self.networkId = networkId
            self.noVoteCount = noVoteCount
            self.outstandingVoteCount = outstandingVoteCount
            self.proposalId = proposalId
            self.proposedByMemberId = proposedByMemberId
            self.proposedByMemberName = proposedByMemberName
            self.status = status
            self.yesVoteCount = yesVoteCount
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case creationDate = "CreationDate"
            case description = "Description"
            case expirationDate = "ExpirationDate"
            case networkId = "NetworkId"
            case noVoteCount = "NoVoteCount"
            case outstandingVoteCount = "OutstandingVoteCount"
            case proposalId = "ProposalId"
            case proposedByMemberId = "ProposedByMemberId"
            case proposedByMemberName = "ProposedByMemberName"
            case status = "Status"
            case yesVoteCount = "YesVoteCount"
        }
    }

    public struct ProposalActions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Invitations", required: false, type: .list), 
            AWSShapeMember(label: "Removals", required: false, type: .list)
        ]
        ///  The actions to perform for an APPROVED proposal to invite an AWS account to create a member and join the network. 
        public let invitations: [InviteAction]?
        ///  The actions to perform for an APPROVED proposal to remove a member from the network, which deletes the member and all associated member resources from the network. 
        public let removals: [RemoveAction]?

        public init(invitations: [InviteAction]? = nil, removals: [RemoveAction]? = nil) {
            self.invitations = invitations
            self.removals = removals
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case removals = "Removals"
        }
    }

    public enum ProposalStatus: String, CustomStringConvertible, Codable {
        case inProgress = "IN_PROGRESS"
        case approved = "APPROVED"
        case rejected = "REJECTED"
        case expired = "EXPIRED"
        case actionFailed = "ACTION_FAILED"
        public var description: String { return self.rawValue }
    }

    public struct ProposalSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ExpirationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ProposalId", required: false, type: .string), 
            AWSShapeMember(label: "ProposedByMemberId", required: false, type: .string), 
            AWSShapeMember(label: "ProposedByMemberName", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]
        ///  The date and time that the proposal was created. 
        public let creationDate: TimeStamp?
        ///  The description of the proposal. 
        public let description: String?
        ///  The date and time that the proposal expires. This is the CreationDate plus the ProposalDurationInHours that is specified in the ProposalThresholdPolicy. After this date and time, if members have not cast enough votes to determine the outcome according to the voting policy, the proposal is EXPIRED and Actions are not carried out. 
        public let expirationDate: TimeStamp?
        ///  The unique identifier of the proposal. 
        public let proposalId: String?
        ///  The unique identifier of the member that created the proposal. 
        public let proposedByMemberId: String?
        ///  The name of the member that created the proposal. 
        public let proposedByMemberName: String?
        /// The status of the proposal. Values are as follows:    IN_PROGRESS - The proposal is active and open for member voting.    APPROVED - The proposal was approved with sufficient YES votes among members according to the VotingPolicy specified for the Network. The specified proposal actions are carried out.    REJECTED - The proposal was rejected with insufficient YES votes among members according to the VotingPolicy specified for the Network. The specified ProposalActions are not carried out.    EXPIRED - Members did not cast the number of votes required to determine the proposal outcome before the proposal expired. The specified ProposalActions are not carried out.    ACTION_FAILED - One or more of the specified ProposalActions in a proposal that was approved could not be completed because of an error.  
        public let status: ProposalStatus?

        public init(creationDate: TimeStamp? = nil, description: String? = nil, expirationDate: TimeStamp? = nil, proposalId: String? = nil, proposedByMemberId: String? = nil, proposedByMemberName: String? = nil, status: ProposalStatus? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.expirationDate = expirationDate
            self.proposalId = proposalId
            self.proposedByMemberId = proposedByMemberId
            self.proposedByMemberName = proposedByMemberName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case description = "Description"
            case expirationDate = "ExpirationDate"
            case proposalId = "ProposalId"
            case proposedByMemberId = "ProposedByMemberId"
            case proposedByMemberName = "ProposedByMemberName"
            case status = "Status"
        }
    }

    public struct RejectInvitationInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InvitationId", location: .uri(locationName: "invitationId"), required: true, type: .string)
        ]
        /// The unique identifier of the invitation to reject.
        public let invitationId: String

        public init(invitationId: String) {
            self.invitationId = invitationId
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "invitationId"
        }
    }

    public struct RejectInvitationOutput: AWSShape {

        public init() {
        }

    }

    public struct RemoveAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", required: true, type: .string)
        ]
        /// The unique identifier of the member to remove.
        public let memberId: String

        public init(memberId: String) {
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
        }
    }

    public enum ThresholdComparator: String, CustomStringConvertible, Codable {
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        public var description: String { return self.rawValue }
    }

    public struct VoteOnProposalInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NetworkId", location: .uri(locationName: "networkId"), required: true, type: .string), 
            AWSShapeMember(label: "ProposalId", location: .uri(locationName: "proposalId"), required: true, type: .string), 
            AWSShapeMember(label: "Vote", required: true, type: .enum), 
            AWSShapeMember(label: "VoterMemberId", required: true, type: .string)
        ]
        ///  The unique identifier of the network. 
        public let networkId: String
        ///  The unique identifier of the proposal. 
        public let proposalId: String
        ///  The value of the vote. 
        public let vote: VoteValue
        /// The unique identifier of the member casting the vote. 
        public let voterMemberId: String

        public init(networkId: String, proposalId: String, vote: VoteValue, voterMemberId: String) {
            self.networkId = networkId
            self.proposalId = proposalId
            self.vote = vote
            self.voterMemberId = voterMemberId
        }

        private enum CodingKeys: String, CodingKey {
            case networkId = "networkId"
            case proposalId = "proposalId"
            case vote = "Vote"
            case voterMemberId = "VoterMemberId"
        }
    }

    public struct VoteOnProposalOutput: AWSShape {

        public init() {
        }

    }

    public struct VoteSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MemberId", required: false, type: .string), 
            AWSShapeMember(label: "MemberName", required: false, type: .string), 
            AWSShapeMember(label: "Vote", required: false, type: .enum)
        ]
        ///  The unique identifier of the member that cast the vote. 
        public let memberId: String?
        ///  The name of the member that cast the vote. 
        public let memberName: String?
        ///  The vote value, either YES or NO. 
        public let vote: VoteValue?

        public init(memberId: String? = nil, memberName: String? = nil, vote: VoteValue? = nil) {
            self.memberId = memberId
            self.memberName = memberName
            self.vote = vote
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case memberName = "MemberName"
            case vote = "Vote"
        }
    }

    public enum VoteValue: String, CustomStringConvertible, Codable {
        case yes = "YES"
        case no = "NO"
        public var description: String { return self.rawValue }
    }

    public struct VotingPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApprovalThresholdPolicy", required: false, type: .structure)
        ]
        /// Defines the rules for the network for voting on proposals, such as the percentage of YES votes required for the proposal to be approved and the duration of the proposal. The policy applies to all proposals and is specified when the network is created.
        public let approvalThresholdPolicy: ApprovalThresholdPolicy?

        public init(approvalThresholdPolicy: ApprovalThresholdPolicy? = nil) {
            self.approvalThresholdPolicy = approvalThresholdPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case approvalThresholdPolicy = "ApprovalThresholdPolicy"
        }
    }
}
