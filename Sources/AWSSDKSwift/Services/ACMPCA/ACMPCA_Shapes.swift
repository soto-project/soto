// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension ACMPCA {

    public struct ASN1Subject: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CommonName", required: false, type: .string), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "DistinguishedNameQualifier", required: false, type: .string), 
            AWSShapeMember(label: "GenerationQualifier", required: false, type: .string), 
            AWSShapeMember(label: "GivenName", required: false, type: .string), 
            AWSShapeMember(label: "Initials", required: false, type: .string), 
            AWSShapeMember(label: "Locality", required: false, type: .string), 
            AWSShapeMember(label: "Organization", required: false, type: .string), 
            AWSShapeMember(label: "OrganizationalUnit", required: false, type: .string), 
            AWSShapeMember(label: "Pseudonym", required: false, type: .string), 
            AWSShapeMember(label: "SerialNumber", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "Surname", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: false, type: .string)
        ]

        /// Fully qualified domain name (FQDN) associated with the certificate subject.
        public let commonName: String?
        /// Two-digit code that specifies the country in which the certificate subject located.
        public let country: String?
        /// Disambiguating information for the certificate subject.
        public let distinguishedNameQualifier: String?
        /// Typically a qualifier appended to the name of an individual. Examples include Jr. for junior, Sr. for senior, and III for third.
        public let generationQualifier: String?
        /// First name.
        public let givenName: String?
        /// Concatenation that typically contains the first letter of the GivenName, the first letter of the middle name if one exists, and the first letter of the SurName.
        public let initials: String?
        /// The locality (such as a city or town) in which the certificate subject is located.
        public let locality: String?
        /// Legal name of the organization with which the certificate subject is affiliated. 
        public let organization: String?
        /// A subdivision or unit of the organization (such as sales or finance) with which the certificate subject is affiliated.
        public let organizationalUnit: String?
        /// Typically a shortened version of a longer GivenName. For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth, Liz, or Eliza.
        public let pseudonym: String?
        /// The certificate serial number.
        public let serialNumber: String?
        /// State in which the subject of the certificate is located.
        public let state: String?
        /// Family name. In the US and the UK, for example, the surname of an individual is ordered last. In Asian cultures the surname is typically ordered first.
        public let surname: String?
        /// A title such as Mr. or Ms., which is pre-pended to the name to refer formally to the certificate subject.
        public let title: String?

        public init(commonName: String? = nil, country: String? = nil, distinguishedNameQualifier: String? = nil, generationQualifier: String? = nil, givenName: String? = nil, initials: String? = nil, locality: String? = nil, organization: String? = nil, organizationalUnit: String? = nil, pseudonym: String? = nil, serialNumber: String? = nil, state: String? = nil, surname: String? = nil, title: String? = nil) {
            self.commonName = commonName
            self.country = country
            self.distinguishedNameQualifier = distinguishedNameQualifier
            self.generationQualifier = generationQualifier
            self.givenName = givenName
            self.initials = initials
            self.locality = locality
            self.organization = organization
            self.organizationalUnit = organizationalUnit
            self.pseudonym = pseudonym
            self.serialNumber = serialNumber
            self.state = state
            self.surname = surname
            self.title = title
        }

        public func validate() throws {
            try validate(commonName, name:"commonName", max: 64)
            try validate(commonName, name:"commonName", min: 0)
            try validate(country, name:"country", pattern: "[A-Za-z]{2}")
            try validate(distinguishedNameQualifier, name:"distinguishedNameQualifier", max: 64)
            try validate(distinguishedNameQualifier, name:"distinguishedNameQualifier", min: 0)
            try validate(distinguishedNameQualifier, name:"distinguishedNameQualifier", pattern: "[a-zA-Z0-9'()+-.?:/= ]*")
            try validate(generationQualifier, name:"generationQualifier", max: 3)
            try validate(generationQualifier, name:"generationQualifier", min: 0)
            try validate(givenName, name:"givenName", max: 16)
            try validate(givenName, name:"givenName", min: 0)
            try validate(initials, name:"initials", max: 5)
            try validate(initials, name:"initials", min: 0)
            try validate(locality, name:"locality", max: 128)
            try validate(locality, name:"locality", min: 0)
            try validate(organization, name:"organization", max: 64)
            try validate(organization, name:"organization", min: 0)
            try validate(organizationalUnit, name:"organizationalUnit", max: 64)
            try validate(organizationalUnit, name:"organizationalUnit", min: 0)
            try validate(pseudonym, name:"pseudonym", max: 128)
            try validate(pseudonym, name:"pseudonym", min: 0)
            try validate(serialNumber, name:"serialNumber", max: 64)
            try validate(serialNumber, name:"serialNumber", min: 0)
            try validate(state, name:"state", max: 128)
            try validate(state, name:"state", min: 0)
            try validate(surname, name:"surname", max: 40)
            try validate(surname, name:"surname", min: 0)
            try validate(title, name:"title", max: 64)
            try validate(title, name:"title", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case commonName = "CommonName"
            case country = "Country"
            case distinguishedNameQualifier = "DistinguishedNameQualifier"
            case generationQualifier = "GenerationQualifier"
            case givenName = "GivenName"
            case initials = "Initials"
            case locality = "Locality"
            case organization = "Organization"
            case organizationalUnit = "OrganizationalUnit"
            case pseudonym = "Pseudonym"
            case serialNumber = "SerialNumber"
            case state = "State"
            case surname = "Surname"
            case title = "Title"
        }
    }

    public enum ActionType: String, CustomStringConvertible, Codable {
        case issuecertificate = "IssueCertificate"
        case getcertificate = "GetCertificate"
        case listpermissions = "ListPermissions"
        public var description: String { return self.rawValue }
    }

    public enum AuditReportResponseFormat: String, CustomStringConvertible, Codable {
        case json = "JSON"
        case csv = "CSV"
        public var description: String { return self.rawValue }
    }

    public enum AuditReportStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case success = "SUCCESS"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct CertificateAuthority: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "CertificateAuthorityConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "FailureReason", required: false, type: .enum), 
            AWSShapeMember(label: "LastStateChangeAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "NotAfter", required: false, type: .timestamp), 
            AWSShapeMember(label: "NotBefore", required: false, type: .timestamp), 
            AWSShapeMember(label: "RestorableUntil", required: false, type: .timestamp), 
            AWSShapeMember(label: "RevocationConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Serial", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]

        /// Amazon Resource Name (ARN) for your private certificate authority (CA). The format is  12345678-1234-1234-1234-123456789012 .
        public let arn: String?
        /// Your private CA configuration.
        public let certificateAuthorityConfiguration: CertificateAuthorityConfiguration?
        /// Date and time at which your private CA was created.
        public let createdAt: TimeStamp?
        /// Reason the request to create your private CA failed.
        public let failureReason: FailureReason?
        /// Date and time at which your private CA was last updated.
        public let lastStateChangeAt: TimeStamp?
        /// Date and time after which your private CA certificate is not valid.
        public let notAfter: TimeStamp?
        /// Date and time before which your private CA certificate is not valid.
        public let notBefore: TimeStamp?
        /// The period during which a deleted CA can be restored. For more information, see the PermanentDeletionTimeInDays parameter of the DeleteCertificateAuthorityRequest action. 
        public let restorableUntil: TimeStamp?
        /// Information about the certificate revocation list (CRL) created and maintained by your private CA. 
        public let revocationConfiguration: RevocationConfiguration?
        /// Serial number of your private CA.
        public let serial: String?
        /// Status of your private CA.
        public let status: CertificateAuthorityStatus?
        /// Type of your private CA.
        public let `type`: CertificateAuthorityType?

        public init(arn: String? = nil, certificateAuthorityConfiguration: CertificateAuthorityConfiguration? = nil, createdAt: TimeStamp? = nil, failureReason: FailureReason? = nil, lastStateChangeAt: TimeStamp? = nil, notAfter: TimeStamp? = nil, notBefore: TimeStamp? = nil, restorableUntil: TimeStamp? = nil, revocationConfiguration: RevocationConfiguration? = nil, serial: String? = nil, status: CertificateAuthorityStatus? = nil, type: CertificateAuthorityType? = nil) {
            self.arn = arn
            self.certificateAuthorityConfiguration = certificateAuthorityConfiguration
            self.createdAt = createdAt
            self.failureReason = failureReason
            self.lastStateChangeAt = lastStateChangeAt
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.restorableUntil = restorableUntil
            self.revocationConfiguration = revocationConfiguration
            self.serial = serial
            self.status = status
            self.`type` = `type`
        }

        public func validate() throws {
            try validate(arn, name:"arn", max: 200)
            try validate(arn, name:"arn", min: 5)
            try validate(arn, name:"arn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try certificateAuthorityConfiguration?.validate()
            try revocationConfiguration?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
            case createdAt = "CreatedAt"
            case failureReason = "FailureReason"
            case lastStateChangeAt = "LastStateChangeAt"
            case notAfter = "NotAfter"
            case notBefore = "NotBefore"
            case restorableUntil = "RestorableUntil"
            case revocationConfiguration = "RevocationConfiguration"
            case serial = "Serial"
            case status = "Status"
            case `type` = "Type"
        }
    }

    public struct CertificateAuthorityConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KeyAlgorithm", required: true, type: .enum), 
            AWSShapeMember(label: "SigningAlgorithm", required: true, type: .enum), 
            AWSShapeMember(label: "Subject", required: true, type: .structure)
        ]

        /// Type of the public key algorithm and size, in bits, of the key pair that your CA creates when it issues a certificate. When you create a subordinate CA, you must use a key algorithm supported by the parent CA.
        public let keyAlgorithm: KeyAlgorithm
        /// Name of the algorithm your private CA uses to sign certificate requests.
        public let signingAlgorithm: SigningAlgorithm
        /// Structure that contains X.500 distinguished name information for your private CA.
        public let subject: ASN1Subject

        public init(keyAlgorithm: KeyAlgorithm, signingAlgorithm: SigningAlgorithm, subject: ASN1Subject) {
            self.keyAlgorithm = keyAlgorithm
            self.signingAlgorithm = signingAlgorithm
            self.subject = subject
        }

        public func validate() throws {
            try subject.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case keyAlgorithm = "KeyAlgorithm"
            case signingAlgorithm = "SigningAlgorithm"
            case subject = "Subject"
        }
    }

    public enum CertificateAuthorityStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case pendingCertificate = "PENDING_CERTIFICATE"
        case active = "ACTIVE"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case expired = "EXPIRED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum CertificateAuthorityType: String, CustomStringConvertible, Codable {
        case root = "ROOT"
        case subordinate = "SUBORDINATE"
        public var description: String { return self.rawValue }
    }

    public struct CreateCertificateAuthorityAuditReportRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuditReportResponseFormat", required: true, type: .enum), 
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "S3BucketName", required: true, type: .string)
        ]

        /// The format in which to create the report. This can be either JSON or CSV.
        public let auditReportResponseFormat: AuditReportResponseFormat
        /// The Amazon Resource Name (ARN) of the CA to be audited. This is of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 .
        public let certificateAuthorityArn: String
        /// The name of the S3 bucket that will contain the audit report.
        public let s3BucketName: String

        public init(auditReportResponseFormat: AuditReportResponseFormat, certificateAuthorityArn: String, s3BucketName: String) {
            self.auditReportResponseFormat = auditReportResponseFormat
            self.certificateAuthorityArn = certificateAuthorityArn
            self.s3BucketName = s3BucketName
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case auditReportResponseFormat = "AuditReportResponseFormat"
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case s3BucketName = "S3BucketName"
        }
    }

    public struct CreateCertificateAuthorityAuditReportResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuditReportId", required: false, type: .string), 
            AWSShapeMember(label: "S3Key", required: false, type: .string)
        ]

        /// An alphanumeric string that contains a report identifier.
        public let auditReportId: String?
        /// The key that uniquely identifies the report file in your S3 bucket.
        public let s3Key: String?

        public init(auditReportId: String? = nil, s3Key: String? = nil) {
            self.auditReportId = auditReportId
            self.s3Key = s3Key
        }

        public func validate() throws {
            try validate(auditReportId, name:"auditReportId", max: 36)
            try validate(auditReportId, name:"auditReportId", min: 36)
            try validate(auditReportId, name:"auditReportId", pattern: "[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case auditReportId = "AuditReportId"
            case s3Key = "S3Key"
        }
    }

    public struct CreateCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "CertificateAuthorityType", required: true, type: .enum), 
            AWSShapeMember(label: "IdempotencyToken", required: false, type: .string), 
            AWSShapeMember(label: "RevocationConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// Name and bit size of the private key algorithm, the name of the signing algorithm, and X.500 certificate subject information.
        public let certificateAuthorityConfiguration: CertificateAuthorityConfiguration
        /// The type of the certificate authority.
        public let certificateAuthorityType: CertificateAuthorityType
        /// Alphanumeric string that can be used to distinguish between calls to CreateCertificateAuthority. Idempotency tokens time out after five minutes. Therefore, if you call CreateCertificateAuthority multiple times with the same idempotency token within a five minute period, ACM Private CA recognizes that you are requesting only one certificate. As a result, ACM Private CA issues only one. If you change the idempotency token for each call, however, ACM Private CA recognizes that you are requesting multiple certificates.
        public let idempotencyToken: String?
        /// Contains a Boolean value that you can use to enable a certification revocation list (CRL) for the CA, the name of the S3 bucket to which ACM Private CA will write the CRL, and an optional CNAME alias that you can use to hide the name of your bucket in the CRL Distribution Points extension of your CA certificate. For more information, see the CrlConfiguration structure. 
        public let revocationConfiguration: RevocationConfiguration?
        /// Key-value pairs that will be attached to the new private CA. You can associate up to 50 tags with a private CA. For information using tags with  IAM to manage permissions, see Controlling Access Using IAM Tags.
        public let tags: [Tag]?

        public init(certificateAuthorityConfiguration: CertificateAuthorityConfiguration, certificateAuthorityType: CertificateAuthorityType, idempotencyToken: String? = nil, revocationConfiguration: RevocationConfiguration? = nil, tags: [Tag]? = nil) {
            self.certificateAuthorityConfiguration = certificateAuthorityConfiguration
            self.certificateAuthorityType = certificateAuthorityType
            self.idempotencyToken = idempotencyToken
            self.revocationConfiguration = revocationConfiguration
            self.tags = tags
        }

        public func validate() throws {
            try certificateAuthorityConfiguration.validate()
            try validate(idempotencyToken, name:"idempotencyToken", max: 36)
            try validate(idempotencyToken, name:"idempotencyToken", min: 1)
            try validate(idempotencyToken, name:"idempotencyToken", pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u00FF]*")
            try revocationConfiguration?.validate()
            try tags?.forEach {
                try $0.validate()
            }
            try validate(tags, name:"tags", max: 50)
            try validate(tags, name:"tags", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
            case certificateAuthorityType = "CertificateAuthorityType"
            case idempotencyToken = "IdempotencyToken"
            case revocationConfiguration = "RevocationConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateCertificateAuthorityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: false, type: .string)
        ]

        /// If successful, the Amazon Resource Name (ARN) of the certificate authority (CA). This is of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String?

        public init(certificateAuthorityArn: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct CreatePermissionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: true, type: .list), 
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "Principal", required: true, type: .string), 
            AWSShapeMember(label: "SourceAccount", required: false, type: .string)
        ]

        /// The actions that the specified AWS service principal can use. These include IssueCertificate, GetCertificate, and ListPermissions.
        public let actions: [ActionType]
        /// The Amazon Resource Name (ARN) of the CA that grants the permissions. You can find the ARN by calling the ListCertificateAuthorities action. This must have the following form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String
        /// The AWS service or identity that receives the permission. At this time, the only valid principal is acm.amazonaws.com.
        public let principal: String
        /// The ID of the calling account.
        public let sourceAccount: String?

        public init(actions: [ActionType], certificateAuthorityArn: String, principal: String, sourceAccount: String? = nil) {
            self.actions = actions
            self.certificateAuthorityArn = certificateAuthorityArn
            self.principal = principal
            self.sourceAccount = sourceAccount
        }

        public func validate() throws {
            try validate(actions, name:"actions", max: 3)
            try validate(actions, name:"actions", min: 1)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(principal, name:"principal", max: 128)
            try validate(principal, name:"principal", min: 0)
            try validate(principal, name:"principal", pattern: "^[^*]+$")
            try validate(sourceAccount, name:"sourceAccount", max: 12)
            try validate(sourceAccount, name:"sourceAccount", min: 12)
            try validate(sourceAccount, name:"sourceAccount", pattern: "[0-9]+")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case principal = "Principal"
            case sourceAccount = "SourceAccount"
        }
    }

    public struct CrlConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CustomCname", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: true, type: .boolean), 
            AWSShapeMember(label: "ExpirationInDays", required: false, type: .integer), 
            AWSShapeMember(label: "S3BucketName", required: false, type: .string)
        ]

        /// Name inserted into the certificate CRL Distribution Points extension that enables the use of an alias for the CRL distribution point. Use this value if you don't want the name of your S3 bucket to be public.
        public let customCname: String?
        /// Boolean value that specifies whether certificate revocation lists (CRLs) are enabled. You can use this value to enable certificate revocation for a new CA when you call the CreateCertificateAuthority action or for an existing CA when you call the UpdateCertificateAuthority action. 
        public let enabled: Bool
        /// Number of days until a certificate expires.
        public let expirationInDays: Int32?
        /// Name of the S3 bucket that contains the CRL. If you do not provide a value for the CustomCname argument, the name of your S3 bucket is placed into the CRL Distribution Points extension of the issued certificate. You can change the name of your bucket by calling the UpdateCertificateAuthority action. You must specify a bucket policy that allows ACM Private CA to write the CRL to your bucket.
        public let s3BucketName: String?

        public init(customCname: String? = nil, enabled: Bool, expirationInDays: Int32? = nil, s3BucketName: String? = nil) {
            self.customCname = customCname
            self.enabled = enabled
            self.expirationInDays = expirationInDays
            self.s3BucketName = s3BucketName
        }

        public func validate() throws {
            try validate(customCname, name:"customCname", max: 253)
            try validate(customCname, name:"customCname", min: 0)
            try validate(expirationInDays, name:"expirationInDays", max: 5000)
            try validate(expirationInDays, name:"expirationInDays", min: 1)
            try validate(s3BucketName, name:"s3BucketName", max: 255)
            try validate(s3BucketName, name:"s3BucketName", min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case customCname = "CustomCname"
            case enabled = "Enabled"
            case expirationInDays = "ExpirationInDays"
            case s3BucketName = "S3BucketName"
        }
    }

    public struct DeleteCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "PermanentDeletionTimeInDays", required: false, type: .integer)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must have the following form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String
        /// The number of days to make a CA restorable after it has been deleted. This can be anywhere from 7 to 30 days, with 30 being the default.
        public let permanentDeletionTimeInDays: Int32?

        public init(certificateAuthorityArn: String, permanentDeletionTimeInDays: Int32? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.permanentDeletionTimeInDays = permanentDeletionTimeInDays
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(permanentDeletionTimeInDays, name:"permanentDeletionTimeInDays", max: 30)
            try validate(permanentDeletionTimeInDays, name:"permanentDeletionTimeInDays", min: 7)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case permanentDeletionTimeInDays = "PermanentDeletionTimeInDays"
        }
    }

    public struct DeletePermissionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "Principal", required: true, type: .string), 
            AWSShapeMember(label: "SourceAccount", required: false, type: .string)
        ]

        /// The Amazon Resource Number (ARN) of the private CA that issued the permissions. You can find the CA's ARN by calling the ListCertificateAuthorities action. This must have the following form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String
        /// The AWS service or identity that will have its CA permissions revoked. At this time, the only valid service principal is acm.amazonaws.com 
        public let principal: String
        /// The AWS account that calls this action.
        public let sourceAccount: String?

        public init(certificateAuthorityArn: String, principal: String, sourceAccount: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.principal = principal
            self.sourceAccount = sourceAccount
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(principal, name:"principal", max: 128)
            try validate(principal, name:"principal", min: 0)
            try validate(principal, name:"principal", pattern: "^[^*]+$")
            try validate(sourceAccount, name:"sourceAccount", max: 12)
            try validate(sourceAccount, name:"sourceAccount", min: 12)
            try validate(sourceAccount, name:"sourceAccount", pattern: "[0-9]+")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case principal = "Principal"
            case sourceAccount = "SourceAccount"
        }
    }

    public struct DescribeCertificateAuthorityAuditReportRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuditReportId", required: true, type: .string), 
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string)
        ]

        /// The report ID returned by calling the CreateCertificateAuthorityAuditReport action.
        public let auditReportId: String
        /// The Amazon Resource Name (ARN) of the private CA. This must be of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String

        public init(auditReportId: String, certificateAuthorityArn: String) {
            self.auditReportId = auditReportId
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(auditReportId, name:"auditReportId", max: 36)
            try validate(auditReportId, name:"auditReportId", min: 36)
            try validate(auditReportId, name:"auditReportId", pattern: "[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}")
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case auditReportId = "AuditReportId"
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct DescribeCertificateAuthorityAuditReportResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuditReportStatus", required: false, type: .enum), 
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "S3BucketName", required: false, type: .string), 
            AWSShapeMember(label: "S3Key", required: false, type: .string)
        ]

        /// Specifies whether report creation is in progress, has succeeded, or has failed.
        public let auditReportStatus: AuditReportStatus?
        /// The date and time at which the report was created.
        public let createdAt: TimeStamp?
        /// Name of the S3 bucket that contains the report.
        public let s3BucketName: String?
        /// S3 key that uniquely identifies the report file in your S3 bucket.
        public let s3Key: String?

        public init(auditReportStatus: AuditReportStatus? = nil, createdAt: TimeStamp? = nil, s3BucketName: String? = nil, s3Key: String? = nil) {
            self.auditReportStatus = auditReportStatus
            self.createdAt = createdAt
            self.s3BucketName = s3BucketName
            self.s3Key = s3Key
        }

        private enum CodingKeys: String, CodingKey {
            case auditReportStatus = "AuditReportStatus"
            case createdAt = "CreatedAt"
            case s3BucketName = "S3BucketName"
            case s3Key = "S3Key"
        }
    }

    public struct DescribeCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String

        public init(certificateAuthorityArn: String) {
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct DescribeCertificateAuthorityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthority", required: false, type: .structure)
        ]

        /// A CertificateAuthority structure that contains information about your private CA.
        public let certificateAuthority: CertificateAuthority?

        public init(certificateAuthority: CertificateAuthority? = nil) {
            self.certificateAuthority = certificateAuthority
        }

        public func validate() throws {
            try certificateAuthority?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthority = "CertificateAuthority"
        }
    }

    public enum FailureReason: String, CustomStringConvertible, Codable {
        case requestTimedOut = "REQUEST_TIMED_OUT"
        case unsupportedAlgorithm = "UNSUPPORTED_ALGORITHM"
        case other = "OTHER"
        public var description: String { return self.rawValue }
    }

    public struct GetCertificateAuthorityCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of your private CA. This is of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String

        public init(certificateAuthorityArn: String) {
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct GetCertificateAuthorityCertificateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "CertificateChain", required: false, type: .string)
        ]

        /// Base64-encoded certificate authority (CA) certificate.
        public let certificate: String?
        /// Base64-encoded certificate chain that includes any intermediate certificates and chains up to root on-premises certificate that you used to sign your private CA certificate. The chain does not include your private CA certificate. If this is a root CA, the value will be null.
        public let certificateChain: String?

        public init(certificate: String? = nil, certificateChain: String? = nil) {
            self.certificate = certificate
            self.certificateChain = certificateChain
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
            case certificateChain = "CertificateChain"
        }
    }

    public struct GetCertificateAuthorityCsrRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called the CreateCertificateAuthority action. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String

        public init(certificateAuthorityArn: String) {
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct GetCertificateAuthorityCsrResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Csr", required: false, type: .string)
        ]

        /// The base64 PEM-encoded certificate signing request (CSR) for your private CA certificate.
        public let csr: String?

        public init(csr: String? = nil) {
            self.csr = csr
        }

        private enum CodingKeys: String, CodingKey {
            case csr = "Csr"
        }
    }

    public struct GetCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: true, type: .string), 
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string)
        ]

        /// The ARN of the issued certificate. The ARN contains the certificate serial number and must be in the following form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012/certificate/286535153982981100925020015808220737245  
        public let certificateArn: String
        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 . 
        public let certificateAuthorityArn: String

        public init(certificateArn: String, certificateAuthorityArn: String) {
            self.certificateArn = certificateArn
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(certificateArn, name:"certificateArn", max: 200)
            try validate(certificateArn, name:"certificateArn", min: 5)
            try validate(certificateArn, name:"certificateArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct GetCertificateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "CertificateChain", required: false, type: .string)
        ]

        /// The base64 PEM-encoded certificate specified by the CertificateArn parameter.
        public let certificate: String?
        /// The base64 PEM-encoded certificate chain that chains up to the on-premises root CA certificate that you used to sign your private CA certificate. 
        public let certificateChain: String?

        public init(certificate: String? = nil, certificateChain: String? = nil) {
            self.certificate = certificate
            self.certificateChain = certificateChain
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
            case certificateChain = "CertificateChain"
        }
    }

    public struct ImportCertificateAuthorityCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: true, type: .blob), 
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "CertificateChain", required: false, type: .blob)
        ]

        /// The PEM-encoded certificate for a private CA. This may be a self-signed certificate in the case of a root CA, or it may be signed by another CA that you control.
        public let certificate: Data
        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// A PEM-encoded file that contains all of your certificates, other than the certificate you're importing, chaining up to your root CA. Your ACM Private CA-hosted or on-premises root certificate is the last in the chain, and each certificate in the chain signs the one preceding.  This parameter must be supplied when you import a subordinate CA. When you import a root CA, there is no chain.
        public let certificateChain: Data?

        public init(certificate: Data, certificateAuthorityArn: String, certificateChain: Data? = nil) {
            self.certificate = certificate
            self.certificateAuthorityArn = certificateAuthorityArn
            self.certificateChain = certificateChain
        }

        public func validate() throws {
            try validate(certificate, name:"certificate", max: 32768)
            try validate(certificate, name:"certificate", min: 1)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(certificateChain, name:"certificateChain", max: 2097152)
            try validate(certificateChain, name:"certificateChain", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case certificateChain = "CertificateChain"
        }
    }

    public struct IssueCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "Csr", required: true, type: .blob), 
            AWSShapeMember(label: "IdempotencyToken", required: false, type: .string), 
            AWSShapeMember(label: "SigningAlgorithm", required: true, type: .enum), 
            AWSShapeMember(label: "TemplateArn", required: false, type: .string), 
            AWSShapeMember(label: "Validity", required: true, type: .structure)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must be of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// The certificate signing request (CSR) for the certificate you want to issue. You can use the following OpenSSL command to create the CSR and a 2048 bit RSA private key.   openssl req -new -newkey rsa:2048 -days 365 -keyout private/test_cert_priv_key.pem -out csr/test_cert_.csr  If you have a configuration file, you can use the following OpenSSL command. The usr_cert block in the configuration file contains your X509 version 3 extensions.   openssl req -new -config openssl_rsa.cnf -extensions usr_cert -newkey rsa:2048 -days -365 -keyout private/test_cert_priv_key.pem -out csr/test_cert_.csr 
        public let csr: Data
        /// Custom string that can be used to distinguish between calls to the IssueCertificate action. Idempotency tokens time out after one hour. Therefore, if you call IssueCertificate multiple times with the same idempotency token within 5 minutes, ACM Private CA recognizes that you are requesting only one certificate and will issue only one. If you change the idempotency token for each call, PCA recognizes that you are requesting multiple certificates.
        public let idempotencyToken: String?
        /// The name of the algorithm that will be used to sign the certificate to be issued.
        public let signingAlgorithm: SigningAlgorithm
        /// Specifies a custom configuration template to use when issuing a certificate. If this parameter is not provided, ACM Private CA defaults to the EndEntityCertificate/V1 template. The following service-owned TemplateArn values are supported by ACM Private CA:    arn:aws:acm-pca:::template/EndEntityCertificate/V1   arn:aws:acm-pca:::template/SubordinateCACertificate_PathLen0/V1   arn:aws:acm-pca:::template/SubordinateCACertificate_PathLen1/V1   arn:aws:acm-pca:::template/SubordinateCACertificate_PathLen2/V1   arn:aws:acm-pca:::template/SubordinateCACertificate_PathLen3/V1   arn:aws:acm-pca:::template/RootCACertificate/V1   For more information, see Using Templates.
        public let templateArn: String?
        /// The type of the validity period.
        public let validity: Validity

        public init(certificateAuthorityArn: String, csr: Data, idempotencyToken: String? = nil, signingAlgorithm: SigningAlgorithm, templateArn: String? = nil, validity: Validity) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.csr = csr
            self.idempotencyToken = idempotencyToken
            self.signingAlgorithm = signingAlgorithm
            self.templateArn = templateArn
            self.validity = validity
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(csr, name:"csr", max: 32768)
            try validate(csr, name:"csr", min: 1)
            try validate(idempotencyToken, name:"idempotencyToken", max: 36)
            try validate(idempotencyToken, name:"idempotencyToken", min: 1)
            try validate(idempotencyToken, name:"idempotencyToken", pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u00FF]*")
            try validate(templateArn, name:"templateArn", max: 200)
            try validate(templateArn, name:"templateArn", min: 5)
            try validate(templateArn, name:"templateArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validity.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case csr = "Csr"
            case idempotencyToken = "IdempotencyToken"
            case signingAlgorithm = "SigningAlgorithm"
            case templateArn = "TemplateArn"
            case validity = "Validity"
        }
    }

    public struct IssueCertificateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the issued certificate and the certificate serial number. This is of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012/certificate/286535153982981100925020015808220737245  
        public let certificateArn: String?

        public init(certificateArn: String? = nil) {
            self.certificateArn = certificateArn
        }

        public func validate() throws {
            try validate(certificateArn, name:"certificateArn", max: 200)
            try validate(certificateArn, name:"certificateArn", min: 5)
            try validate(certificateArn, name:"certificateArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
        }
    }

    public enum KeyAlgorithm: String, CustomStringConvertible, Codable {
        case rsa2048 = "RSA_2048"
        case rsa4096 = "RSA_4096"
        case ecPrime256V1 = "EC_prime256v1"
        case ecSecp384R1 = "EC_secp384r1"
        public var description: String { return self.rawValue }
    }

    public struct ListCertificateAuthoritiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Use this parameter when paginating results to specify the maximum number of items to return in the response on each page. If additional items exist beyond the number you specify, the NextToken element is sent in the response. Use this NextToken value in a subsequent request to retrieve additional items.
        public let maxResults: Int32?
        /// Use this parameter when paginating results in a subsequent request after you receive a response with truncated results. Set it to the value of the NextToken parameter from the response you just received.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 500)
            try validate(nextToken, name:"nextToken", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCertificateAuthoritiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorities", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Summary information about each certificate authority you have created.
        public let certificateAuthorities: [CertificateAuthority]?
        /// When the list is truncated, this value is present and should be used for the NextToken parameter in a subsequent pagination request.
        public let nextToken: String?

        public init(certificateAuthorities: [CertificateAuthority]? = nil, nextToken: String? = nil) {
            self.certificateAuthorities = certificateAuthorities
            self.nextToken = nextToken
        }

        public func validate() throws {
            try certificateAuthorities?.forEach {
                try $0.validate()
            }
            try validate(nextToken, name:"nextToken", max: 500)
            try validate(nextToken, name:"nextToken", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorities = "CertificateAuthorities"
            case nextToken = "NextToken"
        }
    }

    public struct ListPermissionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Number (ARN) of the private CA to inspect. You can find the ARN by calling the ListCertificateAuthorities action. This must be of the form: arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012 You can get a private CA's ARN by running the ListCertificateAuthorities action.
        public let certificateAuthorityArn: String
        /// When paginating results, use this parameter to specify the maximum number of items to return in the response. If additional items exist beyond the number you specify, the NextToken element is sent in the response. Use this NextToken value in a subsequent request to retrieve additional items.
        public let maxResults: Int32?
        /// When paginating results, use this parameter in a subsequent request after you receive a response with truncated results. Set it to the value of NextToken from the response you just received.
        public let nextToken: String?

        public init(certificateAuthorityArn: String, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 500)
            try validate(nextToken, name:"nextToken", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPermissionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Permissions", required: false, type: .list)
        ]

        /// When the list is truncated, this value is present and should be used for the NextToken parameter in a subsequent pagination request. 
        public let nextToken: String?
        /// Summary information about each permission assigned by the specified private CA, including the action enabled, the policy provided, and the time of creation.
        public let permissions: [Permission]?

        public init(nextToken: String? = nil, permissions: [Permission]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        public func validate() throws {
            try validate(nextToken, name:"nextToken", max: 500)
            try validate(nextToken, name:"nextToken", min: 1)
            try permissions?.forEach {
                try $0.validate()
            }
            try validate(permissions, name:"permissions", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case permissions = "Permissions"
        }
    }

    public struct ListTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called the CreateCertificateAuthority action. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// Use this parameter when paginating results to specify the maximum number of items to return in the response. If additional items exist beyond the number you specify, the NextToken element is sent in the response. Use this NextToken value in a subsequent request to retrieve additional items.
        public let maxResults: Int32?
        /// Use this parameter when paginating results in a subsequent request after you receive a response with truncated results. Set it to the value of NextToken from the response you just received.
        public let nextToken: String?

        public init(certificateAuthorityArn: String, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(nextToken, name:"nextToken", max: 500)
            try validate(nextToken, name:"nextToken", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// When the list is truncated, this value is present and should be used for the NextToken parameter in a subsequent pagination request. 
        public let nextToken: String?
        /// The tags associated with your private CA.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate() throws {
            try validate(nextToken, name:"nextToken", max: 500)
            try validate(nextToken, name:"nextToken", min: 1)
            try tags?.forEach {
                try $0.validate()
            }
            try validate(tags, name:"tags", max: 50)
            try validate(tags, name:"tags", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct Permission: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: false, type: .list), 
            AWSShapeMember(label: "CertificateAuthorityArn", required: false, type: .string), 
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "Policy", required: false, type: .string), 
            AWSShapeMember(label: "Principal", required: false, type: .string), 
            AWSShapeMember(label: "SourceAccount", required: false, type: .string)
        ]

        /// The private CA actions that can be performed by the designated AWS service.
        public let actions: [ActionType]?
        /// The Amazon Resource Number (ARN) of the private CA from which the permission was issued.
        public let certificateAuthorityArn: String?
        /// The time at which the permission was created.
        public let createdAt: TimeStamp?
        /// The name of the policy that is associated with the permission.
        public let policy: String?
        /// The AWS service or entity that holds the permission. At this time, the only valid principal is acm.amazonaws.com.
        public let principal: String?
        /// The ID of the account that assigned the permission.
        public let sourceAccount: String?

        public init(actions: [ActionType]? = nil, certificateAuthorityArn: String? = nil, createdAt: TimeStamp? = nil, policy: String? = nil, principal: String? = nil, sourceAccount: String? = nil) {
            self.actions = actions
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.policy = policy
            self.principal = principal
            self.sourceAccount = sourceAccount
        }

        public func validate() throws {
            try validate(actions, name:"actions", max: 3)
            try validate(actions, name:"actions", min: 1)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case createdAt = "CreatedAt"
            case policy = "Policy"
            case principal = "Principal"
            case sourceAccount = "SourceAccount"
        }
    }

    public struct RestoreCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called the CreateCertificateAuthority action. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String

        public init(certificateAuthorityArn: String) {
            self.certificateAuthorityArn = certificateAuthorityArn
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
        }
    }

    public struct RevocationConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrlConfiguration", required: false, type: .structure)
        ]

        /// Configuration of the certificate revocation list (CRL), if any, maintained by your private CA.
        public let crlConfiguration: CrlConfiguration?

        public init(crlConfiguration: CrlConfiguration? = nil) {
            self.crlConfiguration = crlConfiguration
        }

        public func validate() throws {
            try crlConfiguration?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case crlConfiguration = "CrlConfiguration"
        }
    }

    public enum RevocationReason: String, CustomStringConvertible, Codable {
        case unspecified = "UNSPECIFIED"
        case keyCompromise = "KEY_COMPROMISE"
        case certificateAuthorityCompromise = "CERTIFICATE_AUTHORITY_COMPROMISE"
        case affiliationChanged = "AFFILIATION_CHANGED"
        case superseded = "SUPERSEDED"
        case cessationOfOperation = "CESSATION_OF_OPERATION"
        case privilegeWithdrawn = "PRIVILEGE_WITHDRAWN"
        case aACompromise = "A_A_COMPROMISE"
        public var description: String { return self.rawValue }
    }

    public struct RevokeCertificateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "CertificateSerial", required: true, type: .string), 
            AWSShapeMember(label: "RevocationReason", required: true, type: .enum)
        ]

        /// Amazon Resource Name (ARN) of the private CA that issued the certificate to be revoked. This must be of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// Serial number of the certificate to be revoked. This must be in hexadecimal format. You can retrieve the serial number by calling GetCertificate with the Amazon Resource Name (ARN) of the certificate you want and the ARN of your private CA. The GetCertificate action retrieves the certificate in the PEM format. You can use the following OpenSSL command to list the certificate in text format and copy the hexadecimal serial number.   openssl x509 -in file_path -text -noout  You can also copy the serial number from the console or use the DescribeCertificate action in the AWS Certificate Manager API Reference. 
        public let certificateSerial: String
        /// Specifies why you revoked the certificate.
        public let revocationReason: RevocationReason

        public init(certificateAuthorityArn: String, certificateSerial: String, revocationReason: RevocationReason) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.certificateSerial = certificateSerial
            self.revocationReason = revocationReason
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try validate(certificateSerial, name:"certificateSerial", max: 128)
            try validate(certificateSerial, name:"certificateSerial", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case certificateSerial = "CertificateSerial"
            case revocationReason = "RevocationReason"
        }
    }

    public enum SigningAlgorithm: String, CustomStringConvertible, Codable {
        case sha256withecdsa = "SHA256WITHECDSA"
        case sha384withecdsa = "SHA384WITHECDSA"
        case sha512withecdsa = "SHA512WITHECDSA"
        case sha256withrsa = "SHA256WITHRSA"
        case sha384withrsa = "SHA384WITHRSA"
        case sha512withrsa = "SHA512WITHRSA"
        public var description: String { return self.rawValue }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// Key (name) of the tag.
        public let key: String
        /// Value of the tag.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate() throws {
            try validate(key, name:"key", max: 128)
            try validate(key, name:"key", min: 1)
            try validate(key, name:"key", pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try validate(value, name:"value", max: 256)
            try validate(value, name:"value", min: 0)
            try validate(value, name:"value", pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// List of tags to be associated with the CA.
        public let tags: [Tag]

        public init(certificateAuthorityArn: String, tags: [Tag]) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.tags = tags
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try tags.forEach {
                try $0.validate()
            }
            try validate(tags, name:"tags", max: 50)
            try validate(tags, name:"tags", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case tags = "Tags"
        }
    }

    public struct UntagCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) that was returned when you called CreateCertificateAuthority. This must be of the form:   arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// List of tags to be removed from the CA.
        public let tags: [Tag]

        public init(certificateAuthorityArn: String, tags: [Tag]) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.tags = tags
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try tags.forEach {
                try $0.validate()
            }
            try validate(tags, name:"tags", max: 50)
            try validate(tags, name:"tags", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case tags = "Tags"
        }
    }

    public struct UpdateCertificateAuthorityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateAuthorityArn", required: true, type: .string), 
            AWSShapeMember(label: "RevocationConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// Amazon Resource Name (ARN) of the private CA that issued the certificate to be revoked. This must be of the form:  arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012  
        public let certificateAuthorityArn: String
        /// Revocation information for your private CA.
        public let revocationConfiguration: RevocationConfiguration?
        /// Status of your private CA.
        public let status: CertificateAuthorityStatus?

        public init(certificateAuthorityArn: String, revocationConfiguration: RevocationConfiguration? = nil, status: CertificateAuthorityStatus? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.revocationConfiguration = revocationConfiguration
            self.status = status
        }

        public func validate() throws {
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", max: 200)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", min: 5)
            try validate(certificateAuthorityArn, name:"certificateAuthorityArn", pattern: "arn:[\\w+=/,.@-]+:[\\w+=/,.@-]+:[\\w+=/,.@-]*:[0-9]*:[\\w+=,.@-]+(/[\\w+=/,.@-]+)*")
            try revocationConfiguration?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case revocationConfiguration = "RevocationConfiguration"
            case status = "Status"
        }
    }

    public struct Validity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "Value", required: true, type: .long)
        ]

        /// Specifies whether the Value parameter represents days, months, or years.
        public let `type`: ValidityPeriodType
        /// Time period.
        public let value: Int64

        public init(type: ValidityPeriodType, value: Int64) {
            self.`type` = `type`
            self.value = value
        }

        public func validate() throws {
            try validate(value, name:"value", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case value = "Value"
        }
    }

    public enum ValidityPeriodType: String, CustomStringConvertible, Codable {
        case endDate = "END_DATE"
        case absolute = "ABSOLUTE"
        case days = "DAYS"
        case months = "MONTHS"
        case years = "YEARS"
        public var description: String { return self.rawValue }
    }
}
