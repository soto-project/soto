// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Glue {

    public struct Action: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "CrawlerName", required: false, type: .string), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "NotificationProperty", required: false, type: .structure), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer)
        ]

        /// The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The name of the crawler to be used with this action.
        public let crawlerName: String?
        /// The name of a job to be executed.
        public let jobName: String?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The name of the SecurityConfiguration structure to be used with this action.
        public let securityConfiguration: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public let timeout: Int32?

        public init(arguments: [String: String]? = nil, crawlerName: String? = nil, jobName: String? = nil, notificationProperty: NotificationProperty? = nil, securityConfiguration: String? = nil, timeout: Int32? = nil) {
            self.arguments = arguments
            self.crawlerName = crawlerName
            self.jobName = jobName
            self.notificationProperty = notificationProperty
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
        }

        public func validate() throws {
            try validate(crawlerName, name:"crawlerName", max: 255)
            try validate(crawlerName, name:"crawlerName", min: 1)
            try validate(crawlerName, name:"crawlerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try notificationProperty?.validate()
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(timeout, name:"timeout", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case crawlerName = "CrawlerName"
            case jobName = "JobName"
            case notificationProperty = "NotificationProperty"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
        }
    }

    public struct BatchCreatePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionInputList", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String
        /// A list of PartitionInput structures that define the partitions to be created.
        public let partitionInputList: [PartitionInput]
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionInputList: [PartitionInput], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInputList = partitionInputList
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionInputList.forEach {
                try $0.validate()
            }
            try validate(partitionInputList, name:"partitionInputList", max: 100)
            try validate(partitionInputList, name:"partitionInputList", min: 0)
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInputList = "PartitionInputList"
            case tableName = "TableName"
        }
    }

    public struct BatchCreatePartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]

        /// Errors encountered when trying to create the requested partitions.
        public let errors: [PartitionError]?

        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        public func validate() throws {
            try errors?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionNameList", required: true, type: .list)
        ]

        /// The ID of the Data Catalog in which the connections reside. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// A list of names of the connections to delete.
        public let connectionNameList: [String]

        public init(catalogId: String? = nil, connectionNameList: [String]) {
            self.catalogId = catalogId
            self.connectionNameList = connectionNameList
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try connectionNameList.forEach {
                try validate($0, name:"connectionNameList[]", max: 255)
                try validate($0, name:"connectionNameList[]", min: 1)
                try validate($0, name:"connectionNameList[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(connectionNameList, name:"connectionNameList", max: 25)
            try validate(connectionNameList, name:"connectionNameList", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionNameList = "ConnectionNameList"
        }
    }

    public struct BatchDeleteConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .map), 
            AWSShapeMember(label: "Succeeded", required: false, type: .list)
        ]

        /// A map of the names of connections that were not successfully deleted to error details.
        public let errors: [String: ErrorDetail]?
        /// A list of names of the connection definitions that were successfully deleted.
        public let succeeded: [String]?

        public init(errors: [String: ErrorDetail]? = nil, succeeded: [String]? = nil) {
            self.errors = errors
            self.succeeded = succeeded
        }

        public func validate() throws {
            try succeeded?.forEach {
                try validate($0, name:"succeeded[]", max: 255)
                try validate($0, name:"succeeded[]", min: 1)
                try validate($0, name:"succeeded[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case succeeded = "Succeeded"
        }
    }

    public struct BatchDeletePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionsToDelete", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// A list of PartitionInput structures that define the partitions to be deleted.
        public let partitionsToDelete: [PartitionValueList]
        /// The name of the table where the partitions to be deleted is located.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionsToDelete: [PartitionValueList], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionsToDelete = partitionsToDelete
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionsToDelete.forEach {
                try $0.validate()
            }
            try validate(partitionsToDelete, name:"partitionsToDelete", max: 25)
            try validate(partitionsToDelete, name:"partitionsToDelete", min: 0)
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionsToDelete = "PartitionsToDelete"
            case tableName = "TableName"
        }
    }

    public struct BatchDeletePartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]

        /// Errors encountered when trying to delete the requested partitions.
        public let errors: [PartitionError]?

        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        public func validate() throws {
            try errors?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TablesToDelete", required: true, type: .list)
        ]

        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the tables to delete reside. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A list of the table to delete.
        public let tablesToDelete: [String]

        public init(catalogId: String? = nil, databaseName: String, tablesToDelete: [String]) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tablesToDelete = tablesToDelete
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try tablesToDelete.forEach {
                try validate($0, name:"tablesToDelete[]", max: 255)
                try validate($0, name:"tablesToDelete[]", min: 1)
                try validate($0, name:"tablesToDelete[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(tablesToDelete, name:"tablesToDelete", max: 100)
            try validate(tablesToDelete, name:"tablesToDelete", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tablesToDelete = "TablesToDelete"
        }
    }

    public struct BatchDeleteTableResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]

        /// A list of errors encountered in attempting to delete the specified tables.
        public let errors: [TableError]?

        public init(errors: [TableError]? = nil) {
            self.errors = errors
        }

        public func validate() throws {
            try errors?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteTableVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "VersionIds", required: true, type: .list)
        ]

        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// A list of the IDs of versions to be deleted. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public let versionIds: [String]

        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionIds: [String]) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionIds = versionIds
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try versionIds.forEach {
                try validate($0, name:"versionIds[]", max: 255)
                try validate($0, name:"versionIds[]", min: 1)
                try validate($0, name:"versionIds[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(versionIds, name:"versionIds", max: 100)
            try validate(versionIds, name:"versionIds", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionIds = "VersionIds"
        }
    }

    public struct BatchDeleteTableVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]

        /// A list of errors encountered while trying to delete the specified table versions.
        public let errors: [TableVersionError]?

        public init(errors: [TableVersionError]? = nil) {
            self.errors = errors
        }

        public func validate() throws {
            try errors?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetCrawlersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerNames", required: true, type: .list)
        ]

        /// A list of crawler names, which might be the names returned from the ListCrawlers operation.
        public let crawlerNames: [String]

        public init(crawlerNames: [String]) {
            self.crawlerNames = crawlerNames
        }

        public func validate() throws {
            try crawlerNames.forEach {
                try validate($0, name:"crawlerNames[]", max: 255)
                try validate($0, name:"crawlerNames[]", min: 1)
                try validate($0, name:"crawlerNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlerNames, name:"crawlerNames", max: 100)
            try validate(crawlerNames, name:"crawlerNames", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNames = "CrawlerNames"
        }
    }

    public struct BatchGetCrawlersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Crawlers", required: false, type: .list), 
            AWSShapeMember(label: "CrawlersNotFound", required: false, type: .list)
        ]

        /// A list of crawler definitions.
        public let crawlers: [Crawler]?
        /// A list of names of crawlers that were not found.
        public let crawlersNotFound: [String]?

        public init(crawlers: [Crawler]? = nil, crawlersNotFound: [String]? = nil) {
            self.crawlers = crawlers
            self.crawlersNotFound = crawlersNotFound
        }

        public func validate() throws {
            try crawlers?.forEach {
                try $0.validate()
            }
            try crawlersNotFound?.forEach {
                try validate($0, name:"crawlersNotFound[]", max: 255)
                try validate($0, name:"crawlersNotFound[]", min: 1)
                try validate($0, name:"crawlersNotFound[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlersNotFound, name:"crawlersNotFound", max: 100)
            try validate(crawlersNotFound, name:"crawlersNotFound", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case crawlersNotFound = "CrawlersNotFound"
        }
    }

    public struct BatchGetDevEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DevEndpointNames", required: true, type: .list)
        ]

        /// The list of DevEndpoint names, which may be the names returned from the ListDevEndpoint operation.
        public let devEndpointNames: [String]

        public init(devEndpointNames: [String]) {
            self.devEndpointNames = devEndpointNames
        }

        public func validate() throws {
            try validate(devEndpointNames, name:"devEndpointNames", max: 25)
            try validate(devEndpointNames, name:"devEndpointNames", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpointNames = "DevEndpointNames"
        }
    }

    public struct BatchGetDevEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DevEndpoints", required: false, type: .list), 
            AWSShapeMember(label: "DevEndpointsNotFound", required: false, type: .list)
        ]

        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?
        /// A list of DevEndpoints not found.
        public let devEndpointsNotFound: [String]?

        public init(devEndpoints: [DevEndpoint]? = nil, devEndpointsNotFound: [String]? = nil) {
            self.devEndpoints = devEndpoints
            self.devEndpointsNotFound = devEndpointsNotFound
        }

        public func validate() throws {
            try devEndpoints?.forEach {
                try $0.validate()
            }
            try validate(devEndpointsNotFound, name:"devEndpointsNotFound", max: 25)
            try validate(devEndpointsNotFound, name:"devEndpointsNotFound", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoints = "DevEndpoints"
            case devEndpointsNotFound = "DevEndpointsNotFound"
        }
    }

    public struct BatchGetJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobNames", required: true, type: .list)
        ]

        /// A list of job names, which might be the names returned from the ListJobs operation.
        public let jobNames: [String]

        public init(jobNames: [String]) {
            self.jobNames = jobNames
        }

        public func validate() throws {
            try jobNames.forEach {
                try validate($0, name:"jobNames[]", max: 255)
                try validate($0, name:"jobNames[]", min: 1)
                try validate($0, name:"jobNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobNames = "JobNames"
        }
    }

    public struct BatchGetJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Jobs", required: false, type: .list), 
            AWSShapeMember(label: "JobsNotFound", required: false, type: .list)
        ]

        /// A list of job definitions.
        public let jobs: [Job]?
        /// A list of names of jobs not found.
        public let jobsNotFound: [String]?

        public init(jobs: [Job]? = nil, jobsNotFound: [String]? = nil) {
            self.jobs = jobs
            self.jobsNotFound = jobsNotFound
        }

        public func validate() throws {
            try jobs?.forEach {
                try $0.validate()
            }
            try jobsNotFound?.forEach {
                try validate($0, name:"jobsNotFound[]", max: 255)
                try validate($0, name:"jobsNotFound[]", min: 1)
                try validate($0, name:"jobsNotFound[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case jobsNotFound = "JobsNotFound"
        }
    }

    public struct BatchGetPartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionsToGet", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partitions to retrieve.
        public let partitionsToGet: [PartitionValueList]
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionsToGet: [PartitionValueList], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionsToGet = partitionsToGet
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionsToGet.forEach {
                try $0.validate()
            }
            try validate(partitionsToGet, name:"partitionsToGet", max: 1000)
            try validate(partitionsToGet, name:"partitionsToGet", min: 0)
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionsToGet = "PartitionsToGet"
            case tableName = "TableName"
        }
    }

    public struct BatchGetPartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Partitions", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedKeys", required: false, type: .list)
        ]

        /// A list of the requested partitions.
        public let partitions: [Partition]?
        /// A list of the partition values in the request for which partions were not returned.
        public let unprocessedKeys: [PartitionValueList]?

        public init(partitions: [Partition]? = nil, unprocessedKeys: [PartitionValueList]? = nil) {
            self.partitions = partitions
            self.unprocessedKeys = unprocessedKeys
        }

        public func validate() throws {
            try partitions?.forEach {
                try $0.validate()
            }
            try unprocessedKeys?.forEach {
                try $0.validate()
            }
            try validate(unprocessedKeys, name:"unprocessedKeys", max: 1000)
            try validate(unprocessedKeys, name:"unprocessedKeys", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case partitions = "Partitions"
            case unprocessedKeys = "UnprocessedKeys"
        }
    }

    public struct BatchGetTriggersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TriggerNames", required: true, type: .list)
        ]

        /// A list of trigger names, which may be the names returned from the ListTriggers operation.
        public let triggerNames: [String]

        public init(triggerNames: [String]) {
            self.triggerNames = triggerNames
        }

        public func validate() throws {
            try triggerNames.forEach {
                try validate($0, name:"triggerNames[]", max: 255)
                try validate($0, name:"triggerNames[]", min: 1)
                try validate($0, name:"triggerNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case triggerNames = "TriggerNames"
        }
    }

    public struct BatchGetTriggersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Triggers", required: false, type: .list), 
            AWSShapeMember(label: "TriggersNotFound", required: false, type: .list)
        ]

        /// A list of trigger definitions.
        public let triggers: [Trigger]?
        /// A list of names of triggers not found.
        public let triggersNotFound: [String]?

        public init(triggers: [Trigger]? = nil, triggersNotFound: [String]? = nil) {
            self.triggers = triggers
            self.triggersNotFound = triggersNotFound
        }

        public func validate() throws {
            try triggers?.forEach {
                try $0.validate()
            }
            try triggersNotFound?.forEach {
                try validate($0, name:"triggersNotFound[]", max: 255)
                try validate($0, name:"triggersNotFound[]", min: 1)
                try validate($0, name:"triggersNotFound[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case triggers = "Triggers"
            case triggersNotFound = "TriggersNotFound"
        }
    }

    public struct BatchGetWorkflowsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IncludeGraph", required: false, type: .boolean), 
            AWSShapeMember(label: "Names", required: true, type: .list)
        ]

        /// Specifies whether to include a graph when returning the workflow resource metadata.
        public let includeGraph: Bool?
        /// A list of workflow names, which may be the names returned from the ListWorkflows operation.
        public let names: [String]

        public init(includeGraph: Bool? = nil, names: [String]) {
            self.includeGraph = includeGraph
            self.names = names
        }

        public func validate() throws {
            try names.forEach {
                try validate($0, name:"names[]", max: 255)
                try validate($0, name:"names[]", min: 1)
                try validate($0, name:"names[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(names, name:"names", max: 25)
            try validate(names, name:"names", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case names = "Names"
        }
    }

    public struct BatchGetWorkflowsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MissingWorkflows", required: false, type: .list), 
            AWSShapeMember(label: "Workflows", required: false, type: .list)
        ]

        /// A list of names of workflows not found.
        public let missingWorkflows: [String]?
        /// A list of workflow resource metadata.
        public let workflows: [Workflow]?

        public init(missingWorkflows: [String]? = nil, workflows: [Workflow]? = nil) {
            self.missingWorkflows = missingWorkflows
            self.workflows = workflows
        }

        public func validate() throws {
            try missingWorkflows?.forEach {
                try validate($0, name:"missingWorkflows[]", max: 255)
                try validate($0, name:"missingWorkflows[]", min: 1)
                try validate($0, name:"missingWorkflows[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(missingWorkflows, name:"missingWorkflows", max: 25)
            try validate(missingWorkflows, name:"missingWorkflows", min: 1)
            try workflows?.forEach {
                try $0.validate()
            }
            try validate(workflows, name:"workflows", max: 25)
            try validate(workflows, name:"workflows", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case missingWorkflows = "MissingWorkflows"
            case workflows = "Workflows"
        }
    }

    public struct BatchStopJobRunError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "JobRunId", required: false, type: .string)
        ]

        /// Specifies details about the error that was encountered.
        public let errorDetail: ErrorDetail?
        /// The name of the job definition that is used in the job run in question.
        public let jobName: String?
        /// The JobRunId of the job run in question.
        public let jobRunId: String?

        public init(errorDetail: ErrorDetail? = nil, jobName: String? = nil, jobRunId: String? = nil) {
            self.errorDetail = errorDetail
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        public func validate() throws {
            try errorDetail?.validate()
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(jobRunId, name:"jobRunId", max: 255)
            try validate(jobRunId, name:"jobRunId", min: 1)
            try validate(jobRunId, name:"jobRunId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct BatchStopJobRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "JobRunIds", required: true, type: .list)
        ]

        /// The name of the job definition for which to stop job runs.
        public let jobName: String
        /// A list of the JobRunIds that should be stopped for that job definition.
        public let jobRunIds: [String]

        public init(jobName: String, jobRunIds: [String]) {
            self.jobName = jobName
            self.jobRunIds = jobRunIds
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try jobRunIds.forEach {
                try validate($0, name:"jobRunIds[]", max: 255)
                try validate($0, name:"jobRunIds[]", min: 1)
                try validate($0, name:"jobRunIds[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(jobRunIds, name:"jobRunIds", max: 25)
            try validate(jobRunIds, name:"jobRunIds", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunIds = "JobRunIds"
        }
    }

    public struct BatchStopJobRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list), 
            AWSShapeMember(label: "SuccessfulSubmissions", required: false, type: .list)
        ]

        /// A list of the errors that were encountered in trying to stop JobRuns, including the JobRunId for which each error was encountered and details about the error.
        public let errors: [BatchStopJobRunError]?
        /// A list of the JobRuns that were successfully submitted for stopping.
        public let successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]?

        public init(errors: [BatchStopJobRunError]? = nil, successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]? = nil) {
            self.errors = errors
            self.successfulSubmissions = successfulSubmissions
        }

        public func validate() throws {
            try errors?.forEach {
                try $0.validate()
            }
            try successfulSubmissions?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successfulSubmissions = "SuccessfulSubmissions"
        }
    }

    public struct BatchStopJobRunSuccessfulSubmission: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "JobRunId", required: false, type: .string)
        ]

        /// The name of the job definition used in the job run that was stopped.
        public let jobName: String?
        /// The JobRunId of the job run that was stopped.
        public let jobRunId: String?

        public init(jobName: String? = nil, jobRunId: String? = nil) {
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(jobRunId, name:"jobRunId", max: 255)
            try validate(jobRunId, name:"jobRunId", min: 1)
            try validate(jobRunId, name:"jobRunId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public enum CatalogEncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public struct CatalogEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The database in which the table metadata resides.
        public let databaseName: String
        /// The name of the table in question.
        public let tableName: String

        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct CatalogImportStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportCompleted", required: false, type: .boolean), 
            AWSShapeMember(label: "ImportedBy", required: false, type: .string), 
            AWSShapeMember(label: "ImportTime", required: false, type: .timestamp)
        ]

        /// True if the migration has completed, or False otherwise.
        public let importCompleted: Bool?
        /// The name of the person who initiated the migration.
        public let importedBy: String?
        /// The time that the migration was started.
        public let importTime: TimeStamp?

        public init(importCompleted: Bool? = nil, importedBy: String? = nil, importTime: TimeStamp? = nil) {
            self.importCompleted = importCompleted
            self.importedBy = importedBy
            self.importTime = importTime
        }

        public func validate() throws {
            try validate(importedBy, name:"importedBy", max: 255)
            try validate(importedBy, name:"importedBy", min: 1)
            try validate(importedBy, name:"importedBy", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case importCompleted = "ImportCompleted"
            case importedBy = "ImportedBy"
            case importTime = "ImportTime"
        }
    }

    public struct CatalogTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Tables", required: true, type: .list)
        ]

        /// The name of the database to be synchronized.
        public let databaseName: String
        /// A list of the tables to be synchronized.
        public let tables: [String]

        public init(databaseName: String, tables: [String]) {
            self.databaseName = databaseName
            self.tables = tables
        }

        public func validate() throws {
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try tables.forEach {
                try validate($0, name:"tables[]", max: 255)
                try validate($0, name:"tables[]", min: 1)
                try validate($0, name:"tables[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(tables, name:"tables", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tables = "Tables"
        }
    }

    public struct Classifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CsvClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "GrokClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "JsonClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "XMLClassifier", required: false, type: .structure)
        ]

        /// A classifier for comma-separated values (CSV).
        public let csvClassifier: CsvClassifier?
        /// A classifier that uses grok.
        public let grokClassifier: GrokClassifier?
        /// A classifier for JSON content.
        public let jsonClassifier: JsonClassifier?
        /// A classifier for XML content.
        public let xMLClassifier: XMLClassifier?

        public init(csvClassifier: CsvClassifier? = nil, grokClassifier: GrokClassifier? = nil, jsonClassifier: JsonClassifier? = nil, xMLClassifier: XMLClassifier? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xMLClassifier = xMLClassifier
        }

        public func validate() throws {
            try csvClassifier?.validate()
            try grokClassifier?.validate()
            try jsonClassifier?.validate()
            try xMLClassifier?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct CloudWatchEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CloudWatchEncryptionMode", required: false, type: .enum), 
            AWSShapeMember(label: "KmsKeyArn", required: false, type: .string)
        ]

        /// The encryption mode to use for CloudWatch data.
        public let cloudWatchEncryptionMode: CloudWatchEncryptionMode?
        /// The AWS ARN of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        public init(cloudWatchEncryptionMode: CloudWatchEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.cloudWatchEncryptionMode = cloudWatchEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate() throws {
            try validate(kmsKeyArn, name:"kmsKeyArn", pattern: "arn:aws:kms:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryptionMode = "CloudWatchEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public enum CloudWatchEncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public struct CodeGenEdge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Source", required: true, type: .string), 
            AWSShapeMember(label: "Target", required: true, type: .string), 
            AWSShapeMember(label: "TargetParameter", required: false, type: .string)
        ]

        /// The ID of the node at which the edge starts.
        public let source: String
        /// The ID of the node at which the edge ends.
        public let target: String
        /// The target of the edge.
        public let targetParameter: String?

        public init(source: String, target: String, targetParameter: String? = nil) {
            self.source = source
            self.target = target
            self.targetParameter = targetParameter
        }

        public func validate() throws {
            try validate(source, name:"source", max: 255)
            try validate(source, name:"source", min: 1)
            try validate(source, name:"source", pattern: "[A-Za-z_][A-Za-z0-9_]*")
            try validate(target, name:"target", max: 255)
            try validate(target, name:"target", min: 1)
            try validate(target, name:"target", pattern: "[A-Za-z_][A-Za-z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "Source"
            case target = "Target"
            case targetParameter = "TargetParameter"
        }
    }

    public struct CodeGenNode: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Args", required: true, type: .list), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "LineNumber", required: false, type: .integer), 
            AWSShapeMember(label: "NodeType", required: true, type: .string)
        ]

        /// Properties of the node, in the form of name-value pairs.
        public let args: [CodeGenNodeArg]
        /// A node identifier that is unique within the node's graph.
        public let id: String
        /// The line number of the node.
        public let lineNumber: Int32?
        /// The type of node that this is.
        public let nodeType: String

        public init(args: [CodeGenNodeArg], id: String, lineNumber: Int32? = nil, nodeType: String) {
            self.args = args
            self.id = id
            self.lineNumber = lineNumber
            self.nodeType = nodeType
        }

        public func validate() throws {
            try validate(args, name:"args", max: 50)
            try validate(args, name:"args", min: 0)
            try validate(id, name:"id", max: 255)
            try validate(id, name:"id", min: 1)
            try validate(id, name:"id", pattern: "[A-Za-z_][A-Za-z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case args = "Args"
            case id = "Id"
            case lineNumber = "LineNumber"
            case nodeType = "NodeType"
        }
    }

    public struct CodeGenNodeArg: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Param", required: false, type: .boolean), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]

        /// The name of the argument or property.
        public let name: String
        /// True if the value is used as a parameter.
        public let param: Bool?
        /// The value of the argument or property.
        public let value: String

        public init(name: String, param: Bool? = nil, value: String) {
            self.name = name
            self.param = param
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case param = "Param"
            case value = "Value"
        }
    }

    public struct Column: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Comment", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        /// Free-form text comment.
        public let comment: String?
        /// The name of the Column.
        public let name: String
        /// The datatype of data in the Column.
        public let `type`: String?

        public init(comment: String? = nil, name: String, type: String? = nil) {
            self.comment = comment
            self.name = name
            self.`type` = `type`
        }

        public func validate() throws {
            try validate(comment, name:"comment", max: 255)
            try validate(comment, name:"comment", min: 0)
            try validate(comment, name:"comment", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(`type`, name:"`type`", max: 131072)
            try validate(`type`, name:"`type`", min: 0)
            try validate(`type`, name:"`type`", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case name = "Name"
            case `type` = "Type"
        }
    }

    public struct Condition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: false, type: .string), 
            AWSShapeMember(label: "CrawlState", required: false, type: .enum), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "LogicalOperator", required: false, type: .enum), 
            AWSShapeMember(label: "State", required: false, type: .enum)
        ]

        /// The name of the crawler to which this condition applies.
        public let crawlerName: String?
        /// The state of the crawler to which this condition applies.
        public let crawlState: CrawlState?
        /// The name of the job whose JobRuns this condition applies to, and on which this trigger waits.
        public let jobName: String?
        /// A logical operator.
        public let logicalOperator: LogicalOperator?
        /// The condition state. Currently, the values supported are SUCCEEDED, STOPPED, TIMEOUT, and FAILED.
        public let state: JobRunState?

        public init(crawlerName: String? = nil, crawlState: CrawlState? = nil, jobName: String? = nil, logicalOperator: LogicalOperator? = nil, state: JobRunState? = nil) {
            self.crawlerName = crawlerName
            self.crawlState = crawlState
            self.jobName = jobName
            self.logicalOperator = logicalOperator
            self.state = state
        }

        public func validate() throws {
            try validate(crawlerName, name:"crawlerName", max: 255)
            try validate(crawlerName, name:"crawlerName", min: 1)
            try validate(crawlerName, name:"crawlerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case crawlState = "CrawlState"
            case jobName = "JobName"
            case logicalOperator = "LogicalOperator"
            case state = "State"
        }
    }

    public struct Connection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionProperties", required: false, type: .map), 
            AWSShapeMember(label: "ConnectionType", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "MatchCriteria", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "PhysicalConnectionRequirements", required: false, type: .structure)
        ]

        /// These key-value pairs define parameters for the connection:    HOST - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.    PORT - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.    USER_NAME - The name under which to log in to the database. The value string for USER_NAME is "USERNAME".    PASSWORD - A password, if one is used, for the user name.    ENCRYPTED_PASSWORD - When you enable connection password protection by setting ConnectionPasswordEncryption in the Data Catalog encryption settings, this field stores the encrypted password.    JDBC_DRIVER_JAR_URI - The Amazon S3 path of the JAR file that contains the JDBC driver to use.    JDBC_DRIVER_CLASS_NAME - The class name of the JDBC driver to use.    JDBC_ENGINE - The name of the JDBC engine to use.    JDBC_ENGINE_VERSION - The version of the JDBC engine to use.    CONFIG_FILES - (Reserved for future use).    INSTANCE_ID - The instance ID to use.    JDBC_CONNECTION_URL - The URL for the JDBC connection.    JDBC_ENFORCE_SSL - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching will be enforced for the JDBC connection on the client. The default is false.  
        public let connectionProperties: [ConnectionPropertyKey: String]?
        /// The type of the connection. Currently, only JDBC is supported; SFTP is not supported.
        public let connectionType: ConnectionType?
        /// The time that this connection definition was created.
        public let creationTime: TimeStamp?
        /// The description of the connection.
        public let description: String?
        /// The user, group, or role that last updated this connection definition.
        public let lastUpdatedBy: String?
        /// The last time that this connection definition was updated.
        public let lastUpdatedTime: TimeStamp?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// The name of the connection definition.
        public let name: String?
        /// A map of physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to make this connection successfully.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?

        public init(connectionProperties: [ConnectionPropertyKey: String]? = nil, connectionType: ConnectionType? = nil, creationTime: TimeStamp? = nil, description: String? = nil, lastUpdatedBy: String? = nil, lastUpdatedTime: TimeStamp? = nil, matchCriteria: [String]? = nil, name: String? = nil, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil) {
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.creationTime = creationTime
            self.description = description
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
        }

        public func validate() throws {
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(lastUpdatedBy, name:"lastUpdatedBy", max: 255)
            try validate(lastUpdatedBy, name:"lastUpdatedBy", min: 1)
            try validate(lastUpdatedBy, name:"lastUpdatedBy", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try matchCriteria?.forEach {
                try validate($0, name:"matchCriteria[]", max: 255)
                try validate($0, name:"matchCriteria[]", min: 1)
                try validate($0, name:"matchCriteria[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(matchCriteria, name:"matchCriteria", max: 10)
            try validate(matchCriteria, name:"matchCriteria", min: 0)
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try physicalConnectionRequirements?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastUpdatedBy = "LastUpdatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
        }
    }

    public struct ConnectionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionProperties", required: true, type: .map), 
            AWSShapeMember(label: "ConnectionType", required: true, type: .enum), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "MatchCriteria", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "PhysicalConnectionRequirements", required: false, type: .structure)
        ]

        /// These key-value pairs define parameters for the connection.
        public let connectionProperties: [ConnectionPropertyKey: String]
        /// The type of the connection. Currently, only JDBC is supported; SFTP is not supported.
        public let connectionType: ConnectionType
        /// The description of the connection.
        public let description: String?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// The name of the connection.
        public let name: String
        /// A map of physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to successfully make this connection.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?

        public init(connectionProperties: [ConnectionPropertyKey: String], connectionType: ConnectionType, description: String? = nil, matchCriteria: [String]? = nil, name: String, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil) {
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.description = description
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
        }

        public func validate() throws {
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try matchCriteria?.forEach {
                try validate($0, name:"matchCriteria[]", max: 255)
                try validate($0, name:"matchCriteria[]", min: 1)
                try validate($0, name:"matchCriteria[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(matchCriteria, name:"matchCriteria", max: 10)
            try validate(matchCriteria, name:"matchCriteria", min: 0)
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try physicalConnectionRequirements?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
            case description = "Description"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
        }
    }

    public struct ConnectionPasswordEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AwsKmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "ReturnConnectionPasswordEncrypted", required: true, type: .boolean)
        ]

        /// An AWS KMS key that is used to encrypt the connection password.  If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least kms:Encrypt permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog.  You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.
        public let awsKmsKeyId: String?
        /// When the ReturnConnectionPasswordEncrypted flag is set to "true", passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently from catalog encryption. 
        public let returnConnectionPasswordEncrypted: Bool

        public init(awsKmsKeyId: String? = nil, returnConnectionPasswordEncrypted: Bool) {
            self.awsKmsKeyId = awsKmsKeyId
            self.returnConnectionPasswordEncrypted = returnConnectionPasswordEncrypted
        }

        public func validate() throws {
            try validate(awsKmsKeyId, name:"awsKmsKeyId", max: 255)
            try validate(awsKmsKeyId, name:"awsKmsKeyId", min: 1)
            try validate(awsKmsKeyId, name:"awsKmsKeyId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case awsKmsKeyId = "AwsKmsKeyId"
            case returnConnectionPasswordEncrypted = "ReturnConnectionPasswordEncrypted"
        }
    }

    public enum ConnectionPropertyKey: String, CustomStringConvertible, Codable {
        case host = "HOST"
        case port = "PORT"
        case username = "USERNAME"
        case password = "PASSWORD"
        case encryptedPassword = "ENCRYPTED_PASSWORD"
        case jdbcDriverJarUri = "JDBC_DRIVER_JAR_URI"
        case jdbcDriverClassName = "JDBC_DRIVER_CLASS_NAME"
        case jdbcEngine = "JDBC_ENGINE"
        case jdbcEngineVersion = "JDBC_ENGINE_VERSION"
        case configFiles = "CONFIG_FILES"
        case instanceId = "INSTANCE_ID"
        case jdbcConnectionUrl = "JDBC_CONNECTION_URL"
        case jdbcEnforceSsl = "JDBC_ENFORCE_SSL"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable {
        case jdbc = "JDBC"
        case sftp = "SFTP"
        public var description: String { return self.rawValue }
    }

    public struct ConnectionsList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connections", required: false, type: .list)
        ]

        /// A list of connections used by the job.
        public let connections: [String]?

        public init(connections: [String]? = nil) {
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
        }
    }

    public struct Crawl: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompletedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "LogGroup", required: false, type: .string), 
            AWSShapeMember(label: "LogStream", required: false, type: .string), 
            AWSShapeMember(label: "StartedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "State", required: false, type: .enum)
        ]

        /// The date and time on which the crawl completed.
        public let completedOn: TimeStamp?
        /// The error message associated with the crawl.
        public let errorMessage: String?
        /// The log group associated with the crawl.
        public let logGroup: String?
        /// The log stream associated with the crawl.
        public let logStream: String?
        /// The date and time on which the crawl started.
        public let startedOn: TimeStamp?
        /// The state of the crawler.
        public let state: CrawlState?

        public init(completedOn: TimeStamp? = nil, errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, startedOn: TimeStamp? = nil, state: CrawlState? = nil) {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.startedOn = startedOn
            self.state = state
        }

        public func validate() throws {
            try validate(errorMessage, name:"errorMessage", max: 2048)
            try validate(errorMessage, name:"errorMessage", min: 0)
            try validate(errorMessage, name:"errorMessage", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(logGroup, name:"logGroup", max: 512)
            try validate(logGroup, name:"logGroup", min: 1)
            try validate(logGroup, name:"logGroup", pattern: "[\\.\\-_/#A-Za-z0-9]+")
            try validate(logStream, name:"logStream", max: 512)
            try validate(logStream, name:"logStream", min: 1)
            try validate(logStream, name:"logStream", pattern: "[^:*]*")
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case startedOn = "StartedOn"
            case state = "State"
        }
    }

    public enum CrawlState: String, CustomStringConvertible, Codable {
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct Crawler: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "Configuration", required: false, type: .string), 
            AWSShapeMember(label: "CrawlElapsedTime", required: false, type: .long), 
            AWSShapeMember(label: "CrawlerSecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "LastCrawl", required: false, type: .structure), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "SchemaChangePolicy", required: false, type: .structure), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "TablePrefix", required: false, type: .string), 
            AWSShapeMember(label: "Targets", required: false, type: .structure), 
            AWSShapeMember(label: "Version", required: false, type: .long)
        ]

        /// A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
        public let configuration: String?
        /// If the crawler is running, contains the total time elapsed since the last crawl began.
        public let crawlElapsedTime: Int64?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The time that the crawler was created.
        public let creationTime: TimeStamp?
        /// The name of the database in which the crawler's output is stored.
        public let databaseName: String?
        /// A description of the crawler.
        public let description: String?
        /// The status of the last crawl, and potentially error information if an error occurred.
        public let lastCrawl: LastCrawlInfo?
        /// The time that the crawler was last updated.
        public let lastUpdated: TimeStamp?
        /// The name of the crawler.
        public let name: String?
        /// The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.
        public let role: String?
        /// For scheduled crawlers, the schedule when the crawler runs.
        public let schedule: Schedule?
        /// The policy that specifies update and delete behaviors for the crawler.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// Indicates whether the crawler is running, or whether a run is pending.
        public let state: CrawlerState?
        /// The prefix added to the names of tables that are created.
        public let tablePrefix: String?
        /// A collection of targets to crawl.
        public let targets: CrawlerTargets?
        /// The version of the crawler.
        public let version: Int64?

        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlElapsedTime: Int64? = nil, crawlerSecurityConfiguration: String? = nil, creationTime: TimeStamp? = nil, databaseName: String? = nil, description: String? = nil, lastCrawl: LastCrawlInfo? = nil, lastUpdated: TimeStamp? = nil, name: String? = nil, role: String? = nil, schedule: Schedule? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, state: CrawlerState? = nil, tablePrefix: String? = nil, targets: CrawlerTargets? = nil, version: Int64? = nil) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlElapsedTime = crawlElapsedTime
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.description = description
            self.lastCrawl = lastCrawl
            self.lastUpdated = lastUpdated
            self.name = name
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.state = state
            self.tablePrefix = tablePrefix
            self.targets = targets
            self.version = version
        }

        public func validate() throws {
            try classifiers?.forEach {
                try validate($0, name:"classifiers[]", max: 255)
                try validate($0, name:"classifiers[]", min: 1)
                try validate($0, name:"classifiers[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlerSecurityConfiguration, name:"crawlerSecurityConfiguration", max: 128)
            try validate(crawlerSecurityConfiguration, name:"crawlerSecurityConfiguration", min: 0)
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try lastCrawl?.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tablePrefix, name:"tablePrefix", max: 128)
            try validate(tablePrefix, name:"tablePrefix", min: 0)
            try targets?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlElapsedTime = "CrawlElapsedTime"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lastCrawl = "LastCrawl"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case state = "State"
            case tablePrefix = "TablePrefix"
            case targets = "Targets"
            case version = "Version"
        }
    }

    public struct CrawlerMetrics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: false, type: .string), 
            AWSShapeMember(label: "LastRuntimeSeconds", required: false, type: .double), 
            AWSShapeMember(label: "MedianRuntimeSeconds", required: false, type: .double), 
            AWSShapeMember(label: "StillEstimating", required: false, type: .boolean), 
            AWSShapeMember(label: "TablesCreated", required: false, type: .integer), 
            AWSShapeMember(label: "TablesDeleted", required: false, type: .integer), 
            AWSShapeMember(label: "TablesUpdated", required: false, type: .integer), 
            AWSShapeMember(label: "TimeLeftSeconds", required: false, type: .double)
        ]

        /// The name of the crawler.
        public let crawlerName: String?
        /// The duration of the crawler's most recent run, in seconds.
        public let lastRuntimeSeconds: Double?
        /// The median duration of this crawler's runs, in seconds.
        public let medianRuntimeSeconds: Double?
        /// True if the crawler is still estimating how long it will take to complete this run.
        public let stillEstimating: Bool?
        /// The number of tables created by this crawler.
        public let tablesCreated: Int32?
        /// The number of tables deleted by this crawler.
        public let tablesDeleted: Int32?
        /// The number of tables updated by this crawler.
        public let tablesUpdated: Int32?
        /// The estimated time left to complete a running crawl.
        public let timeLeftSeconds: Double?

        public init(crawlerName: String? = nil, lastRuntimeSeconds: Double? = nil, medianRuntimeSeconds: Double? = nil, stillEstimating: Bool? = nil, tablesCreated: Int32? = nil, tablesDeleted: Int32? = nil, tablesUpdated: Int32? = nil, timeLeftSeconds: Double? = nil) {
            self.crawlerName = crawlerName
            self.lastRuntimeSeconds = lastRuntimeSeconds
            self.medianRuntimeSeconds = medianRuntimeSeconds
            self.stillEstimating = stillEstimating
            self.tablesCreated = tablesCreated
            self.tablesDeleted = tablesDeleted
            self.tablesUpdated = tablesUpdated
            self.timeLeftSeconds = timeLeftSeconds
        }

        public func validate() throws {
            try validate(crawlerName, name:"crawlerName", max: 255)
            try validate(crawlerName, name:"crawlerName", min: 1)
            try validate(crawlerName, name:"crawlerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(lastRuntimeSeconds, name:"lastRuntimeSeconds", min: 0)
            try validate(medianRuntimeSeconds, name:"medianRuntimeSeconds", min: 0)
            try validate(tablesCreated, name:"tablesCreated", min: 0)
            try validate(tablesDeleted, name:"tablesDeleted", min: 0)
            try validate(tablesUpdated, name:"tablesUpdated", min: 0)
            try validate(timeLeftSeconds, name:"timeLeftSeconds", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case lastRuntimeSeconds = "LastRuntimeSeconds"
            case medianRuntimeSeconds = "MedianRuntimeSeconds"
            case stillEstimating = "StillEstimating"
            case tablesCreated = "TablesCreated"
            case tablesDeleted = "TablesDeleted"
            case tablesUpdated = "TablesUpdated"
            case timeLeftSeconds = "TimeLeftSeconds"
        }
    }

    public struct CrawlerNodeDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Crawls", required: false, type: .list)
        ]

        /// A list of crawls represented by the crawl node.
        public let crawls: [Crawl]?

        public init(crawls: [Crawl]? = nil) {
            self.crawls = crawls
        }

        public func validate() throws {
            try crawls?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case crawls = "Crawls"
        }
    }

    public enum CrawlerState: String, CustomStringConvertible, Codable {
        case ready = "READY"
        case running = "RUNNING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public struct CrawlerTargets: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogTargets", required: false, type: .list), 
            AWSShapeMember(label: "DynamoDBTargets", required: false, type: .list), 
            AWSShapeMember(label: "JdbcTargets", required: false, type: .list), 
            AWSShapeMember(label: "S3Targets", required: false, type: .list)
        ]

        /// Specifies AWS Glue Data Catalog targets.
        public let catalogTargets: [CatalogTarget]?
        /// Specifies Amazon DynamoDB targets.
        public let dynamoDBTargets: [DynamoDBTarget]?
        /// Specifies JDBC targets.
        public let jdbcTargets: [JdbcTarget]?
        /// Specifies Amazon Simple Storage Service (Amazon S3) targets.
        public let s3Targets: [S3Target]?

        public init(catalogTargets: [CatalogTarget]? = nil, dynamoDBTargets: [DynamoDBTarget]? = nil, jdbcTargets: [JdbcTarget]? = nil, s3Targets: [S3Target]? = nil) {
            self.catalogTargets = catalogTargets
            self.dynamoDBTargets = dynamoDBTargets
            self.jdbcTargets = jdbcTargets
            self.s3Targets = s3Targets
        }

        public func validate() throws {
            try catalogTargets?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case catalogTargets = "CatalogTargets"
            case dynamoDBTargets = "DynamoDBTargets"
            case jdbcTargets = "JdbcTargets"
            case s3Targets = "S3Targets"
        }
    }

    public struct CreateClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CsvClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "GrokClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "JsonClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "XMLClassifier", required: false, type: .structure)
        ]

        /// A CsvClassifier object specifying the classifier to create.
        public let csvClassifier: CreateCsvClassifierRequest?
        /// A GrokClassifier object specifying the classifier to create.
        public let grokClassifier: CreateGrokClassifierRequest?
        /// A JsonClassifier object specifying the classifier to create.
        public let jsonClassifier: CreateJsonClassifierRequest?
        /// An XMLClassifier object specifying the classifier to create.
        public let xMLClassifier: CreateXMLClassifierRequest?

        public init(csvClassifier: CreateCsvClassifierRequest? = nil, grokClassifier: CreateGrokClassifierRequest? = nil, jsonClassifier: CreateJsonClassifierRequest? = nil, xMLClassifier: CreateXMLClassifierRequest? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xMLClassifier = xMLClassifier
        }

        public func validate() throws {
            try csvClassifier?.validate()
            try grokClassifier?.validate()
            try jsonClassifier?.validate()
            try xMLClassifier?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct CreateClassifierResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionInput", required: true, type: .structure)
        ]

        /// The ID of the Data Catalog in which to create the connection. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object defining the connection to create.
        public let connectionInput: ConnectionInput

        public init(catalogId: String? = nil, connectionInput: ConnectionInput) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try connectionInput.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
        }
    }

    public struct CreateConnectionResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "Configuration", required: false, type: .string), 
            AWSShapeMember(label: "CrawlerSecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Role", required: true, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "SchemaChangePolicy", required: false, type: .structure), 
            AWSShapeMember(label: "TablePrefix", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map), 
            AWSShapeMember(label: "Targets", required: true, type: .structure)
        ]

        /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// The crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
        public let configuration: String?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The AWS Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A description of the new crawler.
        public let description: String?
        /// Name of the new crawler.
        public let name: String
        /// The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer resources.
        public let role: String
        /// A cron expression used to specify the schedule. For more information, see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, specify cron(15 12 * * ? *).
        public let schedule: String?
        /// The policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// The tags to use with this crawler request. You can use tags to limit access to the crawler. For more information, see AWS Tags in AWS Glue.
        public let tags: [String: String]?
        /// A list of collection of targets to crawl.
        public let targets: CrawlerTargets

        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlerSecurityConfiguration: String? = nil, databaseName: String? = nil, description: String? = nil, name: String, role: String, schedule: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, tablePrefix: String? = nil, tags: [String: String]? = nil, targets: CrawlerTargets) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.databaseName = databaseName
            self.description = description
            self.name = name
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.tablePrefix = tablePrefix
            self.tags = tags
            self.targets = targets
        }

        public func validate() throws {
            try classifiers?.forEach {
                try validate($0, name:"classifiers[]", max: 255)
                try validate($0, name:"classifiers[]", min: 1)
                try validate($0, name:"classifiers[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlerSecurityConfiguration, name:"crawlerSecurityConfiguration", max: 128)
            try validate(crawlerSecurityConfiguration, name:"crawlerSecurityConfiguration", min: 0)
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tablePrefix, name:"tablePrefix", max: 128)
            try validate(tablePrefix, name:"tablePrefix", min: 0)
            try targets.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case databaseName = "DatabaseName"
            case description = "Description"
            case name = "Name"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case tablePrefix = "TablePrefix"
            case tags = "Tags"
            case targets = "Targets"
        }
    }

    public struct CreateCrawlerResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateCsvClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllowSingleColumn", required: false, type: .boolean), 
            AWSShapeMember(label: "ContainsHeader", required: false, type: .enum), 
            AWSShapeMember(label: "Delimiter", required: false, type: .string), 
            AWSShapeMember(label: "DisableValueTrimming", required: false, type: .boolean), 
            AWSShapeMember(label: "Header", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "QuoteSymbol", required: false, type: .string)
        ]

        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.
        public let quoteSymbol: String?

        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, name: String, quoteSymbol: String? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
        }

        public func validate() throws {
            try validate(delimiter, name:"delimiter", max: 1)
            try validate(delimiter, name:"delimiter", min: 1)
            try validate(delimiter, name:"delimiter", pattern: "[^\\r\\n]")
            try header?.forEach {
                try validate($0, name:"header[]", max: 255)
                try validate($0, name:"header[]", min: 1)
                try validate($0, name:"header[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(quoteSymbol, name:"quoteSymbol", max: 1)
            try validate(quoteSymbol, name:"quoteSymbol", min: 1)
            try validate(quoteSymbol, name:"quoteSymbol", pattern: "[^\\r\\n]")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct CreateDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseInput", required: true, type: .structure)
        ]

        /// The ID of the Data Catalog in which to create the database. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A DatabaseInput object defining the metadata database to create in the catalog.
        public let databaseInput: DatabaseInput

        public init(catalogId: String? = nil, databaseInput: DatabaseInput) {
            self.catalogId = catalogId
            self.databaseInput = databaseInput
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try databaseInput.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseInput = "DatabaseInput"
        }
    }

    public struct CreateDatabaseResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "NumberOfNodes", required: false, type: .integer), 
            AWSShapeMember(label: "PublicKey", required: false, type: .string), 
            AWSShapeMember(label: "PublicKeys", required: false, type: .list), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// A map of arguments used to configure the DevEndpoint.
        public let arguments: [String: String]?
        /// The name to be assigned to the new DevEndpoint.
        public let endpointName: String
        /// Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// The number of AWS Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
        public let numberOfNodes: Int32?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility, as the recommended attribute to use is public keys.
        public let publicKey: String?
        /// A list of public keys to be used by the DevEndpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys: call the UpdateDevEndpoint API with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute. 
        public let publicKeys: [String]?
        /// The IAM role for the DevEndpoint.
        public let roleArn: String
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public let securityConfiguration: String?
        /// Security group IDs for the security groups to be used by the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The subnet ID for the new DevEndpoint to use.
        public let subnetId: String?
        /// The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in AWS Glue, see AWS Tags in AWS Glue in the developer guide.
        public let tags: [String: String]?

        public init(arguments: [String: String]? = nil, endpointName: String, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, numberOfNodes: Int32? = nil, publicKey: String? = nil, publicKeys: [String]? = nil, roleArn: String, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, subnetId: String? = nil, tags: [String: String]? = nil) {
            self.arguments = arguments
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.numberOfNodes = numberOfNodes
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
            self.tags = tags
        }

        public func validate() throws {
            try validate(publicKeys, name:"publicKeys", max: 5)
            try validate(roleArn, name:"roleArn", pattern: "arn:aws:iam::\\d{12}:role/.*")
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case numberOfNodes = "NumberOfNodes"
            case publicKey = "PublicKey"
            case publicKeys = "PublicKeys"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case subnetId = "SubnetId"
            case tags = "Tags"
        }
    }

    public struct CreateDevEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "EndpointName", required: false, type: .string), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "NumberOfNodes", required: false, type: .integer), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string), 
            AWSShapeMember(label: "YarnEndpointAddress", required: false, type: .string), 
            AWSShapeMember(label: "ZeppelinRemoteSparkInterpreterPort", required: false, type: .integer)
        ]

        /// The map of arguments used to configure this DevEndpoint.
        public let arguments: [String: String]?
        /// The AWS availability zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: TimeStamp?
        /// The name assigned to the new DevEndpoint.
        public let endpointName: String?
        /// Path to one or more Java Jars in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// Path(s) to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraPythonLibsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// The number of AWS Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int32?
        /// The AWS ARN of the role assigned to the new DevEndpoint.
        public let roleArn: String?
        /// The name of the SecurityConfiguration structure being used with this DevEndpoint.
        public let securityConfiguration: String?
        /// The security groups assigned to the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The current status of the new DevEndpoint.
        public let status: String?
        /// The subnet ID assigned to the new DevEndpoint.
        public let subnetId: String?
        /// The ID of the VPC used by this DevEndpoint.
        public let vpcId: String?
        /// The address of the YARN endpoint used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int32?

        public init(arguments: [String: String]? = nil, availabilityZone: String? = nil, createdTimestamp: TimeStamp? = nil, endpointName: String? = nil, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, failureReason: String? = nil, numberOfNodes: Int32? = nil, roleArn: String? = nil, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, status: String? = nil, subnetId: String? = nil, vpcId: String? = nil, yarnEndpointAddress: String? = nil, zeppelinRemoteSparkInterpreterPort: Int32? = nil) {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.numberOfNodes = numberOfNodes
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }

        public func validate() throws {
            try validate(roleArn, name:"roleArn", pattern: "arn:aws:iam::\\d{12}:role/.*")
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case failureReason = "FailureReason"
            case numberOfNodes = "NumberOfNodes"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
        }
    }

    public struct CreateGrokClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "CustomPatterns", required: false, type: .string), 
            AWSShapeMember(label: "GrokPattern", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The grok pattern used by this classifier.
        public let grokPattern: String
        /// The name of the new classifier.
        public let name: String

        public init(classification: String, customPatterns: String? = nil, grokPattern: String, name: String) {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }

        public func validate() throws {
            try validate(customPatterns, name:"customPatterns", max: 16000)
            try validate(customPatterns, name:"customPatterns", min: 0)
            try validate(customPatterns, name:"customPatterns", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(grokPattern, name:"grokPattern", max: 2048)
            try validate(grokPattern, name:"grokPattern", min: 1)
            try validate(grokPattern, name:"grokPattern", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case name = "Name"
        }
    }

    public struct CreateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Command", required: true, type: .structure), 
            AWSShapeMember(label: "Connections", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultArguments", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ExecutionProperty", required: false, type: .structure), 
            AWSShapeMember(label: "LogUri", required: false, type: .string), 
            AWSShapeMember(label: "MaxCapacity", required: false, type: .double), 
            AWSShapeMember(label: "MaxRetries", required: false, type: .integer), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "NotificationProperty", required: false, type: .structure), 
            AWSShapeMember(label: "NumberOfWorkers", required: false, type: .integer), 
            AWSShapeMember(label: "Role", required: true, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer), 
            AWSShapeMember(label: "WorkerType", required: false, type: .string)
        ]

        /// The JobCommand that executes this job.
        public let command: JobCommand
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The default arguments for this job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
        public let defaultArguments: [String: String]?
        /// Description of the job being defined.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// This field is reserved for future use.
        public let logUri: String?
        /// The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the AWS Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.  
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int32?
        /// The name you assign to this job definition. It must be unique in your account.
        public let name: String
        /// Specifies configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X. 
        public let numberOfWorkers: Int32?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let role: String
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The tags to use with this job. You may use tags to limit access to the job. For more information about tags in AWS Glue, see AWS Tags in AWS Glue in the developer guide.
        public let tags: [String: String]?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int32?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.  
        public let workerType: String?

        public init(command: JobCommand, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, logUri: String? = nil, maxCapacity: Double? = nil, maxRetries: Int32? = nil, name: String, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int32? = nil, role: String, securityConfiguration: String? = nil, tags: [String: String]? = nil, timeout: Int32? = nil, workerType: String? = nil) {
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionProperty = executionProperty
            self.logUri = logUri
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.tags = tags
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate() throws {
            try command.validate()
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try notificationProperty?.validate()
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(timeout, name:"timeout", min: 1)
            try validate(workerType, name:"workerType", max: 255)
            try validate(workerType, name:"workerType", min: 1)
            try validate(workerType, name:"workerType", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case logUri = "LogUri"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case tags = "Tags"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct CreateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The unique name that was provided for this job definition.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateJsonClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JsonPath", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// A JsonPath string defining the JSON data for the classifier to classify. AWS Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String
        /// The name of the classifier.
        public let name: String

        public init(jsonPath: String, name: String) {
            self.jsonPath = jsonPath
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case name = "Name"
        }
    }

    public struct CreatePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionInput", required: true, type: .structure), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String
        /// A PartitionInput structure defining the partition to be created.
        public let partitionInput: PartitionInput
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionInput: PartitionInput, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInput = partitionInput
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionInput.validate()
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInput = "PartitionInput"
            case tableName = "TableName"
        }
    }

    public struct CreatePartitionResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateScriptRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DagEdges", required: false, type: .list), 
            AWSShapeMember(label: "DagNodes", required: false, type: .list), 
            AWSShapeMember(label: "Language", required: false, type: .enum)
        ]

        /// A list of the edges in the DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the DAG.
        public let dagNodes: [CodeGenNode]?
        /// The programming language of the resulting code from the DAG.
        public let language: Language?

        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil, language: Language? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
            self.language = language
        }

        public func validate() throws {
            try dagEdges?.forEach {
                try $0.validate()
            }
            try dagNodes?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
            case language = "Language"
        }
    }

    public struct CreateScriptResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PythonScript", required: false, type: .string), 
            AWSShapeMember(label: "ScalaCode", required: false, type: .string)
        ]

        /// The Python script generated from the DAG.
        public let pythonScript: String?
        /// The Scala code generated from the DAG.
        public let scalaCode: String?

        public init(pythonScript: String? = nil, scalaCode: String? = nil) {
            self.pythonScript = pythonScript
            self.scalaCode = scalaCode
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
            case scalaCode = "ScalaCode"
        }
    }

    public struct CreateSecurityConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfiguration", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The encryption configuration for the new security configuration.
        public let encryptionConfiguration: EncryptionConfiguration
        /// The name for the new security configuration.
        public let name: String

        public init(encryptionConfiguration: EncryptionConfiguration, name: String) {
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }

        public func validate() throws {
            try encryptionConfiguration.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "EncryptionConfiguration"
            case name = "Name"
        }
    }

    public struct CreateSecurityConfigurationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The time at which the new security configuration was created.
        public let createdTimestamp: TimeStamp?
        /// The name assigned to the new security configuration.
        public let name: String?

        public init(createdTimestamp: TimeStamp? = nil, name: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case name = "Name"
        }
    }

    public struct CreateTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableInput", required: true, type: .structure)
        ]

        /// The ID of the Data Catalog in which to create the Table. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The catalog database in which to create the new table. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The TableInput object that defines the metadata table to create in the catalog.
        public let tableInput: TableInput

        public init(catalogId: String? = nil, databaseName: String, tableInput: TableInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableInput = tableInput
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try tableInput.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableInput = "TableInput"
        }
    }

    public struct CreateTableResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: true, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Predicate", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "StartOnCreation", required: false, type: .boolean), 
            AWSShapeMember(label: "Tags", required: false, type: .map), 
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "WorkflowName", required: false, type: .string)
        ]

        /// The actions initiated by this trigger when it fires.
        public let actions: [Action]
        /// A description of the new trigger.
        public let description: String?
        /// The name of the trigger.
        public let name: String
        /// A predicate to specify when the new trigger should fire. This field is required when the trigger type is CONDITIONAL.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *). This field is required when the trigger type is SCHEDULED.
        public let schedule: String?
        /// Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
        public let startOnCreation: Bool?
        /// The tags to use with this trigger. You may use tags to limit access to the trigger. For more information about tags in AWS Glue, see AWS Tags in AWS Glue in the developer guide. 
        public let tags: [String: String]?
        /// The type of the new trigger.
        public let `type`: TriggerType
        /// The name of the workflow associated with the trigger.
        public let workflowName: String?

        public init(actions: [Action], description: String? = nil, name: String, predicate: Predicate? = nil, schedule: String? = nil, startOnCreation: Bool? = nil, tags: [String: String]? = nil, type: TriggerType, workflowName: String? = nil) {
            self.actions = actions
            self.description = description
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.startOnCreation = startOnCreation
            self.tags = tags
            self.`type` = `type`
            self.workflowName = workflowName
        }

        public func validate() throws {
            try actions.forEach {
                try $0.validate()
            }
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try predicate?.validate()
            try validate(workflowName, name:"workflowName", max: 255)
            try validate(workflowName, name:"workflowName", min: 1)
            try validate(workflowName, name:"workflowName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
            case startOnCreation = "StartOnCreation"
            case tags = "Tags"
            case `type` = "Type"
            case workflowName = "WorkflowName"
        }
    }

    public struct CreateTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the trigger.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "FunctionInput", required: true, type: .structure)
        ]

        /// The ID of the Data Catalog in which to create the function. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which to create the function.
        public let databaseName: String
        /// A FunctionInput object that defines the function to create in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput

        public init(catalogId: String? = nil, databaseName: String, functionInput: UserDefinedFunctionInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionInput = functionInput
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try functionInput.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionInput = "FunctionInput"
        }
    }

    public struct CreateUserDefinedFunctionResponse: AWSShape {


        public init() {
        }

    }

    public struct CreateWorkflowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultRunProperties", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// A collection of properties to be used as part of each execution of the workflow.
        public let defaultRunProperties: [String: String]?
        /// A description of the workflow.
        public let description: String?
        /// The name to be assigned to the workflow. It should be unique within your account.
        public let name: String
        /// The tags to be used with this workflow.
        public let tags: [String: String]?

        public init(defaultRunProperties: [String: String]? = nil, description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateWorkflowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the workflow which was provided as part of the request.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateXMLClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RowTag", required: false, type: .string)
        ]

        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by /&gt;). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A" item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).
        public let rowTag: String?

        public init(classification: String, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct CsvClassifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllowSingleColumn", required: false, type: .boolean), 
            AWSShapeMember(label: "ContainsHeader", required: false, type: .enum), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Delimiter", required: false, type: .string), 
            AWSShapeMember(label: "DisableValueTrimming", required: false, type: .boolean), 
            AWSShapeMember(label: "Header", required: false, type: .list), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "QuoteSymbol", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long)
        ]

        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// The time that this classifier was registered.
        public let creationTime: TimeStamp?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The time that this classifier was last updated.
        public let lastUpdated: TimeStamp?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public let quoteSymbol: String?
        /// The version of this classifier.
        public let version: Int64?

        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, creationTime: TimeStamp? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, lastUpdated: TimeStamp? = nil, name: String, quoteSymbol: String? = nil, version: Int64? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.creationTime = creationTime
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.lastUpdated = lastUpdated
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.version = version
        }

        public func validate() throws {
            try validate(delimiter, name:"delimiter", max: 1)
            try validate(delimiter, name:"delimiter", min: 1)
            try validate(delimiter, name:"delimiter", pattern: "[^\\r\\n]")
            try header?.forEach {
                try validate($0, name:"header[]", max: 255)
                try validate($0, name:"header[]", min: 1)
                try validate($0, name:"header[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(quoteSymbol, name:"quoteSymbol", max: 1)
            try validate(quoteSymbol, name:"quoteSymbol", min: 1)
            try validate(quoteSymbol, name:"quoteSymbol", pattern: "[^\\r\\n]")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case creationTime = "CreationTime"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
            case version = "Version"
        }
    }

    public enum CsvHeaderOption: String, CustomStringConvertible, Codable {
        case unknown = "UNKNOWN"
        case present = "PRESENT"
        case absent = "ABSENT"
        public var description: String { return self.rawValue }
    }

    public struct DataCatalogEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionPasswordEncryption", required: false, type: .structure), 
            AWSShapeMember(label: "EncryptionAtRest", required: false, type: .structure)
        ]

        /// When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption.
        public let connectionPasswordEncryption: ConnectionPasswordEncryption?
        /// Specifies the encryption-at-rest configuration for the Data Catalog.
        public let encryptionAtRest: EncryptionAtRest?

        public init(connectionPasswordEncryption: ConnectionPasswordEncryption? = nil, encryptionAtRest: EncryptionAtRest? = nil) {
            self.connectionPasswordEncryption = connectionPasswordEncryption
            self.encryptionAtRest = encryptionAtRest
        }

        public func validate() throws {
            try connectionPasswordEncryption?.validate()
            try encryptionAtRest?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPasswordEncryption = "ConnectionPasswordEncryption"
            case encryptionAtRest = "EncryptionAtRest"
        }
    }

    public struct Database: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "LocationUri", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map)
        ]

        /// The time at which the metadata database was created in the catalog.
        public let createTime: TimeStamp?
        /// Description of the database.
        public let description: String?
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// Name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// These key-value pairs define parameters and properties of the database.
        public let parameters: [String: String]?

        public init(createTime: TimeStamp? = nil, description: String? = nil, locationUri: String? = nil, name: String, parameters: [String: String]? = nil) {
            self.createTime = createTime
            self.description = description
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
        }

        public func validate() throws {
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(locationUri, name:"locationUri", max: 1024)
            try validate(locationUri, name:"locationUri", min: 1)
            try validate(locationUri, name:"locationUri", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case description = "Description"
            case locationUri = "LocationUri"
            case name = "Name"
            case parameters = "Parameters"
        }
    }

    public struct DatabaseInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "LocationUri", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map)
        ]

        /// Description of the database
        public let description: String?
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// Name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// Thes key-value pairs define parameters and properties of the database.
        public let parameters: [String: String]?

        public init(description: String? = nil, locationUri: String? = nil, name: String, parameters: [String: String]? = nil) {
            self.description = description
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
        }

        public func validate() throws {
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(locationUri, name:"locationUri", max: 1024)
            try validate(locationUri, name:"locationUri", min: 1)
            try validate(locationUri, name:"locationUri", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case locationUri = "LocationUri"
            case name = "Name"
            case parameters = "Parameters"
        }
    }

    public enum DeleteBehavior: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case deleteFromDatabase = "DELETE_FROM_DATABASE"
        case deprecateInDatabase = "DEPRECATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Name of the classifier to remove.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteClassifierResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog in which the connection resides. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the connection to delete.
        public let connectionName: String

        public init(catalogId: String? = nil, connectionName: String) {
            self.catalogId = catalogId
            self.connectionName = connectionName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(connectionName, name:"connectionName", max: 255)
            try validate(connectionName, name:"connectionName", min: 1)
            try validate(connectionName, name:"connectionName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
        }
    }

    public struct DeleteConnectionResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the crawler to remove.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteCrawlerResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the Database to delete. For Hive compatibility, this must be all lowercase.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct DeleteDatabaseResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]

        /// The name of the DevEndpoint.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct DeleteDevEndpointResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]

        /// The name of the job definition to delete.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DeleteJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]

        /// The name of the job definition that was deleted.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DeletePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionValues", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the table where the partition to be deleted is located.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionValues.forEach {
                try validate($0, name:"partitionValues[]", max: 1024)
            }
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct DeletePartitionResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteResourcePolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PolicyHashCondition", required: false, type: .string)
        ]

        /// The hash value returned when this policy was set.
        public let policyHashCondition: String?

        public init(policyHashCondition: String? = nil) {
            self.policyHashCondition = policyHashCondition
        }

        public func validate() throws {
            try validate(policyHashCondition, name:"policyHashCondition", max: 255)
            try validate(policyHashCondition, name:"policyHashCondition", min: 1)
            try validate(policyHashCondition, name:"policyHashCondition", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case policyHashCondition = "PolicyHashCondition"
        }
    }

    public struct DeleteResourcePolicyResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteSecurityConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the security configuration to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteSecurityConfigurationResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.
        public let name: String

        public init(catalogId: String? = nil, databaseName: String, name: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
        }
    }

    public struct DeleteTableResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteTableVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "VersionId", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// The ID of the table version to be deleted. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String

        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionId: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(versionId, name:"versionId", max: 255)
            try validate(versionId, name:"versionId", min: 1)
            try validate(versionId, name:"versionId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct DeleteTableVersionResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the trigger to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the trigger that was deleted.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "FunctionName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function is located.
        public let databaseName: String
        /// The name of the function definition to be deleted.
        public let functionName: String

        public init(catalogId: String? = nil, databaseName: String, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionName = functionName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(functionName, name:"functionName", max: 255)
            try validate(functionName, name:"functionName", min: 1)
            try validate(functionName, name:"functionName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
        }
    }

    public struct DeleteUserDefinedFunctionResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteWorkflowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Name of the workflow to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteWorkflowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// Name of the workflow specified in input.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DevEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "EndpointName", required: false, type: .string), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastUpdateStatus", required: false, type: .string), 
            AWSShapeMember(label: "NumberOfNodes", required: false, type: .integer), 
            AWSShapeMember(label: "PrivateAddress", required: false, type: .string), 
            AWSShapeMember(label: "PublicAddress", required: false, type: .string), 
            AWSShapeMember(label: "PublicKey", required: false, type: .string), 
            AWSShapeMember(label: "PublicKeys", required: false, type: .list), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string), 
            AWSShapeMember(label: "YarnEndpointAddress", required: false, type: .string), 
            AWSShapeMember(label: "ZeppelinRemoteSparkInterpreterPort", required: false, type: .integer)
        ]

        /// A map of arguments used to configure the DevEndpoint. Note that currently, we only support "--enable-glue-datacatalog": "" as a valid argument.
        public let arguments: [String: String]?
        /// The AWS availability zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: TimeStamp?
        /// The name of the DevEndpoint.
        public let endpointName: String?
        /// Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint. Please note that only pure Java/Scala libraries can currently be used on a DevEndpoint.
        public let extraJarsS3Path: String?
        /// Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// The point in time at which this DevEndpoint was last modified.
        public let lastModifiedTimestamp: TimeStamp?
        /// The status of the last update.
        public let lastUpdateStatus: String?
        /// The number of AWS Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int32?
        /// A private IP address to access the DevEndpoint within a VPC, if the DevEndpoint is created within one. The PrivateAddress field is present only when you create the DevEndpoint within your virtual private cloud (VPC).
        public let privateAddress: String?
        /// The public IP address used by this DevEndpoint. The PublicAddress field is present only when you create a non-VPC (virtual private cloud) DevEndpoint.
        public let publicAddress: String?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility, as the recommended attribute to use is public keys.
        public let publicKey: String?
        /// A list of public keys to be used by the DevEndpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys: call the UpdateDevEndpoint API with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute. 
        public let publicKeys: [String]?
        /// The AWS ARN of the IAM role used in this DevEndpoint.
        public let roleArn: String?
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public let securityConfiguration: String?
        /// A list of security group identifiers used in this DevEndpoint.
        public let securityGroupIds: [String]?
        /// The current status of this DevEndpoint.
        public let status: String?
        /// The subnet ID for this DevEndpoint.
        public let subnetId: String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public let vpcId: String?
        /// The YARN endpoint address used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int32?

        public init(arguments: [String: String]? = nil, availabilityZone: String? = nil, createdTimestamp: TimeStamp? = nil, endpointName: String? = nil, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, failureReason: String? = nil, lastModifiedTimestamp: TimeStamp? = nil, lastUpdateStatus: String? = nil, numberOfNodes: Int32? = nil, privateAddress: String? = nil, publicAddress: String? = nil, publicKey: String? = nil, publicKeys: [String]? = nil, roleArn: String? = nil, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, status: String? = nil, subnetId: String? = nil, vpcId: String? = nil, yarnEndpointAddress: String? = nil, zeppelinRemoteSparkInterpreterPort: Int32? = nil) {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.lastUpdateStatus = lastUpdateStatus
            self.numberOfNodes = numberOfNodes
            self.privateAddress = privateAddress
            self.publicAddress = publicAddress
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }

        public func validate() throws {
            try validate(publicKeys, name:"publicKeys", max: 5)
            try validate(roleArn, name:"roleArn", pattern: "arn:aws:iam::\\d{12}:role/.*")
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case failureReason = "FailureReason"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case lastUpdateStatus = "LastUpdateStatus"
            case numberOfNodes = "NumberOfNodes"
            case privateAddress = "PrivateAddress"
            case publicAddress = "PublicAddress"
            case publicKey = "PublicKey"
            case publicKeys = "PublicKeys"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
        }
    }

    public struct DevEndpointCustomLibraries: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string)
        ]

        /// Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint. Please note that only pure Java/Scala libraries can currently be used on a DevEndpoint.
        public let extraJarsS3Path: String?
        /// Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?

        public init(extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil) {
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        }
    }

    public struct DynamoDBTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Path", required: false, type: .string)
        ]

        /// The name of the DynamoDB table to crawl.
        public let path: String?

        public init(path: String? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct Edge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationId", required: false, type: .string), 
            AWSShapeMember(label: "SourceId", required: false, type: .string)
        ]

        /// The unique of the node within the workflow where the edge ends.
        public let destinationId: String?
        /// The unique of the node within the workflow where the edge starts.
        public let sourceId: String?

        public init(destinationId: String? = nil, sourceId: String? = nil) {
            self.destinationId = destinationId
            self.sourceId = sourceId
        }

        public func validate() throws {
            try validate(destinationId, name:"destinationId", max: 255)
            try validate(destinationId, name:"destinationId", min: 1)
            try validate(destinationId, name:"destinationId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(sourceId, name:"sourceId", max: 255)
            try validate(sourceId, name:"sourceId", min: 1)
            try validate(sourceId, name:"sourceId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "DestinationId"
            case sourceId = "SourceId"
        }
    }

    public struct EncryptionAtRest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogEncryptionMode", required: true, type: .enum), 
            AWSShapeMember(label: "SseAwsKmsKeyId", required: false, type: .string)
        ]

        /// The encryption-at-rest mode for encrypting Data Catalog data.
        public let catalogEncryptionMode: CatalogEncryptionMode
        /// The ID of the AWS KMS key to use for encryption at rest.
        public let sseAwsKmsKeyId: String?

        public init(catalogEncryptionMode: CatalogEncryptionMode, sseAwsKmsKeyId: String? = nil) {
            self.catalogEncryptionMode = catalogEncryptionMode
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
        }

        public func validate() throws {
            try validate(sseAwsKmsKeyId, name:"sseAwsKmsKeyId", max: 255)
            try validate(sseAwsKmsKeyId, name:"sseAwsKmsKeyId", min: 1)
            try validate(sseAwsKmsKeyId, name:"sseAwsKmsKeyId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogEncryptionMode = "CatalogEncryptionMode"
            case sseAwsKmsKeyId = "SseAwsKmsKeyId"
        }
    }

    public struct EncryptionConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CloudWatchEncryption", required: false, type: .structure), 
            AWSShapeMember(label: "JobBookmarksEncryption", required: false, type: .structure), 
            AWSShapeMember(label: "S3Encryption", required: false, type: .list)
        ]

        /// The encryption configuration for CloudWatch.
        public let cloudWatchEncryption: CloudWatchEncryption?
        /// The encryption configuration for Job Bookmarks.
        public let jobBookmarksEncryption: JobBookmarksEncryption?
        /// The encryption configuration for S3 data.
        public let s3Encryption: [S3Encryption]?

        public init(cloudWatchEncryption: CloudWatchEncryption? = nil, jobBookmarksEncryption: JobBookmarksEncryption? = nil, s3Encryption: [S3Encryption]? = nil) {
            self.cloudWatchEncryption = cloudWatchEncryption
            self.jobBookmarksEncryption = jobBookmarksEncryption
            self.s3Encryption = s3Encryption
        }

        public func validate() throws {
            try cloudWatchEncryption?.validate()
            try jobBookmarksEncryption?.validate()
            try s3Encryption?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryption = "CloudWatchEncryption"
            case jobBookmarksEncryption = "JobBookmarksEncryption"
            case s3Encryption = "S3Encryption"
        }
    }

    public struct ErrorDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string)
        ]

        /// The code associated with this error.
        public let errorCode: String?
        /// A message describing the error.
        public let errorMessage: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        public func validate() throws {
            try validate(errorCode, name:"errorCode", max: 255)
            try validate(errorCode, name:"errorCode", min: 1)
            try validate(errorCode, name:"errorCode", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(errorMessage, name:"errorMessage", max: 2048)
            try validate(errorMessage, name:"errorMessage", min: 0)
            try validate(errorMessage, name:"errorMessage", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct ExecutionProperty: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxConcurrentRuns", required: false, type: .integer)
        ]

        /// The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.
        public let maxConcurrentRuns: Int32?

        public init(maxConcurrentRuns: Int32? = nil) {
            self.maxConcurrentRuns = maxConcurrentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrentRuns = "MaxConcurrentRuns"
        }
    }

    public enum ExistCondition: String, CustomStringConvertible, Codable {
        case mustExist = "MUST_EXIST"
        case notExist = "NOT_EXIST"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct GetCatalogImportStatusRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]

        /// The ID of the catalog to migrate. Currently, this should be the AWS account ID.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetCatalogImportStatusResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportStatus", required: false, type: .structure)
        ]

        /// The status of the specified catalog migration.
        public let importStatus: CatalogImportStatus?

        public init(importStatus: CatalogImportStatus? = nil) {
            self.importStatus = importStatus
        }

        public func validate() throws {
            try importStatus?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case importStatus = "ImportStatus"
        }
    }

    public struct GetClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Name of the classifier to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetClassifierResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classifier", required: false, type: .structure)
        ]

        /// The requested classifier.
        public let classifier: Classifier?

        public init(classifier: Classifier? = nil) {
            self.classifier = classifier
        }

        public func validate() throws {
            try classifier?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case classifier = "Classifier"
        }
    }

    public struct GetClassifiersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The size of the list to return (optional).
        public let maxResults: Int32?
        /// An optional continuation token.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetClassifiersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The requested list of classifier objects.
        public let classifiers: [Classifier]?
        /// A continuation token.
        public let nextToken: String?

        public init(classifiers: [Classifier]? = nil, nextToken: String? = nil) {
            self.classifiers = classifiers
            self.nextToken = nextToken
        }

        public func validate() throws {
            try classifiers?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case nextToken = "NextToken"
        }
    }

    public struct GetConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "HidePassword", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog in which the connection resides. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// Allows you to retrieve the connection metadata without returning the password. For instance, the AWS Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the AWS KMS key to decrypt the password, but does have permission to access the rest of the connection properties.
        public let hidePassword: Bool?
        /// The name of the connection definition to retrieve.
        public let name: String

        public init(catalogId: String? = nil, hidePassword: Bool? = nil, name: String) {
            self.catalogId = catalogId
            self.hidePassword = hidePassword
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case hidePassword = "HidePassword"
            case name = "Name"
        }
    }

    public struct GetConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connection", required: false, type: .structure)
        ]

        /// The requested connection definition.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        public func validate() throws {
            try connection?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct GetConnectionsFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionType", required: false, type: .enum), 
            AWSShapeMember(label: "MatchCriteria", required: false, type: .list)
        ]

        /// The type of connections to return. Currently, only JDBC is supported; SFTP is not supported.
        public let connectionType: ConnectionType?
        /// A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.
        public let matchCriteria: [String]?

        public init(connectionType: ConnectionType? = nil, matchCriteria: [String]? = nil) {
            self.connectionType = connectionType
            self.matchCriteria = matchCriteria
        }

        public func validate() throws {
            try matchCriteria?.forEach {
                try validate($0, name:"matchCriteria[]", max: 255)
                try validate($0, name:"matchCriteria[]", min: 1)
                try validate($0, name:"matchCriteria[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(matchCriteria, name:"matchCriteria", max: 10)
            try validate(matchCriteria, name:"matchCriteria", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionType = "ConnectionType"
            case matchCriteria = "MatchCriteria"
        }
    }

    public struct GetConnectionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Filter", required: false, type: .structure), 
            AWSShapeMember(label: "HidePassword", required: false, type: .boolean), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The ID of the Data Catalog in which the connections reside. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// A filter that controls which connections will be returned.
        public let filter: GetConnectionsFilter?
        /// Allows you to retrieve the connection metadata without returning the password. For instance, the AWS Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the AWS KMS key to decrypt the password, but does have permission to access the rest of the connection properties.
        public let hidePassword: Bool?
        /// The maximum number of connections to return in one response.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(catalogId: String? = nil, filter: GetConnectionsFilter? = nil, hidePassword: Bool? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.filter = filter
            self.hidePassword = hidePassword
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try filter?.validate()
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case filter = "Filter"
            case hidePassword = "HidePassword"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetConnectionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionList", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of requested connection definitions.
        public let connectionList: [Connection]?
        /// A continuation token, if the list of connections returned does not include the last of the filtered connections.
        public let nextToken: String?

        public init(connectionList: [Connection]? = nil, nextToken: String? = nil) {
            self.connectionList = connectionList
            self.nextToken = nextToken
        }

        public func validate() throws {
            try connectionList?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectionList = "ConnectionList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerMetricsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerNameList", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of the names of crawlers about which to retrieve metrics.
        public let crawlerNameList: [String]?
        /// The maximum size of a list to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(crawlerNameList: [String]? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.crawlerNameList = crawlerNameList
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try crawlerNameList?.forEach {
                try validate($0, name:"crawlerNameList[]", max: 255)
                try validate($0, name:"crawlerNameList[]", min: 1)
                try validate($0, name:"crawlerNameList[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlerNameList, name:"crawlerNameList", max: 100)
            try validate(crawlerNameList, name:"crawlerNameList", min: 0)
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNameList = "CrawlerNameList"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerMetricsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerMetricsList", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of metrics for the specified crawler.
        public let crawlerMetricsList: [CrawlerMetrics]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(crawlerMetricsList: [CrawlerMetrics]? = nil, nextToken: String? = nil) {
            self.crawlerMetricsList = crawlerMetricsList
            self.nextToken = nextToken
        }

        public func validate() throws {
            try crawlerMetricsList?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerMetricsList = "CrawlerMetricsList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the crawler to retrieve metadata for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetCrawlerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Crawler", required: false, type: .structure)
        ]

        /// The metadata for the specified crawler.
        public let crawler: Crawler?

        public init(crawler: Crawler? = nil) {
            self.crawler = crawler
        }

        public func validate() throws {
            try crawler?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case crawler = "Crawler"
        }
    }

    public struct GetCrawlersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The number of crawlers to return on each call.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Crawlers", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of crawler metadata.
        public let crawlers: [Crawler]?
        /// A continuation token, if the returned list has not reached the end of those defined in this customer account.
        public let nextToken: String?

        public init(crawlers: [Crawler]? = nil, nextToken: String? = nil) {
            self.crawlers = crawlers
            self.nextToken = nextToken
        }

        public func validate() throws {
            try crawlers?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case nextToken = "NextToken"
        }
    }

    public struct GetDataCatalogEncryptionSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]

        /// The ID of the Data Catalog for which to retrieve the security configuration. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetDataCatalogEncryptionSettingsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DataCatalogEncryptionSettings", required: false, type: .structure)
        ]

        /// The requested security configuration.
        public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?

        public init(dataCatalogEncryptionSettings: DataCatalogEncryptionSettings? = nil) {
            self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
        }

        public func validate() throws {
            try dataCatalogEncryptionSettings?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
        }
    }

    public struct GetDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the database to retrieve. For Hive compatibility, this should be all lowercase.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct GetDatabaseResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Database", required: false, type: .structure)
        ]

        /// The definition of the specified database in the catalog.
        public let database: Database?

        public init(database: Database? = nil) {
            self.database = database
        }

        public func validate() throws {
            try database?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct GetDatabasesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The ID of the Data Catalog from which to retrieve Databases. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The maximum number of databases to return in one response.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(catalogId: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetDatabasesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseList", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of Database objects from the specified catalog.
        public let databaseList: [Database]
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?

        public init(databaseList: [Database], nextToken: String? = nil) {
            self.databaseList = databaseList
            self.nextToken = nextToken
        }

        public func validate() throws {
            try databaseList.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case databaseList = "DatabaseList"
            case nextToken = "NextToken"
        }
    }

    public struct GetDataflowGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PythonScript", required: false, type: .string)
        ]

        /// The Python script to transform.
        public let pythonScript: String?

        public init(pythonScript: String? = nil) {
            self.pythonScript = pythonScript
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
        }
    }

    public struct GetDataflowGraphResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DagEdges", required: false, type: .list), 
            AWSShapeMember(label: "DagNodes", required: false, type: .list)
        ]

        /// A list of the edges in the resulting DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the resulting DAG.
        public let dagNodes: [CodeGenNode]?

        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
        }

        public func validate() throws {
            try dagEdges?.forEach {
                try $0.validate()
            }
            try dagNodes?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
        }
    }

    public struct GetDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]

        /// Name of the DevEndpoint for which to retrieve information.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct GetDevEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DevEndpoint", required: false, type: .structure)
        ]

        /// A DevEndpoint definition.
        public let devEndpoint: DevEndpoint?

        public init(devEndpoint: DevEndpoint? = nil) {
            self.devEndpoint = devEndpoint
        }

        public func validate() throws {
            try devEndpoint?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoint = "DevEndpoint"
        }
    }

    public struct GetDevEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The maximum size of information to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DevEndpoints", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?
        /// A continuation token, if not all DevEndpoint definitions have yet been returned.
        public let nextToken: String?

        public init(devEndpoints: [DevEndpoint]? = nil, nextToken: String? = nil) {
            self.devEndpoints = devEndpoints
            self.nextToken = nextToken
        }

        public func validate() throws {
            try devEndpoints?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoints = "DevEndpoints"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]

        /// The name of the job definition to retrieve.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct GetJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", required: false, type: .structure)
        ]

        /// The requested job definition.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        public func validate() throws {
            try job?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case job = "Job"
        }
    }

    public struct GetJobRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "PredecessorsIncluded", required: false, type: .boolean), 
            AWSShapeMember(label: "RunId", required: true, type: .string)
        ]

        /// Name of the job definition being run.
        public let jobName: String
        /// True if a list of predecessor runs should be returned.
        public let predecessorsIncluded: Bool?
        /// The ID of the job run.
        public let runId: String

        public init(jobName: String, predecessorsIncluded: Bool? = nil, runId: String) {
            self.jobName = jobName
            self.predecessorsIncluded = predecessorsIncluded
            self.runId = runId
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(runId, name:"runId", max: 255)
            try validate(runId, name:"runId", min: 1)
            try validate(runId, name:"runId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case predecessorsIncluded = "PredecessorsIncluded"
            case runId = "RunId"
        }
    }

    public struct GetJobRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRun", required: false, type: .structure)
        ]

        /// The requested job-run metadata.
        public let jobRun: JobRun?

        public init(jobRun: JobRun? = nil) {
            self.jobRun = jobRun
        }

        public func validate() throws {
            try jobRun?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case jobRun = "JobRun"
        }
    }

    public struct GetJobRunsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The name of the job definition for which to retrieve all job runs.
        public let jobName: String
        /// The maximum size of the response.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(jobName: String, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobRunsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRuns", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of job-run metadata objects.
        public let jobRuns: [JobRun]?
        /// A continuation token, if not all requested job runs have been returned.
        public let nextToken: String?

        public init(jobRuns: [JobRun]? = nil, nextToken: String? = nil) {
            self.jobRuns = jobRuns
            self.nextToken = nextToken
        }

        public func validate() throws {
            try jobRuns?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The maximum size of the response.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Jobs", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// A list of job definitions.
        public let jobs: [Job]?
        /// A continuation token, if not all job definitions have yet been returned.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        public func validate() throws {
            try jobs?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct GetMappingRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Sinks", required: false, type: .list), 
            AWSShapeMember(label: "Source", required: true, type: .structure)
        ]

        /// Parameters for the mapping.
        public let location: Location?
        /// A list of target tables.
        public let sinks: [CatalogEntry]?
        /// Specifies the source table.
        public let source: CatalogEntry

        public init(location: Location? = nil, sinks: [CatalogEntry]? = nil, source: CatalogEntry) {
            self.location = location
            self.sinks = sinks
            self.source = source
        }

        public func validate() throws {
            try location?.validate()
            try sinks?.forEach {
                try $0.validate()
            }
            try source.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case sinks = "Sinks"
            case source = "Source"
        }
    }

    public struct GetMappingResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Mapping", required: true, type: .list)
        ]

        /// A list of mappings to the specified targets.
        public let mapping: [MappingEntry]

        public init(mapping: [MappingEntry]) {
            self.mapping = mapping
        }

        private enum CodingKeys: String, CodingKey {
            case mapping = "Mapping"
        }
    }

    public struct GetPartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionValues", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the partition in question resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partition resides.
        public let databaseName: String
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the partition's table.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionValues.forEach {
                try validate($0, name:"partitionValues[]", max: 1024)
            }
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Partition", required: false, type: .structure)
        ]

        /// The requested information, in the form of a Partition object.
        public let partition: Partition?

        public init(partition: Partition? = nil) {
            self.partition = partition
        }

        public func validate() throws {
            try partition?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case partition = "Partition"
        }
    }

    public struct GetPartitionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Expression", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Segment", required: false, type: .structure), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// An expression filtering the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks if the values of the two operands are equal or not; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.  &lt; &gt;  Checks if the values of two operands are equal or not; if the values are not equal, then the condition becomes true. Example: (a &lt; &gt; b) is true.  &gt;  Checks if the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a &gt; b) is not true.  &lt;  Checks if the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a &lt; b) is true.  &gt;=  Checks if the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a &gt;= b) is not true.  &lt;=  Checks if the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a &lt;= b) is true.  AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an invalid type is encountered, an exception is thrown.  The following list shows the valid operators on each type. When you define a crawler, the partitionKey type is created as a STRING, to be compatible with the catalog partitions.   Sample API Call: 
        public let expression: String?
        /// The maximum number of partitions to return in a single response.
        public let maxResults: Int32?
        /// A continuation token, if this is not the first call to retrieve these partitions.
        public let nextToken: String?
        /// The segment of the table's partitions to scan in this request.
        public let segment: Segment?
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, expression: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil, segment: Segment? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.expression = expression
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.segment = segment
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(expression, name:"expression", max: 2048)
            try validate(expression, name:"expression", min: 0)
            try validate(expression, name:"expression", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try segment?.validate()
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case expression = "Expression"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case segment = "Segment"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Partitions", required: false, type: .list)
        ]

        /// A continuation token, if the returned list of partitions does not does not include the last one.
        public let nextToken: String?
        /// A list of requested partitions.
        public let partitions: [Partition]?

        public init(nextToken: String? = nil, partitions: [Partition]? = nil) {
            self.nextToken = nextToken
            self.partitions = partitions
        }

        public func validate() throws {
            try partitions?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case partitions = "Partitions"
        }
    }

    public struct GetPlanRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Language", required: false, type: .enum), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Mapping", required: true, type: .list), 
            AWSShapeMember(label: "Sinks", required: false, type: .list), 
            AWSShapeMember(label: "Source", required: true, type: .structure)
        ]

        /// The programming language of the code to perform the mapping.
        public let language: Language?
        /// The parameters for the mapping.
        public let location: Location?
        /// The list of mappings from a source table to target tables.
        public let mapping: [MappingEntry]
        /// The target tables.
        public let sinks: [CatalogEntry]?
        /// The source table.
        public let source: CatalogEntry

        public init(language: Language? = nil, location: Location? = nil, mapping: [MappingEntry], sinks: [CatalogEntry]? = nil, source: CatalogEntry) {
            self.language = language
            self.location = location
            self.mapping = mapping
            self.sinks = sinks
            self.source = source
        }

        public func validate() throws {
            try location?.validate()
            try sinks?.forEach {
                try $0.validate()
            }
            try source.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case language = "Language"
            case location = "Location"
            case mapping = "Mapping"
            case sinks = "Sinks"
            case source = "Source"
        }
    }

    public struct GetPlanResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PythonScript", required: false, type: .string), 
            AWSShapeMember(label: "ScalaCode", required: false, type: .string)
        ]

        /// A Python script to perform the mapping.
        public let pythonScript: String?
        /// The Scala code to perform the mapping.
        public let scalaCode: String?

        public init(pythonScript: String? = nil, scalaCode: String? = nil) {
            self.pythonScript = pythonScript
            self.scalaCode = scalaCode
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
            case scalaCode = "ScalaCode"
        }
    }

    public struct GetResourcePolicyRequest: AWSShape {


        public init() {
        }

    }

    public struct GetResourcePolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "PolicyHash", required: false, type: .string), 
            AWSShapeMember(label: "PolicyInJson", required: false, type: .string), 
            AWSShapeMember(label: "UpdateTime", required: false, type: .timestamp)
        ]

        /// The date and time at which the policy was created.
        public let createTime: TimeStamp?
        /// Contains the hash value associated with this policy.
        public let policyHash: String?
        /// Contains the requested policy document, in JSON format.
        public let policyInJson: String?
        /// The date and time at which the policy was last updated.
        public let updateTime: TimeStamp?

        public init(createTime: TimeStamp? = nil, policyHash: String? = nil, policyInJson: String? = nil, updateTime: TimeStamp? = nil) {
            self.createTime = createTime
            self.policyHash = policyHash
            self.policyInJson = policyInJson
            self.updateTime = updateTime
        }

        public func validate() throws {
            try validate(policyHash, name:"policyHash", max: 255)
            try validate(policyHash, name:"policyHash", min: 1)
            try validate(policyHash, name:"policyHash", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(policyInJson, name:"policyInJson", max: 10240)
            try validate(policyInJson, name:"policyInJson", min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case policyHash = "PolicyHash"
            case policyInJson = "PolicyInJson"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetSecurityConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the security configuration to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetSecurityConfigurationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .structure)
        ]

        /// The requested security configuration
        public let securityConfiguration: SecurityConfiguration?

        public init(securityConfiguration: SecurityConfiguration? = nil) {
            self.securityConfiguration = securityConfiguration
        }

        public func validate() throws {
            try securityConfiguration?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfiguration = "SecurityConfiguration"
        }
    }

    public struct GetSecurityConfigurationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The maximum number of results to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetSecurityConfigurationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SecurityConfigurations", required: false, type: .list)
        ]

        /// A continuation token, if there are more security configurations to return.
        public let nextToken: String?
        /// A list of security configurations.
        public let securityConfigurations: [SecurityConfiguration]?

        public init(nextToken: String? = nil, securityConfigurations: [SecurityConfiguration]? = nil) {
            self.nextToken = nextToken
            self.securityConfigurations = securityConfigurations
        }

        public func validate() throws {
            try securityConfigurations?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityConfigurations = "SecurityConfigurations"
        }
    }

    public struct GetTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table for which to retrieve the definition. For Hive compatibility, this name is entirely lowercase.
        public let name: String

        public init(catalogId: String? = nil, databaseName: String, name: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
        }
    }

    public struct GetTableResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Table", required: false, type: .structure)
        ]

        /// The Table object that defines the specified table.
        public let table: Table?

        public init(table: Table? = nil) {
            self.table = table
        }

        public func validate() throws {
            try table?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct GetTableVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "VersionId", required: false, type: .string)
        ]

        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// The ID value of the table version to be retrieved. A VersionID is a string representation of an integer. Each version is incremented by 1. 
        public let versionId: String?

        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(versionId, name:"versionId", max: 255)
            try validate(versionId, name:"versionId", min: 1)
            try validate(versionId, name:"versionId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct GetTableVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableVersion", required: false, type: .structure)
        ]

        /// The requested table version.
        public let tableVersion: TableVersion?

        public init(tableVersion: TableVersion? = nil) {
            self.tableVersion = tableVersion
        }

        public func validate() throws {
            try tableVersion?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case tableVersion = "TableVersion"
        }
    }

    public struct GetTableVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The maximum number of table versions to return in one response.
        public let maxResults: Int32?
        /// A continuation token, if this is not the first call.
        public let nextToken: String?
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, maxResults: Int32? = nil, nextToken: String? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tableName = "TableName"
        }
    }

    public struct GetTableVersionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TableVersions", required: false, type: .list)
        ]

        /// A continuation token, if the list of available versions does not include the last one.
        public let nextToken: String?
        /// A list of strings identifying available versions of the specified table.
        public let tableVersions: [TableVersion]?

        public init(nextToken: String? = nil, tableVersions: [TableVersion]? = nil) {
            self.nextToken = nextToken
            self.tableVersions = tableVersions
        }

        public func validate() throws {
            try tableVersions?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableVersions = "TableVersions"
        }
    }

    public struct GetTablesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Expression", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A regular expression pattern. If present, only those tables whose names match the pattern are returned.
        public let expression: String?
        /// The maximum number of tables to return in a single response.
        public let maxResults: Int32?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?

        public init(catalogId: String? = nil, databaseName: String, expression: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.expression = expression
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(expression, name:"expression", max: 2048)
            try validate(expression, name:"expression", min: 0)
            try validate(expression, name:"expression", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case expression = "Expression"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTablesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TableList", required: false, type: .list)
        ]

        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of the requested Table objects.
        public let tableList: [Table]?

        public init(nextToken: String? = nil, tableList: [Table]? = nil) {
            self.nextToken = nextToken
            self.tableList = tableList
        }

        public func validate() throws {
            try tableList?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableList = "TableList"
        }
    }

    public struct GetTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the resource for which to retrieve tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate() throws {
            try validate(resourceArn, name:"resourceArn", max: 10240)
            try validate(resourceArn, name:"resourceArn", min: 1)
            try validate(resourceArn, name:"resourceArn", pattern: "arn:aws:glue:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetTagsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// The requested tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct GetTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the trigger to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Trigger", required: false, type: .structure)
        ]

        /// The requested trigger definition.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        public func validate() throws {
            try trigger?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct GetTriggersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DependentJobName", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The name of the job to retrieve triggers for. The trigger that can start this job is returned, and if there is no such trigger, all triggers are returned.
        public let dependentJobName: String?
        /// The maximum size of the response.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(dependentJobName: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.dependentJobName = dependentJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(dependentJobName, name:"dependentJobName", max: 255)
            try validate(dependentJobName, name:"dependentJobName", min: 1)
            try validate(dependentJobName, name:"dependentJobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTriggersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Triggers", required: false, type: .list)
        ]

        /// A continuation token, if not all the requested triggers have yet been returned.
        public let nextToken: String?
        /// A list of triggers for the specified job.
        public let triggers: [Trigger]?

        public init(nextToken: String? = nil, triggers: [Trigger]? = nil) {
            self.nextToken = nextToken
            self.triggers = triggers
        }

        public func validate() throws {
            try triggers?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggers = "Triggers"
        }
    }

    public struct GetUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "FunctionName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the function to be retrieved is located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function is located.
        public let databaseName: String
        /// The name of the function.
        public let functionName: String

        public init(catalogId: String? = nil, databaseName: String, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionName = functionName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(functionName, name:"functionName", max: 255)
            try validate(functionName, name:"functionName", min: 1)
            try validate(functionName, name:"functionName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
        }
    }

    public struct GetUserDefinedFunctionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserDefinedFunction", required: false, type: .structure)
        ]

        /// The requested function definition.
        public let userDefinedFunction: UserDefinedFunction?

        public init(userDefinedFunction: UserDefinedFunction? = nil) {
            self.userDefinedFunction = userDefinedFunction
        }

        public func validate() throws {
            try userDefinedFunction?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case userDefinedFunction = "UserDefinedFunction"
        }
    }

    public struct GetUserDefinedFunctionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Pattern", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the functions to be retrieved are located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the functions are located.
        public let databaseName: String
        /// The maximum number of functions to return in one response.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// An optional function-name pattern string that filters the function definitions returned.
        public let pattern: String

        public init(catalogId: String? = nil, databaseName: String, maxResults: Int32? = nil, nextToken: String? = nil, pattern: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pattern = pattern
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(pattern, name:"pattern", max: 255)
            try validate(pattern, name:"pattern", min: 1)
            try validate(pattern, name:"pattern", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pattern = "Pattern"
        }
    }

    public struct GetUserDefinedFunctionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "UserDefinedFunctions", required: false, type: .list)
        ]

        /// A continuation token, if the list of functions returned does not include the last requested function.
        public let nextToken: String?
        /// A list of requested function definitions.
        public let userDefinedFunctions: [UserDefinedFunction]?

        public init(nextToken: String? = nil, userDefinedFunctions: [UserDefinedFunction]? = nil) {
            self.nextToken = nextToken
            self.userDefinedFunctions = userDefinedFunctions
        }

        public func validate() throws {
            try userDefinedFunctions?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userDefinedFunctions = "UserDefinedFunctions"
        }
    }

    public struct GetWorkflowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IncludeGraph", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Specifies whether to include a graph when returning the workflow resource metadata.
        public let includeGraph: Bool?
        /// The name of the workflow to retrieve.
        public let name: String

        public init(includeGraph: Bool? = nil, name: String) {
            self.includeGraph = includeGraph
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case name = "Name"
        }
    }

    public struct GetWorkflowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Workflow", required: false, type: .structure)
        ]

        /// The resource metadata for the workflow.
        public let workflow: Workflow?

        public init(workflow: Workflow? = nil) {
            self.workflow = workflow
        }

        public func validate() throws {
            try workflow?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case workflow = "Workflow"
        }
    }

    public struct GetWorkflowRunPropertiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RunId", required: true, type: .string)
        ]

        /// Name of the workflow which was run.
        public let name: String
        /// The ID of the workflow run whose run properties should be returned.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(runId, name:"runId", max: 255)
            try validate(runId, name:"runId", min: 1)
            try validate(runId, name:"runId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct GetWorkflowRunPropertiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RunProperties", required: false, type: .map)
        ]

        /// The workflow run properties which were set during the specified run.
        public let runProperties: [String: String]?

        public init(runProperties: [String: String]? = nil) {
            self.runProperties = runProperties
        }

        private enum CodingKeys: String, CodingKey {
            case runProperties = "RunProperties"
        }
    }

    public struct GetWorkflowRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IncludeGraph", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RunId", required: true, type: .string)
        ]

        /// Specifies whether to include the workflow graph in response or not.
        public let includeGraph: Bool?
        /// Name of the workflow being run.
        public let name: String
        /// The ID of the workflow run.
        public let runId: String

        public init(includeGraph: Bool? = nil, name: String, runId: String) {
            self.includeGraph = includeGraph
            self.name = name
            self.runId = runId
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(runId, name:"runId", max: 255)
            try validate(runId, name:"runId", min: 1)
            try validate(runId, name:"runId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct GetWorkflowRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Run", required: false, type: .structure)
        ]

        /// The requested workflow run metadata.
        public let run: WorkflowRun?

        public init(run: WorkflowRun? = nil) {
            self.run = run
        }

        public func validate() throws {
            try run?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case run = "Run"
        }
    }

    public struct GetWorkflowRunsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IncludeGraph", required: false, type: .boolean), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Specifies whether to include the workflow graph in response or not.
        public let includeGraph: Bool?
        /// The maximum number of workflow runs to be included in the response.
        public let maxResults: Int32?
        /// Name of the workflow whose metadata of runs should be returned.
        public let name: String
        /// The maximum size of the response.
        public let nextToken: String?

        public init(includeGraph: Bool? = nil, maxResults: Int32? = nil, name: String, nextToken: String? = nil) {
            self.includeGraph = includeGraph
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case maxResults = "MaxResults"
            case name = "Name"
            case nextToken = "NextToken"
        }
    }

    public struct GetWorkflowRunsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Runs", required: false, type: .list)
        ]

        /// A continuation token, if not all requested workflow runs have been returned.
        public let nextToken: String?
        /// A list of workflow run metadata objects.
        public let runs: [WorkflowRun]?

        public init(nextToken: String? = nil, runs: [WorkflowRun]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        public func validate() throws {
            try runs?.forEach {
                try $0.validate()
            }
            try validate(runs, name:"runs", max: 1000)
            try validate(runs, name:"runs", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case runs = "Runs"
        }
    }

    public struct GrokClassifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CustomPatterns", required: false, type: .string), 
            AWSShapeMember(label: "GrokPattern", required: true, type: .string), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long)
        ]

        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.
        public let classification: String
        /// The time that this classifier was registered.
        public let creationTime: TimeStamp?
        /// Optional custom grok patterns defined by this classifier. For more information, see custom patterns in Writing Custom Classifiers.
        public let customPatterns: String?
        /// The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in Writing Custom Classifiers.
        public let grokPattern: String
        /// The time that this classifier was last updated.
        public let lastUpdated: TimeStamp?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        public init(classification: String, creationTime: TimeStamp? = nil, customPatterns: String? = nil, grokPattern: String, lastUpdated: TimeStamp? = nil, name: String, version: Int64? = nil) {
            self.classification = classification
            self.creationTime = creationTime
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }

        public func validate() throws {
            try validate(customPatterns, name:"customPatterns", max: 16000)
            try validate(customPatterns, name:"customPatterns", min: 0)
            try validate(customPatterns, name:"customPatterns", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(grokPattern, name:"grokPattern", max: 2048)
            try validate(grokPattern, name:"grokPattern", min: 1)
            try validate(grokPattern, name:"grokPattern", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case creationTime = "CreationTime"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct ImportCatalogToGlueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]

        /// The ID of the catalog to import. Currently, this should be the AWS account ID.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct ImportCatalogToGlueResponse: AWSShape {


        public init() {
        }

    }

    public struct JdbcTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionName", required: false, type: .string), 
            AWSShapeMember(label: "Exclusions", required: false, type: .list), 
            AWSShapeMember(label: "Path", required: false, type: .string)
        ]

        /// The name of the connection to use to connect to the JDBC target.
        public let connectionName: String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path of the JDBC target.
        public let path: String?

        public init(connectionName: String? = nil, exclusions: [String]? = nil, path: String? = nil) {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case exclusions = "Exclusions"
            case path = "Path"
        }
    }

    public struct Job: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Command", required: false, type: .structure), 
            AWSShapeMember(label: "Connections", required: false, type: .structure), 
            AWSShapeMember(label: "CreatedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "DefaultArguments", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ExecutionProperty", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "LogUri", required: false, type: .string), 
            AWSShapeMember(label: "MaxCapacity", required: false, type: .double), 
            AWSShapeMember(label: "MaxRetries", required: false, type: .integer), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "NotificationProperty", required: false, type: .structure), 
            AWSShapeMember(label: "NumberOfWorkers", required: false, type: .integer), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer), 
            AWSShapeMember(label: "WorkerType", required: false, type: .enum)
        ]

        /// The JobCommand that executes this job.
        public let command: JobCommand?
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The time and date that this job definition was created.
        public let createdOn: TimeStamp?
        /// The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
        public let defaultArguments: [String: String]?
        /// A description of the job.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// The last point in time when this job definition was modified.
        public let lastModifiedOn: TimeStamp?
        /// This field is reserved for future use.
        public let logUri: String?
        /// The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the AWS Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.  
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job after a JobRun fails.
        public let maxRetries: Int32?
        /// The name you assign to this job definition.
        public let name: String?
        /// Specifies configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X. 
        public let numberOfWorkers: Int32?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int32?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.  
        public let workerType: WorkerType?

        public init(command: JobCommand? = nil, connections: ConnectionsList? = nil, createdOn: TimeStamp? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, lastModifiedOn: TimeStamp? = nil, logUri: String? = nil, maxCapacity: Double? = nil, maxRetries: Int32? = nil, name: String? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int32? = nil, role: String? = nil, securityConfiguration: String? = nil, timeout: Int32? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionProperty = executionProperty
            self.lastModifiedOn = lastModifiedOn
            self.logUri = logUri
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate() throws {
            try command?.validate()
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try notificationProperty?.validate()
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(timeout, name:"timeout", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case createdOn = "CreatedOn"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case lastModifiedOn = "LastModifiedOn"
            case logUri = "LogUri"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct JobBookmarkEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attempt", required: false, type: .integer), 
            AWSShapeMember(label: "JobBookmark", required: false, type: .string), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "Run", required: false, type: .integer), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]

        /// The attempt ID number.
        public let attempt: Int32?
        /// The bookmark itself.
        public let jobBookmark: String?
        /// Name of the job in question.
        public let jobName: String?
        /// The run ID number.
        public let run: Int32?
        /// Version of the job.
        public let version: Int32?

        public init(attempt: Int32? = nil, jobBookmark: String? = nil, jobName: String? = nil, run: Int32? = nil, version: Int32? = nil) {
            self.attempt = attempt
            self.jobBookmark = jobBookmark
            self.jobName = jobName
            self.run = run
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case jobBookmark = "JobBookmark"
            case jobName = "JobName"
            case run = "Run"
            case version = "Version"
        }
    }

    public struct JobBookmarksEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobBookmarksEncryptionMode", required: false, type: .enum), 
            AWSShapeMember(label: "KmsKeyArn", required: false, type: .string)
        ]

        /// The encryption mode to use for Job bookmarks data.
        public let jobBookmarksEncryptionMode: JobBookmarksEncryptionMode?
        /// The AWS ARN of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        public init(jobBookmarksEncryptionMode: JobBookmarksEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.jobBookmarksEncryptionMode = jobBookmarksEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate() throws {
            try validate(kmsKeyArn, name:"kmsKeyArn", pattern: "arn:aws:kms:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarksEncryptionMode = "JobBookmarksEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public enum JobBookmarksEncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case cseKms = "CSE-KMS"
        public var description: String { return self.rawValue }
    }

    public struct JobCommand: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "PythonVersion", required: false, type: .string), 
            AWSShapeMember(label: "ScriptLocation", required: false, type: .string)
        ]

        /// The name of the job command. For an Apache Spark ETL job, this must be glueetl. For a Python shell job, it must be pythonshell.
        public let name: String?
        /// The Python version being used to execute a Python shell job. Allowed values are 2 or 3.
        public let pythonVersion: String?
        /// Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that executes a job.
        public let scriptLocation: String?

        public init(name: String? = nil, pythonVersion: String? = nil, scriptLocation: String? = nil) {
            self.name = name
            self.pythonVersion = pythonVersion
            self.scriptLocation = scriptLocation
        }

        public func validate() throws {
            try validate(pythonVersion, name:"pythonVersion", pattern: "^[2-3]$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case pythonVersion = "PythonVersion"
            case scriptLocation = "ScriptLocation"
        }
    }

    public struct JobNodeDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRuns", required: false, type: .list)
        ]

        /// The information for the job runs represented by the job node.
        public let jobRuns: [JobRun]?

        public init(jobRuns: [JobRun]? = nil) {
            self.jobRuns = jobRuns
        }

        public func validate() throws {
            try jobRuns?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
        }
    }

    public struct JobRun: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "Attempt", required: false, type: .integer), 
            AWSShapeMember(label: "CompletedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ExecutionTime", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "JobRunState", required: false, type: .enum), 
            AWSShapeMember(label: "LastModifiedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "LogGroupName", required: false, type: .string), 
            AWSShapeMember(label: "MaxCapacity", required: false, type: .double), 
            AWSShapeMember(label: "NotificationProperty", required: false, type: .structure), 
            AWSShapeMember(label: "NumberOfWorkers", required: false, type: .integer), 
            AWSShapeMember(label: "PredecessorRuns", required: false, type: .list), 
            AWSShapeMember(label: "PreviousRunId", required: false, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "StartedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer), 
            AWSShapeMember(label: "TriggerName", required: false, type: .string), 
            AWSShapeMember(label: "WorkerType", required: false, type: .enum)
        ]

        /// The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The number of the attempt to run this job.
        public let attempt: Int32?
        /// The date and time that this job run completed.
        public let completedOn: TimeStamp?
        /// An error message associated with this job run.
        public let errorMessage: String?
        /// The amount of time (in seconds) that the job run consumed resources.
        public let executionTime: Int32?
        /// The ID of this job run.
        public let id: String?
        /// The name of the job definition being used in this run.
        public let jobName: String?
        /// The current state of the job run.
        public let jobRunState: JobRunState?
        /// The last time that this job run was modified.
        public let lastModifiedOn: TimeStamp?
        /// The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using AWS KMS. This name can be /aws-glue/jobs/, in which case the default encryption is NONE. If you add a role name and SecurityConfiguration name (in other words, /aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/), then that security configuration is used to encrypt the log group.
        public let logGroupName: String?
        /// The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the AWS Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.  
        public let maxCapacity: Double?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X. 
        public let numberOfWorkers: Int32?
        /// A list of predecessors to this job run.
        public let predecessorRuns: [Predecessor]?
        /// The ID of the previous run of this job. For example, the JobRunId specified in the StartJobRun action.
        public let previousRunId: String?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public let securityConfiguration: String?
        /// The date and time at which this job run was started.
        public let startedOn: TimeStamp?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public let timeout: Int32?
        /// The name of the trigger that started this job run.
        public let triggerName: String?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.  
        public let workerType: WorkerType?

        public init(arguments: [String: String]? = nil, attempt: Int32? = nil, completedOn: TimeStamp? = nil, errorMessage: String? = nil, executionTime: Int32? = nil, id: String? = nil, jobName: String? = nil, jobRunState: JobRunState? = nil, lastModifiedOn: TimeStamp? = nil, logGroupName: String? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int32? = nil, predecessorRuns: [Predecessor]? = nil, previousRunId: String? = nil, securityConfiguration: String? = nil, startedOn: TimeStamp? = nil, timeout: Int32? = nil, triggerName: String? = nil, workerType: WorkerType? = nil) {
            self.arguments = arguments
            self.attempt = attempt
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.id = id
            self.jobName = jobName
            self.jobRunState = jobRunState
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.predecessorRuns = predecessorRuns
            self.previousRunId = previousRunId
            self.securityConfiguration = securityConfiguration
            self.startedOn = startedOn
            self.timeout = timeout
            self.triggerName = triggerName
            self.workerType = workerType
        }

        public func validate() throws {
            try validate(id, name:"id", max: 255)
            try validate(id, name:"id", min: 1)
            try validate(id, name:"id", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try notificationProperty?.validate()
            try predecessorRuns?.forEach {
                try $0.validate()
            }
            try validate(previousRunId, name:"previousRunId", max: 255)
            try validate(previousRunId, name:"previousRunId", min: 1)
            try validate(previousRunId, name:"previousRunId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(timeout, name:"timeout", min: 1)
            try validate(triggerName, name:"triggerName", max: 255)
            try validate(triggerName, name:"triggerName", min: 1)
            try validate(triggerName, name:"triggerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case id = "Id"
            case jobName = "JobName"
            case jobRunState = "JobRunState"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case maxCapacity = "MaxCapacity"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case predecessorRuns = "PredecessorRuns"
            case previousRunId = "PreviousRunId"
            case securityConfiguration = "SecurityConfiguration"
            case startedOn = "StartedOn"
            case timeout = "Timeout"
            case triggerName = "TriggerName"
            case workerType = "WorkerType"
        }
    }

    public enum JobRunState: String, CustomStringConvertible, Codable {
        case starting = "STARTING"
        case running = "RUNNING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public struct JobUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Command", required: false, type: .structure), 
            AWSShapeMember(label: "Connections", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultArguments", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ExecutionProperty", required: false, type: .structure), 
            AWSShapeMember(label: "LogUri", required: false, type: .string), 
            AWSShapeMember(label: "MaxCapacity", required: false, type: .double), 
            AWSShapeMember(label: "MaxRetries", required: false, type: .integer), 
            AWSShapeMember(label: "NotificationProperty", required: false, type: .structure), 
            AWSShapeMember(label: "NumberOfWorkers", required: false, type: .integer), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer), 
            AWSShapeMember(label: "WorkerType", required: false, type: .enum)
        ]

        /// The JobCommand that executes this job (required).
        public let command: JobCommand?
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The default arguments for this job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
        public let defaultArguments: [String: String]?
        /// Description of the job being defined.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// This field is reserved for future use.
        public let logUri: String?
        /// The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the AWS Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.  
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int32?
        /// Specifies the configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X. 
        public let numberOfWorkers: Int32?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int32?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.  
        public let workerType: WorkerType?

        public init(command: JobCommand? = nil, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, logUri: String? = nil, maxCapacity: Double? = nil, maxRetries: Int32? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int32? = nil, role: String? = nil, securityConfiguration: String? = nil, timeout: Int32? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionProperty = executionProperty
            self.logUri = logUri
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate() throws {
            try command?.validate()
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try notificationProperty?.validate()
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(timeout, name:"timeout", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case logUri = "LogUri"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct JsonClassifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "JsonPath", required: true, type: .string), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long)
        ]

        /// The time that this classifier was registered.
        public let creationTime: TimeStamp?
        /// A JsonPath string defining the JSON data for the classifier to classify. AWS Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String
        /// The time that this classifier was last updated.
        public let lastUpdated: TimeStamp?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        public init(creationTime: TimeStamp? = nil, jsonPath: String, lastUpdated: TimeStamp? = nil, name: String, version: Int64? = nil) {
            self.creationTime = creationTime
            self.jsonPath = jsonPath
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jsonPath = "JsonPath"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case version = "Version"
        }
    }

    public enum Language: String, CustomStringConvertible, Codable {
        case python = "PYTHON"
        case scala = "SCALA"
        public var description: String { return self.rawValue }
    }

    public struct LastCrawlInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "LogGroup", required: false, type: .string), 
            AWSShapeMember(label: "LogStream", required: false, type: .string), 
            AWSShapeMember(label: "MessagePrefix", required: false, type: .string), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// If an error occurred, the error information about the last crawl.
        public let errorMessage: String?
        /// The log group for the last crawl.
        public let logGroup: String?
        /// The log stream for the last crawl.
        public let logStream: String?
        /// The prefix for a message about this crawl.
        public let messagePrefix: String?
        /// The time at which the crawl started.
        public let startTime: TimeStamp?
        /// Status of the last crawl.
        public let status: LastCrawlStatus?

        public init(errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, messagePrefix: String? = nil, startTime: TimeStamp? = nil, status: LastCrawlStatus? = nil) {
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.messagePrefix = messagePrefix
            self.startTime = startTime
            self.status = status
        }

        public func validate() throws {
            try validate(errorMessage, name:"errorMessage", max: 2048)
            try validate(errorMessage, name:"errorMessage", min: 0)
            try validate(errorMessage, name:"errorMessage", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(logGroup, name:"logGroup", max: 512)
            try validate(logGroup, name:"logGroup", min: 1)
            try validate(logGroup, name:"logGroup", pattern: "[\\.\\-_/#A-Za-z0-9]+")
            try validate(logStream, name:"logStream", max: 512)
            try validate(logStream, name:"logStream", min: 1)
            try validate(logStream, name:"logStream", pattern: "[^:*]*")
            try validate(messagePrefix, name:"messagePrefix", max: 255)
            try validate(messagePrefix, name:"messagePrefix", min: 1)
            try validate(messagePrefix, name:"messagePrefix", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case messagePrefix = "MessagePrefix"
            case startTime = "StartTime"
            case status = "Status"
        }
    }

    public enum LastCrawlStatus: String, CustomStringConvertible, Codable {
        case succeeded = "SUCCEEDED"
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct ListCrawlersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// The maximum size of a list to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListCrawlersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerNames", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The names of all crawlers in the account, or the crawlers with the specified tags.
        public let crawlerNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(crawlerNames: [String]? = nil, nextToken: String? = nil) {
            self.crawlerNames = crawlerNames
            self.nextToken = nextToken
        }

        public func validate() throws {
            try crawlerNames?.forEach {
                try validate($0, name:"crawlerNames[]", max: 255)
                try validate($0, name:"crawlerNames[]", min: 1)
                try validate($0, name:"crawlerNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlerNames, name:"crawlerNames", max: 100)
            try validate(crawlerNames, name:"crawlerNames", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNames = "CrawlerNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// The maximum size of a list to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListDevEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DevEndpointNames", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The names of all the DevEndpoints in the account, or the DevEndpoints with the specified tags.
        public let devEndpointNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(devEndpointNames: [String]? = nil, nextToken: String? = nil) {
            self.devEndpointNames = devEndpointNames
            self.nextToken = nextToken
        }

        public func validate() throws {
            try devEndpointNames?.forEach {
                try validate($0, name:"devEndpointNames[]", max: 255)
                try validate($0, name:"devEndpointNames[]", min: 1)
                try validate($0, name:"devEndpointNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpointNames = "DevEndpointNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        /// The maximum size of a list to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobNames", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The names of all jobs in the account, or the jobs with the specified tags.
        public let jobNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(jobNames: [String]? = nil, nextToken: String? = nil) {
            self.jobNames = jobNames
            self.nextToken = nextToken
        }

        public func validate() throws {
            try jobNames?.forEach {
                try validate($0, name:"jobNames[]", max: 255)
                try validate($0, name:"jobNames[]", min: 1)
                try validate($0, name:"jobNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobNames = "JobNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListTriggersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DependentJobName", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]

        ///  The name of the job for which to retrieve triggers. The trigger that can start this job is returned. If there is no such trigger, all triggers are returned.
        public let dependentJobName: String?
        /// The maximum size of a list to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(dependentJobName: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.dependentJobName = dependentJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate() throws {
            try validate(dependentJobName, name:"dependentJobName", max: 255)
            try validate(dependentJobName, name:"dependentJobName", min: 1)
            try validate(dependentJobName, name:"dependentJobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListTriggersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TriggerNames", required: false, type: .list)
        ]

        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?
        /// The names of all triggers in the account, or the triggers with the specified tags.
        public let triggerNames: [String]?

        public init(nextToken: String? = nil, triggerNames: [String]? = nil) {
            self.nextToken = nextToken
            self.triggerNames = triggerNames
        }

        public func validate() throws {
            try triggerNames?.forEach {
                try validate($0, name:"triggerNames[]", max: 255)
                try validate($0, name:"triggerNames[]", min: 1)
                try validate($0, name:"triggerNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggerNames = "TriggerNames"
        }
    }

    public struct ListWorkflowsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The maximum size of a list to return.
        public let maxResults: Int32?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate() throws {
            try validate(maxResults, name:"maxResults", max: 1000)
            try validate(maxResults, name:"maxResults", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListWorkflowsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Workflows", required: false, type: .list)
        ]

        /// A continuation token, if not all workflow names have been returned.
        public let nextToken: String?
        /// List of names of workflows in the account.
        public let workflows: [String]?

        public init(nextToken: String? = nil, workflows: [String]? = nil) {
            self.nextToken = nextToken
            self.workflows = workflows
        }

        public func validate() throws {
            try workflows?.forEach {
                try validate($0, name:"workflows[]", max: 255)
                try validate($0, name:"workflows[]", min: 1)
                try validate($0, name:"workflows[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(workflows, name:"workflows", max: 25)
            try validate(workflows, name:"workflows", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workflows = "Workflows"
        }
    }

    public struct Location: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DynamoDB", required: false, type: .list), 
            AWSShapeMember(label: "Jdbc", required: false, type: .list), 
            AWSShapeMember(label: "S3", required: false, type: .list)
        ]

        /// An Amazon DynamoDB table location.
        public let dynamoDB: [CodeGenNodeArg]?
        /// A JDBC location.
        public let jdbc: [CodeGenNodeArg]?
        /// An Amazon Simple Storage Service (Amazon S3) location.
        public let s3: [CodeGenNodeArg]?

        public init(dynamoDB: [CodeGenNodeArg]? = nil, jdbc: [CodeGenNodeArg]? = nil, s3: [CodeGenNodeArg]? = nil) {
            self.dynamoDB = dynamoDB
            self.jdbc = jdbc
            self.s3 = s3
        }

        public func validate() throws {
            try validate(dynamoDB, name:"dynamoDB", max: 50)
            try validate(dynamoDB, name:"dynamoDB", min: 0)
            try validate(jdbc, name:"jdbc", max: 50)
            try validate(jdbc, name:"jdbc", min: 0)
            try validate(s3, name:"s3", max: 50)
            try validate(s3, name:"s3", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamoDB = "DynamoDB"
            case jdbc = "Jdbc"
            case s3 = "S3"
        }
    }

    public enum Logical: String, CustomStringConvertible, Codable {
        case and = "AND"
        case any = "ANY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public struct MappingEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourcePath", required: false, type: .string), 
            AWSShapeMember(label: "SourceTable", required: false, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "TargetPath", required: false, type: .string), 
            AWSShapeMember(label: "TargetTable", required: false, type: .string), 
            AWSShapeMember(label: "TargetType", required: false, type: .string)
        ]

        /// The source path.
        public let sourcePath: String?
        /// The name of the source table.
        public let sourceTable: String?
        /// The source type.
        public let sourceType: String?
        /// The target path.
        public let targetPath: String?
        /// The target table.
        public let targetTable: String?
        /// The target type.
        public let targetType: String?

        public init(sourcePath: String? = nil, sourceTable: String? = nil, sourceType: String? = nil, targetPath: String? = nil, targetTable: String? = nil, targetType: String? = nil) {
            self.sourcePath = sourcePath
            self.sourceTable = sourceTable
            self.sourceType = sourceType
            self.targetPath = targetPath
            self.targetTable = targetTable
            self.targetType = targetType
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
            case sourceTable = "SourceTable"
            case sourceType = "SourceType"
            case targetPath = "TargetPath"
            case targetTable = "TargetTable"
            case targetType = "TargetType"
        }
    }

    public struct Node: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerDetails", required: false, type: .structure), 
            AWSShapeMember(label: "JobDetails", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "TriggerDetails", required: false, type: .structure), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "UniqueId", required: false, type: .string)
        ]

        /// Details of the crawler when the node represents a crawler.
        public let crawlerDetails: CrawlerNodeDetails?
        /// Details of the Job when the node represents a Job.
        public let jobDetails: JobNodeDetails?
        /// The name of the AWS Glue component represented by the node.
        public let name: String?
        /// Details of the Trigger when the node represents a Trigger.
        public let triggerDetails: TriggerNodeDetails?
        /// The type of AWS Glue component represented by the node.
        public let `type`: NodeType?
        /// The unique Id assigned to the node within the workflow.
        public let uniqueId: String?

        public init(crawlerDetails: CrawlerNodeDetails? = nil, jobDetails: JobNodeDetails? = nil, name: String? = nil, triggerDetails: TriggerNodeDetails? = nil, type: NodeType? = nil, uniqueId: String? = nil) {
            self.crawlerDetails = crawlerDetails
            self.jobDetails = jobDetails
            self.name = name
            self.triggerDetails = triggerDetails
            self.`type` = `type`
            self.uniqueId = uniqueId
        }

        public func validate() throws {
            try crawlerDetails?.validate()
            try jobDetails?.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try triggerDetails?.validate()
            try validate(uniqueId, name:"uniqueId", max: 255)
            try validate(uniqueId, name:"uniqueId", min: 1)
            try validate(uniqueId, name:"uniqueId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerDetails = "CrawlerDetails"
            case jobDetails = "JobDetails"
            case name = "Name"
            case triggerDetails = "TriggerDetails"
            case `type` = "Type"
            case uniqueId = "UniqueId"
        }
    }

    public enum NodeType: String, CustomStringConvertible, Codable {
        case crawler = "CRAWLER"
        case job = "JOB"
        case trigger = "TRIGGER"
        public var description: String { return self.rawValue }
    }

    public struct NotificationProperty: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NotifyDelayAfter", required: false, type: .integer)
        ]

        /// After a job run starts, the number of minutes to wait before sending a job run delay notification.
        public let notifyDelayAfter: Int32?

        public init(notifyDelayAfter: Int32? = nil) {
            self.notifyDelayAfter = notifyDelayAfter
        }

        public func validate() throws {
            try validate(notifyDelayAfter, name:"notifyDelayAfter", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case notifyDelayAfter = "NotifyDelayAfter"
        }
    }

    public struct Order: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Column", required: true, type: .string), 
            AWSShapeMember(label: "SortOrder", required: true, type: .integer)
        ]

        /// The name of the column.
        public let column: String
        /// Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        public let sortOrder: Int32

        public init(column: String, sortOrder: Int32) {
            self.column = column
            self.sortOrder = sortOrder
        }

        public func validate() throws {
            try validate(column, name:"column", max: 255)
            try validate(column, name:"column", min: 1)
            try validate(column, name:"column", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(sortOrder, name:"sortOrder", max: 1)
            try validate(sortOrder, name:"sortOrder", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortOrder = "SortOrder"
        }
    }

    public struct Partition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "TableName", required: false, type: .string), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]

        /// The time at which the partition was created.
        public let creationTime: TimeStamp?
        /// The name of the catalog database where the table in question is located.
        public let databaseName: String?
        /// The last time at which the partition was accessed.
        public let lastAccessTime: TimeStamp?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: TimeStamp?
        /// These key-value pairs define partition parameters.
        public let parameters: [String: String]?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The name of the table in question.
        public let tableName: String?
        /// The values of the partition.
        public let values: [String]?

        public init(creationTime: TimeStamp? = nil, databaseName: String? = nil, lastAccessTime: TimeStamp? = nil, lastAnalyzedTime: TimeStamp? = nil, parameters: [String: String]? = nil, storageDescriptor: StorageDescriptor? = nil, tableName: String? = nil, values: [String]? = nil) {
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.tableName = tableName
            self.values = values
        }

        public func validate() throws {
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try storageDescriptor?.validate()
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try values?.forEach {
                try validate($0, name:"values[]", max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case parameters = "Parameters"
            case storageDescriptor = "StorageDescriptor"
            case tableName = "TableName"
            case values = "Values"
        }
    }

    public struct PartitionError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "PartitionValues", required: false, type: .list)
        ]

        /// Details about the partition error.
        public let errorDetail: ErrorDetail?
        /// The values that define the partition.
        public let partitionValues: [String]?

        public init(errorDetail: ErrorDetail? = nil, partitionValues: [String]? = nil) {
            self.errorDetail = errorDetail
            self.partitionValues = partitionValues
        }

        public func validate() throws {
            try errorDetail?.validate()
            try partitionValues?.forEach {
                try validate($0, name:"partitionValues[]", max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case partitionValues = "PartitionValues"
        }
    }

    public struct PartitionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]

        /// The last time at which the partition was accessed.
        public let lastAccessTime: TimeStamp?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: TimeStamp?
        /// These key-value pairs define partition parameters.
        public let parameters: [String: String]?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input.
        public let values: [String]?

        public init(lastAccessTime: TimeStamp? = nil, lastAnalyzedTime: TimeStamp? = nil, parameters: [String: String]? = nil, storageDescriptor: StorageDescriptor? = nil, values: [String]? = nil) {
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.values = values
        }

        public func validate() throws {
            try storageDescriptor?.validate()
            try values?.forEach {
                try validate($0, name:"values[]", max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case parameters = "Parameters"
            case storageDescriptor = "StorageDescriptor"
            case values = "Values"
        }
    }

    public struct PartitionValueList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]

        /// The list of values.
        public let values: [String]

        public init(values: [String]) {
            self.values = values
        }

        public func validate() throws {
            try values.forEach {
                try validate($0, name:"values[]", max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct PhysicalConnectionRequirements: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIdList", required: false, type: .list), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string)
        ]

        /// The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.
        public let availabilityZone: String?
        /// The security group ID list used by the connection.
        public let securityGroupIdList: [String]?
        /// The subnet ID used by the connection.
        public let subnetId: String?

        public init(availabilityZone: String? = nil, securityGroupIdList: [String]? = nil, subnetId: String? = nil) {
            self.availabilityZone = availabilityZone
            self.securityGroupIdList = securityGroupIdList
            self.subnetId = subnetId
        }

        public func validate() throws {
            try validate(availabilityZone, name:"availabilityZone", max: 255)
            try validate(availabilityZone, name:"availabilityZone", min: 1)
            try validate(availabilityZone, name:"availabilityZone", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try securityGroupIdList?.forEach {
                try validate($0, name:"securityGroupIdList[]", max: 255)
                try validate($0, name:"securityGroupIdList[]", min: 1)
                try validate($0, name:"securityGroupIdList[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(securityGroupIdList, name:"securityGroupIdList", max: 50)
            try validate(securityGroupIdList, name:"securityGroupIdList", min: 0)
            try validate(subnetId, name:"subnetId", max: 255)
            try validate(subnetId, name:"subnetId", min: 1)
            try validate(subnetId, name:"subnetId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case securityGroupIdList = "SecurityGroupIdList"
            case subnetId = "SubnetId"
        }
    }

    public struct Predecessor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "RunId", required: false, type: .string)
        ]

        /// The name of the job definition used by the predecessor job run.
        public let jobName: String?
        /// The job-run ID of the predecessor job run.
        public let runId: String?

        public init(jobName: String? = nil, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(runId, name:"runId", max: 255)
            try validate(runId, name:"runId", min: 1)
            try validate(runId, name:"runId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct Predicate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Conditions", required: false, type: .list), 
            AWSShapeMember(label: "Logical", required: false, type: .enum)
        ]

        /// A list of the conditions that determine when the trigger will fire.
        public let conditions: [Condition]?
        /// An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.
        public let logical: Logical?

        public init(conditions: [Condition]? = nil, logical: Logical? = nil) {
            self.conditions = conditions
            self.logical = logical
        }

        public func validate() throws {
            try conditions?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "Conditions"
            case logical = "Logical"
        }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable {
        case user = "USER"
        case role = "ROLE"
        case group = "GROUP"
        public var description: String { return self.rawValue }
    }

    public struct PutDataCatalogEncryptionSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DataCatalogEncryptionSettings", required: true, type: .structure)
        ]

        /// The ID of the Data Catalog for which to set the security configuration. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// The security configuration to set.
        public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings

        public init(catalogId: String? = nil, dataCatalogEncryptionSettings: DataCatalogEncryptionSettings) {
            self.catalogId = catalogId
            self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try dataCatalogEncryptionSettings.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
        }
    }

    public struct PutDataCatalogEncryptionSettingsResponse: AWSShape {


        public init() {
        }

    }

    public struct PutResourcePolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PolicyExistsCondition", required: false, type: .enum), 
            AWSShapeMember(label: "PolicyHashCondition", required: false, type: .string), 
            AWSShapeMember(label: "PolicyInJson", required: true, type: .string)
        ]

        /// A value of MUST_EXIST is used to update a policy. A value of NOT_EXIST is used to create a new policy. If a value of NONE or a null value is used, the call will not depend on the existence of a policy.
        public let policyExistsCondition: ExistCondition?
        /// The hash value returned when the previous policy was set using PutResourcePolicy. Its purpose is to prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has been set.
        public let policyHashCondition: String?
        /// Contains the policy document to set, in JSON format.
        public let policyInJson: String

        public init(policyExistsCondition: ExistCondition? = nil, policyHashCondition: String? = nil, policyInJson: String) {
            self.policyExistsCondition = policyExistsCondition
            self.policyHashCondition = policyHashCondition
            self.policyInJson = policyInJson
        }

        public func validate() throws {
            try validate(policyHashCondition, name:"policyHashCondition", max: 255)
            try validate(policyHashCondition, name:"policyHashCondition", min: 1)
            try validate(policyHashCondition, name:"policyHashCondition", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(policyInJson, name:"policyInJson", max: 10240)
            try validate(policyInJson, name:"policyInJson", min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case policyExistsCondition = "PolicyExistsCondition"
            case policyHashCondition = "PolicyHashCondition"
            case policyInJson = "PolicyInJson"
        }
    }

    public struct PutResourcePolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PolicyHash", required: false, type: .string)
        ]

        /// A hash of the policy that has just been set. This must be included in a subsequent call that overwrites or updates this policy.
        public let policyHash: String?

        public init(policyHash: String? = nil) {
            self.policyHash = policyHash
        }

        public func validate() throws {
            try validate(policyHash, name:"policyHash", max: 255)
            try validate(policyHash, name:"policyHash", min: 1)
            try validate(policyHash, name:"policyHash", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case policyHash = "PolicyHash"
        }
    }

    public struct PutWorkflowRunPropertiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RunId", required: true, type: .string), 
            AWSShapeMember(label: "RunProperties", required: true, type: .map)
        ]

        /// Name of the workflow which was run.
        public let name: String
        /// The ID of the workflow run for which the run properties should be updated.
        public let runId: String
        /// The properties to put for the specified run.
        public let runProperties: [String: String]

        public init(name: String, runId: String, runProperties: [String: String]) {
            self.name = name
            self.runId = runId
            self.runProperties = runProperties
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(runId, name:"runId", max: 255)
            try validate(runId, name:"runId", min: 1)
            try validate(runId, name:"runId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
            case runProperties = "RunProperties"
        }
    }

    public struct PutWorkflowRunPropertiesResponse: AWSShape {


        public init() {
        }

    }

    public struct ResetJobBookmarkRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]

        /// The name of the job in question.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct ResetJobBookmarkResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobBookmarkEntry", required: false, type: .structure)
        ]

        /// The reset bookmark entry.
        public let jobBookmarkEntry: JobBookmarkEntry?

        public init(jobBookmarkEntry: JobBookmarkEntry? = nil) {
            self.jobBookmarkEntry = jobBookmarkEntry
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarkEntry = "JobBookmarkEntry"
        }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case jar = "JAR"
        case file = "FILE"
        case archive = "ARCHIVE"
        public var description: String { return self.rawValue }
    }

    public struct ResourceUri: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceType", required: false, type: .enum), 
            AWSShapeMember(label: "Uri", required: false, type: .string)
        ]

        /// The type of the resource.
        public let resourceType: ResourceType?
        /// The URI for accessing the resource.
        public let uri: String?

        public init(resourceType: ResourceType? = nil, uri: String? = nil) {
            self.resourceType = resourceType
            self.uri = uri
        }

        public func validate() throws {
            try validate(uri, name:"uri", max: 1024)
            try validate(uri, name:"uri", min: 1)
            try validate(uri, name:"uri", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case uri = "Uri"
        }
    }

    public struct S3Encryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "S3EncryptionMode", required: false, type: .enum)
        ]

        /// The AWS ARN of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?
        /// The encryption mode to use for S3 data.
        public let s3EncryptionMode: S3EncryptionMode?

        public init(kmsKeyArn: String? = nil, s3EncryptionMode: S3EncryptionMode? = nil) {
            self.kmsKeyArn = kmsKeyArn
            self.s3EncryptionMode = s3EncryptionMode
        }

        public func validate() throws {
            try validate(kmsKeyArn, name:"kmsKeyArn", pattern: "arn:aws:kms:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case s3EncryptionMode = "S3EncryptionMode"
        }
    }

    public enum S3EncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        case sseS3 = "SSE-S3"
        public var description: String { return self.rawValue }
    }

    public struct S3Target: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exclusions", required: false, type: .list), 
            AWSShapeMember(label: "Path", required: false, type: .string)
        ]

        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path to the Amazon S3 target.
        public let path: String?

        public init(exclusions: [String]? = nil, path: String? = nil) {
            self.exclusions = exclusions
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case exclusions = "Exclusions"
            case path = "Path"
        }
    }

    public struct Schedule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ScheduleExpression", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum)
        ]

        /// A cron expression used to specify the schedule. For more information, see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, specify cron(15 12 * * ? *).
        public let scheduleExpression: String?
        /// The state of the schedule.
        public let state: ScheduleState?

        public init(scheduleExpression: String? = nil, state: ScheduleState? = nil) {
            self.scheduleExpression = scheduleExpression
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleExpression = "ScheduleExpression"
            case state = "State"
        }
    }

    public enum ScheduleState: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case notScheduled = "NOT_SCHEDULED"
        case transitioning = "TRANSITIONING"
        public var description: String { return self.rawValue }
    }

    public struct SchemaChangePolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeleteBehavior", required: false, type: .enum), 
            AWSShapeMember(label: "UpdateBehavior", required: false, type: .enum)
        ]

        /// The deletion behavior when the crawler finds a deleted object.
        public let deleteBehavior: DeleteBehavior?
        /// The update behavior when the crawler finds a changed schema.
        public let updateBehavior: UpdateBehavior?

        public init(deleteBehavior: DeleteBehavior? = nil, updateBehavior: UpdateBehavior? = nil) {
            self.deleteBehavior = deleteBehavior
            self.updateBehavior = updateBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case deleteBehavior = "DeleteBehavior"
            case updateBehavior = "UpdateBehavior"
        }
    }

    public struct SecurityConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedTimeStamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "EncryptionConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The time at which this security configuration was created.
        public let createdTimeStamp: TimeStamp?
        /// The encryption configuration associated with this security configuration.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The name of the security configuration.
        public let name: String?

        public init(createdTimeStamp: TimeStamp? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, name: String? = nil) {
            self.createdTimeStamp = createdTimeStamp
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }

        public func validate() throws {
            try encryptionConfiguration?.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimeStamp = "CreatedTimeStamp"
            case encryptionConfiguration = "EncryptionConfiguration"
            case name = "Name"
        }
    }

    public struct Segment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentNumber", required: true, type: .integer), 
            AWSShapeMember(label: "TotalSegments", required: true, type: .integer)
        ]

        /// The zero-based index number of the this segment. For example, if the total number of segments is 4, SegmentNumber values will range from zero through three.
        public let segmentNumber: Int32
        /// The total numer of segments.
        public let totalSegments: Int32

        public init(segmentNumber: Int32, totalSegments: Int32) {
            self.segmentNumber = segmentNumber
            self.totalSegments = totalSegments
        }

        public func validate() throws {
            try validate(segmentNumber, name:"segmentNumber", min: 0)
            try validate(totalSegments, name:"totalSegments", max: 10)
            try validate(totalSegments, name:"totalSegments", min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case segmentNumber = "SegmentNumber"
            case totalSegments = "TotalSegments"
        }
    }

    public struct SerDeInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "SerializationLibrary", required: false, type: .string)
        ]

        /// Name of the SerDe.
        public let name: String?
        /// These key-value pairs define initialization parameters for the SerDe.
        public let parameters: [String: String]?
        /// Usually the class that implements the SerDe. An example is: org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        public let serializationLibrary: String?

        public init(name: String? = nil, parameters: [String: String]? = nil, serializationLibrary: String? = nil) {
            self.name = name
            self.parameters = parameters
            self.serializationLibrary = serializationLibrary
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(serializationLibrary, name:"serializationLibrary", max: 255)
            try validate(serializationLibrary, name:"serializationLibrary", min: 1)
            try validate(serializationLibrary, name:"serializationLibrary", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parameters = "Parameters"
            case serializationLibrary = "SerializationLibrary"
        }
    }

    public struct SkewedInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SkewedColumnNames", required: false, type: .list), 
            AWSShapeMember(label: "SkewedColumnValueLocationMaps", required: false, type: .map), 
            AWSShapeMember(label: "SkewedColumnValues", required: false, type: .list)
        ]

        /// A list of names of columns that contain skewed values.
        public let skewedColumnNames: [String]?
        /// A mapping of skewed values to the columns that contain them.
        public let skewedColumnValueLocationMaps: [String: String]?
        /// A list of values that appear so frequently as to be considered skewed.
        public let skewedColumnValues: [String]?

        public init(skewedColumnNames: [String]? = nil, skewedColumnValueLocationMaps: [String: String]? = nil, skewedColumnValues: [String]? = nil) {
            self.skewedColumnNames = skewedColumnNames
            self.skewedColumnValueLocationMaps = skewedColumnValueLocationMaps
            self.skewedColumnValues = skewedColumnValues
        }

        public func validate() throws {
            try skewedColumnNames?.forEach {
                try validate($0, name:"skewedColumnNames[]", max: 255)
                try validate($0, name:"skewedColumnNames[]", min: 1)
                try validate($0, name:"skewedColumnNames[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case skewedColumnNames = "SkewedColumnNames"
            case skewedColumnValueLocationMaps = "SkewedColumnValueLocationMaps"
            case skewedColumnValues = "SkewedColumnValues"
        }
    }

    public struct StartCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Name of the crawler to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartCrawlerResponse: AWSShape {


        public init() {
        }

    }

    public struct StartCrawlerScheduleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: true, type: .string)
        ]

        /// Name of the crawler to schedule.
        public let crawlerName: String

        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        public func validate() throws {
            try validate(crawlerName, name:"crawlerName", max: 255)
            try validate(crawlerName, name:"crawlerName", min: 1)
            try validate(crawlerName, name:"crawlerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct StartCrawlerScheduleResponse: AWSShape {


        public init() {
        }

    }

    public struct StartJobRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "JobRunId", required: false, type: .string), 
            AWSShapeMember(label: "MaxCapacity", required: false, type: .double), 
            AWSShapeMember(label: "NotificationProperty", required: false, type: .structure), 
            AWSShapeMember(label: "NumberOfWorkers", required: false, type: .integer), 
            AWSShapeMember(label: "SecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "Timeout", required: false, type: .integer), 
            AWSShapeMember(label: "WorkerType", required: false, type: .string)
        ]

        /// The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The name of the job definition to use.
        public let jobName: String
        /// The ID of a previous JobRun to retry.
        public let jobRunId: String?
        /// The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the AWS Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.  
        public let maxCapacity: Double?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X. 
        public let numberOfWorkers: Int32?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public let securityConfiguration: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public let timeout: Int32?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.  
        public let workerType: String?

        public init(arguments: [String: String]? = nil, jobName: String, jobRunId: String? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int32? = nil, securityConfiguration: String? = nil, timeout: Int32? = nil, workerType: String? = nil) {
            self.arguments = arguments
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(jobRunId, name:"jobRunId", max: 255)
            try validate(jobRunId, name:"jobRunId", min: 1)
            try validate(jobRunId, name:"jobRunId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try notificationProperty?.validate()
            try validate(securityConfiguration, name:"securityConfiguration", max: 255)
            try validate(securityConfiguration, name:"securityConfiguration", min: 1)
            try validate(securityConfiguration, name:"securityConfiguration", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(timeout, name:"timeout", min: 1)
            try validate(workerType, name:"workerType", max: 255)
            try validate(workerType, name:"workerType", min: 1)
            try validate(workerType, name:"workerType", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case maxCapacity = "MaxCapacity"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct StartJobRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRunId", required: false, type: .string)
        ]

        /// The ID assigned to this job run.
        public let jobRunId: String?

        public init(jobRunId: String? = nil) {
            self.jobRunId = jobRunId
        }

        public func validate() throws {
            try validate(jobRunId, name:"jobRunId", max: 255)
            try validate(jobRunId, name:"jobRunId", min: 1)
            try validate(jobRunId, name:"jobRunId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobRunId = "JobRunId"
        }
    }

    public struct StartTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the trigger to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the trigger that was started.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartWorkflowRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the workflow to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartWorkflowRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RunId", required: false, type: .string)
        ]

        /// An Id for the new run.
        public let runId: String?

        public init(runId: String? = nil) {
            self.runId = runId
        }

        public func validate() throws {
            try validate(runId, name:"runId", max: 255)
            try validate(runId, name:"runId", min: 1)
            try validate(runId, name:"runId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StopCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Name of the crawler to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopCrawlerResponse: AWSShape {


        public init() {
        }

    }

    public struct StopCrawlerScheduleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: true, type: .string)
        ]

        /// Name of the crawler whose schedule state to set.
        public let crawlerName: String

        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        public func validate() throws {
            try validate(crawlerName, name:"crawlerName", max: 255)
            try validate(crawlerName, name:"crawlerName", min: 1)
            try validate(crawlerName, name:"crawlerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct StopCrawlerScheduleResponse: AWSShape {


        public init() {
        }

    }

    public struct StopTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The name of the trigger to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the trigger that was stopped.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StorageDescriptor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BucketColumns", required: false, type: .list), 
            AWSShapeMember(label: "Columns", required: false, type: .list), 
            AWSShapeMember(label: "Compressed", required: false, type: .boolean), 
            AWSShapeMember(label: "InputFormat", required: false, type: .string), 
            AWSShapeMember(label: "Location", required: false, type: .string), 
            AWSShapeMember(label: "NumberOfBuckets", required: false, type: .integer), 
            AWSShapeMember(label: "OutputFormat", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "SerdeInfo", required: false, type: .structure), 
            AWSShapeMember(label: "SkewedInfo", required: false, type: .structure), 
            AWSShapeMember(label: "SortColumns", required: false, type: .list), 
            AWSShapeMember(label: "StoredAsSubDirectories", required: false, type: .boolean)
        ]

        /// A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        public let bucketColumns: [String]?
        /// A list of the Columns in the table.
        public let columns: [Column]?
        /// True if the data in the table is compressed, or False if not.
        public let compressed: Bool?
        /// The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        public let inputFormat: String?
        /// The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        public let location: String?
        /// Must be specified if the table contains any dimension columns.
        public let numberOfBuckets: Int32?
        /// The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        public let outputFormat: String?
        /// User-supplied properties in key-value form.
        public let parameters: [String: String]?
        /// Serialization/deserialization (SerDe) information.
        public let serdeInfo: SerDeInfo?
        /// Information about values that appear very frequently in a column (skewed values).
        public let skewedInfo: SkewedInfo?
        /// A list specifying the sort order of each bucket in the table.
        public let sortColumns: [Order]?
        /// True if the table data is stored in subdirectories, or False if not.
        public let storedAsSubDirectories: Bool?

        public init(bucketColumns: [String]? = nil, columns: [Column]? = nil, compressed: Bool? = nil, inputFormat: String? = nil, location: String? = nil, numberOfBuckets: Int32? = nil, outputFormat: String? = nil, parameters: [String: String]? = nil, serdeInfo: SerDeInfo? = nil, skewedInfo: SkewedInfo? = nil, sortColumns: [Order]? = nil, storedAsSubDirectories: Bool? = nil) {
            self.bucketColumns = bucketColumns
            self.columns = columns
            self.compressed = compressed
            self.inputFormat = inputFormat
            self.location = location
            self.numberOfBuckets = numberOfBuckets
            self.outputFormat = outputFormat
            self.parameters = parameters
            self.serdeInfo = serdeInfo
            self.skewedInfo = skewedInfo
            self.sortColumns = sortColumns
            self.storedAsSubDirectories = storedAsSubDirectories
        }

        public func validate() throws {
            try bucketColumns?.forEach {
                try validate($0, name:"bucketColumns[]", max: 255)
                try validate($0, name:"bucketColumns[]", min: 1)
                try validate($0, name:"bucketColumns[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try columns?.forEach {
                try $0.validate()
            }
            try validate(inputFormat, name:"inputFormat", max: 128)
            try validate(inputFormat, name:"inputFormat", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(location, name:"location", max: 2056)
            try validate(location, name:"location", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(outputFormat, name:"outputFormat", max: 128)
            try validate(outputFormat, name:"outputFormat", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try serdeInfo?.validate()
            try skewedInfo?.validate()
            try sortColumns?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bucketColumns = "BucketColumns"
            case columns = "Columns"
            case compressed = "Compressed"
            case inputFormat = "InputFormat"
            case location = "Location"
            case numberOfBuckets = "NumberOfBuckets"
            case outputFormat = "OutputFormat"
            case parameters = "Parameters"
            case serdeInfo = "SerdeInfo"
            case skewedInfo = "SkewedInfo"
            case sortColumns = "SortColumns"
            case storedAsSubDirectories = "StoredAsSubDirectories"
        }
    }

    public struct Table: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedBy", required: false, type: .string), 
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Owner", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "PartitionKeys", required: false, type: .list), 
            AWSShapeMember(label: "Retention", required: false, type: .integer), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "TableType", required: false, type: .string), 
            AWSShapeMember(label: "UpdateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ViewExpandedText", required: false, type: .string), 
            AWSShapeMember(label: "ViewOriginalText", required: false, type: .string)
        ]

        /// Person or entity who created the table.
        public let createdBy: String?
        /// Time when the table definition was created in the Data Catalog.
        public let createTime: TimeStamp?
        /// Name of the metadata database where the table metadata resides. For Hive compatibility, this must be all lowercase.
        public let databaseName: String?
        /// Description of the table.
        public let description: String?
        /// Last time the table was accessed. This is usually taken from HDFS, and may not be reliable.
        public let lastAccessTime: TimeStamp?
        /// Last time column statistics were computed for this table.
        public let lastAnalyzedTime: TimeStamp?
        /// Name of the table. For Hive compatibility, this must be entirely lowercase.
        public let name: String
        /// Owner of the table.
        public let owner: String?
        /// These key-value pairs define properties associated with the table.
        public let parameters: [String: String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When creating a table used by Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example:  "PartitionKeys": [] 
        public let partitionKeys: [Column]?
        /// Retention time for this table.
        public let retention: Int32?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).
        public let tableType: String?
        /// Last time the table was updated.
        public let updateTime: TimeStamp?
        /// If the table is a view, the expanded text of the view; otherwise null.
        public let viewExpandedText: String?
        /// If the table is a view, the original text of the view; otherwise null.
        public let viewOriginalText: String?

        public init(createdBy: String? = nil, createTime: TimeStamp? = nil, databaseName: String? = nil, description: String? = nil, lastAccessTime: TimeStamp? = nil, lastAnalyzedTime: TimeStamp? = nil, name: String, owner: String? = nil, parameters: [String: String]? = nil, partitionKeys: [Column]? = nil, retention: Int32? = nil, storageDescriptor: StorageDescriptor? = nil, tableType: String? = nil, updateTime: TimeStamp? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.createdBy = createdBy
            self.createTime = createTime
            self.databaseName = databaseName
            self.description = description
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.updateTime = updateTime
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        public func validate() throws {
            try validate(createdBy, name:"createdBy", max: 255)
            try validate(createdBy, name:"createdBy", min: 1)
            try validate(createdBy, name:"createdBy", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(owner, name:"owner", max: 255)
            try validate(owner, name:"owner", min: 1)
            try validate(owner, name:"owner", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionKeys?.forEach {
                try $0.validate()
            }
            try validate(retention, name:"retention", min: 0)
            try storageDescriptor?.validate()
            try validate(tableType, name:"tableType", max: 255)
            try validate(viewExpandedText, name:"viewExpandedText", max: 409600)
            try validate(viewOriginalText, name:"viewOriginalText", max: 409600)
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case createTime = "CreateTime"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case name = "Name"
            case owner = "Owner"
            case parameters = "Parameters"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case storageDescriptor = "StorageDescriptor"
            case tableType = "TableType"
            case updateTime = "UpdateTime"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct TableError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "TableName", required: false, type: .string)
        ]

        /// Detail about the error.
        public let errorDetail: ErrorDetail?
        /// Name of the table. For Hive compatibility, this must be entirely lowercase.
        public let tableName: String?

        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
        }

        public func validate() throws {
            try errorDetail?.validate()
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
        }
    }

    public struct TableInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Owner", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "PartitionKeys", required: false, type: .list), 
            AWSShapeMember(label: "Retention", required: false, type: .integer), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "TableType", required: false, type: .string), 
            AWSShapeMember(label: "ViewExpandedText", required: false, type: .string), 
            AWSShapeMember(label: "ViewOriginalText", required: false, type: .string)
        ]

        /// Description of the table.
        public let description: String?
        /// Last time the table was accessed.
        public let lastAccessTime: TimeStamp?
        /// Last time column statistics were computed for this table.
        public let lastAnalyzedTime: TimeStamp?
        /// Name of the table. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// Owner of the table.
        public let owner: String?
        /// These key-value pairs define properties associated with the table.
        public let parameters: [String: String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When creating a table used by Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example:  "PartitionKeys": [] 
        public let partitionKeys: [Column]?
        /// Retention time for this table.
        public let retention: Int32?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).
        public let tableType: String?
        /// If the table is a view, the expanded text of the view; otherwise null.
        public let viewExpandedText: String?
        /// If the table is a view, the original text of the view; otherwise null.
        public let viewOriginalText: String?

        public init(description: String? = nil, lastAccessTime: TimeStamp? = nil, lastAnalyzedTime: TimeStamp? = nil, name: String, owner: String? = nil, parameters: [String: String]? = nil, partitionKeys: [Column]? = nil, retention: Int32? = nil, storageDescriptor: StorageDescriptor? = nil, tableType: String? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.description = description
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        public func validate() throws {
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(owner, name:"owner", max: 255)
            try validate(owner, name:"owner", min: 1)
            try validate(owner, name:"owner", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionKeys?.forEach {
                try $0.validate()
            }
            try validate(retention, name:"retention", min: 0)
            try storageDescriptor?.validate()
            try validate(tableType, name:"tableType", max: 255)
            try validate(viewExpandedText, name:"viewExpandedText", max: 409600)
            try validate(viewOriginalText, name:"viewOriginalText", max: 409600)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case name = "Name"
            case owner = "Owner"
            case parameters = "Parameters"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case storageDescriptor = "StorageDescriptor"
            case tableType = "TableType"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct TableVersion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Table", required: false, type: .structure), 
            AWSShapeMember(label: "VersionId", required: false, type: .string)
        ]

        /// The table in question
        public let table: Table?
        /// The ID value that identifies this table version. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        public init(table: Table? = nil, versionId: String? = nil) {
            self.table = table
            self.versionId = versionId
        }

        public func validate() throws {
            try table?.validate()
            try validate(versionId, name:"versionId", max: 255)
            try validate(versionId, name:"versionId", min: 1)
            try validate(versionId, name:"versionId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
            case versionId = "VersionId"
        }
    }

    public struct TableVersionError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "TableName", required: false, type: .string), 
            AWSShapeMember(label: "VersionId", required: false, type: .string)
        ]

        /// Detail about the error.
        public let errorDetail: ErrorDetail?
        /// The name of the table in question.
        public let tableName: String?
        /// The ID value of the version in question. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil, versionId: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate() throws {
            try errorDetail?.validate()
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(versionId, name:"versionId", max: 255)
            try validate(versionId, name:"versionId", min: 1)
            try validate(versionId, name:"versionId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "TagsToAdd", required: true, type: .map)
        ]

        /// The ARN of the AWS Glue resource to which to add the tags. For more information about AWS Glue resource ARNs, see the AWS Glue ARN string pattern.
        public let resourceArn: String
        /// Tags to add to this resource.
        public let tagsToAdd: [String: String]

        public init(resourceArn: String, tagsToAdd: [String: String]) {
            self.resourceArn = resourceArn
            self.tagsToAdd = tagsToAdd
        }

        public func validate() throws {
            try validate(resourceArn, name:"resourceArn", max: 10240)
            try validate(resourceArn, name:"resourceArn", min: 1)
            try validate(resourceArn, name:"resourceArn", pattern: "arn:aws:glue:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagsToAdd = "TagsToAdd"
        }
    }

    public struct TagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct Trigger: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Predicate", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "WorkflowName", required: false, type: .string)
        ]

        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// A description of this trigger.
        public let description: String?
        /// Reserved for future use.
        public let id: String?
        /// The name of the trigger.
        public let name: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The current state of the trigger.
        public let state: TriggerState?
        /// The type of trigger that this is.
        public let `type`: TriggerType?
        /// The name of the workflow associated with the trigger.
        public let workflowName: String?

        public init(actions: [Action]? = nil, description: String? = nil, id: String? = nil, name: String? = nil, predicate: Predicate? = nil, schedule: String? = nil, state: TriggerState? = nil, type: TriggerType? = nil, workflowName: String? = nil) {
            self.actions = actions
            self.description = description
            self.id = id
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.state = state
            self.`type` = `type`
            self.workflowName = workflowName
        }

        public func validate() throws {
            try actions?.forEach {
                try $0.validate()
            }
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(id, name:"id", max: 255)
            try validate(id, name:"id", min: 1)
            try validate(id, name:"id", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try predicate?.validate()
            try validate(workflowName, name:"workflowName", max: 255)
            try validate(workflowName, name:"workflowName", min: 1)
            try validate(workflowName, name:"workflowName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
            case state = "State"
            case `type` = "Type"
            case workflowName = "WorkflowName"
        }
    }

    public struct TriggerNodeDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Trigger", required: false, type: .structure)
        ]

        /// The information of the trigger represented by the trigger node.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        public func validate() throws {
            try trigger?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public enum TriggerState: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case created = "CREATED"
        case activating = "ACTIVATING"
        case activated = "ACTIVATED"
        case deactivating = "DEACTIVATING"
        case deactivated = "DEACTIVATED"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case conditional = "CONDITIONAL"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public struct TriggerUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Predicate", required: false, type: .structure), 
            AWSShapeMember(label: "Schedule", required: false, type: .string)
        ]

        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// A description of this trigger.
        public let description: String?
        /// Reserved for future use.
        public let name: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?

        public init(actions: [Action]? = nil, description: String? = nil, name: String? = nil, predicate: Predicate? = nil, schedule: String? = nil) {
            self.actions = actions
            self.description = description
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
        }

        public func validate() throws {
            try actions?.forEach {
                try $0.validate()
            }
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try predicate?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "TagsToRemove", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the resource from which to remove the tags.
        public let resourceArn: String
        /// Tags to remove from this resource.
        public let tagsToRemove: [String]

        public init(resourceArn: String, tagsToRemove: [String]) {
            self.resourceArn = resourceArn
            self.tagsToRemove = tagsToRemove
        }

        public func validate() throws {
            try validate(resourceArn, name:"resourceArn", max: 10240)
            try validate(resourceArn, name:"resourceArn", min: 1)
            try validate(resourceArn, name:"resourceArn", pattern: "arn:aws:glue:.*")
            try tagsToRemove.forEach {
                try validate($0, name:"tagsToRemove[]", max: 128)
                try validate($0, name:"tagsToRemove[]", min: 1)
            }
            try validate(tagsToRemove, name:"tagsToRemove", max: 50)
            try validate(tagsToRemove, name:"tagsToRemove", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagsToRemove = "TagsToRemove"
        }
    }

    public struct UntagResourceResponse: AWSShape {


        public init() {
        }

    }

    public enum UpdateBehavior: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case updateInDatabase = "UPDATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public struct UpdateClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CsvClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "GrokClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "JsonClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "XMLClassifier", required: false, type: .structure)
        ]

        /// A CsvClassifier object with updated fields.
        public let csvClassifier: UpdateCsvClassifierRequest?
        /// A GrokClassifier object with updated fields.
        public let grokClassifier: UpdateGrokClassifierRequest?
        /// A JsonClassifier object with updated fields.
        public let jsonClassifier: UpdateJsonClassifierRequest?
        /// An XMLClassifier object with updated fields.
        public let xMLClassifier: UpdateXMLClassifierRequest?

        public init(csvClassifier: UpdateCsvClassifierRequest? = nil, grokClassifier: UpdateGrokClassifierRequest? = nil, jsonClassifier: UpdateJsonClassifierRequest? = nil, xMLClassifier: UpdateXMLClassifierRequest? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xMLClassifier = xMLClassifier
        }

        public func validate() throws {
            try csvClassifier?.validate()
            try grokClassifier?.validate()
            try jsonClassifier?.validate()
            try xMLClassifier?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct UpdateClassifierResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionInput", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog in which the connection resides. If none is provided, the AWS account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object that redefines the connection in question.
        public let connectionInput: ConnectionInput
        /// The name of the connection definition to update.
        public let name: String

        public init(catalogId: String? = nil, connectionInput: ConnectionInput, name: String) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try connectionInput.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
            case name = "Name"
        }
    }

    public struct UpdateConnectionResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "Configuration", required: false, type: .string), 
            AWSShapeMember(label: "CrawlerSecurityConfiguration", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "SchemaChangePolicy", required: false, type: .structure), 
            AWSShapeMember(label: "TablePrefix", required: false, type: .string), 
            AWSShapeMember(label: "Targets", required: false, type: .structure)
        ]

        /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// The crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
        public let configuration: String?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The AWS Glue database where results are stored, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A description of the new crawler.
        public let description: String?
        /// Name of the new crawler.
        public let name: String
        /// The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler to access customer resources.
        public let role: String?
        /// A cron expression used to specify the schedule. For more information, see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, specify cron(15 12 * * ? *).
        public let schedule: String?
        /// The policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// A list of targets to crawl.
        public let targets: CrawlerTargets?

        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlerSecurityConfiguration: String? = nil, databaseName: String? = nil, description: String? = nil, name: String, role: String? = nil, schedule: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, tablePrefix: String? = nil, targets: CrawlerTargets? = nil) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.databaseName = databaseName
            self.description = description
            self.name = name
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.tablePrefix = tablePrefix
            self.targets = targets
        }

        public func validate() throws {
            try classifiers?.forEach {
                try validate($0, name:"classifiers[]", max: 255)
                try validate($0, name:"classifiers[]", min: 1)
                try validate($0, name:"classifiers[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(crawlerSecurityConfiguration, name:"crawlerSecurityConfiguration", max: 128)
            try validate(crawlerSecurityConfiguration, name:"crawlerSecurityConfiguration", min: 0)
            try validate(description, name:"description", max: 2048)
            try validate(description, name:"description", min: 0)
            try validate(description, name:"description", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(tablePrefix, name:"tablePrefix", max: 128)
            try validate(tablePrefix, name:"tablePrefix", min: 0)
            try targets?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case databaseName = "DatabaseName"
            case description = "Description"
            case name = "Name"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case tablePrefix = "TablePrefix"
            case targets = "Targets"
        }
    }

    public struct UpdateCrawlerResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateCrawlerScheduleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: true, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .string)
        ]

        /// The name of the crawler whose schedule to update.
        public let crawlerName: String
        /// The updated cron expression used to specify the schedule. For more information, see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, specify cron(15 12 * * ? *).
        public let schedule: String?

        public init(crawlerName: String, schedule: String? = nil) {
            self.crawlerName = crawlerName
            self.schedule = schedule
        }

        public func validate() throws {
            try validate(crawlerName, name:"crawlerName", max: 255)
            try validate(crawlerName, name:"crawlerName", min: 1)
            try validate(crawlerName, name:"crawlerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case schedule = "Schedule"
        }
    }

    public struct UpdateCrawlerScheduleResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateCsvClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllowSingleColumn", required: false, type: .boolean), 
            AWSShapeMember(label: "ContainsHeader", required: false, type: .enum), 
            AWSShapeMember(label: "Delimiter", required: false, type: .string), 
            AWSShapeMember(label: "DisableValueTrimming", required: false, type: .boolean), 
            AWSShapeMember(label: "Header", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "QuoteSymbol", required: false, type: .string)
        ]

        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public let quoteSymbol: String?

        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, name: String, quoteSymbol: String? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
        }

        public func validate() throws {
            try validate(delimiter, name:"delimiter", max: 1)
            try validate(delimiter, name:"delimiter", min: 1)
            try validate(delimiter, name:"delimiter", pattern: "[^\\r\\n]")
            try header?.forEach {
                try validate($0, name:"header[]", max: 255)
                try validate($0, name:"header[]", min: 1)
                try validate($0, name:"header[]", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(quoteSymbol, name:"quoteSymbol", max: 1)
            try validate(quoteSymbol, name:"quoteSymbol", min: 1)
            try validate(quoteSymbol, name:"quoteSymbol", pattern: "[^\\r\\n]")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct UpdateDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseInput", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// The ID of the Data Catalog in which the metadata database resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A DatabaseInput object specifying the new definition of the metadata database in the catalog.
        public let databaseInput: DatabaseInput
        /// The name of the database to update in the catalog. For Hive compatibility, this is folded to lowercase.
        public let name: String

        public init(catalogId: String? = nil, databaseInput: DatabaseInput, name: String) {
            self.catalogId = catalogId
            self.databaseInput = databaseInput
            self.name = name
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try databaseInput.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseInput = "DatabaseInput"
            case name = "Name"
        }
    }

    public struct UpdateDatabaseResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AddArguments", required: false, type: .map), 
            AWSShapeMember(label: "AddPublicKeys", required: false, type: .list), 
            AWSShapeMember(label: "CustomLibraries", required: false, type: .structure), 
            AWSShapeMember(label: "DeleteArguments", required: false, type: .list), 
            AWSShapeMember(label: "DeletePublicKeys", required: false, type: .list), 
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "PublicKey", required: false, type: .string), 
            AWSShapeMember(label: "UpdateEtlLibraries", required: false, type: .boolean)
        ]

        /// The map of arguments to add the map of arguments used to configure the DevEndpoint.
        public let addArguments: [String: String]?
        /// The list of public keys for the DevEndpoint to use.
        public let addPublicKeys: [String]?
        /// Custom Python or Java libraries to be loaded in the DevEndpoint.
        public let customLibraries: DevEndpointCustomLibraries?
        /// The list of argument keys to be deleted from the map of arguments used to configure the DevEndpoint.
        public let deleteArguments: [String]?
        /// The list of public keys to be deleted from the DevEndpoint.
        public let deletePublicKeys: [String]?
        /// The name of the DevEndpoint to be updated.
        public let endpointName: String
        /// The public key for the DevEndpoint to use.
        public let publicKey: String?
        /// True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False otherwise.
        public let updateEtlLibraries: Bool?

        public init(addArguments: [String: String]? = nil, addPublicKeys: [String]? = nil, customLibraries: DevEndpointCustomLibraries? = nil, deleteArguments: [String]? = nil, deletePublicKeys: [String]? = nil, endpointName: String, publicKey: String? = nil, updateEtlLibraries: Bool? = nil) {
            self.addArguments = addArguments
            self.addPublicKeys = addPublicKeys
            self.customLibraries = customLibraries
            self.deleteArguments = deleteArguments
            self.deletePublicKeys = deletePublicKeys
            self.endpointName = endpointName
            self.publicKey = publicKey
            self.updateEtlLibraries = updateEtlLibraries
        }

        public func validate() throws {
            try validate(addPublicKeys, name:"addPublicKeys", max: 5)
            try validate(deletePublicKeys, name:"deletePublicKeys", max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case addArguments = "AddArguments"
            case addPublicKeys = "AddPublicKeys"
            case customLibraries = "CustomLibraries"
            case deleteArguments = "DeleteArguments"
            case deletePublicKeys = "DeletePublicKeys"
            case endpointName = "EndpointName"
            case publicKey = "PublicKey"
            case updateEtlLibraries = "UpdateEtlLibraries"
        }
    }

    public struct UpdateDevEndpointResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateGrokClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: false, type: .string), 
            AWSShapeMember(label: "CustomPatterns", required: false, type: .string), 
            AWSShapeMember(label: "GrokPattern", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String?
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The grok pattern used by this classifier.
        public let grokPattern: String?
        /// The name of the GrokClassifier.
        public let name: String

        public init(classification: String? = nil, customPatterns: String? = nil, grokPattern: String? = nil, name: String) {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }

        public func validate() throws {
            try validate(customPatterns, name:"customPatterns", max: 16000)
            try validate(customPatterns, name:"customPatterns", min: 0)
            try validate(customPatterns, name:"customPatterns", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try validate(grokPattern, name:"grokPattern", max: 2048)
            try validate(grokPattern, name:"grokPattern", min: 1)
            try validate(grokPattern, name:"grokPattern", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*")
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case name = "Name"
        }
    }

    public struct UpdateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "JobUpdate", required: true, type: .structure)
        ]

        /// The name of the job definition to update.
        public let jobName: String
        /// Specifies the values with which to update the job definition.
        public let jobUpdate: JobUpdate

        public init(jobName: String, jobUpdate: JobUpdate) {
            self.jobName = jobName
            self.jobUpdate = jobUpdate
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try jobUpdate.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobUpdate = "JobUpdate"
        }
    }

    public struct UpdateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]

        /// Returns the name of the updated job definition.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        public func validate() throws {
            try validate(jobName, name:"jobName", max: 255)
            try validate(jobName, name:"jobName", min: 1)
            try validate(jobName, name:"jobName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct UpdateJsonClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JsonPath", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// A JsonPath string defining the JSON data for the classifier to classify. AWS Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String?
        /// The name of the classifier.
        public let name: String

        public init(jsonPath: String? = nil, name: String) {
            self.jsonPath = jsonPath
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case name = "Name"
        }
    }

    public struct UpdatePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "PartitionInput", required: true, type: .structure), 
            AWSShapeMember(label: "PartitionValueList", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the partition to be updated resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// The new partition object to which to update the partition.
        public let partitionInput: PartitionInput
        /// A list of the values defining the partition.
        public let partitionValueList: [String]
        /// The name of the table where the partition to be updated is located.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionInput: PartitionInput, partitionValueList: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInput = partitionInput
            self.partitionValueList = partitionValueList
            self.tableName = tableName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try partitionInput.validate()
            try partitionValueList.forEach {
                try validate($0, name:"partitionValueList[]", max: 1024)
            }
            try validate(partitionValueList, name:"partitionValueList", max: 100)
            try validate(partitionValueList, name:"partitionValueList", min: 0)
            try validate(tableName, name:"tableName", max: 255)
            try validate(tableName, name:"tableName", min: 1)
            try validate(tableName, name:"tableName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInput = "PartitionInput"
            case partitionValueList = "PartitionValueList"
            case tableName = "TableName"
        }
    }

    public struct UpdatePartitionResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "SkipArchive", required: false, type: .boolean), 
            AWSShapeMember(label: "TableInput", required: true, type: .structure)
        ]

        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// By default, UpdateTable always creates an archived version of the table before updating it. If skipArchive is set to true, however, UpdateTable does not create the archived version.
        public let skipArchive: Bool?
        /// An updated TableInput object to define the metadata table in the catalog.
        public let tableInput: TableInput

        public init(catalogId: String? = nil, databaseName: String, skipArchive: Bool? = nil, tableInput: TableInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.skipArchive = skipArchive
            self.tableInput = tableInput
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try tableInput.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case skipArchive = "SkipArchive"
            case tableInput = "TableInput"
        }
    }

    public struct UpdateTableResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "TriggerUpdate", required: true, type: .structure)
        ]

        /// The name of the trigger to update.
        public let name: String
        /// The new values with which to update the trigger.
        public let triggerUpdate: TriggerUpdate

        public init(name: String, triggerUpdate: TriggerUpdate) {
            self.name = name
            self.triggerUpdate = triggerUpdate
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try triggerUpdate.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case triggerUpdate = "TriggerUpdate"
        }
    }

    public struct UpdateTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Trigger", required: false, type: .structure)
        ]

        /// The resulting trigger definition.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        public func validate() throws {
            try trigger?.validate()
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct UpdateUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "FunctionInput", required: true, type: .structure), 
            AWSShapeMember(label: "FunctionName", required: true, type: .string)
        ]

        /// The ID of the Data Catalog where the function to be updated is located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function to be updated is located.
        public let databaseName: String
        /// A FunctionInput object that re-defines the function in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput
        /// The name of the function.
        public let functionName: String

        public init(catalogId: String? = nil, databaseName: String, functionInput: UserDefinedFunctionInput, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionInput = functionInput
            self.functionName = functionName
        }

        public func validate() throws {
            try validate(catalogId, name:"catalogId", max: 255)
            try validate(catalogId, name:"catalogId", min: 1)
            try validate(catalogId, name:"catalogId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(databaseName, name:"databaseName", max: 255)
            try validate(databaseName, name:"databaseName", min: 1)
            try validate(databaseName, name:"databaseName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try functionInput.validate()
            try validate(functionName, name:"functionName", max: 255)
            try validate(functionName, name:"functionName", min: 1)
            try validate(functionName, name:"functionName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionInput = "FunctionInput"
            case functionName = "FunctionName"
        }
    }

    public struct UpdateUserDefinedFunctionResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateWorkflowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultRunProperties", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// A collection of properties to be used as part of each execution of the workflow.
        public let defaultRunProperties: [String: String]?
        /// The description of the workflow.
        public let description: String?
        /// Name of the workflow to be updated.
        public let name: String

        public init(defaultRunProperties: [String: String]? = nil, description: String? = nil, name: String) {
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateWorkflowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the workflow which was specified in input.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateXMLClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RowTag", required: false, type: .string)
        ]

        /// An identifier of the data format that the classifier matches.
        public let classification: String?
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by /&gt;). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A" item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).
        public let rowTag: String?

        public init(classification: String? = nil, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct UserDefinedFunction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClassName", required: false, type: .string), 
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "FunctionName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerType", required: false, type: .enum), 
            AWSShapeMember(label: "ResourceUris", required: false, type: .list)
        ]

        /// The Java class that contains the function code.
        public let className: String?
        /// The time at which the function was created.
        public let createTime: TimeStamp?
        /// The name of the function.
        public let functionName: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        public init(className: String? = nil, createTime: TimeStamp? = nil, functionName: String? = nil, ownerName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.className = className
            self.createTime = createTime
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        public func validate() throws {
            try validate(className, name:"className", max: 255)
            try validate(className, name:"className", min: 1)
            try validate(className, name:"className", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(functionName, name:"functionName", max: 255)
            try validate(functionName, name:"functionName", min: 1)
            try validate(functionName, name:"functionName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(ownerName, name:"ownerName", max: 255)
            try validate(ownerName, name:"ownerName", min: 1)
            try validate(ownerName, name:"ownerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try resourceUris?.forEach {
                try $0.validate()
            }
            try validate(resourceUris, name:"resourceUris", max: 1000)
            try validate(resourceUris, name:"resourceUris", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case createTime = "CreateTime"
            case functionName = "FunctionName"
            case ownerName = "OwnerName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct UserDefinedFunctionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClassName", required: false, type: .string), 
            AWSShapeMember(label: "FunctionName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerType", required: false, type: .enum), 
            AWSShapeMember(label: "ResourceUris", required: false, type: .list)
        ]

        /// The Java class that contains the function code.
        public let className: String?
        /// The name of the function.
        public let functionName: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        public init(className: String? = nil, functionName: String? = nil, ownerName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.className = className
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        public func validate() throws {
            try validate(className, name:"className", max: 255)
            try validate(className, name:"className", min: 1)
            try validate(className, name:"className", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(functionName, name:"functionName", max: 255)
            try validate(functionName, name:"functionName", min: 1)
            try validate(functionName, name:"functionName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(ownerName, name:"ownerName", max: 255)
            try validate(ownerName, name:"ownerName", min: 1)
            try validate(ownerName, name:"ownerName", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try resourceUris?.forEach {
                try $0.validate()
            }
            try validate(resourceUris, name:"resourceUris", max: 1000)
            try validate(resourceUris, name:"resourceUris", min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case functionName = "FunctionName"
            case ownerName = "OwnerName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public enum WorkerType: String, CustomStringConvertible, Codable {
        case standard = "Standard"
        case g1X = "G.1X"
        case g2X = "G.2X"
        public var description: String { return self.rawValue }
    }

    public struct Workflow: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "DefaultRunProperties", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Graph", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastRun", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The date and time when the workflow was created.
        public let createdOn: TimeStamp?
        /// A collection of properties to be used as part of each execution of the workflow.
        public let defaultRunProperties: [String: String]?
        /// A description of the workflow.
        public let description: String?
        /// The graph representing all the AWS Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public let graph: WorkflowGraph?
        /// The date and time when the workflow was last modified.
        public let lastModifiedOn: TimeStamp?
        /// The information about the last execution of the workflow.
        public let lastRun: WorkflowRun?
        /// The name of the workflow representing the flow.
        public let name: String?

        public init(createdOn: TimeStamp? = nil, defaultRunProperties: [String: String]? = nil, description: String? = nil, graph: WorkflowGraph? = nil, lastModifiedOn: TimeStamp? = nil, lastRun: WorkflowRun? = nil, name: String? = nil) {
            self.createdOn = createdOn
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.graph = graph
            self.lastModifiedOn = lastModifiedOn
            self.lastRun = lastRun
            self.name = name
        }

        public func validate() throws {
            try graph?.validate()
            try lastRun?.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case graph = "Graph"
            case lastModifiedOn = "LastModifiedOn"
            case lastRun = "LastRun"
            case name = "Name"
        }
    }

    public struct WorkflowGraph: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Edges", required: false, type: .list), 
            AWSShapeMember(label: "Nodes", required: false, type: .list)
        ]

        /// A list of all the directed connections between the nodes belonging to the workflow.
        public let edges: [Edge]?
        /// A list of the the AWS Glue components belong to the workflow represented as nodes.
        public let nodes: [Node]?

        public init(edges: [Edge]? = nil, nodes: [Node]? = nil) {
            self.edges = edges
            self.nodes = nodes
        }

        public func validate() throws {
            try edges?.forEach {
                try $0.validate()
            }
            try nodes?.forEach {
                try $0.validate()
            }
        }

        private enum CodingKeys: String, CodingKey {
            case edges = "Edges"
            case nodes = "Nodes"
        }
    }

    public struct WorkflowRun: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompletedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "Graph", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "StartedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "Statistics", required: false, type: .structure), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "WorkflowRunId", required: false, type: .string), 
            AWSShapeMember(label: "WorkflowRunProperties", required: false, type: .map)
        ]

        /// The date and time when the workflow run completed.
        public let completedOn: TimeStamp?
        /// The graph representing all the AWS Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public let graph: WorkflowGraph?
        /// Name of the workflow which was executed.
        public let name: String?
        /// The date and time when the workflow run was started.
        public let startedOn: TimeStamp?
        /// The statistics of the run.
        public let statistics: WorkflowRunStatistics?
        /// The status of the workflow run.
        public let status: WorkflowRunStatus?
        /// The ID of this workflow run.
        public let workflowRunId: String?
        /// The workflow run properties which were set during the run.
        public let workflowRunProperties: [String: String]?

        public init(completedOn: TimeStamp? = nil, graph: WorkflowGraph? = nil, name: String? = nil, startedOn: TimeStamp? = nil, statistics: WorkflowRunStatistics? = nil, status: WorkflowRunStatus? = nil, workflowRunId: String? = nil, workflowRunProperties: [String: String]? = nil) {
            self.completedOn = completedOn
            self.graph = graph
            self.name = name
            self.startedOn = startedOn
            self.statistics = statistics
            self.status = status
            self.workflowRunId = workflowRunId
            self.workflowRunProperties = workflowRunProperties
        }

        public func validate() throws {
            try graph?.validate()
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try validate(workflowRunId, name:"workflowRunId", max: 255)
            try validate(workflowRunId, name:"workflowRunId", min: 1)
            try validate(workflowRunId, name:"workflowRunId", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case graph = "Graph"
            case name = "Name"
            case startedOn = "StartedOn"
            case statistics = "Statistics"
            case status = "Status"
            case workflowRunId = "WorkflowRunId"
            case workflowRunProperties = "WorkflowRunProperties"
        }
    }

    public struct WorkflowRunStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedActions", required: false, type: .integer), 
            AWSShapeMember(label: "RunningActions", required: false, type: .integer), 
            AWSShapeMember(label: "StoppedActions", required: false, type: .integer), 
            AWSShapeMember(label: "SucceededActions", required: false, type: .integer), 
            AWSShapeMember(label: "TimeoutActions", required: false, type: .integer), 
            AWSShapeMember(label: "TotalActions", required: false, type: .integer)
        ]

        /// Total number of Actions which have failed.
        public let failedActions: Int32?
        /// Total number Actions in running state.
        public let runningActions: Int32?
        /// Total number of Actions which have stopped.
        public let stoppedActions: Int32?
        /// Total number of Actions which have succeeded.
        public let succeededActions: Int32?
        /// Total number of Actions which timed out.
        public let timeoutActions: Int32?
        /// Total number of Actions in the workflow run.
        public let totalActions: Int32?

        public init(failedActions: Int32? = nil, runningActions: Int32? = nil, stoppedActions: Int32? = nil, succeededActions: Int32? = nil, timeoutActions: Int32? = nil, totalActions: Int32? = nil) {
            self.failedActions = failedActions
            self.runningActions = runningActions
            self.stoppedActions = stoppedActions
            self.succeededActions = succeededActions
            self.timeoutActions = timeoutActions
            self.totalActions = totalActions
        }

        private enum CodingKeys: String, CodingKey {
            case failedActions = "FailedActions"
            case runningActions = "RunningActions"
            case stoppedActions = "StoppedActions"
            case succeededActions = "SucceededActions"
            case timeoutActions = "TimeoutActions"
            case totalActions = "TotalActions"
        }
    }

    public enum WorkflowRunStatus: String, CustomStringConvertible, Codable {
        case running = "RUNNING"
        case completed = "COMPLETED"
        public var description: String { return self.rawValue }
    }

    public struct XMLClassifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RowTag", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long)
        ]

        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The time that this classifier was registered.
        public let creationTime: TimeStamp?
        /// The time that this classifier was last updated.
        public let lastUpdated: TimeStamp?
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by /&gt;). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A" item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).
        public let rowTag: String?
        /// The version of this classifier.
        public let version: Int64?

        public init(classification: String, creationTime: TimeStamp? = nil, lastUpdated: TimeStamp? = nil, name: String, rowTag: String? = nil, version: Int64? = nil) {
            self.classification = classification
            self.creationTime = creationTime
            self.lastUpdated = lastUpdated
            self.name = name
            self.rowTag = rowTag
            self.version = version
        }

        public func validate() throws {
            try validate(name, name:"name", max: 255)
            try validate(name, name:"name", min: 1)
            try validate(name, name:"name", pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case creationTime = "CreationTime"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case rowTag = "RowTag"
            case version = "Version"
        }
    }
}
