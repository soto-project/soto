// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Connect {

    public enum Channel: String, CustomStringConvertible, Codable {
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum Comparison: String, CustomStringConvertible, Codable {
        case lt = "LT"
        public var description: String { return self.rawValue }
    }

    public struct ContactFlowSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "ContactFlowType", required: false, type: .enum), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the contact flow.
        public let arn: String?
        /// The type of contact flow.
        public let contactFlowType: ContactFlowType?
        /// The identifier of the contact flow.
        public let id: String?
        /// The name of the contact flow.
        public let name: String?

        public init(arn: String? = nil, contactFlowType: ContactFlowType? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.contactFlowType = contactFlowType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case contactFlowType = "ContactFlowType"
            case id = "Id"
            case name = "Name"
        }
    }

    public enum ContactFlowType: String, CustomStringConvertible, Codable {
        case contactFlow = "CONTACT_FLOW"
        case customerQueue = "CUSTOMER_QUEUE"
        case customerHold = "CUSTOMER_HOLD"
        case customerWhisper = "CUSTOMER_WHISPER"
        case agentHold = "AGENT_HOLD"
        case agentWhisper = "AGENT_WHISPER"
        case outboundWhisper = "OUTBOUND_WHISPER"
        case agentTransfer = "AGENT_TRANSFER"
        case queueTransfer = "QUEUE_TRANSFER"
        public var description: String { return self.rawValue }
    }

    public struct CreateUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DirectoryUserId", required: false, type: .string), 
            AWSShapeMember(label: "HierarchyGroupId", required: false, type: .string), 
            AWSShapeMember(label: "IdentityInfo", required: false, type: .structure), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "PhoneConfig", required: true, type: .structure), 
            AWSShapeMember(label: "RoutingProfileId", required: true, type: .string), 
            AWSShapeMember(label: "SecurityProfileIds", required: true, type: .list), 
            AWSShapeMember(label: "Username", required: true, type: .string)
        ]

        /// The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
        public let directoryUserId: String?
        /// The identifier of the hierarchy group for the user.
        public let hierarchyGroupId: String?
        /// The information about the identity of the user.
        public let identityInfo: UserIdentityInfo?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
        public let password: String?
        /// The phone settings for the user.
        public let phoneConfig: UserPhoneConfig
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String
        /// The identifier of the security profile for the user.
        public let securityProfileIds: [String]
        /// The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.
        public let username: String

        public init(directoryUserId: String? = nil, hierarchyGroupId: String? = nil, identityInfo: UserIdentityInfo? = nil, instanceId: String, password: String? = nil, phoneConfig: UserPhoneConfig, routingProfileId: String, securityProfileIds: [String], username: String) {
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.identityInfo = identityInfo
            self.instanceId = instanceId
            self.password = password
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.username = username
        }

        public func validate(name: String) throws {
            try self.identityInfo?.validate(name: "\(name).identityInfo")
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.password, name:"password", parent: name, pattern: "/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d\\S]{8,64}$/")
            try self.phoneConfig.validate(name: "\(name).phoneConfig")
            try validate(self.securityProfileIds, name:"securityProfileIds", parent: name, max: 10)
            try validate(self.securityProfileIds, name:"securityProfileIds", parent: name, min: 1)
            try validate(self.username, name:"username", parent: name, max: 20)
            try validate(self.username, name:"username", parent: name, min: 1)
            try validate(self.username, name:"username", parent: name, pattern: "[a-zA-Z0-9\\_\\-\\.]+")
        }

        private enum CodingKeys: String, CodingKey {
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case identityInfo = "IdentityInfo"
            case instanceId = "InstanceId"
            case password = "Password"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case username = "Username"
        }
    }

    public struct CreateUserResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserArn", required: false, type: .string), 
            AWSShapeMember(label: "UserId", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the user account.
        public let userArn: String?
        /// The identifier of the user account.
        public let userId: String?

        public init(userArn: String? = nil, userId: String? = nil) {
            self.userArn = userArn
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "UserArn"
            case userId = "UserId"
        }
    }

    public struct Credentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessToken", required: false, type: .string), 
            AWSShapeMember(label: "AccessTokenExpiration", required: false, type: .timestamp), 
            AWSShapeMember(label: "RefreshToken", required: false, type: .string), 
            AWSShapeMember(label: "RefreshTokenExpiration", required: false, type: .timestamp)
        ]

        /// An access token generated for a federated user to access Amazon Connect.
        public let accessToken: String?
        /// A token generated with an expiration time for the session a user is logged in to Amazon Connect.
        public let accessTokenExpiration: TimeStamp?
        /// Renews a token generated for a user to access the Amazon Connect instance.
        public let refreshToken: String?
        /// Renews the expiration timer for a generated token.
        public let refreshTokenExpiration: TimeStamp?

        public init(accessToken: String? = nil, accessTokenExpiration: TimeStamp? = nil, refreshToken: String? = nil, refreshTokenExpiration: TimeStamp? = nil) {
            self.accessToken = accessToken
            self.accessTokenExpiration = accessTokenExpiration
            self.refreshToken = refreshToken
            self.refreshTokenExpiration = refreshTokenExpiration
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "AccessToken"
            case accessTokenExpiration = "AccessTokenExpiration"
            case refreshToken = "RefreshToken"
            case refreshTokenExpiration = "RefreshTokenExpiration"
        }
    }

    public struct CurrentMetric: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .enum), 
            AWSShapeMember(label: "Unit", required: false, type: .enum)
        ]

        /// The name of the metric.
        public let name: CurrentMetricName?
        /// The unit for the metric.
        public let unit: Unit?

        public init(name: CurrentMetricName? = nil, unit: Unit? = nil) {
            self.name = name
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case unit = "Unit"
        }
    }

    public struct CurrentMetricData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Metric", required: false, type: .structure), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]

        /// Information about the metric.
        public let metric: CurrentMetric?
        /// The value of the metric.
        public let value: Double?

        public init(metric: CurrentMetric? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public enum CurrentMetricName: String, CustomStringConvertible, Codable {
        case agentsOnline = "AGENTS_ONLINE"
        case agentsAvailable = "AGENTS_AVAILABLE"
        case agentsOnCall = "AGENTS_ON_CALL"
        case agentsNonProductive = "AGENTS_NON_PRODUCTIVE"
        case agentsAfterContactWork = "AGENTS_AFTER_CONTACT_WORK"
        case agentsError = "AGENTS_ERROR"
        case agentsStaffed = "AGENTS_STAFFED"
        case contactsInQueue = "CONTACTS_IN_QUEUE"
        case oldestContactAge = "OLDEST_CONTACT_AGE"
        case contactsScheduled = "CONTACTS_SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public struct CurrentMetricResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Collections", required: false, type: .list), 
            AWSShapeMember(label: "Dimensions", required: false, type: .structure)
        ]

        /// The set of metrics.
        public let collections: [CurrentMetricData]?
        /// The dimensions for the metrics.
        public let dimensions: Dimensions?

        public init(collections: [CurrentMetricData]? = nil, dimensions: Dimensions? = nil) {
            self.collections = collections
            self.dimensions = dimensions
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
        }
    }

    public struct DeleteUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The identifier of the user.
        public let userId: String

        public init(instanceId: String, userId: String) {
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct DescribeUserHierarchyGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HierarchyGroupId", location: .uri(locationName: "HierarchyGroupId"), required: true, type: .string), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string)
        ]

        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(hierarchyGroupId: String, instanceId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupId = "HierarchyGroupId"
            case instanceId = "InstanceId"
        }
    }

    public struct DescribeUserHierarchyGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HierarchyGroup", required: false, type: .structure)
        ]

        /// Information about the hierarchy group.
        public let hierarchyGroup: HierarchyGroup?

        public init(hierarchyGroup: HierarchyGroup? = nil) {
            self.hierarchyGroup = hierarchyGroup
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroup = "HierarchyGroup"
        }
    }

    public struct DescribeUserHierarchyStructureRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
        }
    }

    public struct DescribeUserHierarchyStructureResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HierarchyStructure", required: false, type: .structure)
        ]

        /// Information about the hierarchy structure.
        public let hierarchyStructure: HierarchyStructure?

        public init(hierarchyStructure: HierarchyStructure? = nil) {
            self.hierarchyStructure = hierarchyStructure
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyStructure = "HierarchyStructure"
        }
    }

    public struct DescribeUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, userId: String) {
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct DescribeUserResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "User", required: false, type: .structure)
        ]

        /// Information about the user account and configuration settings.
        public let user: User?

        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct Dimensions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channel", required: false, type: .enum), 
            AWSShapeMember(label: "Queue", required: false, type: .structure)
        ]

        /// The channel used for grouping and filters.
        public let channel: Channel?
        /// Information about the queue for which metrics are returned.
        public let queue: QueueReference?

        public init(channel: Channel? = nil, queue: QueueReference? = nil) {
            self.channel = channel
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case queue = "Queue"
        }
    }

    public struct Filters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", required: false, type: .list), 
            AWSShapeMember(label: "Queues", required: false, type: .list)
        ]

        /// The channel to use to filter the metrics.
        public let channels: [Channel]?
        /// The queues to use to filter the metrics. You can specify up to 100 queues per request.
        public let queues: [String]?

        public init(channels: [Channel]? = nil, queues: [String]? = nil) {
            self.channels = channels
            self.queues = queues
        }

        public func validate(name: String) throws {
            try validate(self.channels, name:"channels", parent: name, max: 1)
            try validate(self.queues, name:"queues", parent: name, max: 100)
            try validate(self.queues, name:"queues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case queues = "Queues"
        }
    }

    public struct GetContactAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InitialContactId", location: .uri(locationName: "InitialContactId"), required: true, type: .string), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string)
        ]

        /// The identifier of the initial contact.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(initialContactId: String, instanceId: String) {
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try validate(self.initialContactId, name:"initialContactId", parent: name, max: 256)
            try validate(self.initialContactId, name:"initialContactId", parent: name, min: 1)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct GetContactAttributesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map)
        ]

        /// Information about the attributes.
        public let attributes: [String: String]?

        public init(attributes: [String: String]? = nil) {
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct GetCurrentMetricDataRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CurrentMetrics", required: true, type: .list), 
            AWSShapeMember(label: "Filters", required: true, type: .structure), 
            AWSShapeMember(label: "Groupings", required: false, type: .list), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available:  AGENTS_AFTER_CONTACT_WORK  Unit: COUNT  AGENTS_AVAILABLE  Unit: COUNT  AGENTS_ERROR  Unit: COUNT  AGENTS_NON_PRODUCTIVE  Unit: COUNT  AGENTS_ON_CALL  Unit: COUNT  AGENTS_ONLINE  Unit: COUNT  AGENTS_STAFFED  Unit: COUNT  CONTACTS_IN_QUEUE  Unit: COUNT  CONTACTS_SCHEDULED  Unit: COUNT  OLDEST_CONTACT_AGE  Unit: SECONDS  
        public let currentMetrics: [CurrentMetric]
        /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. The only supported channel is VOICE.
        public let filters: Filters
        /// The grouping applied to the metrics returned. For example, when grouped by QUEUE, the metrics returned apply to each queue rather than aggregated for all queues. If you group by CHANNEL, you should include a Channels filter. The only supported channel is VOICE. If no Grouping is included in the request, a summary of metrics is returned.
        public let groupings: [Grouping]?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        public init(currentMetrics: [CurrentMetric], filters: Filters, groupings: [Grouping]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.currentMetrics = currentMetrics
            self.filters = filters
            self.groupings = groupings
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try validate(self.groupings, name:"groupings", parent: name, max: 2)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentMetrics = "CurrentMetrics"
            case filters = "Filters"
            case groupings = "Groupings"
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCurrentMetricDataResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DataSnapshotTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "MetricResults", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The time at which the metrics were retrieved and cached for pagination.
        public let dataSnapshotTime: TimeStamp?
        /// Information about the real-time metrics.
        public let metricResults: [CurrentMetricResult]?
        /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        public init(dataSnapshotTime: TimeStamp? = nil, metricResults: [CurrentMetricResult]? = nil, nextToken: String? = nil) {
            self.dataSnapshotTime = dataSnapshotTime
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSnapshotTime = "DataSnapshotTime"
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetFederationTokenRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
        }
    }

    public struct GetFederationTokenResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Credentials", required: false, type: .structure)
        ]

        /// The credentials to use for federation.
        public let credentials: Credentials?

        public init(credentials: Credentials? = nil) {
            self.credentials = credentials
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
        }
    }

    public struct GetMetricDataRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "Filters", required: true, type: .structure), 
            AWSShapeMember(label: "Groupings", required: false, type: .list), 
            AWSShapeMember(label: "HistoricalMetrics", required: true, type: .list), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]

        /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp. The time range between the start and end time must be less than 24 hours.
        public let endTime: TimeStamp
        /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. The only supported channel is VOICE.
        public let filters: Filters
        /// The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues. The only supported grouping is QUEUE. If no grouping is specified, a summary of metrics for all queues is returned.
        public let groupings: [Grouping]?
        /// The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available:  ABANDON_TIME  Unit: SECONDS Statistic: AVG  AFTER_CONTACT_WORK_TIME  Unit: SECONDS Statistic: AVG  API_CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CALLBACK_CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CONTACTS_ABANDONED  Unit: COUNT Statistic: SUM  CONTACTS_AGENT_HUNG_UP_FIRST  Unit: COUNT Statistic: SUM  CONTACTS_CONSULTED  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED_INCOMING  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED_OUTBOUND  Unit: COUNT Statistic: SUM  CONTACTS_HOLD_ABANDONS  Unit: COUNT Statistic: SUM  CONTACTS_MISSED  Unit: COUNT Statistic: SUM  CONTACTS_QUEUED  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_IN  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_IN_FROM_QUEUE  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_OUT  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_OUT_FROM_QUEUE  Unit: COUNT Statistic: SUM  HANDLE_TIME  Unit: SECONDS Statistic: AVG  HOLD_TIME  Unit: SECONDS Statistic: AVG  INTERACTION_AND_HOLD_TIME  Unit: SECONDS Statistic: AVG  INTERACTION_TIME  Unit: SECONDS Statistic: AVG  OCCUPANCY  Unit: PERCENT Statistic: AVG  QUEUE_ANSWER_TIME  Unit: SECONDS Statistic: AVG  QUEUED_TIME  Unit: SECONDS Statistic: MAX  SERVICE_LEVEL  Unit: PERCENT Statistic: AVG Threshold: Only "Less than" comparisons are supported, with the following service level thresholds: 15, 20, 25, 30, 45, 60, 90, 120, 180, 240, 300, 600  
        public let historicalMetrics: [HistoricalMetric]
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15. The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.
        public let startTime: TimeStamp

        public init(endTime: TimeStamp, filters: Filters, groupings: [Grouping]? = nil, historicalMetrics: [HistoricalMetric], instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, startTime: TimeStamp) {
            self.endTime = endTime
            self.filters = filters
            self.groupings = groupings
            self.historicalMetrics = historicalMetrics
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try validate(self.groupings, name:"groupings", parent: name, max: 2)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filters = "Filters"
            case groupings = "Groupings"
            case historicalMetrics = "HistoricalMetrics"
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetMetricDataResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricResults", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Information about the historical metrics. If no grouping is specified, a summary of metric data is returned.
        public let metricResults: [HistoricalMetricResult]?
        /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        public init(metricResults: [HistoricalMetricResult]? = nil, nextToken: String? = nil) {
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public enum Grouping: String, CustomStringConvertible, Codable {
        case queue = "QUEUE"
        case channel = "CHANNEL"
        public var description: String { return self.rawValue }
    }

    public struct HierarchyGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "HierarchyPath", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "LevelId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let arn: String?
        /// Information about the levels in the hierarchy group.
        public let hierarchyPath: HierarchyPath?
        /// The identifier of the hierarchy group.
        public let id: String?
        /// The identifier of the level in the hierarchy group.
        public let levelId: String?
        /// The name of the hierarchy group.
        public let name: String?

        public init(arn: String? = nil, hierarchyPath: HierarchyPath? = nil, id: String? = nil, levelId: String? = nil, name: String? = nil) {
            self.arn = arn
            self.hierarchyPath = hierarchyPath
            self.id = id
            self.levelId = levelId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case hierarchyPath = "HierarchyPath"
            case id = "Id"
            case levelId = "LevelId"
            case name = "Name"
        }
    }

    public struct HierarchyGroupSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let arn: String?
        /// The identifier of the hierarchy group.
        public let id: String?
        /// The name of the hierarchy group.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct HierarchyLevel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the hierarchy level.
        public let arn: String?
        /// The identifier of the hierarchy level.
        public let id: String?
        /// The name of the hierarchy level.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct HierarchyPath: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LevelFive", required: false, type: .structure), 
            AWSShapeMember(label: "LevelFour", required: false, type: .structure), 
            AWSShapeMember(label: "LevelOne", required: false, type: .structure), 
            AWSShapeMember(label: "LevelThree", required: false, type: .structure), 
            AWSShapeMember(label: "LevelTwo", required: false, type: .structure)
        ]

        /// Information about level five.
        public let levelFive: HierarchyGroupSummary?
        /// Information about level four.
        public let levelFour: HierarchyGroupSummary?
        /// Information about level one.
        public let levelOne: HierarchyGroupSummary?
        /// Information about level three.
        public let levelThree: HierarchyGroupSummary?
        /// Information about level two.
        public let levelTwo: HierarchyGroupSummary?

        public init(levelFive: HierarchyGroupSummary? = nil, levelFour: HierarchyGroupSummary? = nil, levelOne: HierarchyGroupSummary? = nil, levelThree: HierarchyGroupSummary? = nil, levelTwo: HierarchyGroupSummary? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyStructure: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LevelFive", required: false, type: .structure), 
            AWSShapeMember(label: "LevelFour", required: false, type: .structure), 
            AWSShapeMember(label: "LevelOne", required: false, type: .structure), 
            AWSShapeMember(label: "LevelThree", required: false, type: .structure), 
            AWSShapeMember(label: "LevelTwo", required: false, type: .structure)
        ]

        /// Information about level five.
        public let levelFive: HierarchyLevel?
        /// Information about level four.
        public let levelFour: HierarchyLevel?
        /// Information about level one.
        public let levelOne: HierarchyLevel?
        /// Information about level three.
        public let levelThree: HierarchyLevel?
        /// Information about level two.
        public let levelTwo: HierarchyLevel?

        public init(levelFive: HierarchyLevel? = nil, levelFour: HierarchyLevel? = nil, levelOne: HierarchyLevel? = nil, levelThree: HierarchyLevel? = nil, levelTwo: HierarchyLevel? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HistoricalMetric: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .enum), 
            AWSShapeMember(label: "Statistic", required: false, type: .enum), 
            AWSShapeMember(label: "Threshold", required: false, type: .structure), 
            AWSShapeMember(label: "Unit", required: false, type: .enum)
        ]

        /// The name of the metric.
        public let name: HistoricalMetricName?
        /// The statistic for the metric.
        public let statistic: Statistic?
        /// The threshold for the metric, used with service level metrics.
        public let threshold: Threshold?
        /// The unit for the metric.
        public let unit: Unit?

        public init(name: HistoricalMetricName? = nil, statistic: Statistic? = nil, threshold: Threshold? = nil, unit: Unit? = nil) {
            self.name = name
            self.statistic = statistic
            self.threshold = threshold
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case statistic = "Statistic"
            case threshold = "Threshold"
            case unit = "Unit"
        }
    }

    public struct HistoricalMetricData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Metric", required: false, type: .structure), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]

        /// Information about the metric.
        public let metric: HistoricalMetric?
        /// The value of the metric.
        public let value: Double?

        public init(metric: HistoricalMetric? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public enum HistoricalMetricName: String, CustomStringConvertible, Codable {
        case contactsQueued = "CONTACTS_QUEUED"
        case contactsHandled = "CONTACTS_HANDLED"
        case contactsAbandoned = "CONTACTS_ABANDONED"
        case contactsConsulted = "CONTACTS_CONSULTED"
        case contactsAgentHungUpFirst = "CONTACTS_AGENT_HUNG_UP_FIRST"
        case contactsHandledIncoming = "CONTACTS_HANDLED_INCOMING"
        case contactsHandledOutbound = "CONTACTS_HANDLED_OUTBOUND"
        case contactsHoldAbandons = "CONTACTS_HOLD_ABANDONS"
        case contactsTransferredIn = "CONTACTS_TRANSFERRED_IN"
        case contactsTransferredOut = "CONTACTS_TRANSFERRED_OUT"
        case contactsTransferredInFromQueue = "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
        case contactsTransferredOutFromQueue = "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
        case contactsMissed = "CONTACTS_MISSED"
        case callbackContactsHandled = "CALLBACK_CONTACTS_HANDLED"
        case apiContactsHandled = "API_CONTACTS_HANDLED"
        case occupancy = "OCCUPANCY"
        case handleTime = "HANDLE_TIME"
        case afterContactWorkTime = "AFTER_CONTACT_WORK_TIME"
        case queuedTime = "QUEUED_TIME"
        case abandonTime = "ABANDON_TIME"
        case queueAnswerTime = "QUEUE_ANSWER_TIME"
        case holdTime = "HOLD_TIME"
        case interactionTime = "INTERACTION_TIME"
        case interactionAndHoldTime = "INTERACTION_AND_HOLD_TIME"
        case serviceLevel = "SERVICE_LEVEL"
        public var description: String { return self.rawValue }
    }

    public struct HistoricalMetricResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Collections", required: false, type: .list), 
            AWSShapeMember(label: "Dimensions", required: false, type: .structure)
        ]

        /// The set of metrics.
        public let collections: [HistoricalMetricData]?
        /// The dimension for the metrics.
        public let dimensions: Dimensions?

        public init(collections: [HistoricalMetricData]? = nil, dimensions: Dimensions? = nil) {
            self.collections = collections
            self.dimensions = dimensions
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
        }
    }

    public struct HoursOfOperationSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the hours of operation.
        public let arn: String?
        /// The identifier of the hours of operation.
        public let id: String?
        /// The name of the hours of operation.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ListContactFlowsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContactFlowTypes", location: .querystring(locationName: "contactFlowTypes"), required: false, type: .list), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The type of contact flow.
        public let contactFlowTypes: [ContactFlowType]?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(contactFlowTypes: [ContactFlowType]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactFlowTypes = contactFlowTypes
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.contactFlowTypes, name:"contactFlowTypes", parent: name, max: 10)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowTypes = "contactFlowTypes"
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListContactFlowsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContactFlowSummaryList", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Information about the contact flows.
        public let contactFlowSummaryList: [ContactFlowSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contactFlowSummaryList: [ContactFlowSummary]? = nil, nextToken: String? = nil) {
            self.contactFlowSummaryList = contactFlowSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowSummaryList = "ContactFlowSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListHoursOfOperationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListHoursOfOperationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HoursOfOperationSummaryList", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Information about the hours of operation.
        public let hoursOfOperationSummaryList: [HoursOfOperationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(hoursOfOperationSummaryList: [HoursOfOperationSummary]? = nil, nextToken: String? = nil) {
            self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationSummaryList = "HoursOfOperationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListPhoneNumbersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumberCountryCodes", location: .querystring(locationName: "phoneNumberCountryCodes"), required: false, type: .list), 
            AWSShapeMember(label: "PhoneNumberTypes", location: .querystring(locationName: "phoneNumberTypes"), required: false, type: .list)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCodes: [PhoneNumberCountryCode]?
        /// The type of phone number.
        public let phoneNumberTypes: [PhoneNumberType]?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCodes: [PhoneNumberCountryCode]? = nil, phoneNumberTypes: [PhoneNumberType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCodes = phoneNumberCountryCodes
            self.phoneNumberTypes = phoneNumberTypes
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.phoneNumberCountryCodes, name:"phoneNumberCountryCodes", parent: name, max: 10)
            try validate(self.phoneNumberTypes, name:"phoneNumberTypes", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case phoneNumberCountryCodes = "phoneNumberCountryCodes"
            case phoneNumberTypes = "phoneNumberTypes"
        }
    }

    public struct ListPhoneNumbersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumberSummaryList", required: false, type: .list)
        ]

        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the phone numbers.
        public let phoneNumberSummaryList: [PhoneNumberSummary]?

        public init(nextToken: String? = nil, phoneNumberSummaryList: [PhoneNumberSummary]? = nil) {
            self.nextToken = nextToken
            self.phoneNumberSummaryList = phoneNumberSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case phoneNumberSummaryList = "PhoneNumberSummaryList"
        }
    }

    public struct ListQueuesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "QueueTypes", location: .querystring(locationName: "queueTypes"), required: false, type: .list)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of queue.
        public let queueTypes: [QueueType]?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, queueTypes: [QueueType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueTypes = queueTypes
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.queueTypes, name:"queueTypes", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case queueTypes = "queueTypes"
        }
    }

    public struct ListQueuesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "QueueSummaryList", required: false, type: .list)
        ]

        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the queues.
        public let queueSummaryList: [QueueSummary]?

        public init(nextToken: String? = nil, queueSummaryList: [QueueSummary]? = nil) {
            self.nextToken = nextToken
            self.queueSummaryList = queueSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queueSummaryList = "QueueSummaryList"
        }
    }

    public struct ListRoutingProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRoutingProfilesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "RoutingProfileSummaryList", required: false, type: .list)
        ]

        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfileSummaryList: [RoutingProfileSummary]?

        public init(nextToken: String? = nil, routingProfileSummaryList: [RoutingProfileSummary]? = nil) {
            self.nextToken = nextToken
            self.routingProfileSummaryList = routingProfileSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case routingProfileSummaryList = "RoutingProfileSummaryList"
        }
    }

    public struct ListSecurityProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSecurityProfilesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SecurityProfileSummaryList", required: false, type: .list)
        ]

        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the security profiles.
        public let securityProfileSummaryList: [SecurityProfileSummary]?

        public init(nextToken: String? = nil, securityProfileSummaryList: [SecurityProfileSummary]? = nil) {
            self.nextToken = nextToken
            self.securityProfileSummaryList = securityProfileSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityProfileSummaryList = "SecurityProfileSummaryList"
        }
    }

    public struct ListUserHierarchyGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListUserHierarchyGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "UserHierarchyGroupSummaryList", required: false, type: .list)
        ]

        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the hierarchy groups.
        public let userHierarchyGroupSummaryList: [HierarchyGroupSummary]?

        public init(nextToken: String? = nil, userHierarchyGroupSummaryList: [HierarchyGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userHierarchyGroupSummaryList = "UserHierarchyGroupSummaryList"
        }
    }

    public struct ListUsersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximimum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListUsersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "UserSummaryList", required: false, type: .list)
        ]

        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the users.
        public let userSummaryList: [UserSummary]?

        public init(nextToken: String? = nil, userSummaryList: [UserSummary]? = nil) {
            self.nextToken = nextToken
            self.userSummaryList = userSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userSummaryList = "UserSummaryList"
        }
    }

    public enum PhoneNumberCountryCode: String, CustomStringConvertible, Codable {
        case af = "AF"
        case al = "AL"
        case dz = "DZ"
        case `as` = "AS"
        case ad = "AD"
        case ao = "AO"
        case ai = "AI"
        case aq = "AQ"
        case ag = "AG"
        case ar = "AR"
        case am = "AM"
        case aw = "AW"
        case au = "AU"
        case at = "AT"
        case az = "AZ"
        case bs = "BS"
        case bh = "BH"
        case bd = "BD"
        case bb = "BB"
        case by = "BY"
        case be = "BE"
        case bz = "BZ"
        case bj = "BJ"
        case bm = "BM"
        case bt = "BT"
        case bo = "BO"
        case ba = "BA"
        case bw = "BW"
        case br = "BR"
        case io = "IO"
        case vg = "VG"
        case bn = "BN"
        case bg = "BG"
        case bf = "BF"
        case bi = "BI"
        case kh = "KH"
        case cm = "CM"
        case ca = "CA"
        case cv = "CV"
        case ky = "KY"
        case cf = "CF"
        case td = "TD"
        case cl = "CL"
        case cn = "CN"
        case cx = "CX"
        case cc = "CC"
        case co = "CO"
        case km = "KM"
        case ck = "CK"
        case cr = "CR"
        case hr = "HR"
        case cu = "CU"
        case cw = "CW"
        case cy = "CY"
        case cz = "CZ"
        case cd = "CD"
        case dk = "DK"
        case dj = "DJ"
        case dm = "DM"
        case `do` = "DO"
        case tl = "TL"
        case ec = "EC"
        case eg = "EG"
        case sv = "SV"
        case gq = "GQ"
        case er = "ER"
        case ee = "EE"
        case et = "ET"
        case fk = "FK"
        case fo = "FO"
        case fj = "FJ"
        case fi = "FI"
        case fr = "FR"
        case pf = "PF"
        case ga = "GA"
        case gm = "GM"
        case ge = "GE"
        case de = "DE"
        case gh = "GH"
        case gi = "GI"
        case gr = "GR"
        case gl = "GL"
        case gd = "GD"
        case gu = "GU"
        case gt = "GT"
        case gg = "GG"
        case gn = "GN"
        case gw = "GW"
        case gy = "GY"
        case ht = "HT"
        case hn = "HN"
        case hk = "HK"
        case hu = "HU"
        case `is` = "IS"
        case `in` = "IN"
        case id = "ID"
        case ir = "IR"
        case iq = "IQ"
        case ie = "IE"
        case im = "IM"
        case il = "IL"
        case it = "IT"
        case ci = "CI"
        case jm = "JM"
        case jp = "JP"
        case je = "JE"
        case jo = "JO"
        case kz = "KZ"
        case ke = "KE"
        case ki = "KI"
        case kw = "KW"
        case kg = "KG"
        case la = "LA"
        case lv = "LV"
        case lb = "LB"
        case ls = "LS"
        case lr = "LR"
        case ly = "LY"
        case li = "LI"
        case lt = "LT"
        case lu = "LU"
        case mo = "MO"
        case mk = "MK"
        case mg = "MG"
        case mw = "MW"
        case my = "MY"
        case mv = "MV"
        case ml = "ML"
        case mt = "MT"
        case mh = "MH"
        case mr = "MR"
        case mu = "MU"
        case yt = "YT"
        case mx = "MX"
        case fm = "FM"
        case md = "MD"
        case mc = "MC"
        case mn = "MN"
        case me = "ME"
        case ms = "MS"
        case ma = "MA"
        case mz = "MZ"
        case mm = "MM"
        case na = "NA"
        case nr = "NR"
        case np = "NP"
        case nl = "NL"
        case an = "AN"
        case nc = "NC"
        case nz = "NZ"
        case ni = "NI"
        case ne = "NE"
        case ng = "NG"
        case nu = "NU"
        case kp = "KP"
        case mp = "MP"
        case no = "NO"
        case om = "OM"
        case pk = "PK"
        case pw = "PW"
        case pa = "PA"
        case pg = "PG"
        case py = "PY"
        case pe = "PE"
        case ph = "PH"
        case pn = "PN"
        case pl = "PL"
        case pt = "PT"
        case pr = "PR"
        case qa = "QA"
        case cg = "CG"
        case re = "RE"
        case ro = "RO"
        case ru = "RU"
        case rw = "RW"
        case bl = "BL"
        case sh = "SH"
        case kn = "KN"
        case lc = "LC"
        case mf = "MF"
        case pm = "PM"
        case vc = "VC"
        case ws = "WS"
        case sm = "SM"
        case st = "ST"
        case sa = "SA"
        case sn = "SN"
        case rs = "RS"
        case sc = "SC"
        case sl = "SL"
        case sg = "SG"
        case sx = "SX"
        case sk = "SK"
        case si = "SI"
        case sb = "SB"
        case so = "SO"
        case za = "ZA"
        case kr = "KR"
        case es = "ES"
        case lk = "LK"
        case sd = "SD"
        case sr = "SR"
        case sj = "SJ"
        case sz = "SZ"
        case se = "SE"
        case ch = "CH"
        case sy = "SY"
        case tw = "TW"
        case tj = "TJ"
        case tz = "TZ"
        case th = "TH"
        case tg = "TG"
        case tk = "TK"
        case to = "TO"
        case tt = "TT"
        case tn = "TN"
        case tr = "TR"
        case tm = "TM"
        case tc = "TC"
        case tv = "TV"
        case vi = "VI"
        case ug = "UG"
        case ua = "UA"
        case ae = "AE"
        case gb = "GB"
        case us = "US"
        case uy = "UY"
        case uz = "UZ"
        case vu = "VU"
        case va = "VA"
        case ve = "VE"
        case vn = "VN"
        case wf = "WF"
        case eh = "EH"
        case ye = "YE"
        case zm = "ZM"
        case zw = "ZW"
        public var description: String { return self.rawValue }
    }

    public struct PhoneNumberSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumber", required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumberCountryCode", required: false, type: .enum), 
            AWSShapeMember(label: "PhoneNumberType", required: false, type: .enum)
        ]

        /// The Amazon Resource Name (ARN) of the phone number.
        public let arn: String?
        /// The identifier of the phone number.
        public let id: String?
        /// The phone number.
        public let phoneNumber: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?

        public init(arn: String? = nil, id: String? = nil, phoneNumber: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberType: PhoneNumberType? = nil) {
            self.arn = arn
            self.id = id
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case phoneNumber = "PhoneNumber"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberType = "PhoneNumberType"
        }
    }

    public enum PhoneNumberType: String, CustomStringConvertible, Codable {
        case tollFree = "TOLL_FREE"
        case did = "DID"
        public var description: String { return self.rawValue }
    }

    public enum PhoneType: String, CustomStringConvertible, Codable {
        case softPhone = "SOFT_PHONE"
        case deskPhone = "DESK_PHONE"
        public var description: String { return self.rawValue }
    }

    public struct QueueReference: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the queue.
        public let arn: String?
        /// The identifier of the queue.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct QueueSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "QueueType", required: false, type: .enum)
        ]

        /// The Amazon Resource Name (ARN) of the queue.
        public let arn: String?
        /// The identifier of the queue.
        public let id: String?
        /// The name of the queue.
        public let name: String?
        /// The type of queue.
        public let queueType: QueueType?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, queueType: QueueType? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.queueType = queueType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case queueType = "QueueType"
        }
    }

    public enum QueueType: String, CustomStringConvertible, Codable {
        case standard = "STANDARD"
        case agent = "AGENT"
        public var description: String { return self.rawValue }
    }

    public struct RoutingProfileSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the routing profile.
        public let arn: String?
        /// The identifier of the routing profile.
        public let id: String?
        /// The name of the routing profile.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct SecurityProfileSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the security profile.
        public let arn: String?
        /// The identifier of the security profile.
        public let id: String?
        /// The name of the security profile.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct StartOutboundVoiceContactRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ClientToken", required: false, type: .string), 
            AWSShapeMember(label: "ContactFlowId", required: true, type: .string), 
            AWSShapeMember(label: "DestinationPhoneNumber", required: true, type: .string), 
            AWSShapeMember(label: "InstanceId", required: true, type: .string), 
            AWSShapeMember(label: "QueueId", required: false, type: .string), 
            AWSShapeMember(label: "SourcePhoneNumber", required: false, type: .string)
        ]

        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned. If the contact is disconnected, a new contact is started.
        public let clientToken: String?
        /// The identifier of the contact flow for the outbound call.
        public let contactFlowId: String
        /// The phone number of the customer, in E.164 format.
        public let destinationPhoneNumber: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
        public let queueId: String?
        /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
        public let sourcePhoneNumber: String?

        public init(attributes: [String: String]? = nil, clientToken: String? = StartOutboundVoiceContactRequest.idempotencyToken(), contactFlowId: String, destinationPhoneNumber: String, instanceId: String, queueId: String? = nil, sourcePhoneNumber: String? = nil) {
            self.attributes = attributes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.destinationPhoneNumber = destinationPhoneNumber
            self.instanceId = instanceId
            self.queueId = queueId
            self.sourcePhoneNumber = sourcePhoneNumber
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name:"attributes.key", parent: name, max: 32767)
                try validate($0.key, name:"attributes.key", parent: name, min: 1)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, min: 0)
            }
            try validate(self.clientToken, name:"clientToken", parent: name, max: 500)
            try validate(self.contactFlowId, name:"contactFlowId", parent: name, max: 500)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case instanceId = "InstanceId"
            case queueId = "QueueId"
            case sourcePhoneNumber = "SourcePhoneNumber"
        }
    }

    public struct StartOutboundVoiceContactResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContactId", required: false, type: .string)
        ]

        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public enum Statistic: String, CustomStringConvertible, Codable {
        case sum = "SUM"
        case max = "MAX"
        case avg = "AVG"
        public var description: String { return self.rawValue }
    }

    public struct StopContactRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContactId", required: true, type: .string), 
            AWSShapeMember(label: "InstanceId", required: true, type: .string)
        ]

        /// The ID of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(contactId: String, instanceId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try validate(self.contactId, name:"contactId", parent: name, max: 256)
            try validate(self.contactId, name:"contactId", parent: name, min: 1)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StopContactResponse: AWSShape {


        public init() {
        }

    }

    public struct Threshold: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Comparison", required: false, type: .enum), 
            AWSShapeMember(label: "ThresholdValue", required: false, type: .double)
        ]

        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public let comparison: Comparison?
        /// The threshold value to compare.
        public let thresholdValue: Double?

        public init(comparison: Comparison? = nil, thresholdValue: Double? = nil) {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case thresholdValue = "ThresholdValue"
        }
    }

    public enum Unit: String, CustomStringConvertible, Codable {
        case seconds = "SECONDS"
        case count = "COUNT"
        case percent = "PERCENT"
        public var description: String { return self.rawValue }
    }

    public struct UpdateContactAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: true, type: .map), 
            AWSShapeMember(label: "InitialContactId", required: true, type: .string), 
            AWSShapeMember(label: "InstanceId", required: true, type: .string)
        ]

        /// The Amazon Connect attributes. These attributes can be accessed in contact flows just like any other contact attributes. You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(attributes: [String: String], initialContactId: String, instanceId: String) {
            self.attributes = attributes
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try validate($0.key, name:"attributes.key", parent: name, max: 32767)
                try validate($0.key, name:"attributes.key", parent: name, min: 1)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, min: 0)
            }
            try validate(self.initialContactId, name:"initialContactId", parent: name, max: 256)
            try validate(self.initialContactId, name:"initialContactId", parent: name, min: 1)
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct UpdateContactAttributesResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateUserHierarchyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HierarchyGroupId", required: false, type: .string), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(hierarchyGroupId: String? = nil, instanceId: String, userId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupId = "HierarchyGroupId"
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct UpdateUserIdentityInfoRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IdentityInfo", required: true, type: .structure), 
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identity information for the user.
        public let identityInfo: UserIdentityInfo
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(identityInfo: UserIdentityInfo, instanceId: String, userId: String) {
            self.identityInfo = identityInfo
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.identityInfo.validate(name: "\(name).identityInfo")
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityInfo = "IdentityInfo"
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct UpdateUserPhoneConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "PhoneConfig", required: true, type: .structure), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// Information about phone configuration settings for the user.
        public let phoneConfig: UserPhoneConfig
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, phoneConfig: UserPhoneConfig, userId: String) {
            self.instanceId = instanceId
            self.phoneConfig = phoneConfig
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try self.phoneConfig.validate(name: "\(name).phoneConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case phoneConfig = "PhoneConfig"
            case userId = "UserId"
        }
    }

    public struct UpdateUserRoutingProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "RoutingProfileId", required: true, type: .string), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, routingProfileId: String, userId: String) {
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case routingProfileId = "RoutingProfileId"
            case userId = "UserId"
        }
    }

    public struct UpdateUserSecurityProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceId", location: .uri(locationName: "InstanceId"), required: true, type: .string), 
            AWSShapeMember(label: "SecurityProfileIds", required: true, type: .list), 
            AWSShapeMember(label: "UserId", location: .uri(locationName: "UserId"), required: true, type: .string)
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The identifiers of the security profiles for the user.
        public let securityProfileIds: [String]
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, securityProfileIds: [String], userId: String) {
            self.instanceId = instanceId
            self.securityProfileIds = securityProfileIds
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.instanceId, name:"instanceId", parent: name, max: 100)
            try validate(self.instanceId, name:"instanceId", parent: name, min: 1)
            try validate(self.securityProfileIds, name:"securityProfileIds", parent: name, max: 10)
            try validate(self.securityProfileIds, name:"securityProfileIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case securityProfileIds = "SecurityProfileIds"
            case userId = "UserId"
        }
    }

    public struct User: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryUserId", required: false, type: .string), 
            AWSShapeMember(label: "HierarchyGroupId", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "IdentityInfo", required: false, type: .structure), 
            AWSShapeMember(label: "PhoneConfig", required: false, type: .structure), 
            AWSShapeMember(label: "RoutingProfileId", required: false, type: .string), 
            AWSShapeMember(label: "SecurityProfileIds", required: false, type: .list), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the user account.
        public let arn: String?
        /// The identifier of the user account in the directory used for identity management.
        public let directoryUserId: String?
        /// The identifier of the hierarchy group for the user.
        public let hierarchyGroupId: String?
        /// The identifier of the user account.
        public let id: String?
        /// Information about the user identity.
        public let identityInfo: UserIdentityInfo?
        /// Information about the phone configuration for the user.
        public let phoneConfig: UserPhoneConfig?
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String?
        /// The identifiers of the security profiles for the user.
        public let securityProfileIds: [String]?
        /// The user name assigned to the user account.
        public let username: String?

        public init(arn: String? = nil, directoryUserId: String? = nil, hierarchyGroupId: String? = nil, id: String? = nil, identityInfo: UserIdentityInfo? = nil, phoneConfig: UserPhoneConfig? = nil, routingProfileId: String? = nil, securityProfileIds: [String]? = nil, username: String? = nil) {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case id = "Id"
            case identityInfo = "IdentityInfo"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case username = "Username"
        }
    }

    public struct UserIdentityInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Email", required: false, type: .string), 
            AWSShapeMember(label: "FirstName", required: false, type: .string), 
            AWSShapeMember(label: "LastName", required: false, type: .string)
        ]

        /// The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        public let email: String?
        /// The first name. This is required if you are using Amazon Connect or SAML for identity management.
        public let firstName: String?
        /// The last name. This is required if you are using Amazon Connect or SAML for identity management.
        public let lastName: String?

        public init(email: String? = nil, firstName: String? = nil, lastName: String? = nil) {
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
        }

        public func validate(name: String) throws {
            try validate(self.firstName, name:"firstName", parent: name, max: 100)
            try validate(self.firstName, name:"firstName", parent: name, min: 1)
            try validate(self.lastName, name:"lastName", parent: name, max: 100)
            try validate(self.lastName, name:"lastName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case firstName = "FirstName"
            case lastName = "LastName"
        }
    }

    public struct UserPhoneConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AfterContactWorkTimeLimit", required: false, type: .integer), 
            AWSShapeMember(label: "AutoAccept", required: false, type: .boolean), 
            AWSShapeMember(label: "DeskPhoneNumber", required: false, type: .string), 
            AWSShapeMember(label: "PhoneType", required: true, type: .enum)
        ]

        /// The After Call Work (ACW) timeout setting, in seconds.
        public let afterContactWorkTimeLimit: Int?
        /// The Auto accept setting.
        public let autoAccept: Bool?
        /// The phone number for the user's desk phone.
        public let deskPhoneNumber: String?
        /// The phone type.
        public let phoneType: PhoneType

        public init(afterContactWorkTimeLimit: Int? = nil, autoAccept: Bool? = nil, deskPhoneNumber: String? = nil, phoneType: PhoneType) {
            self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
            self.autoAccept = autoAccept
            self.deskPhoneNumber = deskPhoneNumber
            self.phoneType = phoneType
        }

        public func validate(name: String) throws {
            try validate(self.afterContactWorkTimeLimit, name:"afterContactWorkTimeLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case afterContactWorkTimeLimit = "AfterContactWorkTimeLimit"
            case autoAccept = "AutoAccept"
            case deskPhoneNumber = "DeskPhoneNumber"
            case phoneType = "PhoneType"
        }
    }

    public struct UserSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the user account.
        public let arn: String?
        /// The identifier of the user account.
        public let id: String?
        /// The Amazon Connect user name of the user account.
        public let username: String?

        public init(arn: String? = nil, id: String? = nil, username: String? = nil) {
            self.arn = arn
            self.id = id
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case username = "Username"
        }
    }
}
