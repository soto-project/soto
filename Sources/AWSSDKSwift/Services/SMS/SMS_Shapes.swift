// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension SMS {

    public enum AppLaunchStatus: String, CustomStringConvertible, Codable {
        case readyForConfiguration = "READY_FOR_CONFIGURATION"
        case configurationInProgress = "CONFIGURATION_IN_PROGRESS"
        case configurationInvalid = "CONFIGURATION_INVALID"
        case readyForLaunch = "READY_FOR_LAUNCH"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case launchPending = "LAUNCH_PENDING"
        case launchInProgress = "LAUNCH_IN_PROGRESS"
        case launched = "LAUNCHED"
        case deltaLaunchInProgress = "DELTA_LAUNCH_IN_PROGRESS"
        case deltaLaunchFailed = "DELTA_LAUNCH_FAILED"
        case launchFailed = "LAUNCH_FAILED"
        case terminateInProgress = "TERMINATE_IN_PROGRESS"
        case terminateFailed = "TERMINATE_FAILED"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum AppReplicationStatus: String, CustomStringConvertible, Codable {
        case readyForConfiguration = "READY_FOR_CONFIGURATION"
        case configurationInProgress = "CONFIGURATION_IN_PROGRESS"
        case configurationInvalid = "CONFIGURATION_INVALID"
        case readyForReplication = "READY_FOR_REPLICATION"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case replicationPending = "REPLICATION_PENDING"
        case replicationInProgress = "REPLICATION_IN_PROGRESS"
        case replicated = "REPLICATED"
        case deltaReplicationInProgress = "DELTA_REPLICATION_IN_PROGRESS"
        case deltaReplicated = "DELTA_REPLICATED"
        case deltaReplicationFailed = "DELTA_REPLICATION_FAILED"
        case replicationFailed = "REPLICATION_FAILED"
        case replicationStopping = "REPLICATION_STOPPING"
        case replicationStopFailed = "REPLICATION_STOP_FAILED"
        case replicationStopped = "REPLICATION_STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum AppStatus: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case active = "ACTIVE"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        public var description: String { return self.rawValue }
    }

    public struct AppSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "creationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "lastModified", required: false, type: .timestamp), 
            AWSShapeMember(label: "latestReplicationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "launchDetails", required: false, type: .structure), 
            AWSShapeMember(label: "launchStatus", required: false, type: .enum), 
            AWSShapeMember(label: "launchStatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "replicationStatus", required: false, type: .enum), 
            AWSShapeMember(label: "replicationStatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "statusMessage", required: false, type: .string), 
            AWSShapeMember(label: "totalServerGroups", required: false, type: .integer), 
            AWSShapeMember(label: "totalServers", required: false, type: .integer)
        ]
        /// Unique ID of the application.
        public let appId: String?
        /// Time of creation of this application.
        public let creationTime: TimeStamp?
        /// Description of the application.
        public let description: String?
        /// Timestamp of the application's creation.
        public let lastModified: TimeStamp?
        /// Timestamp of the application's most recent successful replication.
        public let latestReplicationTime: TimeStamp?
        /// Details about the latest launch of the application.
        public let launchDetails: LaunchDetails?
        /// Launch status of the application.
        public let launchStatus: AppLaunchStatus?
        /// A message related to the launch status of the application.
        public let launchStatusMessage: String?
        /// Name of the application.
        public let name: String?
        /// Replication status of the application.
        public let replicationStatus: AppReplicationStatus?
        /// A message related to the replication status of the application.
        public let replicationStatusMessage: String?
        /// Name of the service role in the customer's account used by AWS SMS.
        public let roleName: String?
        /// Status of the application.
        public let status: AppStatus?
        /// A message related to the status of the application
        public let statusMessage: String?
        /// Number of server groups present in the application.
        public let totalServerGroups: Int32?
        /// Number of servers present in the application.
        public let totalServers: Int32?

        public init(appId: String? = nil, creationTime: TimeStamp? = nil, description: String? = nil, lastModified: TimeStamp? = nil, latestReplicationTime: TimeStamp? = nil, launchDetails: LaunchDetails? = nil, launchStatus: AppLaunchStatus? = nil, launchStatusMessage: String? = nil, name: String? = nil, replicationStatus: AppReplicationStatus? = nil, replicationStatusMessage: String? = nil, roleName: String? = nil, status: AppStatus? = nil, statusMessage: String? = nil, totalServerGroups: Int32? = nil, totalServers: Int32? = nil) {
            self.appId = appId
            self.creationTime = creationTime
            self.description = description
            self.lastModified = lastModified
            self.latestReplicationTime = latestReplicationTime
            self.launchDetails = launchDetails
            self.launchStatus = launchStatus
            self.launchStatusMessage = launchStatusMessage
            self.name = name
            self.replicationStatus = replicationStatus
            self.replicationStatusMessage = replicationStatusMessage
            self.roleName = roleName
            self.status = status
            self.statusMessage = statusMessage
            self.totalServerGroups = totalServerGroups
            self.totalServers = totalServers
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case creationTime = "creationTime"
            case description = "description"
            case lastModified = "lastModified"
            case latestReplicationTime = "latestReplicationTime"
            case launchDetails = "launchDetails"
            case launchStatus = "launchStatus"
            case launchStatusMessage = "launchStatusMessage"
            case name = "name"
            case replicationStatus = "replicationStatus"
            case replicationStatusMessage = "replicationStatusMessage"
            case roleName = "roleName"
            case status = "status"
            case statusMessage = "statusMessage"
            case totalServerGroups = "totalServerGroups"
            case totalServers = "totalServers"
        }
    }

    public struct Connector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "associatedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "capabilityList", required: false, type: .list), 
            AWSShapeMember(label: "connectorId", required: false, type: .string), 
            AWSShapeMember(label: "ipAddress", required: false, type: .string), 
            AWSShapeMember(label: "macAddress", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "version", required: false, type: .string), 
            AWSShapeMember(label: "vmManagerId", required: false, type: .string), 
            AWSShapeMember(label: "vmManagerName", required: false, type: .string), 
            AWSShapeMember(label: "vmManagerType", required: false, type: .enum)
        ]
        /// The time the connector was associated.
        public let associatedOn: TimeStamp?
        /// The capabilities of the connector.
        public let capabilityList: [ConnectorCapability]?
        /// The identifier of the connector.
        public let connectorId: String?
        /// The IP address of the connector.
        public let ipAddress: String?
        /// The MAC address of the connector.
        public let macAddress: String?
        /// The status of the connector.
        public let status: ConnectorStatus?
        /// The connector version.
        public let version: String?
        /// The identifier of the VM manager.
        public let vmManagerId: String?
        /// The name of the VM manager.
        public let vmManagerName: String?
        /// The VM management product.
        public let vmManagerType: VmManagerType?

        public init(associatedOn: TimeStamp? = nil, capabilityList: [ConnectorCapability]? = nil, connectorId: String? = nil, ipAddress: String? = nil, macAddress: String? = nil, status: ConnectorStatus? = nil, version: String? = nil, vmManagerId: String? = nil, vmManagerName: String? = nil, vmManagerType: VmManagerType? = nil) {
            self.associatedOn = associatedOn
            self.capabilityList = capabilityList
            self.connectorId = connectorId
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.status = status
            self.version = version
            self.vmManagerId = vmManagerId
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
        }

        private enum CodingKeys: String, CodingKey {
            case associatedOn = "associatedOn"
            case capabilityList = "capabilityList"
            case connectorId = "connectorId"
            case ipAddress = "ipAddress"
            case macAddress = "macAddress"
            case status = "status"
            case version = "version"
            case vmManagerId = "vmManagerId"
            case vmManagerName = "vmManagerName"
            case vmManagerType = "vmManagerType"
        }
    }

    public enum ConnectorCapability: String, CustomStringConvertible, Codable {
        case vsphere = "VSPHERE"
        case scvmm = "SCVMM"
        case hypervManager = "HYPERV-MANAGER"
        case snapshotBatching = "SNAPSHOT_BATCHING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorStatus: String, CustomStringConvertible, Codable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public struct CreateAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "serverGroups", required: false, type: .list), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// A unique, case-sensitive identifier you provide to ensure idempotency of application creation.
        public let clientToken: String?
        /// Description of the new application
        public let description: String?
        /// Name of the new application.
        public let name: String?
        /// Name of service role in customer's account to be used by AWS SMS.
        public let roleName: String?
        /// List of server groups to include in the application.
        public let serverGroups: [ServerGroup]?
        /// List of tags to be associated with the application.
        public let tags: [Tag]?

        public init(clientToken: String? = nil, description: String? = nil, name: String? = nil, roleName: String? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.roleName = roleName
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case roleName = "roleName"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct CreateAppResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appSummary", required: false, type: .structure), 
            AWSShapeMember(label: "serverGroups", required: false, type: .list), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// Summary description of the application.
        public let appSummary: AppSummary?
        /// List of server groups included in the application.
        public let serverGroups: [ServerGroup]?
        /// List of taags associated with the application.
        public let tags: [Tag]?

        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary = "appSummary"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct CreateReplicationJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "encrypted", required: false, type: .boolean), 
            AWSShapeMember(label: "frequency", required: false, type: .integer), 
            AWSShapeMember(label: "kmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "licenseType", required: false, type: .enum), 
            AWSShapeMember(label: "numberOfRecentAmisToKeep", required: false, type: .integer), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "runOnce", required: false, type: .boolean), 
            AWSShapeMember(label: "seedReplicationTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "serverId", required: true, type: .string)
        ]
        /// The description of the replication job.
        public let description: String?
        /// When true, the replication job produces encrypted AMIs. See also KmsKeyId below.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int32?
        /// KMS key ID for replication jobs that produce encrypted AMIs. Can be any of the following:    KMS key ID   KMS key alias   ARN referring to KMS key ID   ARN referring to KMS key alias    If encrypted is true but a KMS key id is not specified, the customer's default KMS key for EBS is used. 
        public let kmsKeyId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The maximum number of SMS-created AMIs to retain. The oldest will be deleted once the maximum number is reached and a new AMI is created.
        public let numberOfRecentAmisToKeep: Int32?
        /// The name of the IAM role to be used by the AWS SMS.
        public let roleName: String?
        public let runOnce: Bool?
        /// The seed replication time.
        public let seedReplicationTime: TimeStamp
        /// The identifier of the server.
        public let serverId: String

        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int32? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, numberOfRecentAmisToKeep: Int32? = nil, roleName: String? = nil, runOnce: Bool? = nil, seedReplicationTime: TimeStamp, serverId: String) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case licenseType = "licenseType"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case roleName = "roleName"
            case runOnce = "runOnce"
            case seedReplicationTime = "seedReplicationTime"
            case serverId = "serverId"
        }
    }

    public struct CreateReplicationJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "replicationJobId", required: false, type: .string)
        ]
        /// The unique identifier of the replication job.
        public let replicationJobId: String?

        public init(replicationJobId: String? = nil) {
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId = "replicationJobId"
        }
    }

    public struct DeleteAppLaunchConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application associated with the launch configuration.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DeleteAppLaunchConfigurationResponse: AWSShape {

        public init() {
        }

    }

    public struct DeleteAppReplicationConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application associated with the replication configuration.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DeleteAppReplicationConfigurationResponse: AWSShape {

        public init() {
        }

    }

    public struct DeleteAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "forceStopAppReplication", required: false, type: .boolean), 
            AWSShapeMember(label: "forceTerminateApp", required: false, type: .boolean)
        ]
        /// ID of the application to delete.
        public let appId: String?
        /// While deleting the application, stop all replication jobs corresponding to the servers in the application.
        public let forceStopAppReplication: Bool?
        /// While deleting the application, terminate the stack corresponding to the application.
        public let forceTerminateApp: Bool?

        public init(appId: String? = nil, forceStopAppReplication: Bool? = nil, forceTerminateApp: Bool? = nil) {
            self.appId = appId
            self.forceStopAppReplication = forceStopAppReplication
            self.forceTerminateApp = forceTerminateApp
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case forceStopAppReplication = "forceStopAppReplication"
            case forceTerminateApp = "forceTerminateApp"
        }
    }

    public struct DeleteAppResponse: AWSShape {

        public init() {
        }

    }

    public struct DeleteReplicationJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "replicationJobId", required: true, type: .string)
        ]
        /// The identifier of the replication job.
        public let replicationJobId: String

        public init(replicationJobId: String) {
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId = "replicationJobId"
        }
    }

    public struct DeleteReplicationJobResponse: AWSShape {

        public init() {
        }

    }

    public struct DeleteServerCatalogRequest: AWSShape {

        public init() {
        }

    }

    public struct DeleteServerCatalogResponse: AWSShape {

        public init() {
        }

    }

    public struct DisassociateConnectorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorId", required: true, type: .string)
        ]
        /// The identifier of the connector.
        public let connectorId: String

        public init(connectorId: String) {
            self.connectorId = connectorId
        }

        private enum CodingKeys: String, CodingKey {
            case connectorId = "connectorId"
        }
    }

    public struct DisassociateConnectorResponse: AWSShape {

        public init() {
        }

    }

    public struct GenerateChangeSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "changesetFormat", required: false, type: .enum)
        ]
        /// ID of the application associated with the change set.
        public let appId: String?
        /// Format for the change set.
        public let changesetFormat: OutputFormat?

        public init(appId: String? = nil, changesetFormat: OutputFormat? = nil) {
            self.appId = appId
            self.changesetFormat = changesetFormat
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case changesetFormat = "changesetFormat"
        }
    }

    public struct GenerateChangeSetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3Location", required: false, type: .structure)
        ]
        /// Location of the Amazon S3 object.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct GenerateTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "templateFormat", required: false, type: .enum)
        ]
        /// ID of the application associated with the Amazon CloudFormation template.
        public let appId: String?
        /// Format for generating the Amazon CloudFormation template.
        public let templateFormat: OutputFormat?

        public init(appId: String? = nil, templateFormat: OutputFormat? = nil) {
            self.appId = appId
            self.templateFormat = templateFormat
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case templateFormat = "templateFormat"
        }
    }

    public struct GenerateTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3Location", required: false, type: .structure)
        ]
        /// Location of the Amazon S3 object.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct GetAppLaunchConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application launch configuration.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppLaunchConfigurationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "serverGroupLaunchConfigurations", required: false, type: .list)
        ]
        /// ID of the application associated with the launch configuration.
        public let appId: String?
        /// Name of the service role in the customer's account that Amazon CloudFormation uses to launch the application.
        public let roleName: String?
        /// List of launch configurations for server groups in this application.
        public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

        public init(appId: String? = nil, roleName: String? = nil, serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil) {
            self.appId = appId
            self.roleName = roleName
            self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case roleName = "roleName"
            case serverGroupLaunchConfigurations = "serverGroupLaunchConfigurations"
        }
    }

    public struct GetAppReplicationConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application associated with the replication configuration.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppReplicationConfigurationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "serverGroupReplicationConfigurations", required: false, type: .list)
        ]
        /// Replication configurations associated with server groups in this application.
        public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

        public init(serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil) {
            self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupReplicationConfigurations = "serverGroupReplicationConfigurations"
        }
    }

    public struct GetAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application whose information is being retrieved.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appSummary", required: false, type: .structure), 
            AWSShapeMember(label: "serverGroups", required: false, type: .list), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// Information about the application.
        public let appSummary: AppSummary?
        /// List of server groups belonging to the application.
        public let serverGroups: [ServerGroup]?
        /// List of tags associated with the application.
        public let tags: [Tag]?

        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary = "appSummary"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct GetConnectorsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?
        /// The token for the next set of results.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetConnectorsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorList", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the registered connectors.
        public let connectorList: [Connector]?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(connectorList: [Connector]? = nil, nextToken: String? = nil) {
            self.connectorList = connectorList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorList = "connectorList"
            case nextToken = "nextToken"
        }
    }

    public struct GetReplicationJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "replicationJobId", required: false, type: .string)
        ]
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The identifier of the replication job.
        public let replicationJobId: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, replicationJobId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case replicationJobId = "replicationJobId"
        }
    }

    public struct GetReplicationJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "replicationJobList", required: false, type: .list)
        ]
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the replication jobs.
        public let replicationJobList: [ReplicationJob]?

        public init(nextToken: String? = nil, replicationJobList: [ReplicationJob]? = nil) {
            self.nextToken = nextToken
            self.replicationJobList = replicationJobList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replicationJobList = "replicationJobList"
        }
    }

    public struct GetReplicationRunsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "replicationJobId", required: true, type: .string)
        ]
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The identifier of the replication job.
        public let replicationJobId: String

        public init(maxResults: Int32? = nil, nextToken: String? = nil, replicationJobId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case replicationJobId = "replicationJobId"
        }
    }

    public struct GetReplicationRunsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "replicationJob", required: false, type: .structure), 
            AWSShapeMember(label: "replicationRunList", required: false, type: .list)
        ]
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the replication job.
        public let replicationJob: ReplicationJob?
        /// Information about the replication runs.
        public let replicationRunList: [ReplicationRun]?

        public init(nextToken: String? = nil, replicationJob: ReplicationJob? = nil, replicationRunList: [ReplicationRun]? = nil) {
            self.nextToken = nextToken
            self.replicationJob = replicationJob
            self.replicationRunList = replicationRunList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replicationJob = "replicationJob"
            case replicationRunList = "replicationRunList"
        }
    }

    public struct GetServersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "vmServerAddressList", required: false, type: .list)
        ]
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int32?
        /// The token for the next set of results.
        public let nextToken: String?
        /// List of VmServerAddress objects
        public let vmServerAddressList: [VmServerAddress]?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, vmServerAddressList: [VmServerAddress]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vmServerAddressList = vmServerAddressList
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case vmServerAddressList = "vmServerAddressList"
        }
    }

    public struct GetServersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "lastModifiedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "serverCatalogStatus", required: false, type: .enum), 
            AWSShapeMember(label: "serverList", required: false, type: .list)
        ]
        /// The time when the server was last modified.
        public let lastModifiedOn: TimeStamp?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The status of the server catalog.
        public let serverCatalogStatus: ServerCatalogStatus?
        /// Information about the servers.
        public let serverList: [Server]?

        public init(lastModifiedOn: TimeStamp? = nil, nextToken: String? = nil, serverCatalogStatus: ServerCatalogStatus? = nil, serverList: [Server]? = nil) {
            self.lastModifiedOn = lastModifiedOn
            self.nextToken = nextToken
            self.serverCatalogStatus = serverCatalogStatus
            self.serverList = serverList
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedOn = "lastModifiedOn"
            case nextToken = "nextToken"
            case serverCatalogStatus = "serverCatalogStatus"
            case serverList = "serverList"
        }
    }

    public struct ImportServerCatalogRequest: AWSShape {

        public init() {
        }

    }

    public struct ImportServerCatalogResponse: AWSShape {

        public init() {
        }

    }

    public struct LaunchAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application to launch.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct LaunchAppResponse: AWSShape {

        public init() {
        }

    }

    public struct LaunchDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "latestLaunchTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "stackId", required: false, type: .string), 
            AWSShapeMember(label: "stackName", required: false, type: .string)
        ]
        /// Latest time this application was launched successfully.
        public let latestLaunchTime: TimeStamp?
        /// Identifier of the latest stack launched for this application.
        public let stackId: String?
        /// Name of the latest stack launched for this application.
        public let stackName: String?

        public init(latestLaunchTime: TimeStamp? = nil, stackId: String? = nil, stackName: String? = nil) {
            self.latestLaunchTime = latestLaunchTime
            self.stackId = stackId
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case latestLaunchTime = "latestLaunchTime"
            case stackId = "stackId"
            case stackName = "stackName"
        }
    }

    public enum LicenseType: String, CustomStringConvertible, Codable {
        case aws = "AWS"
        case byol = "BYOL"
        public var description: String { return self.rawValue }
    }

    public struct ListAppsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appIds", required: false, type: .list), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        public let appIds: [String]?
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value. 
        public let maxResults: Int32?
        /// The token for the next set of results.
        public let nextToken: String?

        public init(appIds: [String]? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.appIds = appIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appIds = "appIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAppsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apps", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// A list of application summaries.
        public let apps: [AppSummary]?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(apps: [AppSummary]? = nil, nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps = "apps"
            case nextToken = "nextToken"
        }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable {
        case json = "JSON"
        case yaml = "YAML"
        public var description: String { return self.rawValue }
    }

    public struct PutAppLaunchConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "serverGroupLaunchConfigurations", required: false, type: .list)
        ]
        /// ID of the application associated with the launch configuration.
        public let appId: String?
        /// Name of service role in the customer's account that Amazon CloudFormation uses to launch the application.
        public let roleName: String?
        /// Launch configurations for server groups in the application.
        public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

        public init(appId: String? = nil, roleName: String? = nil, serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil) {
            self.appId = appId
            self.roleName = roleName
            self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case roleName = "roleName"
            case serverGroupLaunchConfigurations = "serverGroupLaunchConfigurations"
        }
    }

    public struct PutAppLaunchConfigurationResponse: AWSShape {

        public init() {
        }

    }

    public struct PutAppReplicationConfigurationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "serverGroupReplicationConfigurations", required: false, type: .list)
        ]
        /// ID of the application tassociated with the replication configuration.
        public let appId: String?
        /// Replication configurations for server groups in the application.
        public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

        public init(appId: String? = nil, serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil) {
            self.appId = appId
            self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case serverGroupReplicationConfigurations = "serverGroupReplicationConfigurations"
        }
    }

    public struct PutAppReplicationConfigurationResponse: AWSShape {

        public init() {
        }

    }

    public struct ReplicationJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "encrypted", required: false, type: .boolean), 
            AWSShapeMember(label: "frequency", required: false, type: .integer), 
            AWSShapeMember(label: "kmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "latestAmiId", required: false, type: .string), 
            AWSShapeMember(label: "licenseType", required: false, type: .enum), 
            AWSShapeMember(label: "nextReplicationRunStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "numberOfRecentAmisToKeep", required: false, type: .integer), 
            AWSShapeMember(label: "replicationJobId", required: false, type: .string), 
            AWSShapeMember(label: "replicationRunList", required: false, type: .list), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "runOnce", required: false, type: .boolean), 
            AWSShapeMember(label: "seedReplicationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "serverId", required: false, type: .string), 
            AWSShapeMember(label: "serverType", required: false, type: .enum), 
            AWSShapeMember(label: "state", required: false, type: .enum), 
            AWSShapeMember(label: "statusMessage", required: false, type: .string), 
            AWSShapeMember(label: "vmServer", required: false, type: .structure)
        ]
        /// The description of the replication job.
        public let description: String?
        /// Whether the replication job should produce encrypted AMIs or not. See also KmsKeyId below.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int32?
        /// KMS key ID for replication jobs that produce encrypted AMIs. Can be any of the following:    KMS key ID   KMS key alias   ARN referring to KMS key ID   ARN referring to KMS key alias    If encrypted is true but a KMS key id is not specified, the customer's default KMS key for EBS is used. 
        public let kmsKeyId: String?
        /// The ID of the latest Amazon Machine Image (AMI).
        public let latestAmiId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The start time of the next replication run.
        public let nextReplicationRunStartTime: TimeStamp?
        /// Number of recent AMIs to keep in the customer's account for a replication job. By default the value is set to zero, meaning that all AMIs are kept.
        public let numberOfRecentAmisToKeep: Int32?
        /// The identifier of the replication job.
        public let replicationJobId: String?
        /// Information about the replication runs.
        public let replicationRunList: [ReplicationRun]?
        /// The name of the IAM role to be used by the Server Migration Service.
        public let roleName: String?
        public let runOnce: Bool?
        /// The seed replication time.
        public let seedReplicationTime: TimeStamp?
        /// The identifier of the server.
        public let serverId: String?
        /// The type of server.
        public let serverType: ServerType?
        /// The state of the replication job.
        public let state: ReplicationJobState?
        /// The description of the current status of the replication job.
        public let statusMessage: String?
        /// Information about the VM server.
        public let vmServer: VmServer?

        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int32? = nil, kmsKeyId: String? = nil, latestAmiId: String? = nil, licenseType: LicenseType? = nil, nextReplicationRunStartTime: TimeStamp? = nil, numberOfRecentAmisToKeep: Int32? = nil, replicationJobId: String? = nil, replicationRunList: [ReplicationRun]? = nil, roleName: String? = nil, runOnce: Bool? = nil, seedReplicationTime: TimeStamp? = nil, serverId: String? = nil, serverType: ServerType? = nil, state: ReplicationJobState? = nil, statusMessage: String? = nil, vmServer: VmServer? = nil) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.latestAmiId = latestAmiId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.replicationRunList = replicationRunList
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
            self.serverType = serverType
            self.state = state
            self.statusMessage = statusMessage
            self.vmServer = vmServer
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case latestAmiId = "latestAmiId"
            case licenseType = "licenseType"
            case nextReplicationRunStartTime = "nextReplicationRunStartTime"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case replicationJobId = "replicationJobId"
            case replicationRunList = "replicationRunList"
            case roleName = "roleName"
            case runOnce = "runOnce"
            case seedReplicationTime = "seedReplicationTime"
            case serverId = "serverId"
            case serverType = "serverType"
            case state = "state"
            case statusMessage = "statusMessage"
            case vmServer = "vmServer"
        }
    }

    public enum ReplicationJobState: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case active = "ACTIVE"
        case failed = "FAILED"
        case deleting = "DELETING"
        case deleted = "DELETED"
        case completed = "COMPLETED"
        case pausedOnFailure = "PAUSED_ON_FAILURE"
        case failing = "FAILING"
        public var description: String { return self.rawValue }
    }

    public struct ReplicationRun: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "amiId", required: false, type: .string), 
            AWSShapeMember(label: "completedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "encrypted", required: false, type: .boolean), 
            AWSShapeMember(label: "kmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "replicationRunId", required: false, type: .string), 
            AWSShapeMember(label: "scheduledStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "stageDetails", required: false, type: .structure), 
            AWSShapeMember(label: "state", required: false, type: .enum), 
            AWSShapeMember(label: "statusMessage", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// The identifier of the Amazon Machine Image (AMI) from the replication run.
        public let amiId: String?
        /// The completion time of the last replication run.
        public let completedTime: TimeStamp?
        /// The description of the replication run.
        public let description: String?
        /// Whether the replication run should produce encrypted AMI or not. See also KmsKeyId below.
        public let encrypted: Bool?
        /// KMS key ID for replication jobs that produce encrypted AMIs. Can be any of the following:    KMS key ID   KMS key alias   ARN referring to KMS key ID   ARN referring to KMS key alias    If encrypted is true but a KMS key id is not specified, the customer's default KMS key for EBS is used. 
        public let kmsKeyId: String?
        /// The identifier of the replication run.
        public let replicationRunId: String?
        /// The start time of the next replication run.
        public let scheduledStartTime: TimeStamp?
        /// Details of the current stage of the replication run.
        public let stageDetails: ReplicationRunStageDetails?
        /// The state of the replication run.
        public let state: ReplicationRunState?
        /// The description of the current status of the replication job.
        public let statusMessage: String?
        /// The type of replication run.
        public let `type`: ReplicationRunType?

        public init(amiId: String? = nil, completedTime: TimeStamp? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, replicationRunId: String? = nil, scheduledStartTime: TimeStamp? = nil, stageDetails: ReplicationRunStageDetails? = nil, state: ReplicationRunState? = nil, statusMessage: String? = nil, type: ReplicationRunType? = nil) {
            self.amiId = amiId
            self.completedTime = completedTime
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.replicationRunId = replicationRunId
            self.scheduledStartTime = scheduledStartTime
            self.stageDetails = stageDetails
            self.state = state
            self.statusMessage = statusMessage
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "amiId"
            case completedTime = "completedTime"
            case description = "description"
            case encrypted = "encrypted"
            case kmsKeyId = "kmsKeyId"
            case replicationRunId = "replicationRunId"
            case scheduledStartTime = "scheduledStartTime"
            case stageDetails = "stageDetails"
            case state = "state"
            case statusMessage = "statusMessage"
            case `type` = "type"
        }
    }

    public struct ReplicationRunStageDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "stage", required: false, type: .string), 
            AWSShapeMember(label: "stageProgress", required: false, type: .string)
        ]
        /// String describing the current stage of a replication run.
        public let stage: String?
        /// String describing the progress of the current stage of a replication run.
        public let stageProgress: String?

        public init(stage: String? = nil, stageProgress: String? = nil) {
            self.stage = stage
            self.stageProgress = stageProgress
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
            case stageProgress = "stageProgress"
        }
    }

    public enum ReplicationRunState: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case missed = "MISSED"
        case active = "ACTIVE"
        case failed = "FAILED"
        case completed = "COMPLETED"
        case deleting = "DELETING"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationRunType: String, CustomStringConvertible, Codable {
        case onDemand = "ON_DEMAND"
        case automatic = "AUTOMATIC"
        public var description: String { return self.rawValue }
    }

    public struct S3Location: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucket", required: false, type: .string), 
            AWSShapeMember(label: "key", required: false, type: .string)
        ]
        /// Amazon S3 bucket name.
        public let bucket: String?
        /// Amazon S3 bucket key.
        public let key: String?

        public init(bucket: String? = nil, key: String? = nil) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
        }
    }

    public struct Server: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "replicationJobId", required: false, type: .string), 
            AWSShapeMember(label: "replicationJobTerminated", required: false, type: .boolean), 
            AWSShapeMember(label: "serverId", required: false, type: .string), 
            AWSShapeMember(label: "serverType", required: false, type: .enum), 
            AWSShapeMember(label: "vmServer", required: false, type: .structure)
        ]
        /// The identifier of the replication job.
        public let replicationJobId: String?
        /// Indicates whether the replication job is deleted or failed.
        public let replicationJobTerminated: Bool?
        /// The identifier of the server.
        public let serverId: String?
        /// The type of server.
        public let serverType: ServerType?
        /// Information about the VM server.
        public let vmServer: VmServer?

        public init(replicationJobId: String? = nil, replicationJobTerminated: Bool? = nil, serverId: String? = nil, serverType: ServerType? = nil, vmServer: VmServer? = nil) {
            self.replicationJobId = replicationJobId
            self.replicationJobTerminated = replicationJobTerminated
            self.serverId = serverId
            self.serverType = serverType
            self.vmServer = vmServer
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId = "replicationJobId"
            case replicationJobTerminated = "replicationJobTerminated"
            case serverId = "serverId"
            case serverType = "serverType"
            case vmServer = "vmServer"
        }
    }

    public enum ServerCatalogStatus: String, CustomStringConvertible, Codable {
        case notImported = "NOT_IMPORTED"
        case importing = "IMPORTING"
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public struct ServerGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "serverGroupId", required: false, type: .string), 
            AWSShapeMember(label: "serverList", required: false, type: .list)
        ]
        /// Name of a server group.
        public let name: String?
        /// Identifier of a server group.
        public let serverGroupId: String?
        /// List of servers belonging to a server group.
        public let serverList: [Server]?

        public init(name: String? = nil, serverGroupId: String? = nil, serverList: [Server]? = nil) {
            self.name = name
            self.serverGroupId = serverGroupId
            self.serverList = serverList
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case serverGroupId = "serverGroupId"
            case serverList = "serverList"
        }
    }

    public struct ServerGroupLaunchConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "launchOrder", required: false, type: .integer), 
            AWSShapeMember(label: "serverGroupId", required: false, type: .string), 
            AWSShapeMember(label: "serverLaunchConfigurations", required: false, type: .list)
        ]
        /// Launch order of servers in the server group.
        public let launchOrder: Int32?
        /// Identifier of the server group the launch configuration is associated with.
        public let serverGroupId: String?
        /// Launch configuration for servers in the server group.
        public let serverLaunchConfigurations: [ServerLaunchConfiguration]?

        public init(launchOrder: Int32? = nil, serverGroupId: String? = nil, serverLaunchConfigurations: [ServerLaunchConfiguration]? = nil) {
            self.launchOrder = launchOrder
            self.serverGroupId = serverGroupId
            self.serverLaunchConfigurations = serverLaunchConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case launchOrder = "launchOrder"
            case serverGroupId = "serverGroupId"
            case serverLaunchConfigurations = "serverLaunchConfigurations"
        }
    }

    public struct ServerGroupReplicationConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "serverGroupId", required: false, type: .string), 
            AWSShapeMember(label: "serverReplicationConfigurations", required: false, type: .list)
        ]
        /// Identifier of the server group this replication configuration is associated with.
        public let serverGroupId: String?
        /// Replication configuration for servers in the server group.
        public let serverReplicationConfigurations: [ServerReplicationConfiguration]?

        public init(serverGroupId: String? = nil, serverReplicationConfigurations: [ServerReplicationConfiguration]? = nil) {
            self.serverGroupId = serverGroupId
            self.serverReplicationConfigurations = serverReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupId = "serverGroupId"
            case serverReplicationConfigurations = "serverReplicationConfigurations"
        }
    }

    public struct ServerLaunchConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "associatePublicIpAddress", required: false, type: .boolean), 
            AWSShapeMember(label: "ec2KeyName", required: false, type: .string), 
            AWSShapeMember(label: "instanceType", required: false, type: .string), 
            AWSShapeMember(label: "logicalId", required: false, type: .string), 
            AWSShapeMember(label: "securityGroup", required: false, type: .string), 
            AWSShapeMember(label: "server", required: false, type: .structure), 
            AWSShapeMember(label: "subnet", required: false, type: .string), 
            AWSShapeMember(label: "userData", required: false, type: .structure), 
            AWSShapeMember(label: "vpc", required: false, type: .string)
        ]
        /// If true, a publicly accessible IP address is created when launching the server.
        public let associatePublicIpAddress: Bool?
        /// Name of the EC2 SSH Key to be used for connecting to the launched server.
        public let ec2KeyName: String?
        /// Instance type to be used for launching the server.
        public let instanceType: String?
        /// Logical ID of the server in the Amazon CloudFormation template.
        public let logicalId: String?
        /// Identifier of the security group that applies to the launched server.
        public let securityGroup: String?
        /// Identifier of the server the launch configuration is associated with.
        public let server: Server?
        /// Identifier of the subnet the server should be launched into.
        public let subnet: String?
        /// Location of the user-data script to be executed when launching the server.
        public let userData: UserData?
        /// Identifier of the VPC the server should be launched into.
        public let vpc: String?

        public init(associatePublicIpAddress: Bool? = nil, ec2KeyName: String? = nil, instanceType: String? = nil, logicalId: String? = nil, securityGroup: String? = nil, server: Server? = nil, subnet: String? = nil, userData: UserData? = nil, vpc: String? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.ec2KeyName = ec2KeyName
            self.instanceType = instanceType
            self.logicalId = logicalId
            self.securityGroup = securityGroup
            self.server = server
            self.subnet = subnet
            self.userData = userData
            self.vpc = vpc
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress = "associatePublicIpAddress"
            case ec2KeyName = "ec2KeyName"
            case instanceType = "instanceType"
            case logicalId = "logicalId"
            case securityGroup = "securityGroup"
            case server = "server"
            case subnet = "subnet"
            case userData = "userData"
            case vpc = "vpc"
        }
    }

    public struct ServerReplicationConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "server", required: false, type: .structure), 
            AWSShapeMember(label: "serverReplicationParameters", required: false, type: .structure)
        ]
        /// Identifier of the server this replication configuration is associated with.
        public let server: Server?
        /// Parameters for replicating the server.
        public let serverReplicationParameters: ServerReplicationParameters?

        public init(server: Server? = nil, serverReplicationParameters: ServerReplicationParameters? = nil) {
            self.server = server
            self.serverReplicationParameters = serverReplicationParameters
        }

        private enum CodingKeys: String, CodingKey {
            case server = "server"
            case serverReplicationParameters = "serverReplicationParameters"
        }
    }

    public struct ServerReplicationParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "encrypted", required: false, type: .boolean), 
            AWSShapeMember(label: "frequency", required: false, type: .integer), 
            AWSShapeMember(label: "kmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "licenseType", required: false, type: .enum), 
            AWSShapeMember(label: "numberOfRecentAmisToKeep", required: false, type: .integer), 
            AWSShapeMember(label: "runOnce", required: false, type: .boolean), 
            AWSShapeMember(label: "seedTime", required: false, type: .timestamp)
        ]
        /// When true, the replication job produces encrypted AMIs. See also KmsKeyId below.
        public let encrypted: Bool?
        /// Frequency of creating replication jobs for the server.
        public let frequency: Int32?
        ///  KMS key ID for replication jobs that produce encrypted AMIs. Can be any of the following:    KMS key ID   KMS key alias   ARN referring to KMS key ID   ARN referring to KMS key alias    If encrypted is true but a KMS key id is not specified, the customer's default KMS key for EBS is used. 
        public let kmsKeyId: String?
        /// License type for creating a replication job for the server.
        public let licenseType: LicenseType?
        /// Number of recent AMIs to keep when creating a replication job for this server.
        public let numberOfRecentAmisToKeep: Int32?
        public let runOnce: Bool?
        /// Seed time for creating a replication job for the server.
        public let seedTime: TimeStamp?

        public init(encrypted: Bool? = nil, frequency: Int32? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, numberOfRecentAmisToKeep: Int32? = nil, runOnce: Bool? = nil, seedTime: TimeStamp? = nil) {
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.runOnce = runOnce
            self.seedTime = seedTime
        }

        private enum CodingKeys: String, CodingKey {
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case licenseType = "licenseType"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case runOnce = "runOnce"
            case seedTime = "seedTime"
        }
    }

    public enum ServerType: String, CustomStringConvertible, Codable {
        case virtualMachine = "VIRTUAL_MACHINE"
        public var description: String { return self.rawValue }
    }

    public struct StartAppReplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application to replicate.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct StartAppReplicationResponse: AWSShape {

        public init() {
        }

    }

    public struct StartOnDemandReplicationRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "replicationJobId", required: true, type: .string)
        ]
        /// The description of the replication run.
        public let description: String?
        /// The identifier of the replication job.
        public let replicationJobId: String

        public init(description: String? = nil, replicationJobId: String) {
            self.description = description
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case replicationJobId = "replicationJobId"
        }
    }

    public struct StartOnDemandReplicationRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "replicationRunId", required: false, type: .string)
        ]
        /// The identifier of the replication run.
        public let replicationRunId: String?

        public init(replicationRunId: String? = nil) {
            self.replicationRunId = replicationRunId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationRunId = "replicationRunId"
        }
    }

    public struct StopAppReplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application to stop replicating.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct StopAppReplicationResponse: AWSShape {

        public init() {
        }

    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: false, type: .string), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]
        /// Tag key.
        public let key: String?
        /// Tag value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TerminateAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string)
        ]
        /// ID of the application to terminate.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct TerminateAppResponse: AWSShape {

        public init() {
        }

    }

    public struct UpdateAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appId", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "roleName", required: false, type: .string), 
            AWSShapeMember(label: "serverGroups", required: false, type: .list), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// ID of the application to update.
        public let appId: String?
        /// New description of the application.
        public let description: String?
        /// New name of the application.
        public let name: String?
        /// Name of the service role in the customer's account used by AWS SMS.
        public let roleName: String?
        /// List of server groups in the application to update.
        public let serverGroups: [ServerGroup]?
        /// List of tags to associate with the application.
        public let tags: [Tag]?

        public init(appId: String? = nil, description: String? = nil, name: String? = nil, roleName: String? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appId = appId
            self.description = description
            self.name = name
            self.roleName = roleName
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case description = "description"
            case name = "name"
            case roleName = "roleName"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct UpdateAppResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "appSummary", required: false, type: .structure), 
            AWSShapeMember(label: "serverGroups", required: false, type: .list), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// Summary description of the application.
        public let appSummary: AppSummary?
        /// List of updated server groups in the application.
        public let serverGroups: [ServerGroup]?
        /// List of tags associated with the application.
        public let tags: [Tag]?

        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary = "appSummary"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct UpdateReplicationJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "encrypted", required: false, type: .boolean), 
            AWSShapeMember(label: "frequency", required: false, type: .integer), 
            AWSShapeMember(label: "kmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "licenseType", required: false, type: .enum), 
            AWSShapeMember(label: "nextReplicationRunStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "numberOfRecentAmisToKeep", required: false, type: .integer), 
            AWSShapeMember(label: "replicationJobId", required: true, type: .string), 
            AWSShapeMember(label: "roleName", required: false, type: .string)
        ]
        /// The description of the replication job.
        public let description: String?
        /// When true, the replication job produces encrypted AMIs . See also KmsKeyId below.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int32?
        ///  KMS key ID for replication jobs that produce encrypted AMIs. Can be any of the following:    KMS key ID   KMS key alias   ARN referring to KMS key ID   ARN referring to KMS key alias    If encrypted is true but a KMS key id is not specified, the customer's default KMS key for EBS is used. 
        public let kmsKeyId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The start time of the next replication run.
        public let nextReplicationRunStartTime: TimeStamp?
        /// The maximum number of SMS-created AMIs to retain. The oldest will be deleted once the maximum number is reached and a new AMI is created.
        public let numberOfRecentAmisToKeep: Int32?
        /// The identifier of the replication job.
        public let replicationJobId: String
        /// The name of the IAM role to be used by AWS SMS.
        public let roleName: String?

        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int32? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, nextReplicationRunStartTime: TimeStamp? = nil, numberOfRecentAmisToKeep: Int32? = nil, replicationJobId: String, roleName: String? = nil) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.roleName = roleName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case licenseType = "licenseType"
            case nextReplicationRunStartTime = "nextReplicationRunStartTime"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case replicationJobId = "replicationJobId"
            case roleName = "roleName"
        }
    }

    public struct UpdateReplicationJobResponse: AWSShape {

        public init() {
        }

    }

    public struct UserData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3Location", required: false, type: .structure)
        ]
        /// Amazon S3 location of the user-data script.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public enum VmManagerType: String, CustomStringConvertible, Codable {
        case vsphere = "VSPHERE"
        case scvmm = "SCVMM"
        case hypervManager = "HYPERV-MANAGER"
        public var description: String { return self.rawValue }
    }

    public struct VmServer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vmManagerName", required: false, type: .string), 
            AWSShapeMember(label: "vmManagerType", required: false, type: .enum), 
            AWSShapeMember(label: "vmName", required: false, type: .string), 
            AWSShapeMember(label: "vmPath", required: false, type: .string), 
            AWSShapeMember(label: "vmServerAddress", required: false, type: .structure)
        ]
        /// The name of the VM manager.
        public let vmManagerName: String?
        /// The type of VM management product.
        public let vmManagerType: VmManagerType?
        /// The name of the VM.
        public let vmName: String?
        /// The VM folder path in the vCenter Server virtual machine inventory tree.
        public let vmPath: String?
        /// Information about the VM server location.
        public let vmServerAddress: VmServerAddress?

        public init(vmManagerName: String? = nil, vmManagerType: VmManagerType? = nil, vmName: String? = nil, vmPath: String? = nil, vmServerAddress: VmServerAddress? = nil) {
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
            self.vmName = vmName
            self.vmPath = vmPath
            self.vmServerAddress = vmServerAddress
        }

        private enum CodingKeys: String, CodingKey {
            case vmManagerName = "vmManagerName"
            case vmManagerType = "vmManagerType"
            case vmName = "vmName"
            case vmPath = "vmPath"
            case vmServerAddress = "vmServerAddress"
        }
    }

    public struct VmServerAddress: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "vmId", required: false, type: .string), 
            AWSShapeMember(label: "vmManagerId", required: false, type: .string)
        ]
        /// The identifier of the VM.
        public let vmId: String?
        /// The identifier of the VM manager.
        public let vmManagerId: String?

        public init(vmId: String? = nil, vmManagerId: String? = nil) {
            self.vmId = vmId
            self.vmManagerId = vmManagerId
        }

        private enum CodingKeys: String, CodingKey {
            case vmId = "vmId"
            case vmManagerId = "vmManagerId"
        }
    }

}