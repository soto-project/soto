//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Personalize {
    // MARK: Enums

    public enum BatchInferenceJobMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case batchInference = "BATCH_INFERENCE"
        case themeGeneration = "THEME_GENERATION"
        public var description: String { return self.rawValue }
    }

    public enum Domain: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ecommerce = "ECOMMERCE"
        case videoOnDemand = "VIDEO_ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public enum ImportMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "FULL"
        case incremental = "INCREMENTAL"
        public var description: String { return self.rawValue }
    }

    public enum IngestionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case bulk = "BULK"
        case put = "PUT"
        public var description: String { return self.rawValue }
    }

    public enum ObjectiveSensitivity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum RecipeProvider: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum TrainingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "FULL"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Algorithm: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String?
        /// The URI of the Docker container for the algorithm image.
        public let algorithmImage: AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public let creationDateTime: Date?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public let defaultHyperParameterRanges: DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public let defaultHyperParameters: [String: String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public let defaultResourceConfig: [String: String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the algorithm.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String?
        /// The training input mode.
        public let trainingInputMode: String?

        public init(algorithmArn: String? = nil, algorithmImage: AlgorithmImage? = nil, creationDateTime: Date? = nil, defaultHyperParameterRanges: DefaultHyperParameterRanges? = nil, defaultHyperParameters: [String: String]? = nil, defaultResourceConfig: [String: String]? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, roleArn: String? = nil, trainingInputMode: String? = nil) {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
            case algorithmImage = "algorithmImage"
            case creationDateTime = "creationDateTime"
            case defaultHyperParameterRanges = "defaultHyperParameterRanges"
            case defaultHyperParameters = "defaultHyperParameters"
            case defaultResourceConfig = "defaultResourceConfig"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case roleArn = "roleArn"
            case trainingInputMode = "trainingInputMode"
        }
    }

    public struct AlgorithmImage: AWSDecodableShape {
        /// The URI of the Docker container for the algorithm image.
        public let dockerURI: String
        /// The name of the algorithm image.
        public let name: String?

        public init(dockerURI: String, name: String? = nil) {
            self.dockerURI = dockerURI
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dockerURI = "dockerURI"
            case name = "name"
        }
    }

    public struct AutoMLConfig: AWSEncodableShape & AWSDecodableShape {
        /// The metric to optimize.
        public let metricName: String?
        /// The list of candidate recipes.
        public let recipeList: [String]?

        public init(metricName: String? = nil, recipeList: [String]? = nil) {
            self.metricName = metricName
            self.recipeList = recipeList
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
            try self.recipeList?.forEach {
                try validate($0, name: "recipeList[]", parent: name, max: 256)
                try validate($0, name: "recipeList[]", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            }
            try self.validate(self.recipeList, name: "recipeList", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "metricName"
            case recipeList = "recipeList"
        }
    }

    public struct AutoMLResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the best recipe.
        public let bestRecipeArn: String?

        public init(bestRecipeArn: String? = nil) {
            self.bestRecipeArn = bestRecipeArn
        }

        private enum CodingKeys: String, CodingKey {
            case bestRecipeArn = "bestRecipeArn"
        }
    }

    public struct BatchInferenceJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let batchInferenceJobArn: String?
        /// A string to string map of the configuration details of a batch inference job.
        public let batchInferenceJobConfig: BatchInferenceJobConfig?
        /// The job's mode.
        public let batchInferenceJobMode: BatchInferenceJobMode?
        /// The time at which the batch inference job was created.
        public let creationDateTime: Date?
        /// If the batch inference job failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter used on the batch inference job.
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference job.
        public let jobInput: BatchInferenceJobInput?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public let jobOutput: BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The number of recommendations generated by the batch inference job. This number includes the error messages generated for failed input records.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job was created.
        public let solutionVersionArn: String?
        /// The status of the batch inference job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED
        public let status: String?
        /// The job's theme generation settings.
        public let themeGenerationConfig: ThemeGenerationConfig?

        public init(batchInferenceJobArn: String? = nil, batchInferenceJobConfig: BatchInferenceJobConfig? = nil, batchInferenceJobMode: BatchInferenceJobMode? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, filterArn: String? = nil, jobInput: BatchInferenceJobInput? = nil, jobName: String? = nil, jobOutput: BatchInferenceJobOutput? = nil, lastUpdatedDateTime: Date? = nil, numResults: Int? = nil, roleArn: String? = nil, solutionVersionArn: String? = nil, status: String? = nil, themeGenerationConfig: ThemeGenerationConfig? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.batchInferenceJobMode = batchInferenceJobMode
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.themeGenerationConfig = themeGenerationConfig
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
            case batchInferenceJobConfig = "batchInferenceJobConfig"
            case batchInferenceJobMode = "batchInferenceJobMode"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case jobInput = "jobInput"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case numResults = "numResults"
            case roleArn = "roleArn"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
            case themeGenerationConfig = "themeGenerationConfig"
        }
    }

    public struct BatchInferenceJobConfig: AWSEncodableShape & AWSDecodableShape {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and  explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items.  See User-Personalization.
        public let itemExplorationConfig: [String: String]?

        public init(itemExplorationConfig: [String: String]? = nil) {
            self.itemExplorationConfig = itemExplorationConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name: "itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name: "itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.validate(self.itemExplorationConfig, name: "itemExplorationConfig", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case itemExplorationConfig = "itemExplorationConfig"
        }
    }

    public struct BatchInferenceJobInput: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the same region as the API endpoint you are calling.
        public let s3DataSource: S3DataConfig

        public init(s3DataSource: S3DataConfig) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "s3DataSource"
        }
    }

    public struct BatchInferenceJobOutput: AWSEncodableShape & AWSDecodableShape {
        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        public let s3DataDestination: S3DataConfig

        public init(s3DataDestination: S3DataConfig) {
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.s3DataDestination.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataDestination = "s3DataDestination"
        }
    }

    public struct BatchInferenceJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let batchInferenceJobArn: String?
        /// The job's mode.
        public let batchInferenceJobMode: BatchInferenceJobMode?
        /// The time at which the batch inference job was created.
        public let creationDateTime: Date?
        /// If the batch inference job failed, the reason for the failure.
        public let failureReason: String?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The time at which the batch inference job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The ARN of the solution version used by the batch inference job.
        public let solutionVersionArn: String?
        /// The status of the batch inference job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED
        public let status: String?

        public init(batchInferenceJobArn: String? = nil, batchInferenceJobMode: BatchInferenceJobMode? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobMode = batchInferenceJobMode
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
            case batchInferenceJobMode = "batchInferenceJobMode"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct BatchSegmentJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public let batchSegmentJobArn: String?
        /// The time at which the batch segment job was created.
        public let creationDateTime: Date?
        /// If the batch segment job failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter used on the batch segment job.
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input data used to generate the batch segment job.
        public let jobInput: BatchSegmentJobInput?
        /// The name of the batch segment job.
        public let jobName: String?
        /// The Amazon S3 bucket that contains the output data generated by the batch segment job.
        public let jobOutput: BatchSegmentJobOutput?
        /// The time at which the batch segment job last updated.
        public let lastUpdatedDateTime: Date?
        /// The number of predicted users generated by the batch segment job for each line of input data. The maximum number of users per segment is 5 million.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch segment job.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public let solutionVersionArn: String?
        /// The status of the batch segment job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED
        public let status: String?

        public init(batchSegmentJobArn: String? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, filterArn: String? = nil, jobInput: BatchSegmentJobInput? = nil, jobName: String? = nil, jobOutput: BatchSegmentJobOutput? = nil, lastUpdatedDateTime: Date? = nil, numResults: Int? = nil, roleArn: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchSegmentJobArn = "batchSegmentJobArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case jobInput = "jobInput"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case numResults = "numResults"
            case roleArn = "roleArn"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct BatchSegmentJobInput: AWSEncodableShape & AWSDecodableShape {
        public let s3DataSource: S3DataConfig

        public init(s3DataSource: S3DataConfig) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "s3DataSource"
        }
    }

    public struct BatchSegmentJobOutput: AWSEncodableShape & AWSDecodableShape {
        public let s3DataDestination: S3DataConfig

        public init(s3DataDestination: S3DataConfig) {
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.s3DataDestination.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataDestination = "s3DataDestination"
        }
    }

    public struct BatchSegmentJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public let batchSegmentJobArn: String?
        /// The time at which the batch segment job was created.
        public let creationDateTime: Date?
        /// If the batch segment job failed, the reason for the failure.
        public let failureReason: String?
        /// The name of the batch segment job.
        public let jobName: String?
        /// The time at which the batch segment job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public let solutionVersionArn: String?
        /// The status of the batch segment job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED
        public let status: String?

        public init(batchSegmentJobArn: String? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchSegmentJobArn = "batchSegmentJobArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct Campaign: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public let creationDateTime: Date?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public let lastUpdatedDateTime: Date?
        public let latestCampaignUpdate: CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
        public let minProvisionedTPS: Int?
        /// The name of the campaign.
        public let name: String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public let solutionVersionArn: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(campaignArn: String? = nil, campaignConfig: CampaignConfig? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, latestCampaignUpdate: CampaignUpdateSummary? = nil, minProvisionedTPS: Int? = nil, name: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case campaignConfig = "campaignConfig"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestCampaignUpdate = "latestCampaignUpdate"
            case minProvisionedTPS = "minProvisionedTPS"
            case name = "name"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct CampaignConfig: AWSEncodableShape & AWSDecodableShape {
        /// Whether metadata with recommendations is enabled for the campaign.  If enabled, you can specify the columns from your Items dataset in your request for recommendations. Amazon Personalize returns this data for each item in the recommendation response. For information about enabling metadata for a campaign, see Enabling metadata in recommendations for a campaign.  If you enable metadata in recommendations, you will incur additional costs. For more information, see Amazon Personalize pricing.
        public let enableMetadataWithRecommendations: Bool?
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and  explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your solution uses the User-Personalization recipe.
        public let itemExplorationConfig: [String: String]?

        public init(enableMetadataWithRecommendations: Bool? = nil, itemExplorationConfig: [String: String]? = nil) {
            self.enableMetadataWithRecommendations = enableMetadataWithRecommendations
            self.itemExplorationConfig = itemExplorationConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name: "itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name: "itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.validate(self.itemExplorationConfig, name: "itemExplorationConfig", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case enableMetadataWithRecommendations = "enableMetadataWithRecommendations"
            case itemExplorationConfig = "itemExplorationConfig"
        }
    }

    public struct CampaignSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?
        /// The date and time (in Unix time) that the campaign was created.
        public let creationDateTime: Date?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the campaign.
        public let name: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(campaignArn: String? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct CampaignUpdateSummary: AWSDecodableShape {
        public let campaignConfig: CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public let creationDateTime: Date?
        /// If a campaign update fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public let lastUpdatedDateTime: Date?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public let solutionVersionArn: String?
        /// The status of the campaign update. A campaign update can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(campaignConfig: CampaignConfig? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, minProvisionedTPS: Int? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignConfig = "campaignConfig"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case minProvisionedTPS = "minProvisionedTPS"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct CategoricalHyperParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
            }
            try self.validate(self.values, name: "values", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct ContinuousHyperParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, min: -1000000.0)
            try self.validate(self.minValue, name: "minValue", parent: name, min: -1000000.0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct CreateBatchInferenceJobRequest: AWSEncodableShape {
        /// The configuration details of a batch inference job.
        public let batchInferenceJobConfig: BatchInferenceJobConfig?
        /// The mode of the batch inference job. To generate descriptive themes for groups of similar items, set the job mode to THEME_GENERATION. If you don't want to generate themes, use the default BATCH_INFERENCE.  When you get batch recommendations with themes, you will incur additional costs. For more information, see Amazon Personalize pricing.
        public let batchInferenceJobMode: BatchInferenceJobMode?
        /// The ARN of the filter to apply to the batch inference job. For more information on using filters, see Filtering batch recommendations.
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input file to base your recommendations on. The input material must be in JSON format.
        public let jobInput: BatchInferenceJobInput
        /// The name of the batch inference job to create.
        public let jobName: String
        /// The path to the Amazon S3 bucket where the job's output will be stored.
        public let jobOutput: BatchInferenceJobOutput
        /// The number of recommendations to retrieve.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the batch inference recommendations.
        public let solutionVersionArn: String
        /// A list of tags to apply to the batch inference job.
        public let tags: [Tag]?
        /// For theme generation jobs, specify the name of the column in your Items dataset that contains each item's name.
        public let themeGenerationConfig: ThemeGenerationConfig?

        public init(batchInferenceJobConfig: BatchInferenceJobConfig? = nil, batchInferenceJobMode: BatchInferenceJobMode? = nil, filterArn: String? = nil, jobInput: BatchInferenceJobInput, jobName: String, jobOutput: BatchInferenceJobOutput, numResults: Int? = nil, roleArn: String, solutionVersionArn: String, tags: [Tag]? = nil, themeGenerationConfig: ThemeGenerationConfig? = nil) {
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.batchInferenceJobMode = batchInferenceJobMode
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.tags = tags
            self.themeGenerationConfig = themeGenerationConfig
        }

        public func validate(name: String) throws {
            try self.batchInferenceJobConfig?.validate(name: "\(name).batchInferenceJobConfig")
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.jobInput.validate(name: "\(name).jobInput")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.jobOutput.validate(name: "\(name).jobOutput")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.themeGenerationConfig?.validate(name: "\(name).themeGenerationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobConfig = "batchInferenceJobConfig"
            case batchInferenceJobMode = "batchInferenceJobMode"
            case filterArn = "filterArn"
            case jobInput = "jobInput"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case numResults = "numResults"
            case roleArn = "roleArn"
            case solutionVersionArn = "solutionVersionArn"
            case tags = "tags"
            case themeGenerationConfig = "themeGenerationConfig"
        }
    }

    public struct CreateBatchInferenceJobResponse: AWSDecodableShape {
        /// The ARN of the batch inference job.
        public let batchInferenceJobArn: String?

        public init(batchInferenceJobArn: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
        }
    }

    public struct CreateBatchSegmentJobRequest: AWSEncodableShape {
        /// The ARN of the filter to apply to the batch segment job. For more information on using filters, see Filtering batch recommendations.
        public let filterArn: String?
        /// The Amazon S3 path for the input data used to generate the batch segment job.
        public let jobInput: BatchSegmentJobInput
        /// The name of the batch segment job to create.
        public let jobName: String
        /// The Amazon S3 path for the bucket where the job's output will be stored.
        public let jobOutput: BatchSegmentJobOutput
        /// The number of predicted users generated by the batch segment job for each line of input data. The maximum number of users per segment is 5 million.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the solution version you want the batch segment job to use to generate batch segments.
        public let solutionVersionArn: String
        /// A list of tags to apply to the batch segment job.
        public let tags: [Tag]?

        public init(filterArn: String? = nil, jobInput: BatchSegmentJobInput, jobName: String, jobOutput: BatchSegmentJobOutput, numResults: Int? = nil, roleArn: String, solutionVersionArn: String, tags: [Tag]? = nil) {
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.jobInput.validate(name: "\(name).jobInput")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.jobOutput.validate(name: "\(name).jobOutput")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
            case jobInput = "jobInput"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case numResults = "numResults"
            case roleArn = "roleArn"
            case solutionVersionArn = "solutionVersionArn"
            case tags = "tags"
        }
    }

    public struct CreateBatchSegmentJobResponse: AWSDecodableShape {
        /// The ARN of the batch segment job.
        public let batchSegmentJobArn: String?

        public init(batchSegmentJobArn: String? = nil) {
            self.batchSegmentJobArn = batchSegmentJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case batchSegmentJobArn = "batchSegmentJobArn"
        }
    }

    public struct CreateCampaignRequest: AWSEncodableShape {
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.  A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
        public let minProvisionedTPS: Int?
        /// A name for the new campaign. The campaign name must be unique within your account.
        public let name: String
        /// The Amazon Resource Name (ARN) of the solution version to deploy.
        public let solutionVersionArn: String
        /// A list of tags to apply to the campaign.
        public let tags: [Tag]?

        public init(campaignConfig: CampaignConfig? = nil, minProvisionedTPS: Int? = nil, name: String, solutionVersionArn: String, tags: [Tag]? = nil) {
            self.campaignConfig = campaignConfig
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.campaignConfig?.validate(name: "\(name).campaignConfig")
            try self.validate(self.minProvisionedTPS, name: "minProvisionedTPS", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case campaignConfig = "campaignConfig"
            case minProvisionedTPS = "minProvisionedTPS"
            case name = "name"
            case solutionVersionArn = "solutionVersionArn"
            case tags = "tags"
        }
    }

    public struct CreateCampaignResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct CreateDatasetExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset that contains the data to export.
        public let datasetArn: String
        /// The data to export, based on how you imported the data. You can choose to export only BULK data that you imported using a dataset import job, only PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public let ingestionMode: IngestionMode?
        /// The name for the dataset export job.
        public let jobName: String
        /// The path to the Amazon S3 bucket where the job's output is stored.
        public let jobOutput: DatasetExportJobOutput
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
        public let roleArn: String
        /// A list of tags to apply to the dataset export job.
        public let tags: [Tag]?

        public init(datasetArn: String, ingestionMode: IngestionMode? = nil, jobName: String, jobOutput: DatasetExportJobOutput, roleArn: String, tags: [Tag]? = nil) {
            self.datasetArn = datasetArn
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.jobOutput.validate(name: "\(name).jobOutput")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case ingestionMode = "ingestionMode"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateDatasetExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public let datasetExportJobArn: String?

        public init(datasetExportJobArn: String? = nil) {
            self.datasetExportJobArn = datasetExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJobArn = "datasetExportJobArn"
        }
    }

    public struct CreateDatasetGroupRequest: AWSEncodableShape {
        /// The domain of the dataset group. Specify a domain to create a Domain dataset group. The domain you specify determines the default schemas for datasets and the use cases available for recommenders. If you don't specify a domain, you create a Custom dataset group with solution versions that you deploy with a campaign.
        public let domain: Domain?
        /// The Amazon Resource Name (ARN) of a Key Management Service (KMS) key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The name for the new dataset group.
        public let name: String
        /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM role is only valid when also specifying a KMS key.
        public let roleArn: String?
        /// A list of tags to apply to the dataset group.
        public let tags: [Tag]?

        public init(domain: Domain? = nil, kmsKeyArn: String? = nil, name: String, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.domain = domain
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws.*:kms:.*:[0-9]{12}:key/")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateDatasetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new dataset group.
        public let datasetGroupArn: String?
        /// The domain for the new Domain dataset group.
        public let domain: Domain?

        public init(datasetGroupArn: String? = nil, domain: Domain? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case domain = "domain"
        }
    }

    public struct CreateDatasetImportJobRequest: AWSEncodableShape {
        /// The ARN of the dataset that receives the imported data.
        public let datasetArn: String
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource
        /// Specify how to add the new records to an existing dataset. The default import mode is FULL. If you haven't imported bulk records into the dataset previously, you can only specify FULL.   Specify FULL to overwrite all existing bulk data in your dataset. Data you imported individually is not replaced.   Specify INCREMENTAL to append the new records to the existing data in your dataset. Amazon Personalize replaces any record with the same ID with the new one.
        public let importMode: ImportMode?
        /// The name for the dataset import job.
        public let jobName: String
        /// If you created a metric attribution, specify whether to publish metrics for this import job to Amazon S3
        public let publishAttributionMetricsToS3: Bool?
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String
        /// A list of tags to apply to the dataset import job.
        public let tags: [Tag]?

        public init(datasetArn: String, dataSource: DataSource, importMode: ImportMode? = nil, jobName: String, publishAttributionMetricsToS3: Bool? = nil, roleArn: String, tags: [Tag]? = nil) {
            self.datasetArn = datasetArn
            self.dataSource = dataSource
            self.importMode = importMode
            self.jobName = jobName
            self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case dataSource = "dataSource"
            case importMode = "importMode"
            case jobName = "jobName"
            case publishAttributionMetricsToS3 = "publishAttributionMetricsToS3"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateDatasetImportJobResponse: AWSDecodableShape {
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "datasetImportJobArn"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
        public let datasetGroupArn: String
        /// The type of dataset. One of the following (case insensitive) values:   Interactions   Items   Users   Actions   Action_Interactions
        public let datasetType: String
        /// The name for the dataset.
        public let name: String
        /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
        public let schemaArn: String
        /// A list of tags to apply to the dataset.
        public let tags: [Tag]?

        public init(datasetGroupArn: String, datasetType: String, name: String, schemaArn: String, tags: [Tag]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.name = name
            self.schemaArn = schemaArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case datasetType = "datasetType"
            case name = "name"
            case schemaArn = "schemaArn"
            case tags = "tags"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The ARN of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct CreateEventTrackerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String
        /// The name for the event tracker.
        public let name: String
        /// A list of tags to apply to the event tracker.
        public let tags: [Tag]?

        public init(datasetGroupArn: String, name: String, tags: [Tag]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateEventTrackerResponse: AWSDecodableShape {
        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(eventTrackerArn: String? = nil, trackingId: String? = nil) {
            self.eventTrackerArn = eventTrackerArn
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
            case trackingId = "trackingId"
        }
    }

    public struct CreateFilterRequest: AWSEncodableShape {
        /// The ARN of the dataset group that the filter will belong to.
        public let datasetGroupArn: String
        /// The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules.  For information about filter expression structure and syntax, see Filter expressions.
        public let filterExpression: String
        /// The name of the filter to create.
        public let name: String
        /// A list of tags to apply to the filter.
        public let tags: [Tag]?

        public init(datasetGroupArn: String, filterExpression: String, name: String, tags: [Tag]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.filterExpression = filterExpression
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.filterExpression, name: "filterExpression", parent: name, max: 2500)
            try self.validate(self.filterExpression, name: "filterExpression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case filterExpression = "filterExpression"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateFilterResponse: AWSDecodableShape {
        /// The ARN of the new filter.
        public let filterArn: String?

        public init(filterArn: String? = nil) {
            self.filterArn = filterArn
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
        }
    }

    public struct CreateMetricAttributionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination dataset group for the metric attribution.
        public let datasetGroupArn: String
        /// A list of metric attributes for the metric attribution. Each metric attribute specifies an event type to track and a function. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the  dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
        public let metrics: [MetricAttribute]
        /// The output configuration details for the metric attribution.
        public let metricsOutputConfig: MetricAttributionOutput
        /// A name for the metric attribution.
        public let name: String

        public init(datasetGroupArn: String, metrics: [MetricAttribute], metricsOutputConfig: MetricAttributionOutput, name: String) {
            self.datasetGroupArn = datasetGroupArn
            self.metrics = metrics
            self.metricsOutputConfig = metricsOutputConfig
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.metrics.forEach {
                try $0.validate(name: "\(name).metrics[]")
            }
            try self.validate(self.metrics, name: "metrics", parent: name, max: 10)
            try self.metricsOutputConfig.validate(name: "\(name).metricsOutputConfig")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case metrics = "metrics"
            case metricsOutputConfig = "metricsOutputConfig"
            case name = "name"
        }
    }

    public struct CreateMetricAttributionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the new metric attribution.
        public let metricAttributionArn: String?

        public init(metricAttributionArn: String? = nil) {
            self.metricAttributionArn = metricAttributionArn
        }

        private enum CodingKeys: String, CodingKey {
            case metricAttributionArn = "metricAttributionArn"
        }
    }

    public struct CreateRecommenderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination domain dataset group for the recommender.
        public let datasetGroupArn: String
        /// The name of the recommender.
        public let name: String
        /// The Amazon Resource Name (ARN) of the recipe that the recommender will use. For a recommender, a recipe is a Domain dataset group use case. Only Domain dataset group use cases can be used to create a recommender. For information about use cases see Choosing recommender use cases.
        public let recipeArn: String
        /// The configuration details of the recommender.
        public let recommenderConfig: RecommenderConfig?
        /// A list of tags to apply to the recommender.
        public let tags: [Tag]?

        public init(datasetGroupArn: String, name: String, recipeArn: String, recommenderConfig: RecommenderConfig? = nil, tags: [Tag]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderConfig = recommenderConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, max: 256)
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.recommenderConfig?.validate(name: "\(name).recommenderConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case name = "name"
            case recipeArn = "recipeArn"
            case recommenderConfig = "recommenderConfig"
            case tags = "tags"
        }
    }

    public struct CreateRecommenderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the recommender.
        public let recommenderArn: String?

        public init(recommenderArn: String? = nil) {
            self.recommenderArn = recommenderArn
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct CreateSchemaRequest: AWSEncodableShape {
        /// The domain for the schema. If you are creating a schema for a dataset in a Domain dataset group, specify the domain you chose when you created the Domain dataset group.
        public let domain: Domain?
        /// The name for the schema.
        public let name: String
        /// A schema in Avro JSON format.
        public let schema: String

        public init(domain: Domain? = nil, name: String, schema: String) {
            self.domain = domain
            self.name = name
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.schema, name: "schema", parent: name, max: 20000)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct CreateSchemaResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created schema.
        public let schemaArn: String?

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct CreateSolutionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String
        /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model. If you do not provide an eventType, Amazon Personalize will use all interactions for training with equal weight regardless of type.
        public let eventType: String?
        /// The name for the solution.
        public let name: String
        ///  We don't recommend enabling automated machine learning. Instead, match your use case to the available Amazon Personalize  recipes. For more information, see Choosing a recipe.  Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
        public let performHPO: Bool?
        /// The Amazon Resource Name (ARN) of the recipe to use for model training. This is required when performAutoML is false. For information about different Amazon Personalize recipes and their ARNs,  see Choosing a recipe.
        public let recipeArn: String?
        /// The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration.  Amazon Personalize doesn't support configuring the hpoObjective  at this time.
        public let solutionConfig: SolutionConfig?
        /// A list of tags to apply to the solution.
        public let tags: [Tag]?

        public init(datasetGroupArn: String, eventType: String? = nil, name: String, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionConfig: SolutionConfig? = nil, tags: [Tag]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionConfig = solutionConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.eventType, name: "eventType", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, max: 256)
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.solutionConfig?.validate(name: "\(name).solutionConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionConfig = "solutionConfig"
            case tags = "tags"
        }
    }

    public struct CreateSolutionResponse: AWSDecodableShape {
        /// The ARN of the solution.
        public let solutionArn: String?

        public init(solutionArn: String? = nil) {
            self.solutionArn = solutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct CreateSolutionVersionRequest: AWSEncodableShape {
        /// The name of the solution version.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
        public let solutionArn: String
        /// A list of tags to apply to the solution version.
        public let tags: [Tag]?
        /// The scope of training to be performed when creating the solution version.  The default is FULL. This creates a completely new model based on the entirety  of the training data from the datasets in your dataset group.  If you use User-Personalization, you can specify a training mode of UPDATE. This updates the model to consider new items for recommendations. It is not a full retraining. You should still complete a full retraining weekly. If you specify UPDATE, Amazon Personalize will stop automatic updates for the solution version. To resume updates, create a new solution with training mode set to FULL and deploy it in a campaign.  For more information about automatic updates, see  Automatic updates.  The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the  User-Personalization recipe or the legacy HRNN-Coldstart recipe.
        public let trainingMode: TrainingMode?

        public init(name: String? = nil, solutionArn: String, tags: [Tag]? = nil, trainingMode: TrainingMode? = nil) {
            self.name = name
            self.solutionArn = solutionArn
            self.tags = tags
            self.trainingMode = trainingMode
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*$")
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case solutionArn = "solutionArn"
            case tags = "tags"
            case trainingMode = "trainingMode"
        }
    }

    public struct CreateSolutionVersionResponse: AWSDecodableShape {
        /// The ARN of the new solution version.
        public let solutionVersionArn: String?

        public init(solutionVersionArn: String? = nil) {
            self.solutionVersionArn = solutionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For example:   s3://bucket-name/folder-name/
        public let dataLocation: String?

        public init(dataLocation: String? = nil) {
            self.dataLocation = dataLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, max: 256)
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, pattern: "^(s3|http|https)://.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLocation = "dataLocation"
        }
    }

    public struct Dataset: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public let datasetArn: String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// One of the following values:   Interactions   Items   Users   Actions   Action_Interactions
        public let datasetType: String?
        /// A time stamp that shows when the dataset was updated.
        public let lastUpdatedDateTime: Date?
        /// Describes the latest update to the dataset.
        public let latestDatasetUpdate: DatasetUpdateSummary?
        /// The name of the dataset.
        public let name: String?
        /// The ARN of the associated schema.
        public let schemaArn: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?
        /// The ID of the event tracker for an Action interactions dataset.  You specify the tracker's ID in the PutActionInteractions API operation. Amazon Personalize uses it to direct new data to the Action interactions dataset in your dataset group.
        public let trackingId: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetGroupArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: Date? = nil, latestDatasetUpdate: DatasetUpdateSummary? = nil, name: String? = nil, schemaArn: String? = nil, status: String? = nil, trackingId: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestDatasetUpdate = latestDatasetUpdate
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetGroupArn = "datasetGroupArn"
            case datasetType = "datasetType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestDatasetUpdate = "latestDatasetUpdate"
            case name = "name"
            case schemaArn = "schemaArn"
            case status = "status"
            case trackingId = "trackingId"
        }
    }

    public struct DatasetExportJob: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset export job.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset to export.
        public let datasetArn: String?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public let datasetExportJobArn: String?
        /// If a dataset export job fails, provides the reason why.
        public let failureReason: String?
        /// The data to export, based on how you imported the data. You can choose to export BULK data that you imported using a dataset import job, PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public let ingestionMode: IngestionMode?
        /// The name of the export job.
        public let jobName: String?
        /// The path to the Amazon S3 bucket where the job's output is stored. For example:  s3://bucket-name/folder-name/
        public let jobOutput: DatasetExportJobOutput?
        /// The date and time (in Unix time) the status of the dataset export job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
        public let roleArn: String?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetExportJobArn: String? = nil, failureReason: String? = nil, ingestionMode: IngestionMode? = nil, jobName: String? = nil, jobOutput: DatasetExportJobOutput? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetExportJobArn = "datasetExportJobArn"
            case failureReason = "failureReason"
            case ingestionMode = "ingestionMode"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetExportJobOutput: AWSEncodableShape & AWSDecodableShape {
        public let s3DataDestination: S3DataConfig

        public init(s3DataDestination: S3DataConfig) {
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.s3DataDestination.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataDestination = "s3DataDestination"
        }
    }

    public struct DatasetExportJobSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset export job was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public let datasetExportJobArn: String?
        /// If a dataset export job fails, the reason behind the failure.
        public let failureReason: String?
        /// The name of the dataset export job.
        public let jobName: String?
        /// The date and time (in Unix time) that the dataset export job status was last updated.
        public let lastUpdatedDateTime: Date?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetExportJobArn: String? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetExportJobArn = "datasetExportJobArn"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case status = "status"
        }
    }

    public struct DatasetGroup: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset group.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The domain of a Domain dataset group.
        public let domain: Domain?
        /// If creating a dataset group fails, provides the reason why.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The last update date and time (in Unix time) of the dataset group.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset group.
        public let name: String?
        /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM role is only valid when also specifying a KMS key.
        public let roleArn: String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, domain: Domain? = nil, failureReason: String? = nil, kmsKeyArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case domain = "domain"
            case failureReason = "failureReason"
            case kmsKeyArn = "kmsKeyArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetGroupSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset group was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The domain of a Domain dataset group.
        public let domain: Domain?
        /// If creating a dataset group fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset group.
        public let name: String?
        /// The status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, domain: Domain? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case domain = "domain"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct DatasetImportJob: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset import job.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource?
        /// If a dataset import job fails, provides the reason why.
        public let failureReason: String?
        /// The import mode used by the dataset import job to import new records.
        public let importMode: ImportMode?
        /// The name of the import job.
        public let jobName: String?
        /// The date and time (in Unix time) the dataset was last updated.
        public let lastUpdatedDateTime: Date?
        /// Whether the job publishes metrics to Amazon S3 for a metric attribution.
        public let publishAttributionMetricsToS3: Bool?
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, dataSource: DataSource? = nil, failureReason: String? = nil, importMode: ImportMode? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, publishAttributionMetricsToS3: Bool? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.dataSource = dataSource
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetImportJobArn = "datasetImportJobArn"
            case dataSource = "dataSource"
            case failureReason = "failureReason"
            case importMode = "importMode"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case publishAttributionMetricsToS3 = "publishAttributionMetricsToS3"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetImportJobSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset import job was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// If a dataset import job fails, the reason behind the failure.
        public let failureReason: String?
        /// The import mode the dataset import job used to update the data in the dataset.  For more information see Updating existing bulk data.
        public let importMode: ImportMode?
        /// The name of the dataset import job.
        public let jobName: String?
        /// The date and time (in Unix time) that the dataset import job status was last updated.
        public let lastUpdatedDateTime: Date?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetImportJobArn: String? = nil, failureReason: String? = nil, importMode: ImportMode? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetImportJobArn = "datasetImportJobArn"
            case failureReason = "failureReason"
            case importMode = "importMode"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case status = "status"
        }
    }

    public struct DatasetSchema: AWSDecodableShape {
        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public let domain: Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the schema.
        public let name: String?
        /// The schema.
        public let schema: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: Date? = nil, domain: Domain? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, schema: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case domain = "domain"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schema = "schema"
            case schemaArn = "schemaArn"
        }
    }

    public struct DatasetSchemaSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public let domain: Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the schema.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: Date? = nil, domain: Domain? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case domain = "domain"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schemaArn = "schemaArn"
        }
    }

    public struct DatasetSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The dataset type. One of the following values:   Interactions   Items   Users   Event-Interactions
        public let datasetType: String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset.
        public let name: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetType = "datasetType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct DatasetUpdateSummary: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset update.
        public let creationDateTime: Date?
        /// If updating a dataset fails, provides the reason why.
        public let failureReason: String?
        /// The last update date and time (in Unix time) of the dataset.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the schema that replaced the previous schema of the dataset.
        public let schemaArn: String?
        /// The status of the dataset update.
        public let status: String?

        public init(creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, schemaArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.schemaArn = schemaArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case schemaArn = "schemaArn"
            case status = "status"
        }
    }

    public struct DefaultCategoricalHyperParameterRange: AWSDecodableShape {
        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(isTunable: Bool? = nil, name: String? = nil, values: [String]? = nil) {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case name = "name"
            case values = "values"
        }
    }

    public struct DefaultContinuousHyperParameterRange: AWSDecodableShape {
        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct DefaultHyperParameterRanges: AWSDecodableShape {
        /// The categorical hyperparameters and their default ranges.
        public let categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public let continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public let integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges = "categoricalHyperParameterRanges"
            case continuousHyperParameterRanges = "continuousHyperParameterRanges"
            case integerHyperParameterRanges = "integerHyperParameterRanges"
        }
    }

    public struct DefaultIntegerHyperParameterRange: AWSDecodableShape {
        /// Indicates whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Int? = nil, minValue: Int? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct DeleteCampaignRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the campaign to delete.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, max: 256)
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct DeleteDatasetGroupRequest: AWSEncodableShape {
        /// The ARN of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct DeleteEventTrackerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the event tracker to delete.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, max: 256)
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
        }
    }

    public struct DeleteFilterRequest: AWSEncodableShape {
        /// The ARN of the filter to delete.
        public let filterArn: String

        public init(filterArn: String) {
            self.filterArn = filterArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
        }
    }

    public struct DeleteMetricAttributionRequest: AWSEncodableShape {
        /// The metric attribution's Amazon Resource Name (ARN).
        public let metricAttributionArn: String

        public init(metricAttributionArn: String) {
            self.metricAttributionArn = metricAttributionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, max: 256)
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metricAttributionArn = "metricAttributionArn"
        }
    }

    public struct DeleteRecommenderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recommender to delete.
        public let recommenderArn: String

        public init(recommenderArn: String) {
            self.recommenderArn = recommenderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, max: 256)
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct DeleteSchemaRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the schema to delete.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct DeleteSolutionRequest: AWSEncodableShape {
        /// The ARN of the solution to delete.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct DescribeAlgorithmRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm to describe.
        public let algorithmArn: String

        public init(algorithmArn: String) {
            self.algorithmArn = algorithmArn
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, max: 256)
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
        }
    }

    public struct DescribeAlgorithmResponse: AWSDecodableShape {
        /// A listing of the properties of the algorithm.
        public let algorithm: Algorithm?

        public init(algorithm: Algorithm? = nil) {
            self.algorithm = algorithm
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
        }
    }

    public struct DescribeBatchInferenceJobRequest: AWSEncodableShape {
        /// The ARN of the batch inference job to describe.
        public let batchInferenceJobArn: String

        public init(batchInferenceJobArn: String) {
            self.batchInferenceJobArn = batchInferenceJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.batchInferenceJobArn, name: "batchInferenceJobArn", parent: name, max: 256)
            try self.validate(self.batchInferenceJobArn, name: "batchInferenceJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
        }
    }

    public struct DescribeBatchInferenceJobResponse: AWSDecodableShape {
        /// Information on the specified batch inference job.
        public let batchInferenceJob: BatchInferenceJob?

        public init(batchInferenceJob: BatchInferenceJob? = nil) {
            self.batchInferenceJob = batchInferenceJob
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJob = "batchInferenceJob"
        }
    }

    public struct DescribeBatchSegmentJobRequest: AWSEncodableShape {
        /// The ARN of the batch segment job to describe.
        public let batchSegmentJobArn: String

        public init(batchSegmentJobArn: String) {
            self.batchSegmentJobArn = batchSegmentJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.batchSegmentJobArn, name: "batchSegmentJobArn", parent: name, max: 256)
            try self.validate(self.batchSegmentJobArn, name: "batchSegmentJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case batchSegmentJobArn = "batchSegmentJobArn"
        }
    }

    public struct DescribeBatchSegmentJobResponse: AWSDecodableShape {
        /// Information on the specified batch segment job.
        public let batchSegmentJob: BatchSegmentJob?

        public init(batchSegmentJob: BatchSegmentJob? = nil) {
            self.batchSegmentJob = batchSegmentJob
        }

        private enum CodingKeys: String, CodingKey {
            case batchSegmentJob = "batchSegmentJob"
        }
    }

    public struct DescribeCampaignRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, max: 256)
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct DescribeCampaignResponse: AWSDecodableShape {
        /// The properties of the campaign.
        public let campaign: Campaign?

        public init(campaign: Campaign? = nil) {
            self.campaign = campaign
        }

        private enum CodingKeys: String, CodingKey {
            case campaign = "campaign"
        }
    }

    public struct DescribeDatasetExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset export job to describe.
        public let datasetExportJobArn: String

        public init(datasetExportJobArn: String) {
            self.datasetExportJobArn = datasetExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetExportJobArn, name: "datasetExportJobArn", parent: name, max: 256)
            try self.validate(self.datasetExportJobArn, name: "datasetExportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJobArn = "datasetExportJobArn"
        }
    }

    public struct DescribeDatasetExportJobResponse: AWSDecodableShape {
        /// Information about the dataset export job, including the status. The status is one of the following values:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED
        public let datasetExportJob: DatasetExportJob?

        public init(datasetExportJob: DatasetExportJob? = nil) {
            self.datasetExportJob = datasetExportJob
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJob = "datasetExportJob"
        }
    }

    public struct DescribeDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group to describe.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct DescribeDatasetGroupResponse: AWSDecodableShape {
        /// A listing of the dataset group's properties.
        public let datasetGroup: DatasetGroup?

        public init(datasetGroup: DatasetGroup? = nil) {
            self.datasetGroup = datasetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroup = "datasetGroup"
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job to describe.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, max: 256)
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "datasetImportJobArn"
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSDecodableShape {
        /// Information about the dataset import job, including the status. The status is one of the following values:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED
        public let datasetImportJob: DatasetImportJob?

        public init(datasetImportJob: DatasetImportJob? = nil) {
            self.datasetImportJob = datasetImportJob
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJob = "datasetImportJob"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to describe.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// A listing of the dataset's properties.
        public let dataset: Dataset?

        public init(dataset: Dataset? = nil) {
            self.dataset = dataset
        }

        private enum CodingKeys: String, CodingKey {
            case dataset = "dataset"
        }
    }

    public struct DescribeEventTrackerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the event tracker to describe.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, max: 256)
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
        }
    }

    public struct DescribeEventTrackerResponse: AWSDecodableShape {
        /// An object that describes the event tracker.
        public let eventTracker: EventTracker?

        public init(eventTracker: EventTracker? = nil) {
            self.eventTracker = eventTracker
        }

        private enum CodingKeys: String, CodingKey {
            case eventTracker = "eventTracker"
        }
    }

    public struct DescribeFeatureTransformationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the feature transformation to describe.
        public let featureTransformationArn: String

        public init(featureTransformationArn: String) {
            self.featureTransformationArn = featureTransformationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.featureTransformationArn, name: "featureTransformationArn", parent: name, max: 256)
            try self.validate(self.featureTransformationArn, name: "featureTransformationArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformationArn = "featureTransformationArn"
        }
    }

    public struct DescribeFeatureTransformationResponse: AWSDecodableShape {
        /// A listing of the FeatureTransformation properties.
        public let featureTransformation: FeatureTransformation?

        public init(featureTransformation: FeatureTransformation? = nil) {
            self.featureTransformation = featureTransformation
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformation = "featureTransformation"
        }
    }

    public struct DescribeFilterRequest: AWSEncodableShape {
        /// The ARN of the filter to describe.
        public let filterArn: String

        public init(filterArn: String) {
            self.filterArn = filterArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
        }
    }

    public struct DescribeFilterResponse: AWSDecodableShape {
        /// The filter's details.
        public let filter: Filter?

        public init(filter: Filter? = nil) {
            self.filter = filter
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct DescribeMetricAttributionRequest: AWSEncodableShape {
        /// The metric attribution's Amazon Resource Name (ARN).
        public let metricAttributionArn: String

        public init(metricAttributionArn: String) {
            self.metricAttributionArn = metricAttributionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, max: 256)
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metricAttributionArn = "metricAttributionArn"
        }
    }

    public struct DescribeMetricAttributionResponse: AWSDecodableShape {
        /// The details of the metric attribution.
        public let metricAttribution: MetricAttribution?

        public init(metricAttribution: MetricAttribution? = nil) {
            self.metricAttribution = metricAttribution
        }

        private enum CodingKeys: String, CodingKey {
            case metricAttribution = "metricAttribution"
        }
    }

    public struct DescribeRecipeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recipe to describe.
        public let recipeArn: String

        public init(recipeArn: String) {
            self.recipeArn = recipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, max: 256)
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case recipeArn = "recipeArn"
        }
    }

    public struct DescribeRecipeResponse: AWSDecodableShape {
        /// An object that describes the recipe.
        public let recipe: Recipe?

        public init(recipe: Recipe? = nil) {
            self.recipe = recipe
        }

        private enum CodingKeys: String, CodingKey {
            case recipe = "recipe"
        }
    }

    public struct DescribeRecommenderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recommender to describe.
        public let recommenderArn: String

        public init(recommenderArn: String) {
            self.recommenderArn = recommenderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, max: 256)
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct DescribeRecommenderResponse: AWSDecodableShape {
        /// The properties of the recommender.
        public let recommender: Recommender?

        public init(recommender: Recommender? = nil) {
            self.recommender = recommender
        }

        private enum CodingKeys: String, CodingKey {
            case recommender = "recommender"
        }
    }

    public struct DescribeSchemaRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the schema to retrieve.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct DescribeSchemaResponse: AWSDecodableShape {
        /// The requested schema.
        public let schema: DatasetSchema?

        public init(schema: DatasetSchema? = nil) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct DescribeSolutionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution to describe.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct DescribeSolutionResponse: AWSDecodableShape {
        /// An object that describes the solution.
        public let solution: Solution?

        public init(solution: Solution? = nil) {
            self.solution = solution
        }

        private enum CodingKeys: String, CodingKey {
            case solution = "solution"
        }
    }

    public struct DescribeSolutionVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct DescribeSolutionVersionResponse: AWSDecodableShape {
        /// The solution version.
        public let solutionVersion: SolutionVersion?

        public init(solutionVersion: SolutionVersion? = nil) {
            self.solutionVersion = solutionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersion = "solutionVersion"
        }
    }

    public struct EventTracker: AWSDecodableShape {
        /// The Amazon Web Services account that owns the event tracker.
        public let accountId: String?
        /// The date and time (in Unix format) that the event tracker was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String?
        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(accountId: String? = nil, creationDateTime: Date? = nil, datasetGroupArn: String? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil, trackingId: String? = nil) {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventTrackerArn = "eventTrackerArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
            case trackingId = "trackingId"
        }
    }

    public struct EventTrackerSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the event tracker was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case eventTrackerArn = "eventTrackerArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct FeatureTransformation: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the feature transformation.
        public let creationDateTime: Date?
        /// Provides the default parameters for feature transformation.
        public let defaultParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public let lastUpdatedDateTime: Date?
        /// The name of the feature transformation.
        public let name: String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, defaultParameters: [String: String]? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case defaultParameters = "defaultParameters"
            case featureTransformationArn = "featureTransformationArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct FieldsForThemeGeneration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Items dataset column that stores the name of each item in the dataset.
        public let itemName: String

        public init(itemName: String) {
            self.itemName = itemName
        }

        public func validate(name: String) throws {
            try self.validate(self.itemName, name: "itemName", parent: name, max: 150)
        }

        private enum CodingKeys: String, CodingKey {
            case itemName = "itemName"
        }
    }

    public struct Filter: AWSDecodableShape {
        /// The time at which the filter was created.
        public let creationDateTime: Date?
        /// The ARN of the dataset group to which the filter belongs.
        public let datasetGroupArn: String?
        /// If the filter failed, the reason for its failure.
        public let failureReason: String?
        /// The ARN of the filter.
        public let filterArn: String?
        /// Specifies the type of item interactions to filter out of recommendation results. The filter expression must follow specific format rules. For information about filter expression structure and syntax, see Filter expressions.
        public let filterExpression: String?
        /// The time at which the filter was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the filter.
        public let name: String?
        /// The status of the filter.
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, filterArn: String? = nil, filterExpression: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case filterExpression = "filterExpression"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct FilterSummary: AWSDecodableShape {
        /// The time at which the filter was created.
        public let creationDateTime: Date?
        /// The ARN of the dataset group to which the filter belongs.
        public let datasetGroupArn: String?
        /// If the filter failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter.
        public let filterArn: String?
        /// The time at which the filter was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the filter.
        public let name: String?
        /// The status of the filter.
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, filterArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetSolutionMetricsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct GetSolutionMetricsResponse: AWSDecodableShape {
        /// The metrics for the solution version. For more information, see  Evaluating a solution version with metrics .
        public let metrics: [String: Double]?
        /// The same solution version ARN as specified in the request.
        public let solutionVersionArn: String?

        public init(metrics: [String: Double]? = nil, solutionVersionArn: String? = nil) {
            self.metrics = metrics
            self.solutionVersionArn = solutionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "metrics"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct HPOConfig: AWSEncodableShape & AWSDecodableShape {
        /// The hyperparameters and their allowable ranges.
        public let algorithmHyperParameterRanges: HyperParameterRanges?
        /// The metric to optimize during HPO.  Amazon Personalize doesn't support configuring the hpoObjective  at this time.
        public let hpoObjective: HPOObjective?
        /// Describes the resource configuration for HPO.
        public let hpoResourceConfig: HPOResourceConfig?

        public init(algorithmHyperParameterRanges: HyperParameterRanges? = nil, hpoObjective: HPOObjective? = nil, hpoResourceConfig: HPOResourceConfig? = nil) {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }

        public func validate(name: String) throws {
            try self.algorithmHyperParameterRanges?.validate(name: "\(name).algorithmHyperParameterRanges")
            try self.hpoObjective?.validate(name: "\(name).hpoObjective")
            try self.hpoResourceConfig?.validate(name: "\(name).hpoResourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameterRanges = "algorithmHyperParameterRanges"
            case hpoObjective = "hpoObjective"
            case hpoResourceConfig = "hpoResourceConfig"
        }
    }

    public struct HPOObjective: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let metricName: String?
        /// A regular expression for finding the metric in the training job logs.
        public let metricRegex: String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public let type: String?

        public init(metricName: String? = nil, metricRegex: String? = nil, type: String? = nil) {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
            try self.validate(self.metricRegex, name: "metricRegex", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "metricName"
            case metricRegex = "metricRegex"
            case type = "type"
        }
    }

    public struct HPOResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
        public let maxNumberOfTrainingJobs: String?
        /// The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
        public let maxParallelTrainingJobs: String?

        public init(maxNumberOfTrainingJobs: String? = nil, maxParallelTrainingJobs: String? = nil) {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxNumberOfTrainingJobs, name: "maxNumberOfTrainingJobs", parent: name, max: 256)
            try self.validate(self.maxParallelTrainingJobs, name: "maxParallelTrainingJobs", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxNumberOfTrainingJobs = "maxNumberOfTrainingJobs"
            case maxParallelTrainingJobs = "maxParallelTrainingJobs"
        }
    }

    public struct HyperParameterRanges: AWSEncodableShape & AWSDecodableShape {
        /// The categorical hyperparameters and their ranges.
        public let categoricalHyperParameterRanges: [CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public let continuousHyperParameterRanges: [ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public let integerHyperParameterRanges: [IntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [CategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [ContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [IntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalHyperParameterRanges[]")
            }
            try self.validate(self.categoricalHyperParameterRanges, name: "categoricalHyperParameterRanges", parent: name, max: 100)
            try self.continuousHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousHyperParameterRanges[]")
            }
            try self.validate(self.continuousHyperParameterRanges, name: "continuousHyperParameterRanges", parent: name, max: 100)
            try self.integerHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerHyperParameterRanges[]")
            }
            try self.validate(self.integerHyperParameterRanges, name: "integerHyperParameterRanges", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges = "categoricalHyperParameterRanges"
            case continuousHyperParameterRanges = "continuousHyperParameterRanges"
            case integerHyperParameterRanges = "integerHyperParameterRanges"
        }
    }

    public struct IntegerHyperParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Int? = nil, minValue: Int? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 1000000)
            try self.validate(self.minValue, name: "minValue", parent: name, min: -1000000)
            try self.validate(self.name, name: "name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct ListBatchInferenceJobsRequest: AWSEncodableShape {
        /// The maximum number of batch inference job results to return in each page. The default value is 100.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs were created.
        public let solutionVersionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionVersionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct ListBatchInferenceJobsResponse: AWSDecodableShape {
        /// A list containing information on each job that is returned.
        public let batchInferenceJobs: [BatchInferenceJobSummary]?
        /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
        public let nextToken: String?

        public init(batchInferenceJobs: [BatchInferenceJobSummary]? = nil, nextToken: String? = nil) {
            self.batchInferenceJobs = batchInferenceJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobs = "batchInferenceJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListBatchSegmentJobsRequest: AWSEncodableShape {
        /// The maximum number of batch segment job results to return in each page. The default value is 100.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution version that the batch segment jobs used to generate batch segments.
        public let solutionVersionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionVersionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct ListBatchSegmentJobsResponse: AWSDecodableShape {
        /// A list containing information on each job that is returned.
        public let batchSegmentJobs: [BatchSegmentJobSummary]?
        /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
        public let nextToken: String?

        public init(batchSegmentJobs: [BatchSegmentJobSummary]? = nil, nextToken: String? = nil) {
            self.batchSegmentJobs = batchSegmentJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchSegmentJobs = "batchSegmentJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListCampaignsRequest: AWSEncodableShape {
        /// The maximum number of campaigns to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListCampaigns for getting the next set of campaigns (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
        public let solutionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionArn = "solutionArn"
        }
    }

    public struct ListCampaignsResponse: AWSDecodableShape {
        /// A list of the campaigns.
        public let campaigns: [CampaignSummary]?
        /// A token for getting the next set of campaigns (if they exist).
        public let nextToken: String?

        public init(campaigns: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaigns = campaigns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaigns = "campaigns"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetExportJobsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.
        public let datasetArn: String?
        /// The maximum number of dataset export jobs to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetExportJobs for getting the next set of dataset export jobs (if they exist).
        public let nextToken: String?

        public init(datasetArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetArn = datasetArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetExportJobsResponse: AWSDecodableShape {
        /// The list of dataset export jobs.
        public let datasetExportJobs: [DatasetExportJobSummary]?
        /// A token for getting the next set of dataset export jobs (if they exist).
        public let nextToken: String?

        public init(datasetExportJobs: [DatasetExportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetExportJobs = datasetExportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJobs = "datasetExportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetGroupsRequest: AWSEncodableShape {
        /// The maximum number of dataset groups to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetGroupsResponse: AWSDecodableShape {
        /// The list of your dataset groups.
        public let datasetGroups: [DatasetGroupSummary]?
        /// A token for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups = "datasetGroups"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetImportJobsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
        public let datasetArn: String?
        /// The maximum number of dataset import jobs to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetArn = datasetArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetImportJobsResponse: AWSDecodableShape {
        /// The list of dataset import jobs.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// A token for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs = "datasetImportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
        public let datasetGroupArn: String?
        /// The maximum number of datasets to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasets for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// An array of Dataset objects. Each object provides metadata information.
        public let datasets: [DatasetSummary]?
        /// A token for getting the next set of datasets (if they exist).
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "datasets"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventTrackersRequest: AWSEncodableShape {
        /// The ARN of a dataset group used to filter the response.
        public let datasetGroupArn: String?
        /// The maximum number of event trackers to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventTrackersResponse: AWSDecodableShape {
        /// A list of event trackers.
        public let eventTrackers: [EventTrackerSummary]?
        /// A token for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(eventTrackers: [EventTrackerSummary]? = nil, nextToken: String? = nil) {
            self.eventTrackers = eventTrackers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackers = "eventTrackers"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersRequest: AWSEncodableShape {
        /// The ARN of the dataset group that contains the filters.
        public let datasetGroupArn: String?
        /// The maximum number of filters to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListFilters for getting the next set of filters (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersResponse: AWSDecodableShape {
        /// A list of returned filters.
        public let filters: [FilterSummary]?
        /// A token for getting the next set of filters (if they exist).
        public let nextToken: String?

        public init(filters: [FilterSummary]? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case nextToken = "nextToken"
        }
    }

    public struct ListMetricAttributionMetricsRequest: AWSEncodableShape {
        /// The maximum number of metrics to return in one page of results.
        public let maxResults: Int?
        /// The Amazon Resource Name (ARN) of the metric attribution to retrieve attributes for.
        public let metricAttributionArn: String?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, metricAttributionArn: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.metricAttributionArn = metricAttributionArn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, max: 256)
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case metricAttributionArn = "metricAttributionArn"
            case nextToken = "nextToken"
        }
    }

    public struct ListMetricAttributionMetricsResponse: AWSDecodableShape {
        /// The metrics for the specified metric attribution.
        public let metrics: [MetricAttribute]?
        /// Specify the pagination token from a previous ListMetricAttributionMetricsResponse request to retrieve the next page of results.
        public let nextToken: String?

        public init(metrics: [MetricAttribute]? = nil, nextToken: String? = nil) {
            self.metrics = metrics
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "metrics"
            case nextToken = "nextToken"
        }
    }

    public struct ListMetricAttributionsRequest: AWSEncodableShape {
        /// The metric attributions' dataset group Amazon Resource Name (ARN).
        public let datasetGroupArn: String?
        /// The maximum number of metric attributions to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListMetricAttributionsResponse: AWSDecodableShape {
        /// The list of metric attributions.
        public let metricAttributions: [MetricAttributionSummary]?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(metricAttributions: [MetricAttributionSummary]? = nil, nextToken: String? = nil) {
            self.metricAttributions = metricAttributions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricAttributions = "metricAttributions"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecipesRequest: AWSEncodableShape {
        ///  Filters returned recipes by domain for a Domain dataset group. Only recipes (Domain dataset group use cases) for this domain are included in the response. If you don't specify a domain, all recipes are returned.
        public let domain: Domain?
        /// The maximum number of recipes to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
        public let nextToken: String?
        /// The default is SERVICE.
        public let recipeProvider: RecipeProvider?

        public init(domain: Domain? = nil, maxResults: Int? = nil, nextToken: String? = nil, recipeProvider: RecipeProvider? = nil) {
            self.domain = domain
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recipeProvider = recipeProvider
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case recipeProvider = "recipeProvider"
        }
    }

    public struct ListRecipesResponse: AWSDecodableShape {
        /// A token for getting the next set of recipes.
        public let nextToken: String?
        /// The list of available recipes.
        public let recipes: [RecipeSummary]?

        public init(nextToken: String? = nil, recipes: [RecipeSummary]? = nil) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recipes = "recipes"
        }
    }

    public struct ListRecommendersRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Domain dataset group to list the recommenders for. When a Domain dataset group is not specified, all the recommenders associated with the account are listed.
        public let datasetGroupArn: String?
        /// The maximum number of recommenders to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListRecommenders for getting the next set of recommenders (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendersResponse: AWSDecodableShape {
        /// A token for getting the next set of recommenders (if they exist).
        public let nextToken: String?
        /// A list of the recommenders.
        public let recommenders: [RecommenderSummary]?

        public init(nextToken: String? = nil, recommenders: [RecommenderSummary]? = nil) {
            self.nextToken = nextToken
            self.recommenders = recommenders
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recommenders = "recommenders"
        }
    }

    public struct ListSchemasRequest: AWSEncodableShape {
        /// The maximum number of schemas to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSchemasResponse: AWSDecodableShape {
        /// A token used to get the next set of schemas (if they exist).
        public let nextToken: String?
        /// A list of schemas.
        public let schemas: [DatasetSchemaSummary]?

        public init(nextToken: String? = nil, schemas: [DatasetSchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemas = "schemas"
        }
    }

    public struct ListSolutionVersionsRequest: AWSEncodableShape {
        /// The maximum number of solution versions to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionArn = "solutionArn"
        }
    }

    public struct ListSolutionVersionsResponse: AWSDecodableShape {
        /// A token for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// A list of solution versions describing the version properties.
        public let solutionVersions: [SolutionVersionSummary]?

        public init(nextToken: String? = nil, solutionVersions: [SolutionVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutionVersions = solutionVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case solutionVersions = "solutionVersions"
        }
    }

    public struct ListSolutionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The maximum number of solutions to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolutionsResponse: AWSDecodableShape {
        /// A token for getting the next set of solutions (if they exist).
        public let nextToken: String?
        /// A list of the current solutions.
        public let solutions: [SolutionSummary]?

        public init(nextToken: String? = nil, solutions: [SolutionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutions = solutions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case solutions = "solutions"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The resource's tags.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MetricAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The metric's event type.
        public let eventType: String
        /// The attribute's expression. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the  dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
        public let expression: String
        /// The metric's name. The name helps you identify the metric in Amazon CloudWatch or Amazon S3.
        public let metricName: String

        public init(eventType: String, expression: String, metricName: String) {
            self.eventType = eventType
            self.expression = expression
            self.metricName = metricName
        }

        public func validate(name: String) throws {
            try self.validate(self.eventType, name: "eventType", parent: name, max: 256)
            try self.validate(self.expression, name: "expression", parent: name, max: 256)
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "eventType"
            case expression = "expression"
            case metricName = "metricName"
        }
    }

    public struct MetricAttribution: AWSDecodableShape {
        /// The metric attribution's creation date time.
        public let creationDateTime: Date?
        /// The metric attribution's dataset group Amazon Resource Name (ARN).
        public let datasetGroupArn: String?
        /// The metric attribution's failure reason.
        public let failureReason: String?
        /// The metric attribution's last updated date time.
        public let lastUpdatedDateTime: Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public let metricAttributionArn: String?
        /// The metric attribution's output configuration.
        public let metricsOutputConfig: MetricAttributionOutput?
        /// The metric attribution's name.
        public let name: String?
        /// The metric attribution's status.
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, metricAttributionArn: String? = nil, metricsOutputConfig: MetricAttributionOutput? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.metricsOutputConfig = metricsOutputConfig
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case metricAttributionArn = "metricAttributionArn"
            case metricsOutputConfig = "metricsOutputConfig"
            case name = "name"
            case status = "status"
        }
    }

    public struct MetricAttributionOutput: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket and add metrics to Amazon CloudWatch. For more information, see Measuring impact of recommendations.
        public let roleArn: String
        public let s3DataDestination: S3DataConfig?

        public init(roleArn: String, s3DataDestination: S3DataConfig? = nil) {
            self.roleArn = roleArn
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.s3DataDestination?.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case s3DataDestination = "s3DataDestination"
        }
    }

    public struct MetricAttributionSummary: AWSDecodableShape {
        /// The metric attribution's creation date time.
        public let creationDateTime: Date?
        /// The metric attribution's failure reason.
        public let failureReason: String?
        /// The metric attribution's last updated date time.
        public let lastUpdatedDateTime: Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public let metricAttributionArn: String?
        /// The name of the metric attribution.
        public let name: String?
        /// The metric attribution's status.
        public let status: String?

        public init(creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, metricAttributionArn: String? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case metricAttributionArn = "metricAttributionArn"
            case name = "name"
            case status = "status"
        }
    }

    public struct OptimizationObjective: AWSEncodableShape & AWSDecodableShape {
        /// The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).
        public let itemAttribute: String?
        /// Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.
        public let objectiveSensitivity: ObjectiveSensitivity?

        public init(itemAttribute: String? = nil, objectiveSensitivity: ObjectiveSensitivity? = nil) {
            self.itemAttribute = itemAttribute
            self.objectiveSensitivity = objectiveSensitivity
        }

        public func validate(name: String) throws {
            try self.validate(self.itemAttribute, name: "itemAttribute", parent: name, max: 150)
            try self.validate(self.itemAttribute, name: "itemAttribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case itemAttribute = "itemAttribute"
            case objectiveSensitivity = "objectiveSensitivity"
        }
    }

    public struct Recipe: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public let algorithmArn: String?
        /// The date and time (in Unix format) that the recipe was created.
        public let creationDateTime: Date?
        /// The description of the recipe.
        public let description: String?
        /// The ARN of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// One of the following values:   PERSONALIZED_RANKING   RELATED_ITEMS   USER_PERSONALIZATION
        public let recipeType: String?
        /// The status of the recipe.
        public let status: String?

        public init(algorithmArn: String? = nil, creationDateTime: Date? = nil, description: String? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, recipeArn: String? = nil, recipeType: String? = nil, status: String? = nil) {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case featureTransformationArn = "featureTransformationArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case recipeType = "recipeType"
            case status = "status"
        }
    }

    public struct RecipeSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the recipe was created.
        public let creationDateTime: Date?
        /// The domain of the recipe (if the recipe is a Domain dataset group use case).
        public let domain: Domain?
        /// The date and time (in Unix time) that the recipe was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// The status of the recipe.
        public let status: String?

        public init(creationDateTime: Date? = nil, domain: Domain? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, recipeArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case domain = "domain"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case status = "status"
        }
    }

    public struct Recommender: AWSDecodableShape {
        /// The date and time (in Unix format) that the recommender was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public let datasetGroupArn: String?
        /// If a recommender fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public let lastUpdatedDateTime: Date?
        /// Provides a summary of the latest updates to the recommender.
        public let latestRecommenderUpdate: RecommenderUpdateSummary?
        /// Provides evaluation metrics that help you determine the performance of a recommender. For more information, see  Evaluating a recommender.
        public let modelMetrics: [String: Double]?
        /// The name of the recommender.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public let recipeArn: String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public let recommenderArn: String?
        /// The configuration details of the recommender.
        public let recommenderConfig: RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, latestRecommenderUpdate: RecommenderUpdateSummary? = nil, modelMetrics: [String: Double]? = nil, name: String? = nil, recipeArn: String? = nil, recommenderArn: String? = nil, recommenderConfig: RecommenderConfig? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestRecommenderUpdate = latestRecommenderUpdate
            self.modelMetrics = modelMetrics
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestRecommenderUpdate = "latestRecommenderUpdate"
            case modelMetrics = "modelMetrics"
            case name = "name"
            case recipeArn = "recipeArn"
            case recommenderArn = "recommenderArn"
            case recommenderConfig = "recommenderConfig"
            case status = "status"
        }
    }

    public struct RecommenderConfig: AWSEncodableShape & AWSDecodableShape {
        /// Whether metadata with recommendations is enabled for the recommender.  If enabled, you can specify the columns from your Items dataset in your request for recommendations. Amazon Personalize returns this data for each item in the recommendation response.  For information about enabling metadata for a recommender, see Enabling metadata in recommendations for a recommender.  If you enable metadata in recommendations, you will incur additional costs. For more information, see Amazon Personalize pricing.
        public let enableMetadataWithRecommendations: Bool?
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and  explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your recommenders generate personalized recommendations for a user (not popular items or similar items).
        public let itemExplorationConfig: [String: String]?
        /// Specifies the requested minimum provisioned recommendation requests per second that Amazon Personalize will support. A high minRecommendationRequestsPerSecond will increase your bill. We recommend starting with 1 for minRecommendationRequestsPerSecond (the default). Track your usage using Amazon CloudWatch metrics, and increase the minRecommendationRequestsPerSecond as necessary.
        public let minRecommendationRequestsPerSecond: Int?
        ///  Specifies the training data configuration to use when creating a domain recommender.
        public let trainingDataConfig: TrainingDataConfig?

        public init(enableMetadataWithRecommendations: Bool? = nil, itemExplorationConfig: [String: String]? = nil, minRecommendationRequestsPerSecond: Int? = nil, trainingDataConfig: TrainingDataConfig? = nil) {
            self.enableMetadataWithRecommendations = enableMetadataWithRecommendations
            self.itemExplorationConfig = itemExplorationConfig
            self.minRecommendationRequestsPerSecond = minRecommendationRequestsPerSecond
            self.trainingDataConfig = trainingDataConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name: "itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name: "itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.validate(self.itemExplorationConfig, name: "itemExplorationConfig", parent: name, max: 100)
            try self.validate(self.minRecommendationRequestsPerSecond, name: "minRecommendationRequestsPerSecond", parent: name, min: 1)
            try self.trainingDataConfig?.validate(name: "\(name).trainingDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case enableMetadataWithRecommendations = "enableMetadataWithRecommendations"
            case itemExplorationConfig = "itemExplorationConfig"
            case minRecommendationRequestsPerSecond = "minRecommendationRequestsPerSecond"
            case trainingDataConfig = "trainingDataConfig"
        }
    }

    public struct RecommenderSummary: AWSDecodableShape {
        /// The date and time (in Unix format) that the recommender was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public let datasetGroupArn: String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the recommender.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public let recipeArn: String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public let recommenderArn: String?
        /// The configuration details of the recommender.
        public let recommenderConfig: RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, recipeArn: String? = nil, recommenderArn: String? = nil, recommenderConfig: RecommenderConfig? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case recommenderArn = "recommenderArn"
            case recommenderConfig = "recommenderConfig"
            case status = "status"
        }
    }

    public struct RecommenderUpdateSummary: AWSDecodableShape {
        /// The date and time (in Unix format) that the recommender update was created.
        public let creationDateTime: Date?
        /// If a recommender update fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the recommender update was last updated.
        public let lastUpdatedDateTime: Date?
        /// The configuration details of the recommender update.
        public let recommenderConfig: RecommenderConfig?
        /// The status of the recommender update. A recommender can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, recommenderConfig: RecommenderConfig? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.recommenderConfig = recommenderConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case recommenderConfig = "recommenderConfig"
            case status = "status"
        }
    }

    public struct S3DataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key that Amazon Personalize uses to encrypt or decrypt the input and output files.
        public let kmsKeyArn: String?
        /// The file path of the Amazon S3 bucket.
        public let path: String

        public init(kmsKeyArn: String? = nil, path: String) {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws.*:kms:.*:[0-9]{12}:key/")
            try self.validate(self.path, name: "path", parent: name, max: 256)
            try self.validate(self.path, name: "path", parent: name, pattern: "^(s3|http|https)://.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case path = "path"
        }
    }

    public struct Solution: AWSDecodableShape {
        /// When performAutoML is true, specifies the best recipe found.
        public let autoMLResult: AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.  If no eventType is provided, Amazon Personalize uses all interactions for training with equal weight regardless of type.
        public let eventType: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: Date?
        /// Describes the latest version of the solution, including the status and the ARN.
        public let latestSolutionVersion: SolutionVersionSummary?
        /// The name of the solution.
        public let name: String?
        ///  We don't recommend enabling automated machine learning. Instead, match your use case to the available Amazon Personalize  recipes. For more information, see Determining your use case.   When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used to create the solution. This is required when performAutoML is false.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(autoMLResult: AutoMLResult? = nil, creationDateTime: Date? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, lastUpdatedDateTime: Date? = nil, latestSolutionVersion: SolutionVersionSummary? = nil, name: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, status: String? = nil) {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLResult = "autoMLResult"
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestSolutionVersion = "latestSolutionVersion"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case solutionConfig = "solutionConfig"
            case status = "status"
        }
    }

    public struct SolutionConfig: AWSEncodableShape & AWSDecodableShape {
        /// Lists the algorithm hyperparameters and their values.
        public let algorithmHyperParameters: [String: String]?
        /// The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
        public let autoMLConfig: AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public let eventValueThreshold: String?
        /// Lists the feature transformation parameters.
        public let featureTransformationParameters: [String: String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public let hpoConfig: HPOConfig?
        /// Describes the additional objective for the solution, such as maximizing streaming  minutes or increasing revenue. For more information see Optimizing a solution.
        public let optimizationObjective: OptimizationObjective?
        ///  Specifies the training data configuration to use when creating a custom solution version (trained model).
        public let trainingDataConfig: TrainingDataConfig?

        public init(algorithmHyperParameters: [String: String]? = nil, autoMLConfig: AutoMLConfig? = nil, eventValueThreshold: String? = nil, featureTransformationParameters: [String: String]? = nil, hpoConfig: HPOConfig? = nil, optimizationObjective: OptimizationObjective? = nil, trainingDataConfig: TrainingDataConfig? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
            self.optimizationObjective = optimizationObjective
            self.trainingDataConfig = trainingDataConfig
        }

        public func validate(name: String) throws {
            try self.algorithmHyperParameters?.forEach {
                try validate($0.key, name: "algorithmHyperParameters.key", parent: name, max: 256)
                try validate($0.value, name: "algorithmHyperParameters[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.validate(self.algorithmHyperParameters, name: "algorithmHyperParameters", parent: name, max: 100)
            try self.autoMLConfig?.validate(name: "\(name).autoMLConfig")
            try self.validate(self.eventValueThreshold, name: "eventValueThreshold", parent: name, max: 256)
            try self.featureTransformationParameters?.forEach {
                try validate($0.key, name: "featureTransformationParameters.key", parent: name, max: 256)
                try validate($0.value, name: "featureTransformationParameters[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.validate(self.featureTransformationParameters, name: "featureTransformationParameters", parent: name, max: 100)
            try self.hpoConfig?.validate(name: "\(name).hpoConfig")
            try self.optimizationObjective?.validate(name: "\(name).optimizationObjective")
            try self.trainingDataConfig?.validate(name: "\(name).trainingDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters = "algorithmHyperParameters"
            case autoMLConfig = "autoMLConfig"
            case eventValueThreshold = "eventValueThreshold"
            case featureTransformationParameters = "featureTransformationParameters"
            case hpoConfig = "hpoConfig"
            case optimizationObjective = "optimizationObjective"
            case trainingDataConfig = "trainingDataConfig"
        }
    }

    public struct SolutionSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the solution was created.
        public let creationDateTime: Date?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the solution.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe used by the solution.
        public let recipeArn: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED   DELETE PENDING > DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, recipeArn: String? = nil, solutionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case status = "status"
        }
    }

    public struct SolutionVersion: AWSDecodableShape {
        /// The date and time (in Unix time) that this version of the solution was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public let eventType: String?
        /// If training a solution version fails, the reason for the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the solution version.
        public let name: String?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used in the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The ARN of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED   CREATE STOPPING   CREATE STOPPED
        public let status: String?
        /// The time used to train the model. You are billed for the time it takes to train a model. This field is visible only after Amazon Personalize successfully trains a model.
        public let trainingHours: Double?
        /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one.  The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the  User-Personalization recipe or the  HRNN-Coldstart recipe.
        public let trainingMode: TrainingMode?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the best performing model.
        public let tunedHPOParams: TunedHPOParams?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, solutionVersionArn: String? = nil, status: String? = nil, trainingHours: Double? = nil, trainingMode: TrainingMode? = nil, tunedHPOParams: TunedHPOParams? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.tunedHPOParams = tunedHPOParams
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case solutionConfig = "solutionConfig"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
            case trainingHours = "trainingHours"
            case trainingMode = "trainingMode"
            case tunedHPOParams = "tunedHPOParams"
        }
    }

    public struct SolutionVersionSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that this version of a solution was created.
        public let creationDateTime: Date?
        /// If a solution version fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct StartRecommenderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recommender to start.
        public let recommenderArn: String

        public init(recommenderArn: String) {
            self.recommenderArn = recommenderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, max: 256)
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct StartRecommenderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the recommender you started.
        public let recommenderArn: String?

        public init(recommenderArn: String? = nil) {
            self.recommenderArn = recommenderArn
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct StopRecommenderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recommender to stop.
        public let recommenderArn: String

        public init(recommenderArn: String) {
            self.recommenderArn = recommenderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, max: 256)
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct StopRecommenderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the recommender you stopped.
        public let recommenderArn: String?

        public init(recommenderArn: String? = nil) {
            self.recommenderArn = recommenderArn
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }

    public struct StopSolutionVersionCreationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution version you want to stop creating.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        public let tagKey: String
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        public let tagValue: String

        public init(tagKey: String, tagValue: String) {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }

        public func validate(name: String) throws {
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 128)
            try self.validate(self.tagKey, name: "tagKey", parent: name, min: 1)
            try self.validate(self.tagKey, name: "tagKey", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.tagValue, name: "tagValue", parent: name, max: 256)
            try self.validate(self.tagValue, name: "tagValue", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "tagKey"
            case tagValue = "tagValue"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String
        /// Tags to apply to the resource. For more information see Tagging Amazon Personalize recources.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThemeGenerationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Fields used to generate descriptive themes for a batch inference job.
        public let fieldsForThemeGeneration: FieldsForThemeGeneration

        public init(fieldsForThemeGeneration: FieldsForThemeGeneration) {
            self.fieldsForThemeGeneration = fieldsForThemeGeneration
        }

        public func validate(name: String) throws {
            try self.fieldsForThemeGeneration.validate(name: "\(name).fieldsForThemeGeneration")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldsForThemeGeneration = "fieldsForThemeGeneration"
        }
    }

    public struct TrainingDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the columns to exclude from training. Each key is a dataset type, and each value is a list of columns. Exclude columns to control what data Amazon Personalize uses to generate recommendations.   For example, you might have a column that you want to use only to filter recommendations. You can exclude this column from training and Amazon Personalize considers it only when filtering.
        public let excludedDatasetColumns: [String: [String]]?

        public init(excludedDatasetColumns: [String: [String]]? = nil) {
            self.excludedDatasetColumns = excludedDatasetColumns
        }

        public func validate(name: String) throws {
            try self.excludedDatasetColumns?.forEach {
                try validate($0.key, name: "excludedDatasetColumns.key", parent: name, max: 256)
                try validate($0.value, name: "excludedDatasetColumns[\"\($0.key)\"]", parent: name, max: 50)
            }
            try self.validate(self.excludedDatasetColumns, name: "excludedDatasetColumns", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case excludedDatasetColumns = "excludedDatasetColumns"
        }
    }

    public struct TunedHPOParams: AWSDecodableShape {
        /// A list of the hyperparameter values of the best performing model.
        public let algorithmHyperParameters: [String: String]?

        public init(algorithmHyperParameters: [String: String]? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters = "algorithmHyperParameters"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource's Amazon Resource Name (ARN).
        public let resourceArn: String
        /// Keys to remove from the resource's tags.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCampaignRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
        public let minProvisionedTPS: Int?
        /// The ARN of a new solution version to deploy.
        public let solutionVersionArn: String?

        public init(campaignArn: String, campaignConfig: CampaignConfig? = nil, minProvisionedTPS: Int? = nil, solutionVersionArn: String? = nil) {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, max: 256)
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.campaignConfig?.validate(name: "\(name).campaignConfig")
            try self.validate(self.minProvisionedTPS, name: "minProvisionedTPS", parent: name, min: 1)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case campaignConfig = "campaignConfig"
            case minProvisionedTPS = "minProvisionedTPS"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct UpdateCampaignResponse: AWSDecodableShape {
        /// The same campaign ARN as given in the request.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct UpdateDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset that you want to update.
        public let datasetArn: String
        /// The Amazon Resource Name (ARN) of the new schema you want use.
        public let schemaArn: String

        public init(datasetArn: String, schemaArn: String) {
            self.datasetArn = datasetArn
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case schemaArn = "schemaArn"
        }
    }

    public struct UpdateDatasetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset you updated.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct UpdateMetricAttributionRequest: AWSEncodableShape {
        /// Add new metric attributes to the metric attribution.
        public let addMetrics: [MetricAttribute]?
        /// The Amazon Resource Name (ARN) for the metric attribution to update.
        public let metricAttributionArn: String?
        /// An output config for the metric attribution.
        public let metricsOutputConfig: MetricAttributionOutput?
        /// Remove metric attributes from the metric attribution.
        public let removeMetrics: [String]?

        public init(addMetrics: [MetricAttribute]? = nil, metricAttributionArn: String? = nil, metricsOutputConfig: MetricAttributionOutput? = nil, removeMetrics: [String]? = nil) {
            self.addMetrics = addMetrics
            self.metricAttributionArn = metricAttributionArn
            self.metricsOutputConfig = metricsOutputConfig
            self.removeMetrics = removeMetrics
        }

        public func validate(name: String) throws {
            try self.addMetrics?.forEach {
                try $0.validate(name: "\(name).addMetrics[]")
            }
            try self.validate(self.addMetrics, name: "addMetrics", parent: name, max: 10)
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, max: 256)
            try self.validate(self.metricAttributionArn, name: "metricAttributionArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.metricsOutputConfig?.validate(name: "\(name).metricsOutputConfig")
            try self.removeMetrics?.forEach {
                try validate($0, name: "removeMetrics[]", parent: name, max: 256)
            }
            try self.validate(self.removeMetrics, name: "removeMetrics", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case addMetrics = "addMetrics"
            case metricAttributionArn = "metricAttributionArn"
            case metricsOutputConfig = "metricsOutputConfig"
            case removeMetrics = "removeMetrics"
        }
    }

    public struct UpdateMetricAttributionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the metric attribution that you updated.
        public let metricAttributionArn: String?

        public init(metricAttributionArn: String? = nil) {
            self.metricAttributionArn = metricAttributionArn
        }

        private enum CodingKeys: String, CodingKey {
            case metricAttributionArn = "metricAttributionArn"
        }
    }

    public struct UpdateRecommenderRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recommender to modify.
        public let recommenderArn: String
        /// The configuration details of the recommender.
        public let recommenderConfig: RecommenderConfig

        public init(recommenderArn: String, recommenderConfig: RecommenderConfig) {
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, max: 256)
            try self.validate(self.recommenderArn, name: "recommenderArn", parent: name, pattern: "^arn:([a-z\\d-]+):personalize:.*:.*:.+$")
            try self.recommenderConfig.validate(name: "\(name).recommenderConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
            case recommenderConfig = "recommenderConfig"
        }
    }

    public struct UpdateRecommenderResponse: AWSDecodableShape {
        /// The same recommender Amazon Resource Name (ARN) as given in the request.
        public let recommenderArn: String?

        public init(recommenderArn: String? = nil) {
            self.recommenderArn = recommenderArn
        }

        private enum CodingKeys: String, CodingKey {
            case recommenderArn = "recommenderArn"
        }
    }
}

// MARK: - Errors

/// Error enum for Personalize
public struct PersonalizeErrorType: AWSErrorType {
    enum Code: String {
        case invalidInputException = "InvalidInputException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case tooManyTagKeysException = "TooManyTagKeysException"
        case tooManyTagsException = "TooManyTagsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Personalize
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Provide a valid value for the field or parameter.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The token is not valid.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// The limit on the number of requests per second has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified resource already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The specified resource is in use.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// Could not find the specified resource.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request contains more tag keys than can be associated with a resource (50 tag keys per resource).
    public static var tooManyTagKeysException: Self { .init(.tooManyTagKeysException) }
    /// You have exceeded the maximum number of tags you can apply to this resource.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
}

extension PersonalizeErrorType: Equatable {
    public static func == (lhs: PersonalizeErrorType, rhs: PersonalizeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PersonalizeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
