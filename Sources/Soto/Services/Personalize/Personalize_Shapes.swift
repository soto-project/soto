//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Personalize {
    // MARK: Enums

    public enum IngestionMode: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case bulk = "BULK"
        case put = "PUT"
        public var description: String { return self.rawValue }
    }

    public enum ObjectiveSensitivity: String, CustomStringConvertible, Codable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum RecipeProvider: String, CustomStringConvertible, Codable {
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum TrainingMode: String, CustomStringConvertible, Codable {
        case full = "FULL"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Algorithm: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String?
        /// The URI of the Docker container for the algorithm image.
        public let algorithmImage: AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public let creationDateTime: Date?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public let defaultHyperParameterRanges: DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public let defaultHyperParameters: [String: String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public let defaultResourceConfig: [String: String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the algorithm.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String?
        /// The training input mode.
        public let trainingInputMode: String?

        public init(algorithmArn: String? = nil, algorithmImage: AlgorithmImage? = nil, creationDateTime: Date? = nil, defaultHyperParameterRanges: DefaultHyperParameterRanges? = nil, defaultHyperParameters: [String: String]? = nil, defaultResourceConfig: [String: String]? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, roleArn: String? = nil, trainingInputMode: String? = nil) {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn
            case algorithmImage
            case creationDateTime
            case defaultHyperParameterRanges
            case defaultHyperParameters
            case defaultResourceConfig
            case lastUpdatedDateTime
            case name
            case roleArn
            case trainingInputMode
        }
    }

    public struct AlgorithmImage: AWSDecodableShape {
        /// The URI of the Docker container for the algorithm image.
        public let dockerURI: String
        /// The name of the algorithm image.
        public let name: String?

        public init(dockerURI: String, name: String? = nil) {
            self.dockerURI = dockerURI
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dockerURI
            case name
        }
    }

    public struct AutoMLConfig: AWSEncodableShape & AWSDecodableShape {
        /// The metric to optimize.
        public let metricName: String?
        /// The list of candidate recipes.
        public let recipeList: [String]?

        public init(metricName: String? = nil, recipeList: [String]? = nil) {
            self.metricName = metricName
            self.recipeList = recipeList
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
            try self.recipeList?.forEach {
                try validate($0, name: "recipeList[]", parent: name, max: 256)
                try validate($0, name: "recipeList[]", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            }
            try self.validate(self.recipeList, name: "recipeList", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName
            case recipeList
        }
    }

    public struct AutoMLResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the best recipe.
        public let bestRecipeArn: String?

        public init(bestRecipeArn: String? = nil) {
            self.bestRecipeArn = bestRecipeArn
        }

        private enum CodingKeys: String, CodingKey {
            case bestRecipeArn
        }
    }

    public struct BatchInferenceJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let batchInferenceJobArn: String?
        /// A string to string map of the configuration details of a batch inference job.
        public let batchInferenceJobConfig: BatchInferenceJobConfig?
        /// The time at which the batch inference job was created.
        public let creationDateTime: Date?
        /// If the batch inference job failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter used on the batch inference job.
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference job.
        public let jobInput: BatchInferenceJobInput?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public let jobOutput: BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The number of recommendations generated by the batch inference job. This number includes the error messages generated for failed input records.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job was created.
        public let solutionVersionArn: String?
        /// The status of the batch inference job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED
        public let status: String?

        public init(batchInferenceJobArn: String? = nil, batchInferenceJobConfig: BatchInferenceJobConfig? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, filterArn: String? = nil, jobInput: BatchInferenceJobInput? = nil, jobName: String? = nil, jobOutput: BatchInferenceJobOutput? = nil, lastUpdatedDateTime: Date? = nil, numResults: Int? = nil, roleArn: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn
            case batchInferenceJobConfig
            case creationDateTime
            case failureReason
            case filterArn
            case jobInput
            case jobName
            case jobOutput
            case lastUpdatedDateTime
            case numResults
            case roleArn
            case solutionVersionArn
            case status
        }
    }

    public struct BatchInferenceJobConfig: AWSEncodableShape & AWSDecodableShape {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. See User-Personalization.
        public let itemExplorationConfig: [String: String]?

        public init(itemExplorationConfig: [String: String]? = nil) {
            self.itemExplorationConfig = itemExplorationConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name: "itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name: "itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case itemExplorationConfig
        }
    }

    public struct BatchInferenceJobInput: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the same region as the API endpoint you are calling.
        public let s3DataSource: S3DataConfig

        public init(s3DataSource: S3DataConfig) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource
        }
    }

    public struct BatchInferenceJobOutput: AWSEncodableShape & AWSDecodableShape {
        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        public let s3DataDestination: S3DataConfig

        public init(s3DataDestination: S3DataConfig) {
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.s3DataDestination.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataDestination
        }
    }

    public struct BatchInferenceJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let batchInferenceJobArn: String?
        /// The time at which the batch inference job was created.
        public let creationDateTime: Date?
        /// If the batch inference job failed, the reason for the failure.
        public let failureReason: String?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The time at which the batch inference job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The ARN of the solution version used by the batch inference job.
        public let solutionVersionArn: String?
        /// The status of the batch inference job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED
        public let status: String?

        public init(batchInferenceJobArn: String? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn
            case creationDateTime
            case failureReason
            case jobName
            case lastUpdatedDateTime
            case solutionVersionArn
            case status
        }
    }

    public struct Campaign: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public let creationDateTime: Date?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public let lastUpdatedDateTime: Date?
        public let latestCampaignUpdate: CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second.
        public let minProvisionedTPS: Int?
        /// The name of the campaign.
        public let name: String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public let solutionVersionArn: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(campaignArn: String? = nil, campaignConfig: CampaignConfig? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, latestCampaignUpdate: CampaignUpdateSummary? = nil, minProvisionedTPS: Int? = nil, name: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
            case campaignConfig
            case creationDateTime
            case failureReason
            case lastUpdatedDateTime
            case latestCampaignUpdate
            case minProvisionedTPS
            case name
            case solutionVersionArn
            case status
        }
    }

    public struct CampaignConfig: AWSEncodableShape & AWSDecodableShape {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your solution uses the User-Personalization recipe.
        public let itemExplorationConfig: [String: String]?

        public init(itemExplorationConfig: [String: String]? = nil) {
            self.itemExplorationConfig = itemExplorationConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name: "itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name: "itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case itemExplorationConfig
        }
    }

    public struct CampaignSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?
        /// The date and time (in Unix time) that the campaign was created.
        public let creationDateTime: Date?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the campaign.
        public let name: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(campaignArn: String? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
            case creationDateTime
            case failureReason
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct CampaignUpdateSummary: AWSDecodableShape {
        public let campaignConfig: CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public let creationDateTime: Date?
        /// If a campaign update fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public let lastUpdatedDateTime: Date?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public let solutionVersionArn: String?
        /// The status of the campaign update. A campaign update can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(campaignConfig: CampaignConfig? = nil, creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, minProvisionedTPS: Int? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignConfig
            case creationDateTime
            case failureReason
            case lastUpdatedDateTime
            case minProvisionedTPS
            case solutionVersionArn
            case status
        }
    }

    public struct CategoricalHyperParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
            }
            try self.validate(self.values, name: "values", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case values
        }
    }

    public struct ContinuousHyperParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, min: -1_000_000)
            try self.validate(self.minValue, name: "minValue", parent: name, min: -1_000_000)
            try self.validate(self.name, name: "name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue
            case minValue
            case name
        }
    }

    public struct CreateBatchInferenceJobRequest: AWSEncodableShape {
        /// The configuration details of a batch inference job.
        public let batchInferenceJobConfig: BatchInferenceJobConfig?
        /// The ARN of the filter to apply to the batch inference job. For more information on using filters, see Filtering Batch Recommendations..
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input file to base your recommendations on. The input material must be in JSON format.
        public let jobInput: BatchInferenceJobInput
        /// The name of the batch inference job to create.
        public let jobName: String
        /// The path to the Amazon S3 bucket where the job's output will be stored.
        public let jobOutput: BatchInferenceJobOutput
        /// The number of recommendations to retreive.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the batch inference recommendations.
        public let solutionVersionArn: String

        public init(batchInferenceJobConfig: BatchInferenceJobConfig? = nil, filterArn: String? = nil, jobInput: BatchInferenceJobInput, jobName: String, jobOutput: BatchInferenceJobOutput, numResults: Int? = nil, roleArn: String, solutionVersionArn: String) {
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.batchInferenceJobConfig?.validate(name: "\(name).batchInferenceJobConfig")
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.jobInput.validate(name: "\(name).jobInput")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.jobOutput.validate(name: "\(name).jobOutput")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobConfig
            case filterArn
            case jobInput
            case jobName
            case jobOutput
            case numResults
            case roleArn
            case solutionVersionArn
        }
    }

    public struct CreateBatchInferenceJobResponse: AWSDecodableShape {
        /// The ARN of the batch inference job.
        public let batchInferenceJobArn: String?

        public init(batchInferenceJobArn: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn
        }
    }

    public struct CreateCampaignRequest: AWSEncodableShape {
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int
        /// A name for the new campaign. The campaign name must be unique within your account.
        public let name: String
        /// The Amazon Resource Name (ARN) of the solution version to deploy.
        public let solutionVersionArn: String

        public init(campaignConfig: CampaignConfig? = nil, minProvisionedTPS: Int, name: String, solutionVersionArn: String) {
            self.campaignConfig = campaignConfig
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.campaignConfig?.validate(name: "\(name).campaignConfig")
            try self.validate(self.minProvisionedTPS, name: "minProvisionedTPS", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignConfig
            case minProvisionedTPS
            case name
            case solutionVersionArn
        }
    }

    public struct CreateCampaignResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
        }
    }

    public struct CreateDatasetExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset that contains the data to export.
        public let datasetArn: String
        /// The data to export, based on how you imported the data. You can choose to export only BULK data that you imported using a dataset import job, only PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public let ingestionMode: IngestionMode?
        /// The name for the dataset export job.
        public let jobName: String
        /// The path to the Amazon S3 bucket where the job's output is stored.
        public let jobOutput: DatasetExportJobOutput
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management service role that has permissions to add data to your output Amazon S3 bucket.
        public let roleArn: String

        public init(datasetArn: String, ingestionMode: IngestionMode? = nil, jobName: String, jobOutput: DatasetExportJobOutput, roleArn: String) {
            self.datasetArn = datasetArn
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.jobOutput.validate(name: "\(name).jobOutput")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
            case ingestionMode
            case jobName
            case jobOutput
            case roleArn
        }
    }

    public struct CreateDatasetExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public let datasetExportJobArn: String?

        public init(datasetExportJobArn: String? = nil) {
            self.datasetExportJobArn = datasetExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJobArn
        }
    }

    public struct CreateDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of a KMS key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The name for the new dataset group.
        public let name: String
        /// The ARN of the IAM role that has permissions to access the KMS key. Supplying an IAM role is only valid when also specifying a KMS key.
        public let roleArn: String?

        public init(kmsKeyArn: String? = nil, name: String, roleArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws.*:kms:.*:[0-9]{12}:key/.*")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn
            case name
            case roleArn
        }
    }

    public struct CreateDatasetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new dataset group.
        public let datasetGroupArn: String?

        public init(datasetGroupArn: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
        }
    }

    public struct CreateDatasetImportJobRequest: AWSEncodableShape {
        /// The ARN of the dataset that receives the imported data.
        public let datasetArn: String
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource
        /// The name for the dataset import job.
        public let jobName: String
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String

        public init(datasetArn: String, dataSource: DataSource, jobName: String, roleArn: String) {
            self.datasetArn = datasetArn
            self.dataSource = dataSource
            self.jobName = jobName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
            case dataSource
            case jobName
            case roleArn
        }
    }

    public struct CreateDatasetImportJobResponse: AWSDecodableShape {
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
        public let datasetGroupArn: String
        /// The type of dataset. One of the following (case insensitive) values:   Interactions   Items   Users
        public let datasetType: String
        /// The name for the dataset.
        public let name: String
        /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
        public let schemaArn: String

        public init(datasetGroupArn: String, datasetType: String, name: String, schemaArn: String) {
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.name = name
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case datasetType
            case name
            case schemaArn
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The ARN of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
        }
    }

    public struct CreateEventTrackerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String
        /// The name for the event tracker.
        public let name: String

        public init(datasetGroupArn: String, name: String) {
            self.datasetGroupArn = datasetGroupArn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case name
        }
    }

    public struct CreateEventTrackerResponse: AWSDecodableShape {
        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(eventTrackerArn: String? = nil, trackingId: String? = nil) {
            self.eventTrackerArn = eventTrackerArn
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn
            case trackingId
        }
    }

    public struct CreateFilterRequest: AWSEncodableShape {
        /// The ARN of the dataset group that the filter will belong to.
        public let datasetGroupArn: String
        /// The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules. For information about filter expression structure and syntax, see filter-expressions.
        public let filterExpression: String
        /// The name of the filter to create.
        public let name: String

        public init(datasetGroupArn: String, filterExpression: String, name: String) {
            self.datasetGroupArn = datasetGroupArn
            self.filterExpression = filterExpression
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.filterExpression, name: "filterExpression", parent: name, max: 2500)
            try self.validate(self.filterExpression, name: "filterExpression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case filterExpression
            case name
        }
    }

    public struct CreateFilterResponse: AWSDecodableShape {
        /// The ARN of the new filter.
        public let filterArn: String?

        public init(filterArn: String? = nil) {
            self.filterArn = filterArn
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn
        }
    }

    public struct CreateSchemaRequest: AWSEncodableShape {
        /// The name for the schema.
        public let name: String
        /// A schema in Avro JSON format.
        public let schema: String

        public init(name: String, schema: String) {
            self.name = name
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.schema, name: "schema", parent: name, max: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case schema
        }
    }

    public struct CreateSchemaResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created schema.
        public let schemaArn: String?

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn
        }
    }

    public struct CreateSolutionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String
        /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model. If you do not provide an eventType, Amazon Personalize will use all interactions for training with equal weight regardless of type.
        public let eventType: String?
        /// The name for the solution.
        public let name: String
        /// Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
        public let performHPO: Bool?
        /// The ARN of the recipe to use for model training. Only specified when performAutoML is false.
        public let recipeArn: String?
        /// The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration.  Amazon Personalize doesn't support configuring the hpoObjective at this time.
        public let solutionConfig: SolutionConfig?

        public init(datasetGroupArn: String, eventType: String? = nil, name: String, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionConfig: SolutionConfig? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionConfig = solutionConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.eventType, name: "eventType", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, max: 256)
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.solutionConfig?.validate(name: "\(name).solutionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case eventType
            case name
            case performAutoML
            case performHPO
            case recipeArn
            case solutionConfig
        }
    }

    public struct CreateSolutionResponse: AWSDecodableShape {
        /// The ARN of the solution.
        public let solutionArn: String?

        public init(solutionArn: String? = nil) {
            self.solutionArn = solutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn
        }
    }

    public struct CreateSolutionVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
        public let solutionArn: String
        /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one.  The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the User-Personalization recipe or the HRNN-Coldstart recipe.
        public let trainingMode: TrainingMode?

        public init(solutionArn: String, trainingMode: TrainingMode? = nil) {
            self.solutionArn = solutionArn
            self.trainingMode = trainingMode
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn
            case trainingMode
        }
    }

    public struct CreateSolutionVersionResponse: AWSDecodableShape {
        /// The ARN of the new solution version.
        public let solutionVersionArn: String?

        public init(solutionVersionArn: String? = nil) {
            self.solutionVersionArn = solutionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For example:   s3://bucket-name/folder-name/
        public let dataLocation: String?

        public init(dataLocation: String? = nil) {
            self.dataLocation = dataLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, max: 256)
            try self.validate(self.dataLocation, name: "dataLocation", parent: name, pattern: "(s3|http|https)://.+")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLocation
        }
    }

    public struct Dataset: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public let datasetArn: String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// One of the following values:   Interactions   Items   Users
        public let datasetType: String?
        /// A time stamp that shows when the dataset was updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset.
        public let name: String?
        /// The ARN of the associated schema.
        public let schemaArn: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetGroupArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, schemaArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetArn
            case datasetGroupArn
            case datasetType
            case lastUpdatedDateTime
            case name
            case schemaArn
            case status
        }
    }

    public struct DatasetExportJob: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset export job.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset to export.
        public let datasetArn: String?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public let datasetExportJobArn: String?
        /// If a dataset export job fails, provides the reason why.
        public let failureReason: String?
        /// The data to export, based on how you imported the data. You can choose to export BULK data that you imported using a dataset import job, PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public let ingestionMode: IngestionMode?
        /// The name of the export job.
        public let jobName: String?
        /// The path to the Amazon S3 bucket where the job's output is stored. For example:  s3://bucket-name/folder-name/
        public let jobOutput: DatasetExportJobOutput?
        /// The date and time (in Unix time) the status of the dataset export job was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management service role that has permissions to add data to your output Amazon S3 bucket.
        public let roleArn: String?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetExportJobArn: String? = nil, failureReason: String? = nil, ingestionMode: IngestionMode? = nil, jobName: String? = nil, jobOutput: DatasetExportJobOutput? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetArn
            case datasetExportJobArn
            case failureReason
            case ingestionMode
            case jobName
            case jobOutput
            case lastUpdatedDateTime
            case roleArn
            case status
        }
    }

    public struct DatasetExportJobOutput: AWSEncodableShape & AWSDecodableShape {
        public let s3DataDestination: S3DataConfig

        public init(s3DataDestination: S3DataConfig) {
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.s3DataDestination.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataDestination
        }
    }

    public struct DatasetExportJobSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset export job was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public let datasetExportJobArn: String?
        /// If a dataset export job fails, the reason behind the failure.
        public let failureReason: String?
        /// The name of the dataset export job.
        public let jobName: String?
        /// The date and time (in Unix time) that the dataset export job status was last updated.
        public let lastUpdatedDateTime: Date?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetExportJobArn: String? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetExportJobArn
            case failureReason
            case jobName
            case lastUpdatedDateTime
            case status
        }
    }

    public struct DatasetGroup: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset group.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// If creating a dataset group fails, provides the reason why.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The last update date and time (in Unix time) of the dataset group.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset group.
        public let name: String?
        /// The ARN of the IAM role that has permissions to create the dataset group.
        public let roleArn: String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, kmsKeyArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetGroupArn
            case failureReason
            case kmsKeyArn
            case lastUpdatedDateTime
            case name
            case roleArn
            case status
        }
    }

    public struct DatasetGroupSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset group was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// If creating a dataset group fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset group.
        public let name: String?
        /// The status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetGroupArn
            case failureReason
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct DatasetImportJob: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the dataset import job.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource?
        /// If a dataset import job fails, provides the reason why.
        public let failureReason: String?
        /// The name of the import job.
        public let jobName: String?
        /// The date and time (in Unix time) the dataset was last updated.
        public let lastUpdatedDateTime: Date?
        /// The ARN of the AWS Identity and Access Management (IAM) role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, dataSource: DataSource? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.dataSource = dataSource
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetArn
            case datasetImportJobArn
            case dataSource
            case failureReason
            case jobName
            case lastUpdatedDateTime
            case roleArn
            case status
        }
    }

    public struct DatasetImportJobSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset import job was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// If a dataset import job fails, the reason behind the failure.
        public let failureReason: String?
        /// The name of the dataset import job.
        public let jobName: String?
        /// The date and time (in Unix time) that the dataset import job status was last updated.
        public let lastUpdatedDateTime: Date?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetImportJobArn: String? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: Date? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetImportJobArn
            case failureReason
            case jobName
            case lastUpdatedDateTime
            case status
        }
    }

    public struct DatasetSchema: AWSDecodableShape {
        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: Date?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the schema.
        public let name: String?
        /// The schema.
        public let schema: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, schema: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case lastUpdatedDateTime
            case name
            case schema
            case schemaArn
        }
    }

    public struct DatasetSchemaSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: Date?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the schema.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case lastUpdatedDateTime
            case name
            case schemaArn
        }
    }

    public struct DatasetSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the dataset was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The dataset type. One of the following values:   Interactions   Items   Users   Event-Interactions
        public let datasetType: String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the dataset.
        public let name: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetArn
            case datasetType
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct DefaultCategoricalHyperParameterRange: AWSDecodableShape {
        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(isTunable: Bool? = nil, name: String? = nil, values: [String]? = nil) {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable
            case name
            case values
        }
    }

    public struct DefaultContinuousHyperParameterRange: AWSDecodableShape {
        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable
            case maxValue
            case minValue
            case name
        }
    }

    public struct DefaultHyperParameterRanges: AWSDecodableShape {
        /// The categorical hyperparameters and their default ranges.
        public let categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public let continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public let integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges
            case continuousHyperParameterRanges
            case integerHyperParameterRanges
        }
    }

    public struct DefaultIntegerHyperParameterRange: AWSDecodableShape {
        /// Indicates whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Int? = nil, minValue: Int? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable
            case maxValue
            case minValue
            case name
        }
    }

    public struct DeleteCampaignRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the campaign to delete.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, max: 256)
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
        }
    }

    public struct DeleteDatasetGroupRequest: AWSEncodableShape {
        /// The ARN of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
        }
    }

    public struct DeleteEventTrackerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the event tracker to delete.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, max: 256)
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn
        }
    }

    public struct DeleteFilterRequest: AWSEncodableShape {
        /// The ARN of the filter to delete.
        public let filterArn: String

        public init(filterArn: String) {
            self.filterArn = filterArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn
        }
    }

    public struct DeleteSchemaRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the schema to delete.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn
        }
    }

    public struct DeleteSolutionRequest: AWSEncodableShape {
        /// The ARN of the solution to delete.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn
        }
    }

    public struct DescribeAlgorithmRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm to describe.
        public let algorithmArn: String

        public init(algorithmArn: String) {
            self.algorithmArn = algorithmArn
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, max: 256)
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn
        }
    }

    public struct DescribeAlgorithmResponse: AWSDecodableShape {
        /// A listing of the properties of the algorithm.
        public let algorithm: Algorithm?

        public init(algorithm: Algorithm? = nil) {
            self.algorithm = algorithm
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm
        }
    }

    public struct DescribeBatchInferenceJobRequest: AWSEncodableShape {
        /// The ARN of the batch inference job to describe.
        public let batchInferenceJobArn: String

        public init(batchInferenceJobArn: String) {
            self.batchInferenceJobArn = batchInferenceJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.batchInferenceJobArn, name: "batchInferenceJobArn", parent: name, max: 256)
            try self.validate(self.batchInferenceJobArn, name: "batchInferenceJobArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn
        }
    }

    public struct DescribeBatchInferenceJobResponse: AWSDecodableShape {
        /// Information on the specified batch inference job.
        public let batchInferenceJob: BatchInferenceJob?

        public init(batchInferenceJob: BatchInferenceJob? = nil) {
            self.batchInferenceJob = batchInferenceJob
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJob
        }
    }

    public struct DescribeCampaignRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, max: 256)
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
        }
    }

    public struct DescribeCampaignResponse: AWSDecodableShape {
        /// The properties of the campaign.
        public let campaign: Campaign?

        public init(campaign: Campaign? = nil) {
            self.campaign = campaign
        }

        private enum CodingKeys: String, CodingKey {
            case campaign
        }
    }

    public struct DescribeDatasetExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset export job to describe.
        public let datasetExportJobArn: String

        public init(datasetExportJobArn: String) {
            self.datasetExportJobArn = datasetExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetExportJobArn, name: "datasetExportJobArn", parent: name, max: 256)
            try self.validate(self.datasetExportJobArn, name: "datasetExportJobArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJobArn
        }
    }

    public struct DescribeDatasetExportJobResponse: AWSDecodableShape {
        /// Information about the dataset export job, including the status. The status is one of the following values:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED
        public let datasetExportJob: DatasetExportJob?

        public init(datasetExportJob: DatasetExportJob? = nil) {
            self.datasetExportJob = datasetExportJob
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJob
        }
    }

    public struct DescribeDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group to describe.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
        }
    }

    public struct DescribeDatasetGroupResponse: AWSDecodableShape {
        /// A listing of the dataset group's properties.
        public let datasetGroup: DatasetGroup?

        public init(datasetGroup: DatasetGroup? = nil) {
            self.datasetGroup = datasetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroup
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job to describe.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, max: 256)
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSDecodableShape {
        /// Information about the dataset import job, including the status. The status is one of the following values:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED
        public let datasetImportJob: DatasetImportJob?

        public init(datasetImportJob: DatasetImportJob? = nil) {
            self.datasetImportJob = datasetImportJob
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJob
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to describe.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
        }
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// A listing of the dataset's properties.
        public let dataset: Dataset?

        public init(dataset: Dataset? = nil) {
            self.dataset = dataset
        }

        private enum CodingKeys: String, CodingKey {
            case dataset
        }
    }

    public struct DescribeEventTrackerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the event tracker to describe.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, max: 256)
            try self.validate(self.eventTrackerArn, name: "eventTrackerArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn
        }
    }

    public struct DescribeEventTrackerResponse: AWSDecodableShape {
        /// An object that describes the event tracker.
        public let eventTracker: EventTracker?

        public init(eventTracker: EventTracker? = nil) {
            self.eventTracker = eventTracker
        }

        private enum CodingKeys: String, CodingKey {
            case eventTracker
        }
    }

    public struct DescribeFeatureTransformationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the feature transformation to describe.
        public let featureTransformationArn: String

        public init(featureTransformationArn: String) {
            self.featureTransformationArn = featureTransformationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.featureTransformationArn, name: "featureTransformationArn", parent: name, max: 256)
            try self.validate(self.featureTransformationArn, name: "featureTransformationArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformationArn
        }
    }

    public struct DescribeFeatureTransformationResponse: AWSDecodableShape {
        /// A listing of the FeatureTransformation properties.
        public let featureTransformation: FeatureTransformation?

        public init(featureTransformation: FeatureTransformation? = nil) {
            self.featureTransformation = featureTransformation
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformation
        }
    }

    public struct DescribeFilterRequest: AWSEncodableShape {
        /// The ARN of the filter to describe.
        public let filterArn: String

        public init(filterArn: String) {
            self.filterArn = filterArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 256)
            try self.validate(self.filterArn, name: "filterArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn
        }
    }

    public struct DescribeFilterResponse: AWSDecodableShape {
        /// The filter's details.
        public let filter: Filter?

        public init(filter: Filter? = nil) {
            self.filter = filter
        }

        private enum CodingKeys: String, CodingKey {
            case filter
        }
    }

    public struct DescribeRecipeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the recipe to describe.
        public let recipeArn: String

        public init(recipeArn: String) {
            self.recipeArn = recipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, max: 256)
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case recipeArn
        }
    }

    public struct DescribeRecipeResponse: AWSDecodableShape {
        /// An object that describes the recipe.
        public let recipe: Recipe?

        public init(recipe: Recipe? = nil) {
            self.recipe = recipe
        }

        private enum CodingKeys: String, CodingKey {
            case recipe
        }
    }

    public struct DescribeSchemaRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the schema to retrieve.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 256)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn
        }
    }

    public struct DescribeSchemaResponse: AWSDecodableShape {
        /// The requested schema.
        public let schema: DatasetSchema?

        public init(schema: DatasetSchema? = nil) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema
        }
    }

    public struct DescribeSolutionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution to describe.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn
        }
    }

    public struct DescribeSolutionResponse: AWSDecodableShape {
        /// An object that describes the solution.
        public let solution: Solution?

        public init(solution: Solution? = nil) {
            self.solution = solution
        }

        private enum CodingKeys: String, CodingKey {
            case solution
        }
    }

    public struct DescribeSolutionVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn
        }
    }

    public struct DescribeSolutionVersionResponse: AWSDecodableShape {
        /// The solution version.
        public let solutionVersion: SolutionVersion?

        public init(solutionVersion: SolutionVersion? = nil) {
            self.solutionVersion = solutionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersion
        }
    }

    public struct EventTracker: AWSDecodableShape {
        /// The Amazon AWS account that owns the event tracker.
        public let accountId: String?
        /// The date and time (in Unix format) that the event tracker was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String?
        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(accountId: String? = nil, creationDateTime: Date? = nil, datasetGroupArn: String? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil, trackingId: String? = nil) {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case creationDateTime
            case datasetGroupArn
            case eventTrackerArn
            case lastUpdatedDateTime
            case name
            case status
            case trackingId
        }
    }

    public struct EventTrackerSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the event tracker was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case eventTrackerArn
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct FeatureTransformation: AWSDecodableShape {
        /// The creation date and time (in Unix time) of the feature transformation.
        public let creationDateTime: Date?
        /// Provides the default parameters for feature transformation.
        public let defaultParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public let lastUpdatedDateTime: Date?
        /// The name of the feature transformation.
        public let name: String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, defaultParameters: [String: String]? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case defaultParameters
            case featureTransformationArn
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct Filter: AWSDecodableShape {
        /// The time at which the filter was created.
        public let creationDateTime: Date?
        /// The ARN of the dataset group to which the filter belongs.
        public let datasetGroupArn: String?
        /// If the filter failed, the reason for its failure.
        public let failureReason: String?
        /// The ARN of the filter.
        public let filterArn: String?
        /// Specifies the type of item interactions to filter out of recommendation results. The filter expression must follow specific format rules. For information about filter expression structure and syntax, see filter-expressions.
        public let filterExpression: String?
        /// The time at which the filter was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the filter.
        public let name: String?
        /// The status of the filter.
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, filterArn: String? = nil, filterExpression: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetGroupArn
            case failureReason
            case filterArn
            case filterExpression
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct FilterSummary: AWSDecodableShape {
        /// The time at which the filter was created.
        public let creationDateTime: Date?
        /// The ARN of the dataset group to which the filter belongs.
        public let datasetGroupArn: String?
        /// If the filter failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter.
        public let filterArn: String?
        /// The time at which the filter was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the filter.
        public let name: String?
        /// The status of the filter.
        public let status: String?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, filterArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetGroupArn
            case failureReason
            case filterArn
            case lastUpdatedDateTime
            case name
            case status
        }
    }

    public struct GetSolutionMetricsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn
        }
    }

    public struct GetSolutionMetricsResponse: AWSDecodableShape {
        /// The metrics for the solution version.
        public let metrics: [String: Double]?
        /// The same solution version ARN as specified in the request.
        public let solutionVersionArn: String?

        public init(metrics: [String: Double]? = nil, solutionVersionArn: String? = nil) {
            self.metrics = metrics
            self.solutionVersionArn = solutionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case metrics
            case solutionVersionArn
        }
    }

    public struct HPOConfig: AWSEncodableShape & AWSDecodableShape {
        /// The hyperparameters and their allowable ranges.
        public let algorithmHyperParameterRanges: HyperParameterRanges?
        /// The metric to optimize during HPO.  Amazon Personalize doesn't support configuring the hpoObjective at this time.
        public let hpoObjective: HPOObjective?
        /// Describes the resource configuration for HPO.
        public let hpoResourceConfig: HPOResourceConfig?

        public init(algorithmHyperParameterRanges: HyperParameterRanges? = nil, hpoObjective: HPOObjective? = nil, hpoResourceConfig: HPOResourceConfig? = nil) {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }

        public func validate(name: String) throws {
            try self.algorithmHyperParameterRanges?.validate(name: "\(name).algorithmHyperParameterRanges")
            try self.hpoObjective?.validate(name: "\(name).hpoObjective")
            try self.hpoResourceConfig?.validate(name: "\(name).hpoResourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameterRanges
            case hpoObjective
            case hpoResourceConfig
        }
    }

    public struct HPOObjective: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let metricName: String?
        /// A regular expression for finding the metric in the training job logs.
        public let metricRegex: String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public let type: String?

        public init(metricName: String? = nil, metricRegex: String? = nil, type: String? = nil) {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, max: 256)
            try self.validate(self.metricRegex, name: "metricRegex", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName
            case metricRegex
            case type
        }
    }

    public struct HPOResourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
        public let maxNumberOfTrainingJobs: String?
        /// The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
        public let maxParallelTrainingJobs: String?

        public init(maxNumberOfTrainingJobs: String? = nil, maxParallelTrainingJobs: String? = nil) {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }

        public func validate(name: String) throws {
            try self.validate(self.maxNumberOfTrainingJobs, name: "maxNumberOfTrainingJobs", parent: name, max: 256)
            try self.validate(self.maxParallelTrainingJobs, name: "maxParallelTrainingJobs", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxNumberOfTrainingJobs
            case maxParallelTrainingJobs
        }
    }

    public struct HyperParameterRanges: AWSEncodableShape & AWSDecodableShape {
        /// The categorical hyperparameters and their ranges.
        public let categoricalHyperParameterRanges: [CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public let continuousHyperParameterRanges: [ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public let integerHyperParameterRanges: [IntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [CategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [ContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [IntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalHyperParameterRanges[]")
            }
            try self.validate(self.categoricalHyperParameterRanges, name: "categoricalHyperParameterRanges", parent: name, max: 100)
            try self.continuousHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousHyperParameterRanges[]")
            }
            try self.validate(self.continuousHyperParameterRanges, name: "continuousHyperParameterRanges", parent: name, max: 100)
            try self.integerHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerHyperParameterRanges[]")
            }
            try self.validate(self.integerHyperParameterRanges, name: "integerHyperParameterRanges", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges
            case continuousHyperParameterRanges
            case integerHyperParameterRanges
        }
    }

    public struct IntegerHyperParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Int? = nil, minValue: Int? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 1_000_000)
            try self.validate(self.minValue, name: "minValue", parent: name, min: -1_000_000)
            try self.validate(self.name, name: "name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue
            case minValue
            case name
        }
    }

    public struct ListBatchInferenceJobsRequest: AWSEncodableShape {
        /// The maximum number of batch inference job results to return in each page. The default value is 100.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs were created.
        public let solutionVersionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionVersionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case solutionVersionArn
        }
    }

    public struct ListBatchInferenceJobsResponse: AWSDecodableShape {
        /// A list containing information on each job that is returned.
        public let batchInferenceJobs: [BatchInferenceJobSummary]?
        /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
        public let nextToken: String?

        public init(batchInferenceJobs: [BatchInferenceJobSummary]? = nil, nextToken: String? = nil) {
            self.batchInferenceJobs = batchInferenceJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobs
            case nextToken
        }
    }

    public struct ListCampaignsRequest: AWSEncodableShape {
        /// The maximum number of campaigns to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListCampaigns for getting the next set of campaigns (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
        public let solutionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case solutionArn
        }
    }

    public struct ListCampaignsResponse: AWSDecodableShape {
        /// A list of the campaigns.
        public let campaigns: [CampaignSummary]?
        /// A token for getting the next set of campaigns (if they exist).
        public let nextToken: String?

        public init(campaigns: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaigns = campaigns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaigns
            case nextToken
        }
    }

    public struct ListDatasetExportJobsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.
        public let datasetArn: String?
        /// The maximum number of dataset export jobs to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetExportJobs for getting the next set of dataset export jobs (if they exist).
        public let nextToken: String?

        public init(datasetArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetArn = datasetArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
            case maxResults
            case nextToken
        }
    }

    public struct ListDatasetExportJobsResponse: AWSDecodableShape {
        /// The list of dataset export jobs.
        public let datasetExportJobs: [DatasetExportJobSummary]?
        /// A token for getting the next set of dataset export jobs (if they exist).
        public let nextToken: String?

        public init(datasetExportJobs: [DatasetExportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetExportJobs = datasetExportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetExportJobs
            case nextToken
        }
    }

    public struct ListDatasetGroupsRequest: AWSEncodableShape {
        /// The maximum number of dataset groups to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListDatasetGroupsResponse: AWSDecodableShape {
        /// The list of your dataset groups.
        public let datasetGroups: [DatasetGroupSummary]?
        /// A token for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups
            case nextToken
        }
    }

    public struct ListDatasetImportJobsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
        public let datasetArn: String?
        /// The maximum number of dataset import jobs to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetArn = datasetArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn
            case maxResults
            case nextToken
        }
    }

    public struct ListDatasetImportJobsResponse: AWSDecodableShape {
        /// The list of dataset import jobs.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// A token for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs
            case nextToken
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
        public let datasetGroupArn: String?
        /// The maximum number of datasets to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case maxResults
            case nextToken
        }
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// An array of Dataset objects. Each object provides metadata information.
        public let datasets: [DatasetSummary]?
        /// A token for getting the next set of datasets (if they exist).
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets
            case nextToken
        }
    }

    public struct ListEventTrackersRequest: AWSEncodableShape {
        /// The ARN of a dataset group used to filter the response.
        public let datasetGroupArn: String?
        /// The maximum number of event trackers to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case maxResults
            case nextToken
        }
    }

    public struct ListEventTrackersResponse: AWSDecodableShape {
        /// A list of event trackers.
        public let eventTrackers: [EventTrackerSummary]?
        /// A token for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(eventTrackers: [EventTrackerSummary]? = nil, nextToken: String? = nil) {
            self.eventTrackers = eventTrackers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackers
            case nextToken
        }
    }

    public struct ListFiltersRequest: AWSEncodableShape {
        /// The ARN of the dataset group that contains the filters.
        public let datasetGroupArn: String?
        /// The maximum number of filters to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListFilters for getting the next set of filters (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case maxResults
            case nextToken
        }
    }

    public struct ListFiltersResponse: AWSDecodableShape {
        /// A list of returned filters.
        public let filters: [FilterSummary]?
        /// A token for getting the next set of filters (if they exist).
        public let nextToken: String?

        public init(filters: [FilterSummary]? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case nextToken
        }
    }

    public struct ListRecipesRequest: AWSEncodableShape {
        /// The maximum number of recipes to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
        public let nextToken: String?
        /// The default is SERVICE.
        public let recipeProvider: RecipeProvider?

        public init(maxResults: Int? = nil, nextToken: String? = nil, recipeProvider: RecipeProvider? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recipeProvider = recipeProvider
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case recipeProvider
        }
    }

    public struct ListRecipesResponse: AWSDecodableShape {
        /// A token for getting the next set of recipes.
        public let nextToken: String?
        /// The list of available recipes.
        public let recipes: [RecipeSummary]?

        public init(nextToken: String? = nil, recipes: [RecipeSummary]? = nil) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case recipes
        }
    }

    public struct ListSchemasRequest: AWSEncodableShape {
        /// The maximum number of schemas to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListSchemasResponse: AWSDecodableShape {
        /// A token used to get the next set of schemas (if they exist).
        public let nextToken: String?
        /// A list of schemas.
        public let schemas: [DatasetSchemaSummary]?

        public init(nextToken: String? = nil, schemas: [DatasetSchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case schemas
        }
    }

    public struct ListSolutionVersionsRequest: AWSEncodableShape {
        /// The maximum number of solution versions to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, max: 256)
            try self.validate(self.solutionArn, name: "solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case solutionArn
        }
    }

    public struct ListSolutionVersionsResponse: AWSDecodableShape {
        /// A token for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// A list of solution versions describing the version properties.
        public let solutionVersions: [SolutionVersionSummary]?

        public init(nextToken: String? = nil, solutionVersions: [SolutionVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutionVersions = solutionVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case solutionVersions
        }
    }

    public struct ListSolutionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The maximum number of solutions to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn
            case maxResults
            case nextToken
        }
    }

    public struct ListSolutionsResponse: AWSDecodableShape {
        /// A token for getting the next set of solutions (if they exist).
        public let nextToken: String?
        /// A list of the current solutions.
        public let solutions: [SolutionSummary]?

        public init(nextToken: String? = nil, solutions: [SolutionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutions = solutions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case solutions
        }
    }

    public struct OptimizationObjective: AWSEncodableShape & AWSDecodableShape {
        /// The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).
        public let itemAttribute: String?
        /// Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.
        public let objectiveSensitivity: ObjectiveSensitivity?

        public init(itemAttribute: String? = nil, objectiveSensitivity: ObjectiveSensitivity? = nil) {
            self.itemAttribute = itemAttribute
            self.objectiveSensitivity = objectiveSensitivity
        }

        public func validate(name: String) throws {
            try self.validate(self.itemAttribute, name: "itemAttribute", parent: name, max: 150)
            try self.validate(self.itemAttribute, name: "itemAttribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case itemAttribute
            case objectiveSensitivity
        }
    }

    public struct Recipe: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public let algorithmArn: String?
        /// The date and time (in Unix format) that the recipe was created.
        public let creationDateTime: Date?
        /// The description of the recipe.
        public let description: String?
        /// The ARN of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// One of the following values:   PERSONALIZED_RANKING   RELATED_ITEMS   USER_PERSONALIZATION
        public let recipeType: String?
        /// The status of the recipe.
        public let status: String?

        public init(algorithmArn: String? = nil, creationDateTime: Date? = nil, description: String? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, recipeArn: String? = nil, recipeType: String? = nil, status: String? = nil) {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn
            case creationDateTime
            case description
            case featureTransformationArn
            case lastUpdatedDateTime
            case name
            case recipeArn
            case recipeType
            case status
        }
    }

    public struct RecipeSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the recipe was created.
        public let creationDateTime: Date?
        /// The date and time (in Unix time) that the recipe was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// The status of the recipe.
        public let status: String?

        public init(creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, recipeArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case lastUpdatedDateTime
            case name
            case recipeArn
            case status
        }
    }

    public struct S3DataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Key Management Service (KMS) key that Amazon Personalize uses to encrypt or decrypt the input and output files of a batch inference job.
        public let kmsKeyArn: String?
        /// The file path of the Amazon S3 bucket.
        public let path: String

        public init(kmsKeyArn: String? = nil, path: String) {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws.*:kms:.*:[0-9]{12}:key/.*")
            try self.validate(self.path, name: "path", parent: name, max: 256)
            try self.validate(self.path, name: "path", parent: name, pattern: "(s3|http|https)://.+")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn
            case path
        }
    }

    public struct Solution: AWSDecodableShape {
        /// When performAutoML is true, specifies the best recipe found.
        public let autoMLResult: AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model. If no eventType is provided, Amazon Personalize uses all interactions for training with equal weight regardless of type.
        public let eventType: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: Date?
        /// Describes the latest version of the solution, including the status and the ARN.
        public let latestSolutionVersion: SolutionVersionSummary?
        /// The name of the solution.
        public let name: String?
        /// When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used to create the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(autoMLResult: AutoMLResult? = nil, creationDateTime: Date? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, lastUpdatedDateTime: Date? = nil, latestSolutionVersion: SolutionVersionSummary? = nil, name: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, status: String? = nil) {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLResult
            case creationDateTime
            case datasetGroupArn
            case eventType
            case lastUpdatedDateTime
            case latestSolutionVersion
            case name
            case performAutoML
            case performHPO
            case recipeArn
            case solutionArn
            case solutionConfig
            case status
        }
    }

    public struct SolutionConfig: AWSEncodableShape & AWSDecodableShape {
        /// Lists the hyperparameter names and ranges.
        public let algorithmHyperParameters: [String: String]?
        /// The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
        public let autoMLConfig: AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public let eventValueThreshold: String?
        /// Lists the feature transformation parameters.
        public let featureTransformationParameters: [String: String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public let hpoConfig: HPOConfig?
        /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see Optimizing a solution.
        public let optimizationObjective: OptimizationObjective?

        public init(algorithmHyperParameters: [String: String]? = nil, autoMLConfig: AutoMLConfig? = nil, eventValueThreshold: String? = nil, featureTransformationParameters: [String: String]? = nil, hpoConfig: HPOConfig? = nil, optimizationObjective: OptimizationObjective? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
            self.optimizationObjective = optimizationObjective
        }

        public func validate(name: String) throws {
            try self.algorithmHyperParameters?.forEach {
                try validate($0.key, name: "algorithmHyperParameters.key", parent: name, max: 256)
                try validate($0.value, name: "algorithmHyperParameters[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.autoMLConfig?.validate(name: "\(name).autoMLConfig")
            try self.validate(self.eventValueThreshold, name: "eventValueThreshold", parent: name, max: 256)
            try self.featureTransformationParameters?.forEach {
                try validate($0.key, name: "featureTransformationParameters.key", parent: name, max: 256)
                try validate($0.value, name: "featureTransformationParameters[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.hpoConfig?.validate(name: "\(name).hpoConfig")
            try self.optimizationObjective?.validate(name: "\(name).optimizationObjective")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters
            case autoMLConfig
            case eventValueThreshold
            case featureTransformationParameters
            case hpoConfig
            case optimizationObjective
        }
    }

    public struct SolutionSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that the solution was created.
        public let creationDateTime: Date?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: Date?
        /// The name of the solution.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS
        public let status: String?

        public init(creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, name: String? = nil, solutionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.solutionArn = solutionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case lastUpdatedDateTime
            case name
            case solutionArn
            case status
        }
    }

    public struct SolutionVersion: AWSDecodableShape {
        /// The date and time (in Unix time) that this version of the solution was created.
        public let creationDateTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public let eventType: String?
        /// If training a solution version fails, the reason for the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: Date?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used in the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The ARN of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED   CREATE STOPPING   CREATE STOPPED
        public let status: String?
        /// The time used to train the model. You are billed for the time it takes to train a model. This field is visible only after Amazon Personalize successfully trains a model.
        public let trainingHours: Double?
        /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one.  The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the User-Personalization recipe or the HRNN-Coldstart recipe.
        public let trainingMode: TrainingMode?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the best performing model.
        public let tunedHPOParams: TunedHPOParams?

        public init(creationDateTime: Date? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, solutionVersionArn: String? = nil, status: String? = nil, trainingHours: Double? = nil, trainingMode: TrainingMode? = nil, tunedHPOParams: TunedHPOParams? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.tunedHPOParams = tunedHPOParams
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case datasetGroupArn
            case eventType
            case failureReason
            case lastUpdatedDateTime
            case performAutoML
            case performHPO
            case recipeArn
            case solutionArn
            case solutionConfig
            case solutionVersionArn
            case status
            case trainingHours
            case trainingMode
            case tunedHPOParams
        }
    }

    public struct SolutionVersionSummary: AWSDecodableShape {
        /// The date and time (in Unix time) that this version of a solution was created.
        public let creationDateTime: Date?
        /// If a solution version fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED
        public let status: String?

        public init(creationDateTime: Date? = nil, failureReason: String? = nil, lastUpdatedDateTime: Date? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime
            case failureReason
            case lastUpdatedDateTime
            case solutionVersionArn
            case status
        }
    }

    public struct StopSolutionVersionCreationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the solution version you want to stop creating.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn
        }
    }

    public struct TunedHPOParams: AWSDecodableShape {
        /// A list of the hyperparameter values of the best performing model.
        public let algorithmHyperParameters: [String: String]?

        public init(algorithmHyperParameters: [String: String]? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters
        }
    }

    public struct UpdateCampaignRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int?
        /// The ARN of a new solution version to deploy.
        public let solutionVersionArn: String?

        public init(campaignArn: String, campaignConfig: CampaignConfig? = nil, minProvisionedTPS: Int? = nil, solutionVersionArn: String? = nil) {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, max: 256)
            try self.validate(self.campaignArn, name: "campaignArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.campaignConfig?.validate(name: "\(name).campaignConfig")
            try self.validate(self.minProvisionedTPS, name: "minProvisionedTPS", parent: name, min: 1)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, max: 256)
            try self.validate(self.solutionVersionArn, name: "solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
            case campaignConfig
            case minProvisionedTPS
            case solutionVersionArn
        }
    }

    public struct UpdateCampaignResponse: AWSDecodableShape {
        /// The same campaign ARN as given in the request.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn
        }
    }
}
