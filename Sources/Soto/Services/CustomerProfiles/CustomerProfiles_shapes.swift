//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CustomerProfiles {
    // MARK: Enums

    public enum AttributeDimensionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after = "AFTER"
        case before = "BEFORE"
        case beginsWith = "BEGINS_WITH"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equal = "EQUAL"
        case exclusive = "EXCLUSIVE"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case inclusive = "INCLUSIVE"
        case lessThan = "LESS_THAN"
        case lessThanOrEqual = "LESS_THAN_OR_EQUAL"
        case notBetween = "NOT_BETWEEN"
        case on = "ON"
        public var description: String { return self.rawValue }
    }

    public enum AttributeMatchingModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case manyToMany = "MANY_TO_MANY"
        case oneToOne = "ONE_TO_ONE"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after = "AFTER"
        case before = "BEFORE"
        case beginsWith = "BEGINS_WITH"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equal = "EQUAL"
        case exclusive = "EXCLUSIVE"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case inclusive = "INCLUSIVE"
        case lessThan = "LESS_THAN"
        case lessThanOrEqual = "LESS_THAN_OR_EQUAL"
        case notBetween = "NOT_BETWEEN"
        case on = "ON"
        public var description: String { return self.rawValue }
    }

    public enum ConflictResolvingModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case recency = "RECENCY"
        case source = "SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum DataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case jsonl = "JSONL"
        case orc = "ORC"
        public var description: String { return self.rawValue }
    }

    public enum DataPullMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "Complete"
        case incremental = "Incremental"
        public var description: String { return self.rawValue }
    }

    public enum DateDimensionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after = "AFTER"
        case before = "BEFORE"
        case between = "BETWEEN"
        case notBetween = "NOT_BETWEEN"
        case on = "ON"
        public var description: String { return self.rawValue }
    }

    public enum EstimateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum EventStreamDestinationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum EventStreamState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case running = "RUNNING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum EventTriggerLogicalOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum FieldContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case emailAddress = "EMAIL_ADDRESS"
        case name = "NAME"
        case number = "NUMBER"
        case phoneNumber = "PHONE_NUMBER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum FilterDimensionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case after = "AFTER"
        case before = "BEFORE"
        case beginsWith = "BEGINS_WITH"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case equal = "EQUAL"
        case exclusive = "EXCLUSIVE"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqual = "GREATER_THAN_OR_EQUAL"
        case inclusive = "INCLUSIVE"
        case lessThan = "LESS_THAN"
        case lessThanOrEqual = "LESS_THAN_OR_EQUAL"
        case notBetween = "NOT_BETWEEN"
        case on = "ON"
        public var description: String { return self.rawValue }
    }

    public enum Gender: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case female = "FEMALE"
        case male = "MALE"
        case unspecified = "UNSPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum IdentityResolutionJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case findMatching = "FIND_MATCHING"
        case merging = "MERGING"
        case partialSuccess = "PARTIAL_SUCCESS"
        case pending = "PENDING"
        case preprocessing = "PREPROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum Include: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum IncludeOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum JobScheduleDayOfTheWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum MarketoConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum MatchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mlBasedMatching = "ML_BASED_MATCHING"
        case ruleBasedMatching = "RULE_BASED_MATCHING"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
        case notEqualTo = "NOT_EQUAL_TO"
        public var description: String { return self.rawValue }
    }

    public enum OperatorPropertiesKeys: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concatFormat = "CONCAT_FORMAT"
        case dataType = "DATA_TYPE"
        case destinationDataType = "DESTINATION_DATA_TYPE"
        case lowerBound = "LOWER_BOUND"
        case maskLength = "MASK_LENGTH"
        case maskValue = "MASK_VALUE"
        case mathOperationFieldsOrder = "MATH_OPERATION_FIELDS_ORDER"
        case sourceDataType = "SOURCE_DATA_TYPE"
        case subfieldCategoryMap = "SUBFIELD_CATEGORY_MAP"
        case truncateLength = "TRUNCATE_LENGTH"
        case upperBound = "UPPER_BOUND"
        case validationAction = "VALIDATION_ACTION"
        case value = "VALUE"
        case values = "VALUES"
        public var description: String { return self.rawValue }
    }

    public enum PartyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case business = "BUSINESS"
        case individual = "INDIVIDUAL"
        case other = "OTHER"
        public var description: String { return self.rawValue }
    }

    public enum PeriodUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        case hours = "HOURS"
        case months = "MONTHS"
        case weeks = "WEEKS"
        public var description: String { return self.rawValue }
    }

    public enum QueryResult: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case absent = "ABSENT"
        case present = "PRESENT"
        public var description: String { return self.rawValue }
    }

    public enum RangeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        public var description: String { return self.rawValue }
    }

    public enum RuleBasedMatchingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum S3ConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SegmentSnapshotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNowConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SourceConnectorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case servicenow = "Servicenow"
        case zendesk = "Zendesk"
        public var description: String { return self.rawValue }
    }

    public enum StandardIdentifier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `case` = "CASE"
        case asset = "ASSET"
        case communicationRecord = "COMMUNICATION_RECORD"
        case lookupOnly = "LOOKUP_ONLY"
        case newOnly = "NEW_ONLY"
        case order = "ORDER"
        case profile = "PROFILE"
        case secondary = "SECONDARY"
        case unique = "UNIQUE"
        public var description: String { return self.rawValue }
    }

    public enum Statistic: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case average = "AVERAGE"
        case count = "COUNT"
        case firstOccurrence = "FIRST_OCCURRENCE"
        case lastOccurrence = "LAST_OCCURRENCE"
        case maxOccurrence = "MAX_OCCURRENCE"
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        case retry = "RETRY"
        case split = "SPLIT"
        public var description: String { return self.rawValue }
    }

    public enum StringDimensionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beginsWith = "BEGINS_WITH"
        case contains = "CONTAINS"
        case endsWith = "ENDS_WITH"
        case exclusive = "EXCLUSIVE"
        case inclusive = "INCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arithmetic = "Arithmetic"
        case filter = "Filter"
        case map = "Map"
        case mask = "Mask"
        case merge = "Merge"
        case truncate = "Truncate"
        case validate = "Validate"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "Event"
        case ondemand = "OnDemand"
        case scheduled = "Scheduled"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appflowIntegration = "APPFLOW_INTEGRATION"
        public var description: String { return self.rawValue }
    }

    public enum ZendeskConnectorOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Dimension: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Object that holds the calculated attributes to segment on.
        case calculatedAttributes([String: CalculatedAttributeDimension])
        /// Object that holds the profile attributes to segment on.
        case profileAttributes(ProfileAttributes)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .calculatedAttributes:
                let value = try container.decode([String: CalculatedAttributeDimension].self, forKey: .calculatedAttributes)
                self = .calculatedAttributes(value)
            case .profileAttributes:
                let value = try container.decode(ProfileAttributes.self, forKey: .profileAttributes)
                self = .profileAttributes(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .calculatedAttributes(let value):
                try container.encode(value, forKey: .calculatedAttributes)
            case .profileAttributes(let value):
                try container.encode(value, forKey: .profileAttributes)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .calculatedAttributes(let value):
                try value.forEach {
                    try validate($0.key, name: "calculatedAttributes.key", parent: name, max: 255)
                    try validate($0.key, name: "calculatedAttributes.key", parent: name, min: 1)
                    try validate($0.key, name: "calculatedAttributes.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
                    try $0.value.validate(name: "\(name).calculatedAttributes[\"\($0.key)\"]")
                }
            case .profileAttributes(let value):
                try value.validate(name: "\(name).profileAttributes")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedAttributes = "CalculatedAttributes"
            case profileAttributes = "ProfileAttributes"
        }
    }

    // MARK: Shapes

    public struct AddProfileKeyRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// A searchable identifier of a customer profile. The predefined keys you can use include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
        public let keyName: String
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// A list of key values.
        public let values: [String]

        @inlinable
        public init(domainName: String, keyName: String, profileId: String, values: [String]) {
            self.domainName = domainName
            self.keyName = keyName
            self.profileId = profileId
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.keyName, forKey: .keyName)
            try container.encode(self.profileId, forKey: .profileId)
            try container.encode(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case profileId = "ProfileId"
            case values = "Values"
        }
    }

    public struct AddProfileKeyResponse: AWSDecodableShape {
        /// A searchable identifier of a customer profile.
        public let keyName: String?
        /// A list of key values.
        public let values: [String]?

        @inlinable
        public init(keyName: String? = nil, values: [String]? = nil) {
            self.keyName = keyName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case values = "Values"
        }
    }

    public struct AdditionalSearchKey: AWSEncodableShape {
        /// A searchable identifier of a customer profile.
        public let keyName: String
        /// A list of key values.
        public let values: [String]

        @inlinable
        public init(keyName: String, values: [String]) {
            self.keyName = keyName
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case values = "Values"
        }
    }

    public struct Address: AWSEncodableShape & AWSDecodableShape {
        /// The first line of a customer address.
        public let address1: String?
        /// The second line of a customer address.
        public let address2: String?
        /// The third line of a customer address.
        public let address3: String?
        /// The fourth line of a customer address.
        public let address4: String?
        /// The city in which a customer lives.
        public let city: String?
        /// The country in which a customer lives.
        public let country: String?
        /// The county in which a customer lives.
        public let county: String?
        /// The postal code of a customer address.
        public let postalCode: String?
        /// The province in which a customer lives.
        public let province: String?
        /// The state in which a customer lives.
        public let state: String?

        @inlinable
        public init(address1: String? = nil, address2: String? = nil, address3: String? = nil, address4: String? = nil, city: String? = nil, country: String? = nil, county: String? = nil, postalCode: String? = nil, province: String? = nil, state: String? = nil) {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.address1, name: "address1", parent: name, max: 255)
            try self.validate(self.address1, name: "address1", parent: name, min: 1)
            try self.validate(self.address2, name: "address2", parent: name, max: 255)
            try self.validate(self.address2, name: "address2", parent: name, min: 1)
            try self.validate(self.address3, name: "address3", parent: name, max: 255)
            try self.validate(self.address3, name: "address3", parent: name, min: 1)
            try self.validate(self.address4, name: "address4", parent: name, max: 255)
            try self.validate(self.address4, name: "address4", parent: name, min: 1)
            try self.validate(self.city, name: "city", parent: name, max: 255)
            try self.validate(self.city, name: "city", parent: name, min: 1)
            try self.validate(self.country, name: "country", parent: name, max: 255)
            try self.validate(self.country, name: "country", parent: name, min: 1)
            try self.validate(self.county, name: "county", parent: name, max: 255)
            try self.validate(self.county, name: "county", parent: name, min: 1)
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 255)
            try self.validate(self.postalCode, name: "postalCode", parent: name, min: 1)
            try self.validate(self.province, name: "province", parent: name, max: 255)
            try self.validate(self.province, name: "province", parent: name, min: 1)
            try self.validate(self.state, name: "state", parent: name, max: 255)
            try self.validate(self.state, name: "state", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case address1 = "Address1"
            case address2 = "Address2"
            case address3 = "Address3"
            case address4 = "Address4"
            case city = "City"
            case country = "Country"
            case county = "County"
            case postalCode = "PostalCode"
            case province = "Province"
            case state = "State"
        }
    }

    public struct AddressDimension: AWSEncodableShape & AWSDecodableShape {
        /// The city belonging to the address.
        public let city: ProfileDimension?
        /// The country belonging to the address.
        public let country: ProfileDimension?
        /// The county belonging to the address.
        public let county: ProfileDimension?
        /// The postal code belonging to the address.
        public let postalCode: ProfileDimension?
        /// The province belonging to the address.
        public let province: ProfileDimension?
        /// The state belonging to the address.
        public let state: ProfileDimension?

        @inlinable
        public init(city: ProfileDimension? = nil, country: ProfileDimension? = nil, county: ProfileDimension? = nil, postalCode: ProfileDimension? = nil, province: ProfileDimension? = nil, state: ProfileDimension? = nil) {
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }

        public func validate(name: String) throws {
            try self.city?.validate(name: "\(name).city")
            try self.country?.validate(name: "\(name).country")
            try self.county?.validate(name: "\(name).county")
            try self.postalCode?.validate(name: "\(name).postalCode")
            try self.province?.validate(name: "\(name).province")
            try self.state?.validate(name: "\(name).state")
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case country = "Country"
            case county = "County"
            case postalCode = "PostalCode"
            case province = "Province"
            case state = "State"
        }
    }

    public struct AppflowIntegration: AWSEncodableShape {
        /// Batches in workflow of type APPFLOW_INTEGRATION.
        public let batches: [Batch]?
        public let flowDefinition: FlowDefinition

        @inlinable
        public init(batches: [Batch]? = nil, flowDefinition: FlowDefinition) {
            self.batches = batches
            self.flowDefinition = flowDefinition
        }

        public func validate(name: String) throws {
            try self.flowDefinition.validate(name: "\(name).flowDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case batches = "Batches"
            case flowDefinition = "FlowDefinition"
        }
    }

    public struct AppflowIntegrationWorkflowAttributes: AWSDecodableShape {
        /// The name of the AppFlow connector profile used for ingestion.
        public let connectorProfileName: String
        /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String?
        /// Specifies the source connector type, such as Salesforce, ServiceNow, and Marketo. Indicates source of ingestion.
        public let sourceConnectorType: SourceConnectorType

        @inlinable
        public init(connectorProfileName: String, roleArn: String? = nil, sourceConnectorType: SourceConnectorType) {
            self.connectorProfileName = connectorProfileName
            self.roleArn = roleArn
            self.sourceConnectorType = sourceConnectorType
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "ConnectorProfileName"
            case roleArn = "RoleArn"
            case sourceConnectorType = "SourceConnectorType"
        }
    }

    public struct AppflowIntegrationWorkflowMetrics: AWSDecodableShape {
        /// Number of records processed in APPFLOW_INTEGRATION workflow.
        public let recordsProcessed: Int64
        /// Total steps completed in APPFLOW_INTEGRATION workflow.
        public let stepsCompleted: Int64
        /// Total steps in APPFLOW_INTEGRATION workflow.
        public let totalSteps: Int64

        @inlinable
        public init(recordsProcessed: Int64, stepsCompleted: Int64, totalSteps: Int64) {
            self.recordsProcessed = recordsProcessed
            self.stepsCompleted = stepsCompleted
            self.totalSteps = totalSteps
        }

        private enum CodingKeys: String, CodingKey {
            case recordsProcessed = "RecordsProcessed"
            case stepsCompleted = "StepsCompleted"
            case totalSteps = "TotalSteps"
        }
    }

    public struct AppflowIntegrationWorkflowStep: AWSDecodableShape {
        /// End datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        public let batchRecordsEndTime: String
        /// Start datetime of records pulled in batch during execution of workflow step for APPFLOW_INTEGRATION workflow.
        public let batchRecordsStartTime: String
        /// Creation timestamp of workflow step for APPFLOW_INTEGRATION workflow.
        public let createdAt: Date
        /// Message indicating execution of workflow step for APPFLOW_INTEGRATION workflow.
        public let executionMessage: String
        /// Name of the flow created during execution of workflow step. APPFLOW_INTEGRATION workflow type creates an appflow flow during workflow step execution on the customers behalf.
        public let flowName: String
        /// Last updated timestamp for workflow step for APPFLOW_INTEGRATION workflow.
        public let lastUpdatedAt: Date
        /// Total number of records processed during execution of workflow step for APPFLOW_INTEGRATION workflow.
        public let recordsProcessed: Int64
        /// Workflow step status for APPFLOW_INTEGRATION workflow.
        public let status: Status

        @inlinable
        public init(batchRecordsEndTime: String, batchRecordsStartTime: String, createdAt: Date, executionMessage: String, flowName: String, lastUpdatedAt: Date, recordsProcessed: Int64, status: Status) {
            self.batchRecordsEndTime = batchRecordsEndTime
            self.batchRecordsStartTime = batchRecordsStartTime
            self.createdAt = createdAt
            self.executionMessage = executionMessage
            self.flowName = flowName
            self.lastUpdatedAt = lastUpdatedAt
            self.recordsProcessed = recordsProcessed
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchRecordsEndTime = "BatchRecordsEndTime"
            case batchRecordsStartTime = "BatchRecordsStartTime"
            case createdAt = "CreatedAt"
            case executionMessage = "ExecutionMessage"
            case flowName = "FlowName"
            case lastUpdatedAt = "LastUpdatedAt"
            case recordsProcessed = "RecordsProcessed"
            case status = "Status"
        }
    }

    public struct AttributeDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of attribute items specified in the mathematical expression.
        public let attributes: [AttributeItem]
        /// Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \"{ObjectTypeName.AttributeName}\".
        public let expression: String

        @inlinable
        public init(attributes: [AttributeItem], expression: String) {
            self.attributes = attributes
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 2)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 255)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case expression = "Expression"
        }
    }

    public struct AttributeDimension: AWSEncodableShape & AWSDecodableShape {
        /// The action to segment with.
        public let dimensionType: AttributeDimensionType
        /// The values to apply the DimensionType on.
        public let values: [String]

        @inlinable
        public init(dimensionType: AttributeDimensionType, values: [String]) {
            self.dimensionType = dimensionType
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 50)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct AttributeItem: AWSEncodableShape & AWSDecodableShape {
        /// The name of an attribute defined in a profile object type.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AttributeTypesSelector: AWSEncodableShape & AWSDecodableShape {
        /// The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        public let address: [String]?
        /// Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        public let attributeMatchingModel: AttributeMatchingModel
        /// The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        public let emailAddress: [String]?
        /// The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        public let phoneNumber: [String]?

        @inlinable
        public init(address: [String]? = nil, attributeMatchingModel: AttributeMatchingModel, emailAddress: [String]? = nil, phoneNumber: [String]? = nil) {
            self.address = address
            self.attributeMatchingModel = attributeMatchingModel
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }

        public func validate(name: String) throws {
            try self.address?.forEach {
                try validate($0, name: "address[]", parent: name, max: 255)
                try validate($0, name: "address[]", parent: name, min: 1)
            }
            try self.validate(self.address, name: "address", parent: name, max: 4)
            try self.validate(self.address, name: "address", parent: name, min: 1)
            try self.emailAddress?.forEach {
                try validate($0, name: "emailAddress[]", parent: name, max: 255)
                try validate($0, name: "emailAddress[]", parent: name, min: 1)
            }
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 3)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.phoneNumber?.forEach {
                try validate($0, name: "phoneNumber[]", parent: name, max: 255)
                try validate($0, name: "phoneNumber[]", parent: name, min: 1)
            }
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 4)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case attributeMatchingModel = "AttributeMatchingModel"
            case emailAddress = "EmailAddress"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct AttributeValueItem: AWSDecodableShape {
        /// An individual value belonging to the given attribute.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct AutoMerging: AWSEncodableShape & AWSDecodableShape {
        /// How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used?
        public let conflictResolution: ConflictResolution?
        /// A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        public let consolidation: Consolidation?
        /// The flag that enables the auto-merging of duplicate profiles.
        public let enabled: Bool
        /// A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        public let minAllowedConfidenceScoreForMerging: Double?

        @inlinable
        public init(conflictResolution: ConflictResolution? = nil, consolidation: Consolidation? = nil, enabled: Bool, minAllowedConfidenceScoreForMerging: Double? = nil) {
            self.conflictResolution = conflictResolution
            self.consolidation = consolidation
            self.enabled = enabled
            self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
        }

        public func validate(name: String) throws {
            try self.conflictResolution?.validate(name: "\(name).conflictResolution")
            try self.consolidation?.validate(name: "\(name).consolidation")
            try self.validate(self.minAllowedConfidenceScoreForMerging, name: "minAllowedConfidenceScoreForMerging", parent: name, max: 1.0)
            try self.validate(self.minAllowedConfidenceScoreForMerging, name: "minAllowedConfidenceScoreForMerging", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case conflictResolution = "ConflictResolution"
            case consolidation = "Consolidation"
            case enabled = "Enabled"
            case minAllowedConfidenceScoreForMerging = "MinAllowedConfidenceScoreForMerging"
        }
    }

    public struct Batch: AWSEncodableShape {
        /// End time of batch to split ingestion.
        public let endTime: Date
        /// Start time of batch to split ingestion.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct BatchGetCalculatedAttributeForProfileError: AWSDecodableShape {
        /// Status code for why a specific profile and calculated attribute failed.
        public let code: String
        /// Message describing why a specific profile and calculated attribute failed.
        public let message: String
        /// The profile id that failed.
        public let profileId: String

        @inlinable
        public init(code: String, message: String, profileId: String) {
            self.code = code
            self.message = message
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case profileId = "ProfileId"
        }
    }

    public struct BatchGetCalculatedAttributeForProfileRequest: AWSEncodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String
        /// Overrides the condition block within the original calculated attribute definition.
        public let conditionOverrides: ConditionOverrides?
        /// The unique name of the domain.
        public let domainName: String
        /// List of unique identifiers for customer profiles to retrieve.
        public let profileIds: [String]

        @inlinable
        public init(calculatedAttributeName: String, conditionOverrides: ConditionOverrides? = nil, domainName: String, profileIds: [String]) {
            self.calculatedAttributeName = calculatedAttributeName
            self.conditionOverrides = conditionOverrides
            self.domainName = domainName
            self.profileIds = profileIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatedAttributeName, key: "CalculatedAttributeName")
            try container.encodeIfPresent(self.conditionOverrides, forKey: .conditionOverrides)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.profileIds, forKey: .profileIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, max: 255)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, min: 1)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.conditionOverrides?.validate(name: "\(name).conditionOverrides")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.profileIds.forEach {
                try validate($0, name: "profileIds[]", parent: name, pattern: "^[a-f0-9]{32}$")
            }
            try self.validate(self.profileIds, name: "profileIds", parent: name, max: 100)
            try self.validate(self.profileIds, name: "profileIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionOverrides = "ConditionOverrides"
            case profileIds = "ProfileIds"
        }
    }

    public struct BatchGetCalculatedAttributeForProfileResponse: AWSDecodableShape {
        /// List of calculated attribute values retrieved.
        public let calculatedAttributeValues: [CalculatedAttributeValue]?
        /// Overrides the condition block within the original calculated attribute definition.
        public let conditionOverrides: ConditionOverrides?
        /// List of errors for calculated attribute values that could not be retrieved.
        public let errors: [BatchGetCalculatedAttributeForProfileError]?

        @inlinable
        public init(calculatedAttributeValues: [CalculatedAttributeValue]? = nil, conditionOverrides: ConditionOverrides? = nil, errors: [BatchGetCalculatedAttributeForProfileError]? = nil) {
            self.calculatedAttributeValues = calculatedAttributeValues
            self.conditionOverrides = conditionOverrides
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedAttributeValues = "CalculatedAttributeValues"
            case conditionOverrides = "ConditionOverrides"
            case errors = "Errors"
        }
    }

    public struct BatchGetProfileError: AWSDecodableShape {
        /// Status code for why a specific profile failed.
        public let code: String
        /// Message describing why a specific profile failed.
        public let message: String
        /// The profile id that failed.
        public let profileId: String

        @inlinable
        public init(code: String, message: String, profileId: String) {
            self.code = code
            self.message = message
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case profileId = "ProfileId"
        }
    }

    public struct BatchGetProfileRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// List of unique identifiers for customer profiles to retrieve.
        public let profileIds: [String]

        @inlinable
        public init(domainName: String, profileIds: [String]) {
            self.domainName = domainName
            self.profileIds = profileIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.profileIds, forKey: .profileIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.profileIds.forEach {
                try validate($0, name: "profileIds[]", parent: name, pattern: "^[a-f0-9]{32}$")
            }
            try self.validate(self.profileIds, name: "profileIds", parent: name, max: 20)
            try self.validate(self.profileIds, name: "profileIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case profileIds = "ProfileIds"
        }
    }

    public struct BatchGetProfileResponse: AWSDecodableShape {
        /// For information about the errors that are common to all actions, see Common Errors.
        public let errors: [BatchGetProfileError]?
        /// Array of Profile Objects.
        public let profiles: [Profile]?

        @inlinable
        public init(errors: [BatchGetProfileError]? = nil, profiles: [Profile]? = nil) {
            self.errors = errors
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case profiles = "Profiles"
        }
    }

    public struct CalculatedAttributeDimension: AWSEncodableShape & AWSDecodableShape {
        /// Applies the given condition over the initial Calculated Attribute's definition.
        public let conditionOverrides: ConditionOverrides?
        /// The action to segment with.
        public let dimensionType: AttributeDimensionType
        /// The values to apply the DimensionType with.
        public let values: [String]

        @inlinable
        public init(conditionOverrides: ConditionOverrides? = nil, dimensionType: AttributeDimensionType, values: [String]) {
            self.conditionOverrides = conditionOverrides
            self.dimensionType = dimensionType
            self.values = values
        }

        public func validate(name: String) throws {
            try self.conditionOverrides?.validate(name: "\(name).conditionOverrides")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 50)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionOverrides = "ConditionOverrides"
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct CalculatedAttributeValue: AWSDecodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// Indicates whether the calculated attribute's value is based on partial data. If the data is partial, it is set to true.
        public let isDataPartial: String?
        /// The profile id belonging to this calculated attribute value.
        public let profileId: String?
        /// The value of the calculated attribute.
        public let value: String?

        @inlinable
        public init(calculatedAttributeName: String? = nil, displayName: String? = nil, isDataPartial: String? = nil, profileId: String? = nil, value: String? = nil) {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.profileId = profileId
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedAttributeName = "CalculatedAttributeName"
            case displayName = "DisplayName"
            case isDataPartial = "IsDataPartial"
            case profileId = "ProfileId"
            case value = "Value"
        }
    }

    public struct ConditionOverrides: AWSEncodableShape & AWSDecodableShape {
        /// The relative time period over which data is included in the aggregation for this override.
        public let range: RangeOverride?

        @inlinable
        public init(range: RangeOverride? = nil) {
            self.range = range
        }

        public func validate(name: String) throws {
            try self.range?.validate(name: "\(name).range")
        }

        private enum CodingKeys: String, CodingKey {
            case range = "Range"
        }
    }

    public struct Conditions: AWSEncodableShape & AWSDecodableShape {
        /// The number of profile objects used for the calculated attribute.
        public let objectCount: Int?
        /// The relative time period over which data is included in the aggregation.
        public let range: Range?
        /// The threshold for the calculated attribute.
        public let threshold: Threshold?

        @inlinable
        public init(objectCount: Int? = nil, range: Range? = nil, threshold: Threshold? = nil) {
            self.objectCount = objectCount
            self.range = range
            self.threshold = threshold
        }

        public func validate(name: String) throws {
            try self.validate(self.objectCount, name: "objectCount", parent: name, max: 100)
            try self.validate(self.objectCount, name: "objectCount", parent: name, min: 1)
            try self.range?.validate(name: "\(name).range")
            try self.threshold?.validate(name: "\(name).threshold")
        }

        private enum CodingKeys: String, CodingKey {
            case objectCount = "ObjectCount"
            case range = "Range"
            case threshold = "Threshold"
        }
    }

    public struct ConflictResolution: AWSEncodableShape & AWSDecodableShape {
        /// How the auto-merging process should resolve conflicts between different profiles.    RECENCY: Uses the data that was most recently updated.    SOURCE: Uses the data from a specific source. For example, if a company has been aquired or two departments have merged, data from the specified source is used. If two duplicate profiles are from the same source, then RECENCY is used again.
        public let conflictResolvingModel: ConflictResolvingModel
        /// The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        public let sourceName: String?

        @inlinable
        public init(conflictResolvingModel: ConflictResolvingModel, sourceName: String? = nil) {
            self.conflictResolvingModel = conflictResolvingModel
            self.sourceName = sourceName
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceName, name: "sourceName", parent: name, max: 255)
            try self.validate(self.sourceName, name: "sourceName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conflictResolvingModel = "ConflictResolvingModel"
            case sourceName = "SourceName"
        }
    }

    public struct ConnectorOperator: AWSEncodableShape {
        /// The operation to be performed on the provided Marketo source fields.
        public let marketo: MarketoConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public let s3: S3ConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public let salesforce: SalesforceConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public let serviceNow: ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public let zendesk: ZendeskConnectorOperator?

        @inlinable
        public init(marketo: MarketoConnectorOperator? = nil, s3: S3ConnectorOperator? = nil, salesforce: SalesforceConnectorOperator? = nil, serviceNow: ServiceNowConnectorOperator? = nil, zendesk: ZendeskConnectorOperator? = nil) {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case zendesk = "Zendesk"
        }
    }

    public struct Consolidation: AWSEncodableShape & AWSDecodableShape {
        /// A list of matching criteria.
        public let matchingAttributesList: [[String]]

        @inlinable
        public init(matchingAttributesList: [[String]]) {
            self.matchingAttributesList = matchingAttributesList
        }

        public func validate(name: String) throws {
            try self.matchingAttributesList.forEach {
                try validate($0, name: "matchingAttributesList[]", parent: name, max: 20)
                try validate($0, name: "matchingAttributesList[]", parent: name, min: 1)
            }
            try self.validate(self.matchingAttributesList, name: "matchingAttributesList", parent: name, max: 10)
            try self.validate(self.matchingAttributesList, name: "matchingAttributesList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case matchingAttributesList = "MatchingAttributesList"
        }
    }

    public struct CreateCalculatedAttributeDefinitionRequest: AWSEncodableShape {
        /// Mathematical expression and a list of attribute items specified in that expression.
        public let attributeDetails: AttributeDetails
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String
        /// The conditions including range, object count, and threshold for the calculated attribute.
        public let conditions: Conditions?
        /// The description of the calculated attribute.
        public let description: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// The unique name of the domain.
        public let domainName: String
        /// Defines how to filter incoming objects to include part of the Calculated Attribute.
        public let filter: Filter?
        /// The aggregation operation to perform for the calculated attribute.
        public let statistic: Statistic
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributeDetails: AttributeDetails, calculatedAttributeName: String, conditions: Conditions? = nil, description: String? = nil, displayName: String? = nil, domainName: String, filter: Filter? = nil, statistic: Statistic, tags: [String: String]? = nil) {
            self.attributeDetails = attributeDetails
            self.calculatedAttributeName = calculatedAttributeName
            self.conditions = conditions
            self.description = description
            self.displayName = displayName
            self.domainName = domainName
            self.filter = filter
            self.statistic = statistic
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attributeDetails, forKey: .attributeDetails)
            request.encodePath(self.calculatedAttributeName, key: "CalculatedAttributeName")
            try container.encodeIfPresent(self.conditions, forKey: .conditions)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encode(self.statistic, forKey: .statistic)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.attributeDetails.validate(name: "\(name).attributeDetails")
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, max: 255)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, min: 1)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.conditions?.validate(name: "\(name).conditions")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-\\s]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.filter?.validate(name: "\(name).filter")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeDetails = "AttributeDetails"
            case conditions = "Conditions"
            case description = "Description"
            case displayName = "DisplayName"
            case filter = "Filter"
            case statistic = "Statistic"
            case tags = "Tags"
        }
    }

    public struct CreateCalculatedAttributeDefinitionResponse: AWSDecodableShape {
        /// Mathematical expression and a list of attribute items specified in that expression.
        public let attributeDetails: AttributeDetails?
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The conditions including range, object count, and threshold for the calculated attribute.
        public let conditions: Conditions?
        /// The timestamp of when the calculated attribute definition was created.
        public let createdAt: Date?
        /// The description of the calculated attribute.
        public let description: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// The filter that was used as part of the request.
        public let filter: Filter?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public let lastUpdatedAt: Date?
        /// The aggregation operation to perform for the calculated attribute.
        public let statistic: Statistic?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributeDetails: AttributeDetails? = nil, calculatedAttributeName: String? = nil, conditions: Conditions? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, filter: Filter? = nil, lastUpdatedAt: Date? = nil, statistic: Statistic? = nil, tags: [String: String]? = nil) {
            self.attributeDetails = attributeDetails
            self.calculatedAttributeName = calculatedAttributeName
            self.conditions = conditions
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.filter = filter
            self.lastUpdatedAt = lastUpdatedAt
            self.statistic = statistic
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributeDetails = "AttributeDetails"
            case calculatedAttributeName = "CalculatedAttributeName"
            case conditions = "Conditions"
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case filter = "Filter"
            case lastUpdatedAt = "LastUpdatedAt"
            case statistic = "Statistic"
            case tags = "Tags"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int
        /// The unique name of the domain.
        public let domainName: String
        /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly
        /// batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every
        /// Saturday at 12AM UTC to detect duplicate profiles in your domains.  After the Identity Resolution Job completes, use the
        /// GetMatches
        /// API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from
        /// S3.
        public let matching: MatchingRequest?
        /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        public let ruleBasedMatching: RuleBasedMatchingRequest?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int, domainName: String, matching: MatchingRequest? = nil, ruleBasedMatching: RuleBasedMatchingRequest? = nil, tags: [String: String]? = nil) {
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.matching = matching
            self.ruleBasedMatching = ruleBasedMatching
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deadLetterQueueUrl, forKey: .deadLetterQueueUrl)
            try container.encodeIfPresent(self.defaultEncryptionKey, forKey: .defaultEncryptionKey)
            try container.encode(self.defaultExpirationDays, forKey: .defaultExpirationDays)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.matching, forKey: .matching)
            try container.encodeIfPresent(self.ruleBasedMatching, forKey: .ruleBasedMatching)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.deadLetterQueueUrl, name: "deadLetterQueueUrl", parent: name, max: 255)
            try self.validate(self.defaultEncryptionKey, name: "defaultEncryptionKey", parent: name, max: 255)
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, max: 1098)
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.matching?.validate(name: "\(name).matching")
            try self.ruleBasedMatching?.validate(name: "\(name).ruleBasedMatching")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case matching = "Matching"
            case ruleBasedMatching = "RuleBasedMatching"
            case tags = "Tags"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly
        /// batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every
        /// Saturday at 12AM UTC to detect duplicate profiles in your domains.  After the Identity Resolution Job completes, use the
        /// GetMatches
        /// API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from
        /// S3.
        public let matching: MatchingResponse?
        /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        public let ruleBasedMatching: RuleBasedMatchingResponse?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int, domainName: String, lastUpdatedAt: Date, matching: MatchingResponse? = nil, ruleBasedMatching: RuleBasedMatchingResponse? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.matching = matching
            self.ruleBasedMatching = ruleBasedMatching
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case matching = "Matching"
            case ruleBasedMatching = "RuleBasedMatching"
            case tags = "Tags"
        }
    }

    public struct CreateEventStreamRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The name of the event stream.
        public let eventStreamName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name
        public let uri: String

        @inlinable
        public init(domainName: String, eventStreamName: String, tags: [String: String]? = nil, uri: String) {
            self.domainName = domainName
            self.eventStreamName = eventStreamName
            self.tags = tags
            self.uri = uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.eventStreamName, key: "EventStreamName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.uri, forKey: .uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, max: 64)
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, min: 1)
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case uri = "Uri"
        }
    }

    public struct CreateEventStreamResponse: AWSDecodableShape {
        /// A unique identifier for the event stream.
        public let eventStreamArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(eventStreamArn: String, tags: [String: String]? = nil) {
            self.eventStreamArn = eventStreamArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case eventStreamArn = "EventStreamArn"
            case tags = "Tags"
        }
    }

    public struct CreateEventTriggerRequest: AWSEncodableShape {
        /// The description of the event trigger.
        public let description: String?
        /// The unique name of the domain.
        public let domainName: String
        /// A list of conditions that determine when an event should trigger the destination.
        public let eventTriggerConditions: [EventTriggerCondition]
        /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
        public let eventTriggerLimits: EventTriggerLimits?
        /// The unique name of the event trigger.
        public let eventTriggerName: String
        /// The unique name of the object type.
        public let objectTypeName: String
        /// The destination is triggered only for profiles that meet the criteria of a segment definition.
        public let segmentFilter: String?
        /// An array of key-value pairs to apply to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, domainName: String, eventTriggerConditions: [EventTriggerCondition], eventTriggerLimits: EventTriggerLimits? = nil, eventTriggerName: String, objectTypeName: String, segmentFilter: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.domainName = domainName
            self.eventTriggerConditions = eventTriggerConditions
            self.eventTriggerLimits = eventTriggerLimits
            self.eventTriggerName = eventTriggerName
            self.objectTypeName = objectTypeName
            self.segmentFilter = segmentFilter
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.eventTriggerConditions, forKey: .eventTriggerConditions)
            try container.encodeIfPresent(self.eventTriggerLimits, forKey: .eventTriggerLimits)
            request.encodePath(self.eventTriggerName, key: "EventTriggerName")
            try container.encode(self.objectTypeName, forKey: .objectTypeName)
            try container.encodeIfPresent(self.segmentFilter, forKey: .segmentFilter)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.eventTriggerConditions.forEach {
                try $0.validate(name: "\(name).eventTriggerConditions[]")
            }
            try self.validate(self.eventTriggerConditions, name: "eventTriggerConditions", parent: name, max: 5)
            try self.validate(self.eventTriggerConditions, name: "eventTriggerConditions", parent: name, min: 1)
            try self.eventTriggerLimits?.validate(name: "\(name).eventTriggerLimits")
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, max: 64)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, min: 1)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.segmentFilter, name: "segmentFilter", parent: name, max: 64)
            try self.validate(self.segmentFilter, name: "segmentFilter", parent: name, min: 1)
            try self.validate(self.segmentFilter, name: "segmentFilter", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventTriggerConditions = "EventTriggerConditions"
            case eventTriggerLimits = "EventTriggerLimits"
            case objectTypeName = "ObjectTypeName"
            case segmentFilter = "SegmentFilter"
            case tags = "Tags"
        }
    }

    public struct CreateEventTriggerResponse: AWSDecodableShape {
        /// The timestamp of when the event trigger was created.
        public let createdAt: Date?
        /// The description of the event trigger.
        public let description: String?
        /// A list of conditions that determine when an event should trigger the destination.
        public let eventTriggerConditions: [EventTriggerCondition]?
        /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
        public let eventTriggerLimits: EventTriggerLimits?
        /// The unique name of the event trigger.
        public let eventTriggerName: String?
        /// The timestamp of when the event trigger was most recently updated.
        public let lastUpdatedAt: Date?
        /// The unique name of the object type.
        public let objectTypeName: String?
        /// The destination is triggered only for profiles that meet the criteria of a segment definition.
        public let segmentFilter: String?
        /// An array of key-value pairs to apply to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, eventTriggerConditions: [EventTriggerCondition]? = nil, eventTriggerLimits: EventTriggerLimits? = nil, eventTriggerName: String? = nil, lastUpdatedAt: Date? = nil, objectTypeName: String? = nil, segmentFilter: String? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.eventTriggerConditions = eventTriggerConditions
            self.eventTriggerLimits = eventTriggerLimits
            self.eventTriggerName = eventTriggerName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.segmentFilter = segmentFilter
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case eventTriggerConditions = "EventTriggerConditions"
            case eventTriggerLimits = "EventTriggerLimits"
            case eventTriggerName = "EventTriggerName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case segmentFilter = "SegmentFilter"
            case tags = "Tags"
        }
    }

    public struct CreateIntegrationWorkflowRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// Configuration data for integration workflow.
        public let integrationConfig: IntegrationConfig
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The Amazon Resource Name (ARN) of the IAM role. Customer Profiles assumes this role to create resources on your behalf as part of workflow execution.
        public let roleArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        public let workflowType: WorkflowType

        @inlinable
        public init(domainName: String, integrationConfig: IntegrationConfig, objectTypeName: String, roleArn: String, tags: [String: String]? = nil, workflowType: WorkflowType) {
            self.domainName = domainName
            self.integrationConfig = integrationConfig
            self.objectTypeName = objectTypeName
            self.roleArn = roleArn
            self.tags = tags
            self.workflowType = workflowType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.integrationConfig, forKey: .integrationConfig)
            try container.encode(self.objectTypeName, forKey: .objectTypeName)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.workflowType, forKey: .workflowType)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.integrationConfig.validate(name: "\(name).integrationConfig")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:.*:[0-9]+:")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case integrationConfig = "IntegrationConfig"
            case objectTypeName = "ObjectTypeName"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case workflowType = "WorkflowType"
        }
    }

    public struct CreateIntegrationWorkflowResponse: AWSDecodableShape {
        /// A message indicating create request was received.
        public let message: String
        /// Unique identifier for the workflow.
        public let workflowId: String

        @inlinable
        public init(message: String, workflowId: String) {
            self.message = message
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case workflowId = "WorkflowId"
        }
    }

    public struct CreateProfileRequest: AWSEncodableShape {
        /// An account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customers profile.
        public let additionalInformation: String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public let address: Address?
        /// A key value pair of attributes of a customer profile.
        public let attributes: [String: String]?
        /// The customers billing address.
        public let billingAddress: Address?
        /// The customers birth date.
        public let birthDate: String?
        /// The customers business email address.
        public let businessEmailAddress: String?
        /// The name of the customers business.
        public let businessName: String?
        /// The customers business phone number.
        public let businessPhoneNumber: String?
        /// The unique name of the domain.
        public let domainName: String
        /// The customers email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customers first name.
        public let firstName: String?
        /// The gender with which the customer identifies.
        public let gender: Gender?
        /// An alternative to Gender which accepts any string as input.
        public let genderString: String?
        /// The customers home phone number.
        public let homePhoneNumber: String?
        /// The customers last name.
        public let lastName: String?
        /// The customers mailing address.
        public let mailingAddress: Address?
        /// The customers middle name.
        public let middleName: String?
        /// The customers mobile phone number.
        public let mobilePhoneNumber: String?
        /// The type of profile used to describe the customer.
        public let partyType: PartyType?
        /// An alternative to PartyType which accepts any string as input.
        public let partyTypeString: String?
        /// The customers personal email address.
        public let personalEmailAddress: String?
        /// The customers phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The customers shipping address.
        public let shippingAddress: Address?

        @inlinable
        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: Address? = nil, attributes: [String: String]? = nil, billingAddress: Address? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, domainName: String, emailAddress: String? = nil, firstName: String? = nil, gender: Gender? = nil, genderString: String? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: Address? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: PartyType? = nil, partyTypeString: String? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, shippingAddress: Address? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.domainName = domainName
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.shippingAddress = shippingAddress
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountNumber, forKey: .accountNumber)
            try container.encodeIfPresent(self.additionalInformation, forKey: .additionalInformation)
            try container.encodeIfPresent(self.address, forKey: .address)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encodeIfPresent(self.billingAddress, forKey: .billingAddress)
            try container.encodeIfPresent(self.birthDate, forKey: .birthDate)
            try container.encodeIfPresent(self.businessEmailAddress, forKey: .businessEmailAddress)
            try container.encodeIfPresent(self.businessName, forKey: .businessName)
            try container.encodeIfPresent(self.businessPhoneNumber, forKey: .businessPhoneNumber)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.emailAddress, forKey: .emailAddress)
            try container.encodeIfPresent(self.firstName, forKey: .firstName)
            try container.encodeIfPresent(self.gender, forKey: .gender)
            try container.encodeIfPresent(self.genderString, forKey: .genderString)
            try container.encodeIfPresent(self.homePhoneNumber, forKey: .homePhoneNumber)
            try container.encodeIfPresent(self.lastName, forKey: .lastName)
            try container.encodeIfPresent(self.mailingAddress, forKey: .mailingAddress)
            try container.encodeIfPresent(self.middleName, forKey: .middleName)
            try container.encodeIfPresent(self.mobilePhoneNumber, forKey: .mobilePhoneNumber)
            try container.encodeIfPresent(self.partyType, forKey: .partyType)
            try container.encodeIfPresent(self.partyTypeString, forKey: .partyTypeString)
            try container.encodeIfPresent(self.personalEmailAddress, forKey: .personalEmailAddress)
            try container.encodeIfPresent(self.phoneNumber, forKey: .phoneNumber)
            try container.encodeIfPresent(self.shippingAddress, forKey: .shippingAddress)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, max: 255)
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, min: 1)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, max: 1000)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, min: 1)
            try self.address?.validate(name: "\(name).address")
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 255)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.billingAddress?.validate(name: "\(name).billingAddress")
            try self.validate(self.birthDate, name: "birthDate", parent: name, max: 255)
            try self.validate(self.birthDate, name: "birthDate", parent: name, min: 1)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, max: 255)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, min: 1)
            try self.validate(self.businessName, name: "businessName", parent: name, max: 255)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, max: 255)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 255)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, max: 255)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.genderString, name: "genderString", parent: name, max: 255)
            try self.validate(self.genderString, name: "genderString", parent: name, min: 1)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, max: 255)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 255)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.mailingAddress?.validate(name: "\(name).mailingAddress")
            try self.validate(self.middleName, name: "middleName", parent: name, max: 255)
            try self.validate(self.middleName, name: "middleName", parent: name, min: 1)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, max: 255)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, min: 1)
            try self.validate(self.partyTypeString, name: "partyTypeString", parent: name, max: 255)
            try self.validate(self.partyTypeString, name: "partyTypeString", parent: name, min: 1)
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, max: 255)
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, min: 1)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 255)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 1)
            try self.shippingAddress?.validate(name: "\(name).shippingAddress")
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case gender = "Gender"
            case genderString = "GenderString"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case partyTypeString = "PartyTypeString"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct CreateProfileResponse: AWSDecodableShape {
        /// The unique identifier of a customer profile.
        public let profileId: String

        @inlinable
        public init(profileId: String) {
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
        }
    }

    public struct CreateSegmentDefinitionRequest: AWSEncodableShape {
        /// The description of the segment definition.
        public let description: String?
        /// The display name of the segment definition.
        public let displayName: String
        /// The unique name of the domain.
        public let domainName: String
        /// The unique name of the segment definition.
        public let segmentDefinitionName: String
        /// Specifies the base segments and dimensions for a segment definition along with their respective relationship.
        public let segmentGroups: SegmentGroup
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, displayName: String, domainName: String, segmentDefinitionName: String, segmentGroups: SegmentGroup, tags: [String: String]? = nil) {
            self.description = description
            self.displayName = displayName
            self.domainName = domainName
            self.segmentDefinitionName = segmentDefinitionName
            self.segmentGroups = segmentGroups
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.segmentDefinitionName, key: "SegmentDefinitionName")
            try container.encode(self.segmentGroups, forKey: .segmentGroups)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.segmentGroups.validate(name: "\(name).segmentGroups")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case segmentGroups = "SegmentGroups"
            case tags = "Tags"
        }
    }

    public struct CreateSegmentDefinitionResponse: AWSDecodableShape {
        /// The timestamp of when the segment definition was created.
        public let createdAt: Date?
        /// The description of the segment definition.
        public let description: String?
        /// The display name of the segment definition.
        public let displayName: String?
        /// The arn of the segment definition.
        public let segmentDefinitionArn: String?
        /// The name of the segment definition.
        public let segmentDefinitionName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, segmentDefinitionArn: String? = nil, segmentDefinitionName: String, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.segmentDefinitionArn = segmentDefinitionArn
            self.segmentDefinitionName = segmentDefinitionName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case segmentDefinitionArn = "SegmentDefinitionArn"
            case segmentDefinitionName = "SegmentDefinitionName"
            case tags = "Tags"
        }
    }

    public struct CreateSegmentEstimateRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The segment query for calculating a segment estimate.
        public let segmentQuery: SegmentGroupStructure

        @inlinable
        public init(domainName: String, segmentQuery: SegmentGroupStructure) {
            self.domainName = domainName
            self.segmentQuery = segmentQuery
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.segmentQuery, forKey: .segmentQuery)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.segmentQuery.validate(name: "\(name).segmentQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case segmentQuery = "SegmentQuery"
        }
    }

    public struct CreateSegmentEstimateResponse: AWSDecodableShape {
        /// The unique name of the domain.
        public let domainName: String?
        /// A unique identifier for the resource. The value can be passed to GetSegmentEstimate to retrieve the result of segment estimate status.
        public let estimateId: String?
        /// The status code for the response.
        public let statusCode: Int?

        @inlinable
        public init(domainName: String? = nil, estimateId: String? = nil, statusCode: Int? = nil) {
            self.domainName = domainName
            self.estimateId = estimateId
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.domainName = try container.decodeIfPresent(String.self, forKey: .domainName)
            self.estimateId = try container.decodeIfPresent(String.self, forKey: .estimateId)
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case estimateId = "EstimateId"
        }
    }

    public struct CreateSegmentSnapshotRequest: AWSEncodableShape {
        /// The format in which the segment will be exported.
        public let dataFormat: DataFormat
        /// The destination to which the segment will be exported. This field must be provided if the request is not submitted from the Amazon Connect Admin Website.
        public let destinationUri: String?
        /// The unique name of the domain.
        public let domainName: String
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the exported segment.
        public let encryptionKey: String?
        /// The Amazon Resource Name (ARN) of the IAM role that allows Customer Profiles service principal to assume the role for conducting KMS and S3 operations.
        public let roleArn: String?
        /// The name of the segment definition used in this snapshot request.
        public let segmentDefinitionName: String

        @inlinable
        public init(dataFormat: DataFormat, destinationUri: String? = nil, domainName: String, encryptionKey: String? = nil, roleArn: String? = nil, segmentDefinitionName: String) {
            self.dataFormat = dataFormat
            self.destinationUri = destinationUri
            self.domainName = domainName
            self.encryptionKey = encryptionKey
            self.roleArn = roleArn
            self.segmentDefinitionName = segmentDefinitionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataFormat, forKey: .dataFormat)
            try container.encodeIfPresent(self.destinationUri, forKey: .destinationUri)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.encryptionKey, forKey: .encryptionKey)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            request.encodePath(self.segmentDefinitionName, key: "SegmentDefinitionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationUri, name: "destinationUri", parent: name, max: 255)
            try self.validate(self.destinationUri, name: "destinationUri", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 255)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:.*:[0-9]+:")
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFormat = "DataFormat"
            case destinationUri = "DestinationUri"
            case encryptionKey = "EncryptionKey"
            case roleArn = "RoleArn"
        }
    }

    public struct CreateSegmentSnapshotResponse: AWSDecodableShape {
        /// The unique identifier of the segment snapshot.
        public let snapshotId: String

        @inlinable
        public init(snapshotId: String) {
            self.snapshotId = snapshotId
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotId = "SnapshotId"
        }
    }

    public struct DateDimension: AWSEncodableShape & AWSDecodableShape {
        /// The action to segment with.
        public let dimensionType: DateDimensionType
        /// The values to apply the DimensionType on.
        public let values: [String]

        @inlinable
        public init(dimensionType: DateDimensionType, values: [String]) {
            self.dimensionType = dimensionType
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 50)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct DeleteCalculatedAttributeDefinitionRequest: AWSEncodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String
        /// The unique name of the domain.
        public let domainName: String

        @inlinable
        public init(calculatedAttributeName: String, domainName: String) {
            self.calculatedAttributeName = calculatedAttributeName
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatedAttributeName, key: "CalculatedAttributeName")
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, max: 255)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, min: 1)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCalculatedAttributeDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteEventStreamRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The name of the event stream
        public let eventStreamName: String

        @inlinable
        public init(domainName: String, eventStreamName: String) {
            self.domainName = domainName
            self.eventStreamName = eventStreamName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.eventStreamName, key: "EventStreamName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, max: 64)
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, min: 1)
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventStreamResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventTriggerRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The unique name of the event trigger.
        public let eventTriggerName: String

        @inlinable
        public init(domainName: String, eventTriggerName: String) {
            self.domainName = domainName
            self.eventTriggerName = eventTriggerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.eventTriggerName, key: "EventTriggerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, max: 64)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, min: 1)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventTriggerResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteIntegrationRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        @inlinable
        public init(domainName: String, uri: String) {
            self.domainName = domainName
            self.uri = uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.uri, forKey: .uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "Uri"
        }
    }

    public struct DeleteIntegrationResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileKeyRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// A searchable identifier of a customer profile.
        public let keyName: String
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// A list of key values.
        public let values: [String]

        @inlinable
        public init(domainName: String, keyName: String, profileId: String, values: [String]) {
            self.domainName = domainName
            self.keyName = keyName
            self.profileId = profileId
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.keyName, forKey: .keyName)
            try container.encode(self.profileId, forKey: .profileId)
            try container.encode(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case profileId = "ProfileId"
            case values = "Values"
        }
    }

    public struct DeleteProfileKeyResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileObjectRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// The unique identifier of the profile object generated by the service.
        public let profileObjectUniqueKey: String

        @inlinable
        public init(domainName: String, objectTypeName: String, profileId: String, profileObjectUniqueKey: String) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
            self.profileId = profileId
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.objectTypeName, forKey: .objectTypeName)
            try container.encode(self.profileId, forKey: .profileId)
            try container.encode(self.profileObjectUniqueKey, forKey: .profileObjectUniqueKey)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.profileObjectUniqueKey, name: "profileObjectUniqueKey", parent: name, max: 255)
            try self.validate(self.profileObjectUniqueKey, name: "profileObjectUniqueKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case objectTypeName = "ObjectTypeName"
            case profileId = "ProfileId"
            case profileObjectUniqueKey = "ProfileObjectUniqueKey"
        }
    }

    public struct DeleteProfileObjectResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileObjectTypeRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The name of the profile object type.
        public let objectTypeName: String

        @inlinable
        public init(domainName: String, objectTypeName: String) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.objectTypeName, key: "ObjectTypeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfileObjectTypeResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The unique identifier of a customer profile.
        public let profileId: String

        @inlinable
        public init(domainName: String, profileId: String) {
            self.domainName = domainName
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.profileId, forKey: .profileId)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
        }
    }

    public struct DeleteProfileResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteSegmentDefinitionRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The unique name of the segment definition.
        public let segmentDefinitionName: String

        @inlinable
        public init(domainName: String, segmentDefinitionName: String) {
            self.domainName = domainName
            self.segmentDefinitionName = segmentDefinitionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.segmentDefinitionName, key: "SegmentDefinitionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSegmentDefinitionResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// Unique identifier for the workflow.
        public let workflowId: String

        @inlinable
        public init(domainName: String, workflowId: String) {
            self.domainName = domainName
            self.workflowId = workflowId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.workflowId, key: "WorkflowId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.workflowId, name: "workflowId", parent: name, max: 255)
            try self.validate(self.workflowId, name: "workflowId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkflowResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DestinationSummary: AWSDecodableShape {
        /// The status of enabling the Kinesis stream as a destination for export.
        public let status: EventStreamDestinationStatus
        /// The timestamp when the status last changed to UNHEALHY.
        public let unhealthySince: Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        public let uri: String

        @inlinable
        public init(status: EventStreamDestinationStatus, unhealthySince: Date? = nil, uri: String) {
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case unhealthySince = "UnhealthySince"
            case uri = "Uri"
        }
    }

    public struct DetectProfileObjectTypeRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// A string that is serialized from a JSON object.
        public let objects: [String]

        @inlinable
        public init(domainName: String, objects: [String]) {
            self.domainName = domainName
            self.objects = objects
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.objects, forKey: .objects)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.objects.forEach {
                try validate($0, name: "objects[]", parent: name, max: 256000)
                try validate($0, name: "objects[]", parent: name, min: 1)
            }
            try self.validate(self.objects, name: "objects", parent: name, max: 5)
            try self.validate(self.objects, name: "objects", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case objects = "Objects"
        }
    }

    public struct DetectProfileObjectTypeResponse: AWSDecodableShape {
        /// Detected ProfileObjectType mappings from given objects. A maximum of one mapping is supported.
        public let detectedProfileObjectTypes: [DetectedProfileObjectType]?

        @inlinable
        public init(detectedProfileObjectTypes: [DetectedProfileObjectType]? = nil) {
            self.detectedProfileObjectTypes = detectedProfileObjectTypes
        }

        private enum CodingKeys: String, CodingKey {
            case detectedProfileObjectTypes = "DetectedProfileObjectTypes"
        }
    }

    public struct DetectedProfileObjectType: AWSDecodableShape {
        /// A map of the name and the ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to a profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The format of sourceLastUpdatedTimestamp that was detected in fields.
        public let sourceLastUpdatedTimestampFormat: String?

        @inlinable
        public init(fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, sourceLastUpdatedTimestampFormat: String? = nil) {
            self.fields = fields
            self.keys = keys
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case keys = "Keys"
            case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
        }
    }

    public struct DomainStats: AWSDecodableShape {
        /// The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        public let meteringProfileCount: Int64?
        /// The total number of objects in domain.
        public let objectCount: Int64?
        /// The total number of profiles currently in the domain.
        public let profileCount: Int64?
        /// The total size, in bytes, of all objects in the domain.
        public let totalSize: Int64?

        @inlinable
        public init(meteringProfileCount: Int64? = nil, objectCount: Int64? = nil, profileCount: Int64? = nil, totalSize: Int64? = nil) {
            self.meteringProfileCount = meteringProfileCount
            self.objectCount = objectCount
            self.profileCount = profileCount
            self.totalSize = totalSize
        }

        private enum CodingKeys: String, CodingKey {
            case meteringProfileCount = "MeteringProfileCount"
            case objectCount = "ObjectCount"
            case profileCount = "ProfileCount"
            case totalSize = "TotalSize"
        }
    }

    public struct EventStreamDestinationDetails: AWSDecodableShape {
        /// The human-readable string that corresponds to the error or success while enabling the streaming destination.
        public let message: String?
        /// The status of enabling the Kinesis stream as a destination for export.
        public let status: EventStreamDestinationStatus
        /// The timestamp when the status last changed to UNHEALHY.
        public let unhealthySince: Date?
        /// The StreamARN of the destination to deliver profile events to. For example, arn:aws:kinesis:region:account-id:stream/stream-name.
        public let uri: String

        @inlinable
        public init(message: String? = nil, status: EventStreamDestinationStatus, unhealthySince: Date? = nil, uri: String) {
            self.message = message
            self.status = status
            self.unhealthySince = unhealthySince
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case status = "Status"
            case unhealthySince = "UnhealthySince"
            case uri = "Uri"
        }
    }

    public struct EventStreamSummary: AWSDecodableShape {
        /// Summary information about the Kinesis data stream.
        public let destinationSummary: DestinationSummary?
        /// The unique name of the domain.
        public let domainName: String
        /// A unique identifier for the event stream.
        public let eventStreamArn: String
        /// The name of the event stream.
        public let eventStreamName: String
        /// The operational state of destination stream for export.
        public let state: EventStreamState
        /// The timestamp when the State changed to STOPPED.
        public let stoppedSince: Date?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(destinationSummary: DestinationSummary? = nil, domainName: String, eventStreamArn: String, eventStreamName: String, state: EventStreamState, stoppedSince: Date? = nil, tags: [String: String]? = nil) {
            self.destinationSummary = destinationSummary
            self.domainName = domainName
            self.eventStreamArn = eventStreamArn
            self.eventStreamName = eventStreamName
            self.state = state
            self.stoppedSince = stoppedSince
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case destinationSummary = "DestinationSummary"
            case domainName = "DomainName"
            case eventStreamArn = "EventStreamArn"
            case eventStreamName = "EventStreamName"
            case state = "State"
            case stoppedSince = "StoppedSince"
            case tags = "Tags"
        }
    }

    public struct EventTriggerCondition: AWSEncodableShape & AWSDecodableShape {
        /// A list of dimensions to be evaluated for the event.
        public let eventTriggerDimensions: [EventTriggerDimension]
        /// The operator used to combine multiple dimensions.
        public let logicalOperator: EventTriggerLogicalOperator

        @inlinable
        public init(eventTriggerDimensions: [EventTriggerDimension], logicalOperator: EventTriggerLogicalOperator) {
            self.eventTriggerDimensions = eventTriggerDimensions
            self.logicalOperator = logicalOperator
        }

        public func validate(name: String) throws {
            try self.eventTriggerDimensions.forEach {
                try $0.validate(name: "\(name).eventTriggerDimensions[]")
            }
            try self.validate(self.eventTriggerDimensions, name: "eventTriggerDimensions", parent: name, max: 10)
            try self.validate(self.eventTriggerDimensions, name: "eventTriggerDimensions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTriggerDimensions = "EventTriggerDimensions"
            case logicalOperator = "LogicalOperator"
        }
    }

    public struct EventTriggerDimension: AWSEncodableShape & AWSDecodableShape {
        /// A list of object attributes to be evaluated.
        public let objectAttributes: [ObjectAttribute]

        @inlinable
        public init(objectAttributes: [ObjectAttribute]) {
            self.objectAttributes = objectAttributes
        }

        public func validate(name: String) throws {
            try self.objectAttributes.forEach {
                try $0.validate(name: "\(name).objectAttributes[]")
            }
            try self.validate(self.objectAttributes, name: "objectAttributes", parent: name, max: 10)
            try self.validate(self.objectAttributes, name: "objectAttributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case objectAttributes = "ObjectAttributes"
        }
    }

    public struct EventTriggerLimits: AWSEncodableShape & AWSDecodableShape {
        /// In milliseconds. Specifies that an event will only trigger the destination if it is processed within a certain latency period.
        public let eventExpiration: Int64?
        /// A list of time periods during which the limits apply.
        public let periods: [Period]?

        @inlinable
        public init(eventExpiration: Int64? = nil, periods: [Period]? = nil) {
            self.eventExpiration = eventExpiration
            self.periods = periods
        }

        public func validate(name: String) throws {
            try self.periods?.forEach {
                try $0.validate(name: "\(name).periods[]")
            }
            try self.validate(self.periods, name: "periods", parent: name, max: 4)
            try self.validate(self.periods, name: "periods", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventExpiration = "EventExpiration"
            case periods = "Periods"
        }
    }

    public struct EventTriggerSummaryItem: AWSDecodableShape {
        /// The timestamp of when the event trigger was created.
        public let createdAt: Date?
        /// The description of the event trigger.
        public let description: String?
        /// The unique name of the event trigger.
        public let eventTriggerName: String?
        /// The timestamp of when the event trigger was most recently updated.
        public let lastUpdatedAt: Date?
        /// The unique name of the object type.
        public let objectTypeName: String?
        /// An array of key-value pairs to apply to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, eventTriggerName: String? = nil, lastUpdatedAt: Date? = nil, objectTypeName: String? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.eventTriggerName = eventTriggerName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case eventTriggerName = "EventTriggerName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
        }
    }

    public struct ExportingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 location where Identity Resolution Jobs write result files.
        public let s3Exporting: S3ExportingConfig?

        @inlinable
        public init(s3Exporting: S3ExportingConfig? = nil) {
            self.s3Exporting = s3Exporting
        }

        public func validate(name: String) throws {
            try self.s3Exporting?.validate(name: "\(name).s3Exporting")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Exporting = "S3Exporting"
        }
    }

    public struct ExportingLocation: AWSDecodableShape {
        /// Information about the S3 location where Identity Resolution Jobs write result files.
        public let s3Exporting: S3ExportingLocation?

        @inlinable
        public init(s3Exporting: S3ExportingLocation? = nil) {
            self.s3Exporting = s3Exporting
        }

        private enum CodingKeys: String, CodingKey {
            case s3Exporting = "S3Exporting"
        }
    }

    public struct ExtraLengthValueProfileDimension: AWSEncodableShape & AWSDecodableShape {
        /// The action to segment with.
        public let dimensionType: StringDimensionType
        /// The values to apply the DimensionType on.
        public let values: [String]

        @inlinable
        public init(dimensionType: StringDimensionType, values: [String]) {
            self.dimensionType = dimensionType
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 50)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct FieldSourceProfileIds: AWSEncodableShape {
        /// A unique identifier for the account number field to be merged.
        public let accountNumber: String?
        /// A unique identifier for the additional information field to be merged.
        public let additionalInformation: String?
        /// A unique identifier for the party type field to be merged.
        public let address: String?
        /// A unique identifier for the attributes field to be merged.
        public let attributes: [String: String]?
        /// A unique identifier for the billing type field to be merged.
        public let billingAddress: String?
        /// A unique identifier for the birthdate field to be merged.
        public let birthDate: String?
        /// A unique identifier for the party type field to be merged.
        public let businessEmailAddress: String?
        /// A unique identifier for the business name field to be merged.
        public let businessName: String?
        /// A unique identifier for the business phone number field to be merged.
        public let businessPhoneNumber: String?
        /// A unique identifier for the email address field to be merged.
        public let emailAddress: String?
        /// A unique identifier for the first name field to be merged.
        public let firstName: String?
        /// A unique identifier for the gender field to be merged.
        public let gender: String?
        /// A unique identifier for the home phone number field to be merged.
        public let homePhoneNumber: String?
        /// A unique identifier for the last name field to be merged.
        public let lastName: String?
        /// A unique identifier for the mailing address field to be merged.
        public let mailingAddress: String?
        /// A unique identifier for the middle name field to be merged.
        public let middleName: String?
        /// A unique identifier for the mobile phone number field to be merged.
        public let mobilePhoneNumber: String?
        /// A unique identifier for the party type field to be merged.
        public let partyType: String?
        /// A unique identifier for the personal email address field to be merged.
        public let personalEmailAddress: String?
        /// A unique identifier for the phone number field to be merged.
        public let phoneNumber: String?
        /// A unique identifier for the shipping address field to be merged.
        public let shippingAddress: String?

        @inlinable
        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: String? = nil, attributes: [String: String]? = nil, billingAddress: String? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, emailAddress: String? = nil, firstName: String? = nil, gender: String? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: String? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: String? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, shippingAddress: String? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.shippingAddress = shippingAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.address, name: "address", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 255)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, pattern: "^[a-f0-9]{32}$")
            }
            try self.validate(self.billingAddress, name: "billingAddress", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.birthDate, name: "birthDate", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.businessName, name: "businessName", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.gender, name: "gender", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.mailingAddress, name: "mailingAddress", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.middleName, name: "middleName", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.partyType, name: "partyType", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.validate(self.shippingAddress, name: "shippingAddress", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case gender = "Gender"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        /// Holds the list of Filter groups within the Filter definition.
        public let groups: [FilterGroup]
        /// Define whether to include or exclude objects for Calculated Attributed calculation that fit the filter groups criteria.
        public let include: Include

        @inlinable
        public init(groups: [FilterGroup], include: Include) {
            self.groups = groups
            self.include = include
        }

        public func validate(name: String) throws {
            try self.groups.forEach {
                try $0.validate(name: "\(name).groups[]")
            }
            try self.validate(self.groups, name: "groups", parent: name, max: 2)
            try self.validate(self.groups, name: "groups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case include = "Include"
        }
    }

    public struct FilterAttributeDimension: AWSEncodableShape & AWSDecodableShape {
        /// The action to filter with.
        public let dimensionType: FilterDimensionType
        /// The values to apply the DimensionType on.
        public let values: [String]

        @inlinable
        public init(dimensionType: FilterDimensionType, values: [String]) {
            self.dimensionType = dimensionType
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct FilterDimension: AWSEncodableShape & AWSDecodableShape {
        /// Is the attribute within the FilterDimension map
        public let attributes: [String: FilterAttributeDimension]

        @inlinable
        public init(attributes: [String: FilterAttributeDimension]) {
            self.attributes = attributes
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 64)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
                try $0.value.validate(name: "\(name).attributes[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct FilterGroup: AWSEncodableShape & AWSDecodableShape {
        /// Object that holds the attributes to filter on.
        public let dimensions: [FilterDimension]
        /// The type of logical relationship between the dimensions of the Filter group.
        public let type: `Type`

        @inlinable
        public init(dimensions: [FilterDimension], type: `Type`) {
            self.dimensions = dimensions
            self.type = type
        }

        public func validate(name: String) throws {
            try self.dimensions.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.dimensions, name: "dimensions", parent: name, max: 10)
            try self.validate(self.dimensions, name: "dimensions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case type = "Type"
        }
    }

    public struct FlowDefinition: AWSEncodableShape {
        /// A description of the flow you want to create.
        public let description: String?
        /// The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        public let flowName: String
        /// The Amazon Resource Name of the AWS Key Management Service (KMS) key you provide for encryption.
        public let kmsArn: String
        /// The configuration that controls how Customer Profiles retrieves data from the source.
        public let sourceFlowConfig: SourceFlowConfig
        /// A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        public let tasks: [Task]
        /// The trigger settings that determine how and when the flow runs.
        public let triggerConfig: TriggerConfig

        @inlinable
        public init(description: String? = nil, flowName: String, kmsArn: String, sourceFlowConfig: SourceFlowConfig, tasks: [Task], triggerConfig: TriggerConfig) {
            self.description = description
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\w!@#\\-.?,\\s]*$")
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "^[a-zA-Z0-9][\\w!@#.-]+$")
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 20)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "^arn:aws:kms:.*:[0-9]+:")
            try self.sourceFlowConfig.validate(name: "\(name).sourceFlowConfig")
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case flowName = "FlowName"
            case kmsArn = "KmsArn"
            case sourceFlowConfig = "SourceFlowConfig"
            case tasks = "Tasks"
            case triggerConfig = "TriggerConfig"
        }
    }

    public struct FoundByKeyValue: AWSDecodableShape {
        /// A searchable identifier of a customer profile.
        public let keyName: String?
        /// A list of key values.
        public let values: [String]?

        @inlinable
        public init(keyName: String? = nil, values: [String]? = nil) {
            self.keyName = keyName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case values = "Values"
        }
    }

    public struct GetAutoMergingPreviewRequest: AWSEncodableShape {
        /// How the auto-merging process should resolve conflicts between different profiles.
        public let conflictResolution: ConflictResolution
        /// A list of matching attributes that represent matching criteria.
        public let consolidation: Consolidation
        /// The unique name of the domain.
        public let domainName: String
        /// Minimum confidence score required for profiles within a matching group to be merged during the auto-merge process.
        public let minAllowedConfidenceScoreForMerging: Double?

        @inlinable
        public init(conflictResolution: ConflictResolution, consolidation: Consolidation, domainName: String, minAllowedConfidenceScoreForMerging: Double? = nil) {
            self.conflictResolution = conflictResolution
            self.consolidation = consolidation
            self.domainName = domainName
            self.minAllowedConfidenceScoreForMerging = minAllowedConfidenceScoreForMerging
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.conflictResolution, forKey: .conflictResolution)
            try container.encode(self.consolidation, forKey: .consolidation)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.minAllowedConfidenceScoreForMerging, forKey: .minAllowedConfidenceScoreForMerging)
        }

        public func validate(name: String) throws {
            try self.conflictResolution.validate(name: "\(name).conflictResolution")
            try self.consolidation.validate(name: "\(name).consolidation")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.minAllowedConfidenceScoreForMerging, name: "minAllowedConfidenceScoreForMerging", parent: name, max: 1.0)
            try self.validate(self.minAllowedConfidenceScoreForMerging, name: "minAllowedConfidenceScoreForMerging", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case conflictResolution = "ConflictResolution"
            case consolidation = "Consolidation"
            case minAllowedConfidenceScoreForMerging = "MinAllowedConfidenceScoreForMerging"
        }
    }

    public struct GetAutoMergingPreviewResponse: AWSDecodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The number of match groups in the domain that have been reviewed in this preview dry run.
        public let numberOfMatchesInSample: Int64?
        /// The number of profiles found in this preview dry run.
        public let numberOfProfilesInSample: Int64?
        /// The number of profiles that would be merged if this wasn't a preview dry run.
        public let numberOfProfilesWillBeMerged: Int64?

        @inlinable
        public init(domainName: String, numberOfMatchesInSample: Int64? = nil, numberOfProfilesInSample: Int64? = nil, numberOfProfilesWillBeMerged: Int64? = nil) {
            self.domainName = domainName
            self.numberOfMatchesInSample = numberOfMatchesInSample
            self.numberOfProfilesInSample = numberOfProfilesInSample
            self.numberOfProfilesWillBeMerged = numberOfProfilesWillBeMerged
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case numberOfMatchesInSample = "NumberOfMatchesInSample"
            case numberOfProfilesInSample = "NumberOfProfilesInSample"
            case numberOfProfilesWillBeMerged = "NumberOfProfilesWillBeMerged"
        }
    }

    public struct GetCalculatedAttributeDefinitionRequest: AWSEncodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String
        /// The unique name of the domain.
        public let domainName: String

        @inlinable
        public init(calculatedAttributeName: String, domainName: String) {
            self.calculatedAttributeName = calculatedAttributeName
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatedAttributeName, key: "CalculatedAttributeName")
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, max: 255)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, min: 1)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCalculatedAttributeDefinitionResponse: AWSDecodableShape {
        /// Mathematical expression and a list of attribute items specified in that expression.
        public let attributeDetails: AttributeDetails?
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The conditions including range, object count, and threshold for the calculated attribute.
        public let conditions: Conditions?
        /// The timestamp of when the calculated attribute definition was created.
        public let createdAt: Date?
        /// The description of the calculated attribute.
        public let description: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// The filter assigned to this calculated attribute definition.
        public let filter: Filter?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public let lastUpdatedAt: Date?
        /// The aggregation operation to perform for the calculated attribute.
        public let statistic: Statistic?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributeDetails: AttributeDetails? = nil, calculatedAttributeName: String? = nil, conditions: Conditions? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, filter: Filter? = nil, lastUpdatedAt: Date? = nil, statistic: Statistic? = nil, tags: [String: String]? = nil) {
            self.attributeDetails = attributeDetails
            self.calculatedAttributeName = calculatedAttributeName
            self.conditions = conditions
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.filter = filter
            self.lastUpdatedAt = lastUpdatedAt
            self.statistic = statistic
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributeDetails = "AttributeDetails"
            case calculatedAttributeName = "CalculatedAttributeName"
            case conditions = "Conditions"
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case filter = "Filter"
            case lastUpdatedAt = "LastUpdatedAt"
            case statistic = "Statistic"
            case tags = "Tags"
        }
    }

    public struct GetCalculatedAttributeForProfileRequest: AWSEncodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String
        /// The unique name of the domain.
        public let domainName: String
        /// The unique identifier of a customer profile.
        public let profileId: String

        @inlinable
        public init(calculatedAttributeName: String, domainName: String, profileId: String) {
            self.calculatedAttributeName = calculatedAttributeName
            self.domainName = domainName
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatedAttributeName, key: "CalculatedAttributeName")
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.profileId, key: "ProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, max: 255)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, min: 1)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCalculatedAttributeForProfileResponse: AWSDecodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// Indicates whether the calculated attributes value is based on partial data. If data is partial, it is set to true.
        public let isDataPartial: String?
        /// The value of the calculated attribute.
        public let value: String?

        @inlinable
        public init(calculatedAttributeName: String? = nil, displayName: String? = nil, isDataPartial: String? = nil, value: String? = nil) {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedAttributeName = "CalculatedAttributeName"
            case displayName = "DisplayName"
            case isDataPartial = "IsDataPartial"
            case value = "Value"
        }
    }

    public struct GetDomainRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int?
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly
        /// batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every
        /// Saturday at 12AM UTC to detect duplicate profiles in your domains.  After the Identity Resolution Job completes, use the
        /// GetMatches
        /// API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from
        /// S3.
        public let matching: MatchingResponse?
        /// The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        public let ruleBasedMatching: RuleBasedMatchingResponse?
        /// Usage-specific statistics about the domain.
        public let stats: DomainStats?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int? = nil, domainName: String, lastUpdatedAt: Date, matching: MatchingResponse? = nil, ruleBasedMatching: RuleBasedMatchingResponse? = nil, stats: DomainStats? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.matching = matching
            self.ruleBasedMatching = ruleBasedMatching
            self.stats = stats
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case matching = "Matching"
            case ruleBasedMatching = "RuleBasedMatching"
            case stats = "Stats"
            case tags = "Tags"
        }
    }

    public struct GetEventStreamRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The name of the event stream provided during create operations.
        public let eventStreamName: String

        @inlinable
        public init(domainName: String, eventStreamName: String) {
            self.domainName = domainName
            self.eventStreamName = eventStreamName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.eventStreamName, key: "EventStreamName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, max: 64)
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, min: 1)
            try self.validate(self.eventStreamName, name: "eventStreamName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventStreamResponse: AWSDecodableShape {
        /// The timestamp of when the export was created.
        public let createdAt: Date
        /// Details regarding the Kinesis stream.
        public let destinationDetails: EventStreamDestinationDetails
        /// The unique name of the domain.
        public let domainName: String
        /// A unique identifier for the event stream.
        public let eventStreamArn: String
        /// The operational state of destination stream for export.
        public let state: EventStreamState
        /// The timestamp when the State changed to STOPPED.
        public let stoppedSince: Date?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, destinationDetails: EventStreamDestinationDetails, domainName: String, eventStreamArn: String, state: EventStreamState, stoppedSince: Date? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.destinationDetails = destinationDetails
            self.domainName = domainName
            self.eventStreamArn = eventStreamArn
            self.state = state
            self.stoppedSince = stoppedSince
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case destinationDetails = "DestinationDetails"
            case domainName = "DomainName"
            case eventStreamArn = "EventStreamArn"
            case state = "State"
            case stoppedSince = "StoppedSince"
            case tags = "Tags"
        }
    }

    public struct GetEventTriggerRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The unique name of the event trigger.
        public let eventTriggerName: String

        @inlinable
        public init(domainName: String, eventTriggerName: String) {
            self.domainName = domainName
            self.eventTriggerName = eventTriggerName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.eventTriggerName, key: "EventTriggerName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, max: 64)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, min: 1)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventTriggerResponse: AWSDecodableShape {
        /// The timestamp of when the event trigger was created.
        public let createdAt: Date?
        /// The description of the event trigger.
        public let description: String?
        /// A list of conditions that determine when an event should trigger the destination.
        public let eventTriggerConditions: [EventTriggerCondition]?
        /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
        public let eventTriggerLimits: EventTriggerLimits?
        /// The unique name of the event trigger.
        public let eventTriggerName: String?
        /// The timestamp of when the event trigger was most recently updated.
        public let lastUpdatedAt: Date?
        /// The unique name of the object type.
        public let objectTypeName: String?
        /// The destination is triggered only for profiles that meet the criteria of a segment definition.
        public let segmentFilter: String?
        /// An array of key-value pairs to apply to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, eventTriggerConditions: [EventTriggerCondition]? = nil, eventTriggerLimits: EventTriggerLimits? = nil, eventTriggerName: String? = nil, lastUpdatedAt: Date? = nil, objectTypeName: String? = nil, segmentFilter: String? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.eventTriggerConditions = eventTriggerConditions
            self.eventTriggerLimits = eventTriggerLimits
            self.eventTriggerName = eventTriggerName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.segmentFilter = segmentFilter
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case eventTriggerConditions = "EventTriggerConditions"
            case eventTriggerLimits = "EventTriggerLimits"
            case eventTriggerName = "EventTriggerName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case segmentFilter = "SegmentFilter"
            case tags = "Tags"
        }
    }

    public struct GetIdentityResolutionJobRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The unique identifier of the Identity Resolution Job.
        public let jobId: String

        @inlinable
        public init(domainName: String, jobId: String) {
            self.domainName = domainName
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.jobId, key: "JobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdentityResolutionJobResponse: AWSDecodableShape {
        /// Configuration settings for how to perform the auto-merging of profiles.
        public let autoMerging: AutoMerging?
        /// The unique name of the domain.
        public let domainName: String?
        /// The S3 location where the Identity Resolution Job writes result files.
        public let exportingLocation: ExportingLocation?
        /// The timestamp of when the Identity Resolution Job was completed.
        public let jobEndTime: Date?
        /// The timestamp of when the Identity Resolution Job will expire.
        public let jobExpirationTime: Date?
        /// The unique identifier of the Identity Resolution Job.
        public let jobId: String?
        /// The timestamp of when the Identity Resolution Job was started or will be started.
        public let jobStartTime: Date?
        /// Statistics about the Identity Resolution Job.
        public let jobStats: JobStats?
        /// The timestamp of when the Identity Resolution Job was most recently edited.
        public let lastUpdatedAt: Date?
        /// The error messages that are generated when the Identity Resolution Job runs.
        public let message: String?
        /// The status of the Identity Resolution Job.    PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.    PREPROCESSING: The Identity Resolution Job is loading your data.    FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.    MERGING: The Identity Resolution Job is merging duplicate profiles.    COMPLETED: The Identity Resolution Job completed successfully.    PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.    FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
        public let status: IdentityResolutionJobStatus?

        @inlinable
        public init(autoMerging: AutoMerging? = nil, domainName: String? = nil, exportingLocation: ExportingLocation? = nil, jobEndTime: Date? = nil, jobExpirationTime: Date? = nil, jobId: String? = nil, jobStartTime: Date? = nil, jobStats: JobStats? = nil, lastUpdatedAt: Date? = nil, message: String? = nil, status: IdentityResolutionJobStatus? = nil) {
            self.autoMerging = autoMerging
            self.domainName = domainName
            self.exportingLocation = exportingLocation
            self.jobEndTime = jobEndTime
            self.jobExpirationTime = jobExpirationTime
            self.jobId = jobId
            self.jobStartTime = jobStartTime
            self.jobStats = jobStats
            self.lastUpdatedAt = lastUpdatedAt
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case autoMerging = "AutoMerging"
            case domainName = "DomainName"
            case exportingLocation = "ExportingLocation"
            case jobEndTime = "JobEndTime"
            case jobExpirationTime = "JobExpirationTime"
            case jobId = "JobId"
            case jobStartTime = "JobStartTime"
            case jobStats = "JobStats"
            case lastUpdatedAt = "LastUpdatedAt"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct GetIntegrationRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        @inlinable
        public init(domainName: String, uri: String) {
            self.domainName = domainName
            self.uri = uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.uri, forKey: .uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "Uri"
        }
    }

    public struct GetIntegrationResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// A list of unique names for active event triggers associated with the integration. This list would be empty if no Event Trigger is associated with the integration.
        public let eventTriggerNames: [String]?
        /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
        public let isUnstructured: Bool?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The name of the profile object type.
        public let objectTypeName: String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event.
        /// It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders,
        /// ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public let objectTypeNames: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String
        /// Unique identifier for the workflow.
        public let workflowId: String?

        @inlinable
        public init(createdAt: Date, domainName: String, eventTriggerNames: [String]? = nil, isUnstructured: Bool? = nil, lastUpdatedAt: Date, objectTypeName: String? = nil, objectTypeNames: [String: String]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, uri: String, workflowId: String? = nil) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.eventTriggerNames = eventTriggerNames
            self.isUnstructured = isUnstructured
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.roleArn = roleArn
            self.tags = tags
            self.uri = uri
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case eventTriggerNames = "EventTriggerNames"
            case isUnstructured = "IsUnstructured"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case objectTypeNames = "ObjectTypeNames"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case uri = "Uri"
            case workflowId = "WorkflowId"
        }
    }

    public struct GetMatchesRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMatchesResponse: AWSDecodableShape {
        /// The list of matched profiles for this instance.
        public let matches: [MatchItem]?
        /// The timestamp this version of Match Result generated.
        public let matchGenerationDate: Date?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The number of potential matches found.
        public let potentialMatches: Int?

        @inlinable
        public init(matches: [MatchItem]? = nil, matchGenerationDate: Date? = nil, nextToken: String? = nil, potentialMatches: Int? = nil) {
            self.matches = matches
            self.matchGenerationDate = matchGenerationDate
            self.nextToken = nextToken
            self.potentialMatches = potentialMatches
        }

        private enum CodingKeys: String, CodingKey {
            case matches = "Matches"
            case matchGenerationDate = "MatchGenerationDate"
            case nextToken = "NextToken"
            case potentialMatches = "PotentialMatches"
        }
    }

    public struct GetProfileObjectTypeRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The name of the profile object type.
        public let objectTypeName: String

        @inlinable
        public init(domainName: String, objectTypeName: String) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.objectTypeName, key: "ObjectTypeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileObjectTypeResponse: AWSDecodableShape {
        /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// The timestamp of when the domain was created.
        public let createdAt: Date?
        /// The description of the profile object type.
        public let description: String
        /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
        public let encryptionKey: String?
        /// The number of days until the data in the object expires.
        public let expirationDays: Int?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date?
        /// The amount of provisioned profile object max count available.
        public let maxAvailableProfileObjectCount: Int?
        /// The amount of profile object max count assigned to the object type.
        public let maxProfileObjectCount: Int?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The format of your sourceLastUpdatedTimestamp that was previously set up.
        public let sourceLastUpdatedTimestampFormat: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier for the object template.
        public let templateId: String?

        @inlinable
        public init(allowProfileCreation: Bool? = nil, createdAt: Date? = nil, description: String, encryptionKey: String? = nil, expirationDays: Int? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, lastUpdatedAt: Date? = nil, maxAvailableProfileObjectCount: Int? = nil, maxProfileObjectCount: Int? = nil, objectTypeName: String, sourceLastUpdatedTimestampFormat: String? = nil, tags: [String: String]? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.createdAt = createdAt
            self.description = description
            self.encryptionKey = encryptionKey
            self.expirationDays = expirationDays
            self.fields = fields
            self.keys = keys
            self.lastUpdatedAt = lastUpdatedAt
            self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
            self.maxProfileObjectCount = maxProfileObjectCount
            self.objectTypeName = objectTypeName
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case createdAt = "CreatedAt"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case expirationDays = "ExpirationDays"
            case fields = "Fields"
            case keys = "Keys"
            case lastUpdatedAt = "LastUpdatedAt"
            case maxAvailableProfileObjectCount = "MaxAvailableProfileObjectCount"
            case maxProfileObjectCount = "MaxProfileObjectCount"
            case objectTypeName = "ObjectTypeName"
            case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
            case tags = "Tags"
            case templateId = "TemplateId"
        }
    }

    public struct GetProfileObjectTypeTemplateRequest: AWSEncodableShape {
        /// A unique identifier for the object template.
        public let templateId: String

        @inlinable
        public init(templateId: String) {
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.templateId, name: "templateId", parent: name, max: 64)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileObjectTypeTemplateResponse: AWSDecodableShape {
        /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The format of your sourceLastUpdatedTimestamp that was previously set up.
        public let sourceLastUpdatedTimestampFormat: String?
        /// The name of the source of the object template.
        public let sourceName: String?
        /// The source of the object template.
        public let sourceObject: String?
        /// A unique identifier for the object template.
        public let templateId: String?

        @inlinable
        public init(allowProfileCreation: Bool? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, sourceLastUpdatedTimestampFormat: String? = nil, sourceName: String? = nil, sourceObject: String? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.fields = fields
            self.keys = keys
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case fields = "Fields"
            case keys = "Keys"
            case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
            case sourceName = "SourceName"
            case sourceObject = "SourceObject"
            case templateId = "TemplateId"
        }
    }

    public struct GetSegmentDefinitionRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The unique name of the segment definition.
        public let segmentDefinitionName: String

        @inlinable
        public init(domainName: String, segmentDefinitionName: String) {
            self.domainName = domainName
            self.segmentDefinitionName = segmentDefinitionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.segmentDefinitionName, key: "SegmentDefinitionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSegmentDefinitionResponse: AWSDecodableShape {
        /// The timestamp of when the segment definition was created.
        public let createdAt: Date?
        /// The description of the segment definition.
        public let description: String?
        /// The display name of the segment definition.
        public let displayName: String?
        /// The arn of the segment definition.
        public let segmentDefinitionArn: String
        /// The name of the segment definition.
        public let segmentDefinitionName: String?
        /// The segment criteria associated with this definition.
        public let segmentGroups: SegmentGroup?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, segmentDefinitionArn: String, segmentDefinitionName: String? = nil, segmentGroups: SegmentGroup? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.segmentDefinitionArn = segmentDefinitionArn
            self.segmentDefinitionName = segmentDefinitionName
            self.segmentGroups = segmentGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case segmentDefinitionArn = "SegmentDefinitionArn"
            case segmentDefinitionName = "SegmentDefinitionName"
            case segmentGroups = "SegmentGroups"
            case tags = "Tags"
        }
    }

    public struct GetSegmentEstimateRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The query Id passed by a previous CreateSegmentEstimate operation.
        public let estimateId: String

        @inlinable
        public init(domainName: String, estimateId: String) {
            self.domainName = domainName
            self.estimateId = estimateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.estimateId, key: "EstimateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.estimateId, name: "estimateId", parent: name, max: 255)
            try self.validate(self.estimateId, name: "estimateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSegmentEstimateResponse: AWSDecodableShape {
        /// The unique name of the domain.
        public let domainName: String?
        /// The estimated number of profiles contained in the segment.
        public let estimate: String?
        /// The QueryId which is the same as the value passed in QueryId.
        public let estimateId: String?
        /// The error message if there is any error.
        public let message: String?
        /// The current status of the query.
        public let status: EstimateStatus?
        /// The status code of the segment estimate.
        public let statusCode: Int?

        @inlinable
        public init(domainName: String? = nil, estimate: String? = nil, estimateId: String? = nil, message: String? = nil, status: EstimateStatus? = nil, statusCode: Int? = nil) {
            self.domainName = domainName
            self.estimate = estimate
            self.estimateId = estimateId
            self.message = message
            self.status = status
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.domainName = try container.decodeIfPresent(String.self, forKey: .domainName)
            self.estimate = try container.decodeIfPresent(String.self, forKey: .estimate)
            self.estimateId = try container.decodeIfPresent(String.self, forKey: .estimateId)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.status = try container.decodeIfPresent(EstimateStatus.self, forKey: .status)
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case estimate = "Estimate"
            case estimateId = "EstimateId"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct GetSegmentMembershipRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The list of profile IDs to query for.
        public let profileIds: [String]
        /// The Id of the wanted segment. Needs to be a valid, and existing segment Id.
        public let segmentDefinitionName: String

        @inlinable
        public init(domainName: String, profileIds: [String], segmentDefinitionName: String) {
            self.domainName = domainName
            self.profileIds = profileIds
            self.segmentDefinitionName = segmentDefinitionName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.profileIds, forKey: .profileIds)
            request.encodePath(self.segmentDefinitionName, key: "SegmentDefinitionName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.profileIds.forEach {
                try validate($0, name: "profileIds[]", parent: name, pattern: "^[a-f0-9]{32}$")
            }
            try self.validate(self.profileIds, name: "profileIds", parent: name, max: 100)
            try self.validate(self.profileIds, name: "profileIds", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case profileIds = "ProfileIds"
        }
    }

    public struct GetSegmentMembershipResponse: AWSDecodableShape {
        /// An array of maps where each contains a response per profile failed for the request.
        public let failures: [ProfileQueryFailures]?
        /// An array of maps where each contains a response per profile requested.
        public let profiles: [ProfileQueryResult]?
        /// The unique name of the segment definition.
        public let segmentDefinitionName: String?

        @inlinable
        public init(failures: [ProfileQueryFailures]? = nil, profiles: [ProfileQueryResult]? = nil, segmentDefinitionName: String? = nil) {
            self.failures = failures
            self.profiles = profiles
            self.segmentDefinitionName = segmentDefinitionName
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "Failures"
            case profiles = "Profiles"
            case segmentDefinitionName = "SegmentDefinitionName"
        }
    }

    public struct GetSegmentSnapshotRequest: AWSEncodableShape {
        /// The unique identifier of the domain.
        public let domainName: String
        /// The unique name of the segment definition.
        public let segmentDefinitionName: String
        /// The unique identifier of the segment snapshot.
        public let snapshotId: String

        @inlinable
        public init(domainName: String, segmentDefinitionName: String, snapshotId: String) {
            self.domainName = domainName
            self.segmentDefinitionName = segmentDefinitionName
            self.snapshotId = snapshotId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.segmentDefinitionName, key: "SegmentDefinitionName")
            request.encodePath(self.snapshotId, key: "SnapshotId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSegmentSnapshotResponse: AWSDecodableShape {
        /// The format in which the segment will be exported.
        public let dataFormat: DataFormat
        /// The destination to which the segment will be exported. This field must be provided if the request is not submitted from the Amazon Connect Admin Website.
        public let destinationUri: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the exported segment.
        public let encryptionKey: String?
        /// The Amazon Resource Name (ARN) of the IAM role that allows Customer Profiles service principal to assume the role for conducting KMS and S3 operations.
        public let roleArn: String?
        /// The unique identifier of the segment snapshot.
        public let snapshotId: String
        /// The status of the asynchronous job for exporting the segment snapshot.
        public let status: SegmentSnapshotStatus
        /// The status message of the asynchronous job for exporting the segment snapshot.
        public let statusMessage: String?

        @inlinable
        public init(dataFormat: DataFormat, destinationUri: String? = nil, encryptionKey: String? = nil, roleArn: String? = nil, snapshotId: String, status: SegmentSnapshotStatus, statusMessage: String? = nil) {
            self.dataFormat = dataFormat
            self.destinationUri = destinationUri
            self.encryptionKey = encryptionKey
            self.roleArn = roleArn
            self.snapshotId = snapshotId
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case dataFormat = "DataFormat"
            case destinationUri = "DestinationUri"
            case encryptionKey = "EncryptionKey"
            case roleArn = "RoleArn"
            case snapshotId = "SnapshotId"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct GetSimilarProfilesRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// Specify the type of matching to get similar profiles for.
        public let matchType: MatchType
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous GetSimilarProfiles API call.
        public let nextToken: String?
        /// The string indicating the search key to be used.
        public let searchKey: String
        /// The string based on SearchKey to be searched for similar profiles.
        public let searchValue: String

        @inlinable
        public init(domainName: String, matchType: MatchType, maxResults: Int? = nil, nextToken: String? = nil, searchKey: String, searchValue: String) {
            self.domainName = domainName
            self.matchType = matchType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchKey = searchKey
            self.searchValue = searchValue
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.matchType, forKey: .matchType)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            try container.encode(self.searchKey, forKey: .searchKey)
            try container.encode(self.searchValue, forKey: .searchValue)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.searchKey, name: "searchKey", parent: name, max: 255)
            try self.validate(self.searchKey, name: "searchKey", parent: name, min: 1)
            try self.validate(self.searchValue, name: "searchValue", parent: name, max: 255)
            try self.validate(self.searchValue, name: "searchValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case matchType = "MatchType"
            case searchKey = "SearchKey"
            case searchValue = "SearchValue"
        }
    }

    public struct GetSimilarProfilesResponse: AWSDecodableShape {
        /// It only has value when the MatchType is ML_BASED_MATCHING.A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used as an absolute measure of matching quality.
        public let confidenceScore: Double?
        /// The string matchId that the similar profiles belong to.
        public let matchId: String?
        /// Specify the type of matching to get similar profiles for.
        public let matchType: MatchType?
        /// The pagination token from the previous GetSimilarProfiles API call.
        public let nextToken: String?
        /// Set of profileIds that belong to the same matching group.
        public let profileIds: [String]?
        /// The integer rule level that the profiles matched on.
        public let ruleLevel: Int?

        @inlinable
        public init(confidenceScore: Double? = nil, matchId: String? = nil, matchType: MatchType? = nil, nextToken: String? = nil, profileIds: [String]? = nil, ruleLevel: Int? = nil) {
            self.confidenceScore = confidenceScore
            self.matchId = matchId
            self.matchType = matchType
            self.nextToken = nextToken
            self.profileIds = profileIds
            self.ruleLevel = ruleLevel
        }

        private enum CodingKeys: String, CodingKey {
            case confidenceScore = "ConfidenceScore"
            case matchId = "MatchId"
            case matchType = "MatchType"
            case nextToken = "NextToken"
            case profileIds = "ProfileIds"
            case ruleLevel = "RuleLevel"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// Unique identifier for the workflow.
        public let workflowId: String

        @inlinable
        public init(domainName: String, workflowId: String) {
            self.domainName = domainName
            self.workflowId = workflowId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.workflowId, key: "WorkflowId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.workflowId, name: "workflowId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// Attributes provided for workflow execution.
        public let attributes: WorkflowAttributes?
        /// Workflow error messages during execution (if any).
        public let errorDescription: String?
        /// The timestamp that represents when workflow execution last updated.
        public let lastUpdatedAt: Date?
        /// Workflow specific execution metrics.
        public let metrics: WorkflowMetrics?
        /// The timestamp that represents when workflow execution started.
        public let startDate: Date?
        /// Status of workflow execution.
        public let status: Status?
        /// Unique identifier for the workflow.
        public let workflowId: String?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        public let workflowType: WorkflowType?

        @inlinable
        public init(attributes: WorkflowAttributes? = nil, errorDescription: String? = nil, lastUpdatedAt: Date? = nil, metrics: WorkflowMetrics? = nil, startDate: Date? = nil, status: Status? = nil, workflowId: String? = nil, workflowType: WorkflowType? = nil) {
            self.attributes = attributes
            self.errorDescription = errorDescription
            self.lastUpdatedAt = lastUpdatedAt
            self.metrics = metrics
            self.startDate = startDate
            self.status = status
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case errorDescription = "ErrorDescription"
            case lastUpdatedAt = "LastUpdatedAt"
            case metrics = "Metrics"
            case startDate = "StartDate"
            case status = "Status"
            case workflowId = "WorkflowId"
            case workflowType = "WorkflowType"
        }
    }

    public struct GetWorkflowStepsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// Unique identifier for the workflow.
        public let workflowId: String

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil, workflowId: String) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workflowId = workflowId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.workflowId, key: "WorkflowId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.workflowId, name: "workflowId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkflowStepsResponse: AWSDecodableShape {
        /// List containing workflow step details.
        public let items: [WorkflowStepItem]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Unique identifier for the workflow.
        public let workflowId: String?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        public let workflowType: WorkflowType?

        @inlinable
        public init(items: [WorkflowStepItem]? = nil, nextToken: String? = nil, workflowId: String? = nil, workflowType: WorkflowType? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
            case workflowId = "WorkflowId"
            case workflowType = "WorkflowType"
        }
    }

    public struct Group: AWSEncodableShape & AWSDecodableShape {
        /// Defines the attributes to segment on.
        public let dimensions: [Dimension]?
        /// Defines the starting source of data.
        public let sourceSegments: [SourceSegment]?
        /// Defines how to interact with the source data.
        public let sourceType: IncludeOptions?
        /// Defines how to interact with the profiles found in the current filtering.
        public let type: IncludeOptions?

        @inlinable
        public init(dimensions: [Dimension]? = nil, sourceSegments: [SourceSegment]? = nil, sourceType: IncludeOptions? = nil, type: IncludeOptions? = nil) {
            self.dimensions = dimensions
            self.sourceSegments = sourceSegments
            self.sourceType = sourceType
            self.type = type
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.sourceSegments?.forEach {
                try $0.validate(name: "\(name).sourceSegments[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case sourceSegments = "SourceSegments"
            case sourceType = "SourceType"
            case type = "Type"
        }
    }

    public struct IdentityResolutionJob: AWSDecodableShape {
        /// The unique name of the domain.
        public let domainName: String?
        /// The S3 location where the Identity Resolution Job writes result files.
        public let exportingLocation: ExportingLocation?
        /// The timestamp of when the job was completed.
        public let jobEndTime: Date?
        /// The unique identifier of the Identity Resolution Job.
        public let jobId: String?
        /// The timestamp of when the job was started or will be started.
        public let jobStartTime: Date?
        /// Statistics about an Identity Resolution Job.
        public let jobStats: JobStats?
        /// The error messages that are generated when the Identity Resolution Job runs.
        public let message: String?
        /// The status of the Identity Resolution Job.    PENDING: The Identity Resolution Job is scheduled but has not started yet. If you turn off the Identity Resolution feature in your domain, jobs in the PENDING state are deleted.    PREPROCESSING: The Identity Resolution Job is loading your data.    FIND_MATCHING: The Identity Resolution Job is using the machine learning model to identify profiles that belong to the same matching group.    MERGING: The Identity Resolution Job is merging duplicate profiles.    COMPLETED: The Identity Resolution Job completed successfully.    PARTIAL_SUCCESS: There's a system error and not all of the data is merged. The Identity Resolution Job writes a message indicating the source of the problem.    FAILED: The Identity Resolution Job did not merge any data. It writes a message indicating the source of the problem.
        public let status: IdentityResolutionJobStatus?

        @inlinable
        public init(domainName: String? = nil, exportingLocation: ExportingLocation? = nil, jobEndTime: Date? = nil, jobId: String? = nil, jobStartTime: Date? = nil, jobStats: JobStats? = nil, message: String? = nil, status: IdentityResolutionJobStatus? = nil) {
            self.domainName = domainName
            self.exportingLocation = exportingLocation
            self.jobEndTime = jobEndTime
            self.jobId = jobId
            self.jobStartTime = jobStartTime
            self.jobStats = jobStats
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case exportingLocation = "ExportingLocation"
            case jobEndTime = "JobEndTime"
            case jobId = "JobId"
            case jobStartTime = "JobStartTime"
            case jobStats = "JobStats"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct IncrementalPullConfig: AWSEncodableShape {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public let datetimeTypeFieldName: String?

        @inlinable
        public init(datetimeTypeFieldName: String? = nil) {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }

        public func validate(name: String) throws {
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, max: 256)
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case datetimeTypeFieldName = "DatetimeTypeFieldName"
        }
    }

    public struct IntegrationConfig: AWSEncodableShape {
        /// Configuration data for APPFLOW_INTEGRATION workflow type.
        public let appflowIntegration: AppflowIntegration?

        @inlinable
        public init(appflowIntegration: AppflowIntegration? = nil) {
            self.appflowIntegration = appflowIntegration
        }

        public func validate(name: String) throws {
            try self.appflowIntegration?.validate(name: "\(name).appflowIntegration")
        }

        private enum CodingKeys: String, CodingKey {
            case appflowIntegration = "AppflowIntegration"
        }
    }

    public struct JobSchedule: AWSEncodableShape & AWSDecodableShape {
        /// The day when the Identity Resolution Job should run every week.
        public let dayOfTheWeek: JobScheduleDayOfTheWeek
        /// The time when the Identity Resolution Job should run every week.
        public let time: String

        @inlinable
        public init(dayOfTheWeek: JobScheduleDayOfTheWeek, time: String) {
            self.dayOfTheWeek = dayOfTheWeek
            self.time = time
        }

        public func validate(name: String) throws {
            try self.validate(self.time, name: "time", parent: name, max: 5)
            try self.validate(self.time, name: "time", parent: name, min: 3)
            try self.validate(self.time, name: "time", parent: name, pattern: "^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfTheWeek = "DayOfTheWeek"
            case time = "Time"
        }
    }

    public struct JobStats: AWSDecodableShape {
        /// The number of matches found.
        public let numberOfMatchesFound: Int64?
        /// The number of merges completed.
        public let numberOfMergesDone: Int64?
        /// The number of profiles reviewed.
        public let numberOfProfilesReviewed: Int64?

        @inlinable
        public init(numberOfMatchesFound: Int64? = nil, numberOfMergesDone: Int64? = nil, numberOfProfilesReviewed: Int64? = nil) {
            self.numberOfMatchesFound = numberOfMatchesFound
            self.numberOfMergesDone = numberOfMergesDone
            self.numberOfProfilesReviewed = numberOfProfilesReviewed
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfMatchesFound = "NumberOfMatchesFound"
            case numberOfMergesDone = "NumberOfMergesDone"
            case numberOfProfilesReviewed = "NumberOfProfilesReviewed"
        }
    }

    public struct ListAccountIntegrationsRequest: AWSEncodableShape {
        /// Boolean to indicate if hidden integration should be returned. Defaults to False.
        public let includeHidden: Bool?
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListAccountIntegrations API call.
        public let nextToken: String?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        @inlinable
        public init(includeHidden: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, uri: String) {
            self.includeHidden = includeHidden
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.uri = uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeHidden, key: "include-hidden")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            try container.encode(self.uri, forKey: .uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "Uri"
        }
    }

    public struct ListAccountIntegrationsResponse: AWSDecodableShape {
        /// The list of ListAccountIntegration instances.
        public let items: [ListIntegrationItem]?
        /// The pagination token from the previous ListAccountIntegrations API call.
        public let nextToken: String?

        @inlinable
        public init(items: [ListIntegrationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListCalculatedAttributeDefinitionItem: AWSDecodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The threshold for the calculated attribute.
        public let createdAt: Date?
        /// The threshold for the calculated attribute.
        public let description: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public let lastUpdatedAt: Date?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(calculatedAttributeName: String? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, lastUpdatedAt: Date? = nil, tags: [String: String]? = nil) {
            self.calculatedAttributeName = calculatedAttributeName
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedAttributeName = "CalculatedAttributeName"
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case lastUpdatedAt = "LastUpdatedAt"
            case tags = "Tags"
        }
    }

    public struct ListCalculatedAttributeDefinitionsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of calculated attribute definitions returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCalculatedAttributeDefinitionsResponse: AWSDecodableShape {
        /// The list of calculated attribute definitions.
        public let items: [ListCalculatedAttributeDefinitionItem]?
        /// The pagination token from the previous call to ListCalculatedAttributeDefinitions.
        public let nextToken: String?

        @inlinable
        public init(items: [ListCalculatedAttributeDefinitionItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListCalculatedAttributeForProfileItem: AWSDecodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// Indicates whether the calculated attributes value is based on partial data. If data is partial, it is set to true.
        public let isDataPartial: String?
        /// The value of the calculated attribute.
        public let value: String?

        @inlinable
        public init(calculatedAttributeName: String? = nil, displayName: String? = nil, isDataPartial: String? = nil, value: String? = nil) {
            self.calculatedAttributeName = calculatedAttributeName
            self.displayName = displayName
            self.isDataPartial = isDataPartial
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedAttributeName = "CalculatedAttributeName"
            case displayName = "DisplayName"
            case isDataPartial = "IsDataPartial"
            case value = "Value"
        }
    }

    public struct ListCalculatedAttributesForProfileRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of calculated attributes returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
        public let nextToken: String?
        /// The unique identifier of a customer profile.
        public let profileId: String

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil, profileId: String) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.profileId, key: "ProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCalculatedAttributesForProfileResponse: AWSDecodableShape {
        /// The list of calculated attributes.
        public let items: [ListCalculatedAttributeForProfileItem]?
        /// The pagination token from the previous call to ListCalculatedAttributesForProfile.
        public let nextToken: String?

        @inlinable
        public init(items: [ListCalculatedAttributeForProfileItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListDomainItem: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, domainName: String, lastUpdatedAt: Date, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case tags = "Tags"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListDomain API call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The list of ListDomains instances.
        public let items: [ListDomainItem]?
        /// The pagination token from the previous ListDomains API call.
        public let nextToken: String?

        @inlinable
        public init(items: [ListDomainItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventStreamsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventStreamsResponse: AWSDecodableShape {
        /// Contains summary information about an EventStream.
        public let items: [EventStreamSummary]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(items: [EventStreamSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventTriggersRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The pagination token to use with ListEventTriggers.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventTriggersResponse: AWSDecodableShape {
        /// The list of Event Triggers.
        public let items: [EventTriggerSummaryItem]?
        /// The pagination token from the previous call to ListEventTriggers.
        public let nextToken: String?

        @inlinable
        public init(items: [EventTriggerSummaryItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListIdentityResolutionJobsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdentityResolutionJobsResponse: AWSDecodableShape {
        /// A list of Identity Resolution Jobs.
        public let identityResolutionJobsList: [IdentityResolutionJob]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(identityResolutionJobsList: [IdentityResolutionJob]? = nil, nextToken: String? = nil) {
            self.identityResolutionJobsList = identityResolutionJobsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case identityResolutionJobsList = "IdentityResolutionJobsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListIntegrationItem: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// A list of unique names for active event triggers associated with the integration.
        public let eventTriggerNames: [String]?
        /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
        public let isUnstructured: Bool?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The name of the profile object type.
        public let objectTypeName: String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event.
        /// It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders,
        /// ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public let objectTypeNames: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String
        /// Unique identifier for the workflow.
        public let workflowId: String?

        @inlinable
        public init(createdAt: Date, domainName: String, eventTriggerNames: [String]? = nil, isUnstructured: Bool? = nil, lastUpdatedAt: Date, objectTypeName: String? = nil, objectTypeNames: [String: String]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, uri: String, workflowId: String? = nil) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.eventTriggerNames = eventTriggerNames
            self.isUnstructured = isUnstructured
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.roleArn = roleArn
            self.tags = tags
            self.uri = uri
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case eventTriggerNames = "EventTriggerNames"
            case isUnstructured = "IsUnstructured"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case objectTypeNames = "ObjectTypeNames"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case uri = "Uri"
            case workflowId = "WorkflowId"
        }
    }

    public struct ListIntegrationsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// Boolean to indicate if hidden integration should be returned. Defaults to False.
        public let includeHidden: Bool?
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListIntegrations API call.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, includeHidden: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.includeHidden = includeHidden
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.includeHidden, key: "include-hidden")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIntegrationsResponse: AWSDecodableShape {
        /// The list of ListIntegrations instances.
        public let items: [ListIntegrationItem]?
        /// The pagination token from the previous ListIntegrations API call.
        public let nextToken: String?

        @inlinable
        public init(items: [ListIntegrationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListObjectTypeAttributeItem: AWSDecodableShape {
        /// Name of the attribute.
        public let attributeName: String
        /// When the attribute was last updated.
        public let lastUpdatedAt: Date

        @inlinable
        public init(attributeName: String, lastUpdatedAt: Date) {
            self.attributeName = attributeName
            self.lastUpdatedAt = lastUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case lastUpdatedAt = "LastUpdatedAt"
        }
    }

    public struct ListObjectTypeAttributesRequest: AWSEncodableShape {
        /// The unique identifier of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous call.
        public let nextToken: String?
        /// The name of the profile object type.
        public let objectTypeName: String

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil, objectTypeName: String) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectTypeName = objectTypeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.objectTypeName, key: "ObjectTypeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListObjectTypeAttributesResponse: AWSDecodableShape {
        /// The items returned as part of the response.
        public let items: [ListObjectTypeAttributeItem]?
        /// The pagination token from the previous call.
        public let nextToken: String?

        @inlinable
        public init(items: [ListObjectTypeAttributeItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListProfileObjectTypeItem: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date?
        /// Description of the profile object type.
        public let description: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date?
        /// The amount of provisioned profile object max count available.
        public let maxAvailableProfileObjectCount: Int?
        /// The amount of profile object max count assigned to the object type.
        public let maxProfileObjectCount: Int?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String, lastUpdatedAt: Date? = nil, maxAvailableProfileObjectCount: Int? = nil, maxProfileObjectCount: Int? = nil, objectTypeName: String, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
            self.maxProfileObjectCount = maxProfileObjectCount
            self.objectTypeName = objectTypeName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case lastUpdatedAt = "LastUpdatedAt"
            case maxAvailableProfileObjectCount = "MaxAvailableProfileObjectCount"
            case maxProfileObjectCount = "MaxProfileObjectCount"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
        }
    }

    public struct ListProfileObjectTypeTemplateItem: AWSDecodableShape {
        /// The name of the source of the object template.
        public let sourceName: String?
        /// The source of the object template.
        public let sourceObject: String?
        /// A unique identifier for the object template.
        public let templateId: String?

        @inlinable
        public init(sourceName: String? = nil, sourceObject: String? = nil, templateId: String? = nil) {
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case sourceName = "SourceName"
            case sourceObject = "SourceObject"
            case templateId = "TemplateId"
        }
    }

    public struct ListProfileObjectTypeTemplatesRequest: AWSEncodableShape {
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListObjectTypeTemplates API call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfileObjectTypeTemplatesResponse: AWSDecodableShape {
        /// The list of ListProfileObjectType template instances.
        public let items: [ListProfileObjectTypeTemplateItem]?
        /// The pagination token from the previous ListObjectTypeTemplates API call.
        public let nextToken: String?

        @inlinable
        public init(items: [ListProfileObjectTypeTemplateItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListProfileObjectTypesRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfileObjectTypesResponse: AWSDecodableShape {
        /// The list of ListProfileObjectTypes instances.
        public let items: [ListProfileObjectTypeItem]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        @inlinable
        public init(items: [ListProfileObjectTypeItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListProfileObjectsItem: AWSDecodableShape {
        /// A JSON representation of a ProfileObject that belongs to a profile.
        public let object: String?
        /// Specifies the kind of object being added to a profile, such as "Salesforce-Account."
        public let objectTypeName: String?
        /// The unique identifier of the ProfileObject generated by the service.
        public let profileObjectUniqueKey: String?

        @inlinable
        public init(object: String? = nil, objectTypeName: String? = nil, profileObjectUniqueKey: String? = nil) {
            self.object = object
            self.objectTypeName = objectTypeName
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
            case objectTypeName = "ObjectTypeName"
            case profileObjectUniqueKey = "ProfileObjectUniqueKey"
        }
    }

    public struct ListProfileObjectsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous call to ListProfileObjects.
        public let nextToken: String?
        /// Applies a filter to the response to include profile objects with the specified index values.
        public let objectFilter: ObjectFilter?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The unique identifier of a customer profile.
        public let profileId: String

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil, objectFilter: ObjectFilter? = nil, objectTypeName: String, profileId: String) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectFilter = objectFilter
            self.objectTypeName = objectTypeName
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            try container.encodeIfPresent(self.objectFilter, forKey: .objectFilter)
            try container.encode(self.objectTypeName, forKey: .objectTypeName)
            try container.encode(self.profileId, forKey: .profileId)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.objectFilter?.validate(name: "\(name).objectFilter")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case objectFilter = "ObjectFilter"
            case objectTypeName = "ObjectTypeName"
            case profileId = "ProfileId"
        }
    }

    public struct ListProfileObjectsResponse: AWSDecodableShape {
        /// The list of ListProfileObject instances.
        public let items: [ListProfileObjectsItem]?
        /// The pagination token from the previous call to ListProfileObjects.
        public let nextToken: String?

        @inlinable
        public init(items: [ListProfileObjectsItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListRuleBasedMatchesRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of MatchIds returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListRuleBasedMatches API call.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRuleBasedMatchesResponse: AWSDecodableShape {
        /// The list of MatchIds for the given domain.
        public let matchIds: [String]?
        /// The pagination token from the previous ListRuleBasedMatches API call.
        public let nextToken: String?

        @inlinable
        public init(matchIds: [String]? = nil, nextToken: String? = nil) {
            self.matchIds = matchIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case matchIds = "MatchIds"
            case nextToken = "NextToken"
        }
    }

    public struct ListSegmentDefinitionsRequest: AWSEncodableShape {
        /// The unique identifier of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous call.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSegmentDefinitionsResponse: AWSDecodableShape {
        /// List of segment definitions.
        public let items: [SegmentDefinitionItem]?
        /// The pagination token from the previous call.
        public let nextToken: String?

        @inlinable
        public init(items: [SegmentDefinitionItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9]{1,10}:profile$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkflowsItem: AWSDecodableShape {
        /// Creation timestamp for workflow.
        public let createdAt: Date
        /// Last updated timestamp for workflow.
        public let lastUpdatedAt: Date
        /// Status of workflow execution.
        public let status: Status
        /// Description for workflow execution status.
        public let statusDescription: String
        /// Unique identifier for the workflow.
        public let workflowId: String
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        public let workflowType: WorkflowType

        @inlinable
        public init(createdAt: Date, lastUpdatedAt: Date, status: Status, statusDescription: String, workflowId: String, workflowType: WorkflowType) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusDescription = statusDescription
            self.workflowId = workflowId
            self.workflowType = workflowType
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case lastUpdatedAt = "LastUpdatedAt"
            case status = "Status"
            case statusDescription = "StatusDescription"
            case workflowId = "WorkflowId"
            case workflowType = "WorkflowType"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// Retrieve workflows ended after timestamp.
        public let queryEndDate: Date?
        /// Retrieve workflows started after timestamp.
        public let queryStartDate: Date?
        /// Status of workflow execution.
        public let status: Status?
        /// The type of workflow. The only supported value is APPFLOW_INTEGRATION.
        public let workflowType: WorkflowType?

        @inlinable
        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil, queryEndDate: Date? = nil, queryStartDate: Date? = nil, status: Status? = nil, workflowType: WorkflowType? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryEndDate = queryEndDate
            self.queryStartDate = queryStartDate
            self.status = status
            self.workflowType = workflowType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            try container.encodeIfPresent(self.queryEndDate, forKey: .queryEndDate)
            try container.encodeIfPresent(self.queryStartDate, forKey: .queryStartDate)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.workflowType, forKey: .workflowType)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queryEndDate = "QueryEndDate"
            case queryStartDate = "QueryStartDate"
            case status = "Status"
            case workflowType = "WorkflowType"
        }
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// List containing workflow details.
        public let items: [ListWorkflowsItem]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ListWorkflowsItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct MarketoSourceProperties: AWSEncodableShape {
        /// The object specified in the Marketo flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
        }
    }

    public struct MatchItem: AWSDecodableShape {
        /// A number between 0 and 1, where a higher score means higher similarity. Examining match confidence scores lets you distinguish between groups of similar records in which the system is highly confident (which you may decide to merge), groups of similar records about which the system is uncertain (which you may decide to have reviewed by a human), and groups of similar records that the system deems to be unlikely (which you may decide to reject). Given confidence scores vary as per the data input, it should not be used an absolute measure of matching quality.
        public let confidenceScore: Double?
        /// The unique identifiers for this group of profiles that match.
        public let matchId: String?
        /// A list of identifiers for profiles that match.
        public let profileIds: [String]?

        @inlinable
        public init(confidenceScore: Double? = nil, matchId: String? = nil, profileIds: [String]? = nil) {
            self.confidenceScore = confidenceScore
            self.matchId = matchId
            self.profileIds = profileIds
        }

        private enum CodingKeys: String, CodingKey {
            case confidenceScore = "ConfidenceScore"
            case matchId = "MatchId"
            case profileIds = "ProfileIds"
        }
    }

    public struct MatchingRequest: AWSEncodableShape {
        /// Configuration information about the auto-merging process.
        public let autoMerging: AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        public let enabled: Bool
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public let exportingConfig: ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public let jobSchedule: JobSchedule?

        @inlinable
        public init(autoMerging: AutoMerging? = nil, enabled: Bool, exportingConfig: ExportingConfig? = nil, jobSchedule: JobSchedule? = nil) {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }

        public func validate(name: String) throws {
            try self.autoMerging?.validate(name: "\(name).autoMerging")
            try self.exportingConfig?.validate(name: "\(name).exportingConfig")
            try self.jobSchedule?.validate(name: "\(name).jobSchedule")
        }

        private enum CodingKeys: String, CodingKey {
            case autoMerging = "AutoMerging"
            case enabled = "Enabled"
            case exportingConfig = "ExportingConfig"
            case jobSchedule = "JobSchedule"
        }
    }

    public struct MatchingResponse: AWSDecodableShape {
        /// Configuration information about the auto-merging process.
        public let autoMerging: AutoMerging?
        /// The flag that enables the matching process of duplicate profiles.
        public let enabled: Bool?
        /// Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        public let exportingConfig: ExportingConfig?
        /// The day and time when do you want to start the Identity Resolution Job every week.
        public let jobSchedule: JobSchedule?

        @inlinable
        public init(autoMerging: AutoMerging? = nil, enabled: Bool? = nil, exportingConfig: ExportingConfig? = nil, jobSchedule: JobSchedule? = nil) {
            self.autoMerging = autoMerging
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.jobSchedule = jobSchedule
        }

        private enum CodingKeys: String, CodingKey {
            case autoMerging = "AutoMerging"
            case enabled = "Enabled"
            case exportingConfig = "ExportingConfig"
            case jobSchedule = "JobSchedule"
        }
    }

    public struct MatchingRule: AWSEncodableShape & AWSDecodableShape {
        /// A single rule level of the MatchRules. Configures how the rule-based matching process should match profiles.
        public let rule: [String]

        @inlinable
        public init(rule: [String]) {
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.rule.forEach {
                try validate($0, name: "rule[]", parent: name, max: 255)
                try validate($0, name: "rule[]", parent: name, min: 1)
            }
            try self.validate(self.rule, name: "rule", parent: name, max: 15)
            try self.validate(self.rule, name: "rule", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
        }
    }

    public struct MergeProfilesRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// The identifiers of the fields in the profile that has the information you want to apply to the merge. For example, say you want to merge EmailAddress from Profile1 into MainProfile. This would be the identifier of the EmailAddress field in Profile1.
        public let fieldSourceProfileIds: FieldSourceProfileIds?
        /// The identifier of the profile to be taken.
        public let mainProfileId: String
        /// The identifier of the profile to be merged into MainProfileId.
        public let profileIdsToBeMerged: [String]

        @inlinable
        public init(domainName: String, fieldSourceProfileIds: FieldSourceProfileIds? = nil, mainProfileId: String, profileIdsToBeMerged: [String]) {
            self.domainName = domainName
            self.fieldSourceProfileIds = fieldSourceProfileIds
            self.mainProfileId = mainProfileId
            self.profileIdsToBeMerged = profileIdsToBeMerged
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.fieldSourceProfileIds, forKey: .fieldSourceProfileIds)
            try container.encode(self.mainProfileId, forKey: .mainProfileId)
            try container.encode(self.profileIdsToBeMerged, forKey: .profileIdsToBeMerged)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.fieldSourceProfileIds?.validate(name: "\(name).fieldSourceProfileIds")
            try self.validate(self.mainProfileId, name: "mainProfileId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.profileIdsToBeMerged.forEach {
                try validate($0, name: "profileIdsToBeMerged[]", parent: name, pattern: "^[a-f0-9]{32}$")
            }
            try self.validate(self.profileIdsToBeMerged, name: "profileIdsToBeMerged", parent: name, max: 20)
            try self.validate(self.profileIdsToBeMerged, name: "profileIdsToBeMerged", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldSourceProfileIds = "FieldSourceProfileIds"
            case mainProfileId = "MainProfileId"
            case profileIdsToBeMerged = "ProfileIdsToBeMerged"
        }
    }

    public struct MergeProfilesResponse: AWSDecodableShape {
        /// A message that indicates the merge request is complete.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct ObjectAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The operator used to compare an attribute against a list of values.
        public let comparisonOperator: ComparisonOperator
        /// A field defined within an object type.
        public let fieldName: String?
        /// An attribute contained within a source object.
        public let source: String?
        /// A list of attribute values used for comparison.
        public let values: [String]

        @inlinable
        public init(comparisonOperator: ComparisonOperator, fieldName: String? = nil, source: String? = nil, values: [String]) {
            self.comparisonOperator = comparisonOperator
            self.fieldName = fieldName
            self.source = source
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 64)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.source, name: "source", parent: name, max: 1000)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case fieldName = "FieldName"
            case source = "Source"
            case values = "Values"
        }
    }

    public struct ObjectFilter: AWSEncodableShape {
        /// A searchable identifier of a profile object. The predefined keys you can use to search for _asset include: _assetId, _assetName, and _serialNumber. The predefined keys you can use to search for _case include: _caseId. The predefined keys you can use to search for _order include: _orderId.
        public let keyName: String
        /// A list of key values.
        public let values: [String]

        @inlinable
        public init(keyName: String, values: [String]) {
            self.keyName = keyName
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case values = "Values"
        }
    }

    public struct ObjectTypeField: AWSEncodableShape & AWSDecodableShape {
        /// The content type of the field. Used for determining equality when searching.
        public let contentType: FieldContentType?
        /// A field of a ProfileObject. For example: _source.FirstName, where _source is a ProfileObjectType of a Zendesk user and FirstName is a field in that ObjectType.
        public let source: String?
        /// The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        public let target: String?

        @inlinable
        public init(contentType: FieldContentType? = nil, source: String? = nil, target: String? = nil) {
            self.contentType = contentType
            self.source = source
            self.target = target
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 1000)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.target, name: "target", parent: name, max: 1000)
            try self.validate(self.target, name: "target", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case source = "Source"
            case target = "Target"
        }
    }

    public struct ObjectTypeKey: AWSEncodableShape & AWSDecodableShape {
        /// The reference for the key name of the fields map.
        public let fieldNames: [String]?
        /// The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE, ASSET, CASE, or ORDER means that this key can be used to tie an object to a PROFILE, ASSET, CASE, or ORDER respectively. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        public let standardIdentifiers: [StandardIdentifier]?

        @inlinable
        public init(fieldNames: [String]? = nil, standardIdentifiers: [StandardIdentifier]? = nil) {
            self.fieldNames = fieldNames
            self.standardIdentifiers = standardIdentifiers
        }

        public func validate(name: String) throws {
            try self.fieldNames?.forEach {
                try validate($0, name: "fieldNames[]", parent: name, max: 64)
                try validate($0, name: "fieldNames[]", parent: name, min: 1)
                try validate($0, name: "fieldNames[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fieldNames = "FieldNames"
            case standardIdentifiers = "StandardIdentifiers"
        }
    }

    public struct Period: AWSEncodableShape & AWSDecodableShape {
        /// The maximum allowed number of destination invocations per profile.
        public let maxInvocationsPerProfile: Int?
        /// The unit of time.
        public let unit: PeriodUnit
        /// If set to true, there is no limit on the number of destination invocations per profile. The default is false.
        public let unlimited: Bool?
        /// The amount of time of the specified unit.
        public let value: Int

        @inlinable
        public init(maxInvocationsPerProfile: Int? = nil, unit: PeriodUnit, unlimited: Bool? = nil, value: Int) {
            self.maxInvocationsPerProfile = maxInvocationsPerProfile
            self.unit = unit
            self.unlimited = unlimited
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.maxInvocationsPerProfile, name: "maxInvocationsPerProfile", parent: name, max: 1000)
            try self.validate(self.maxInvocationsPerProfile, name: "maxInvocationsPerProfile", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 24)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxInvocationsPerProfile = "MaxInvocationsPerProfile"
            case unit = "Unit"
            case unlimited = "Unlimited"
            case value = "Value"
        }
    }

    public struct Profile: AWSDecodableShape {
        /// An account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customers profile.
        public let additionalInformation: String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public let address: Address?
        /// A key value pair of attributes of a customer profile.
        public let attributes: [String: String]?
        /// The customers billing address.
        public let billingAddress: Address?
        /// The customers birth date.
        public let birthDate: String?
        /// The customers business email address.
        public let businessEmailAddress: String?
        /// The name of the customers business.
        public let businessName: String?
        /// The customers home phone number.
        public let businessPhoneNumber: String?
        /// The customers email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customers first name.
        public let firstName: String?
        /// A list of items used to find a profile returned in a SearchProfiles response. An item is a key-value(s) pair that matches an attribute in the profile. If the optional AdditionalSearchKeys parameter was included in the SearchProfiles request, the FoundByItems list should be interpreted based on the LogicalOperator used in the request:    AND - The profile included in the response matched all of the search keys specified in the request. The FoundByItems will include all of the key-value(s) pairs that were specified in the request (as this is a requirement of AND search logic).    OR - The profile included in the response matched at least one of the search keys specified in the request. The FoundByItems will include each of the key-value(s) pairs that the profile was found by.   The OR relationship is the default behavior if the LogicalOperator parameter is not included in the SearchProfiles request.
        public let foundByItems: [FoundByKeyValue]?
        /// The gender with which the customer identifies.
        public let gender: Gender?
        /// An alternative to Gender which accepts any string as input.
        public let genderString: String?
        /// The customers home phone number.
        public let homePhoneNumber: String?
        /// The customers last name.
        public let lastName: String?
        /// The customers mailing address.
        public let mailingAddress: Address?
        /// The customers middle name.
        public let middleName: String?
        /// The customers mobile phone number.
        public let mobilePhoneNumber: String?
        /// The type of profile used to describe the customer.
        public let partyType: PartyType?
        /// An alternative to PartyType which accepts any string as input.
        public let partyTypeString: String?
        /// The customers personal email address.
        public let personalEmailAddress: String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The unique identifier of a customer profile.
        public let profileId: String?
        /// The customers shipping address.
        public let shippingAddress: Address?

        @inlinable
        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: Address? = nil, attributes: [String: String]? = nil, billingAddress: Address? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, emailAddress: String? = nil, firstName: String? = nil, foundByItems: [FoundByKeyValue]? = nil, gender: Gender? = nil, genderString: String? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: Address? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: PartyType? = nil, partyTypeString: String? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, profileId: String? = nil, shippingAddress: Address? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.foundByItems = foundByItems
            self.gender = gender
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.shippingAddress = shippingAddress
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case foundByItems = "FoundByItems"
            case gender = "Gender"
            case genderString = "GenderString"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case partyTypeString = "PartyTypeString"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case profileId = "ProfileId"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct ProfileAttributeValuesRequest: AWSEncodableShape {
        /// The attribute name.
        public let attributeName: String
        /// The unique identifier of the domain.
        public let domainName: String

        @inlinable
        public init(attributeName: String, domainName: String) {
            self.attributeName = attributeName
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attributeName, key: "AttributeName")
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 255)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ProfileAttributeValuesResponse: AWSDecodableShape {
        /// The attribute name.
        public let attributeName: String?
        /// The name of the domain.
        public let domainName: String?
        /// The items returned as part of the response.
        public let items: [AttributeValueItem]?
        /// The status code for the response.
        public let statusCode: Int?

        @inlinable
        public init(attributeName: String? = nil, domainName: String? = nil, items: [AttributeValueItem]? = nil, statusCode: Int? = nil) {
            self.attributeName = attributeName
            self.domainName = domainName
            self.items = items
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.attributeName = try container.decodeIfPresent(String.self, forKey: .attributeName)
            self.domainName = try container.decodeIfPresent(String.self, forKey: .domainName)
            self.items = try container.decodeIfPresent([AttributeValueItem].self, forKey: .items)
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case domainName = "DomainName"
            case items = "Items"
        }
    }

    public struct ProfileAttributes: AWSEncodableShape & AWSDecodableShape {
        /// A field to describe values to segment on within account number.
        public let accountNumber: ProfileDimension?
        /// A field to describe values to segment on within additional information.
        public let additionalInformation: ExtraLengthValueProfileDimension?
        /// A field to describe values to segment on within address.
        public let address: AddressDimension?
        /// A field to describe values to segment on within attributes.
        public let attributes: [String: AttributeDimension]?
        /// A field to describe values to segment on within billing address.
        public let billingAddress: AddressDimension?
        /// A field to describe values to segment on within birthDate.
        public let birthDate: DateDimension?
        /// A field to describe values to segment on within business email address.
        public let businessEmailAddress: ProfileDimension?
        /// A field to describe values to segment on within business name.
        public let businessName: ProfileDimension?
        /// A field to describe values to segment on within business phone number.
        public let businessPhoneNumber: ProfileDimension?
        /// A field to describe values to segment on within email address.
        public let emailAddress: ProfileDimension?
        /// A field to describe values to segment on within first name.
        public let firstName: ProfileDimension?
        /// A field to describe values to segment on within genderString.
        public let genderString: ProfileDimension?
        /// A field to describe values to segment on within home phone number.
        public let homePhoneNumber: ProfileDimension?
        /// A field to describe values to segment on within last name.
        public let lastName: ProfileDimension?
        /// A field to describe values to segment on within mailing address.
        public let mailingAddress: AddressDimension?
        /// A field to describe values to segment on within middle name.
        public let middleName: ProfileDimension?
        /// A field to describe values to segment on within mobile phone number.
        public let mobilePhoneNumber: ProfileDimension?
        /// A field to describe values to segment on within partyTypeString.
        public let partyTypeString: ProfileDimension?
        /// A field to describe values to segment on within personal email address.
        public let personalEmailAddress: ProfileDimension?
        /// A field to describe values to segment on within phone number.
        public let phoneNumber: ProfileDimension?
        /// A field to describe values to segment on within shipping address.
        public let shippingAddress: AddressDimension?

        @inlinable
        public init(accountNumber: ProfileDimension? = nil, additionalInformation: ExtraLengthValueProfileDimension? = nil, address: AddressDimension? = nil, attributes: [String: AttributeDimension]? = nil, billingAddress: AddressDimension? = nil, birthDate: DateDimension? = nil, businessEmailAddress: ProfileDimension? = nil, businessName: ProfileDimension? = nil, businessPhoneNumber: ProfileDimension? = nil, emailAddress: ProfileDimension? = nil, firstName: ProfileDimension? = nil, genderString: ProfileDimension? = nil, homePhoneNumber: ProfileDimension? = nil, lastName: ProfileDimension? = nil, mailingAddress: AddressDimension? = nil, middleName: ProfileDimension? = nil, mobilePhoneNumber: ProfileDimension? = nil, partyTypeString: ProfileDimension? = nil, personalEmailAddress: ProfileDimension? = nil, phoneNumber: ProfileDimension? = nil, shippingAddress: AddressDimension? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.shippingAddress = shippingAddress
        }

        public func validate(name: String) throws {
            try self.accountNumber?.validate(name: "\(name).accountNumber")
            try self.additionalInformation?.validate(name: "\(name).additionalInformation")
            try self.address?.validate(name: "\(name).address")
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 255)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
                try $0.value.validate(name: "\(name).attributes[\"\($0.key)\"]")
            }
            try self.billingAddress?.validate(name: "\(name).billingAddress")
            try self.birthDate?.validate(name: "\(name).birthDate")
            try self.businessEmailAddress?.validate(name: "\(name).businessEmailAddress")
            try self.businessName?.validate(name: "\(name).businessName")
            try self.businessPhoneNumber?.validate(name: "\(name).businessPhoneNumber")
            try self.emailAddress?.validate(name: "\(name).emailAddress")
            try self.firstName?.validate(name: "\(name).firstName")
            try self.genderString?.validate(name: "\(name).genderString")
            try self.homePhoneNumber?.validate(name: "\(name).homePhoneNumber")
            try self.lastName?.validate(name: "\(name).lastName")
            try self.mailingAddress?.validate(name: "\(name).mailingAddress")
            try self.middleName?.validate(name: "\(name).middleName")
            try self.mobilePhoneNumber?.validate(name: "\(name).mobilePhoneNumber")
            try self.partyTypeString?.validate(name: "\(name).partyTypeString")
            try self.personalEmailAddress?.validate(name: "\(name).personalEmailAddress")
            try self.phoneNumber?.validate(name: "\(name).phoneNumber")
            try self.shippingAddress?.validate(name: "\(name).shippingAddress")
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case genderString = "GenderString"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyTypeString = "PartyTypeString"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct ProfileDimension: AWSEncodableShape & AWSDecodableShape {
        /// The action to segment on.
        public let dimensionType: StringDimensionType
        /// The values to apply the DimensionType on.
        public let values: [String]

        @inlinable
        public init(dimensionType: StringDimensionType, values: [String]) {
            self.dimensionType = dimensionType
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 50)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionType = "DimensionType"
            case values = "Values"
        }
    }

    public struct ProfileQueryFailures: AWSDecodableShape {
        /// A message describing the failure.
        public let message: String
        /// The profile id the failure belongs to.
        public let profileId: String
        /// The status describing the failure.
        public let status: Int?

        @inlinable
        public init(message: String, profileId: String, status: Int? = nil) {
            self.message = message
            self.profileId = profileId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case profileId = "ProfileId"
            case status = "Status"
        }
    }

    public struct ProfileQueryResult: AWSDecodableShape {
        public let profile: Profile?
        /// The profile id the result belongs to.
        public let profileId: String
        /// Describes whether the profile was absent or present in the segment.
        public let queryResult: QueryResult

        @inlinable
        public init(profile: Profile? = nil, profileId: String, queryResult: QueryResult) {
            self.profile = profile
            self.profileId = profileId
            self.queryResult = queryResult
        }

        private enum CodingKeys: String, CodingKey {
            case profile = "Profile"
            case profileId = "ProfileId"
            case queryResult = "QueryResult"
        }
    }

    public struct PutIntegrationRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// A list of unique names for active event triggers associated with the integration.
        public let eventTriggerNames: [String]?
        /// The configuration that controls how Customer Profiles retrieves data from the source.
        public let flowDefinition: FlowDefinition?
        /// The name of the profile object type.
        public let objectTypeName: String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event.
        /// It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders,
        /// ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public let objectTypeNames: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String?

        @inlinable
        public init(domainName: String, eventTriggerNames: [String]? = nil, flowDefinition: FlowDefinition? = nil, objectTypeName: String? = nil, objectTypeNames: [String: String]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, uri: String? = nil) {
            self.domainName = domainName
            self.eventTriggerNames = eventTriggerNames
            self.flowDefinition = flowDefinition
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.roleArn = roleArn
            self.tags = tags
            self.uri = uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.eventTriggerNames, forKey: .eventTriggerNames)
            try container.encodeIfPresent(self.flowDefinition, forKey: .flowDefinition)
            try container.encodeIfPresent(self.objectTypeName, forKey: .objectTypeName)
            try container.encodeIfPresent(self.objectTypeNames, forKey: .objectTypeNames)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.uri, forKey: .uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.eventTriggerNames?.forEach {
                try validate($0, name: "eventTriggerNames[]", parent: name, max: 64)
                try validate($0, name: "eventTriggerNames[]", parent: name, min: 1)
                try validate($0, name: "eventTriggerNames[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.validate(self.eventTriggerNames, name: "eventTriggerNames", parent: name, max: 1)
            try self.validate(self.eventTriggerNames, name: "eventTriggerNames", parent: name, min: 1)
            try self.flowDefinition?.validate(name: "\(name).flowDefinition")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.objectTypeNames?.forEach {
                try validate($0.key, name: "objectTypeNames.key", parent: name, max: 255)
                try validate($0.key, name: "objectTypeNames.key", parent: name, min: 1)
                try validate($0.value, name: "objectTypeNames[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "objectTypeNames[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "objectTypeNames[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            }
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam:.*:[0-9]+:")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTriggerNames = "EventTriggerNames"
            case flowDefinition = "FlowDefinition"
            case objectTypeName = "ObjectTypeName"
            case objectTypeNames = "ObjectTypeNames"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case uri = "Uri"
        }
    }

    public struct PutIntegrationResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// A list of unique names for active event triggers associated with the integration. This list would be empty if no Event Trigger is associated with the integration.
        public let eventTriggerNames: [String]?
        /// Boolean that shows if the Flow that's associated with the Integration is created in Amazon Appflow, or with ObjectTypeName equals _unstructured via API/CLI in flowDefinition.
        public let isUnstructured: Bool?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The name of the profile object type.
        public let objectTypeName: String?
        /// A map in which each key is an event type from an external application such as Segment or Shopify, and each value is an ObjectTypeName (template) used to ingest the event.
        /// It supports the following event types: SegmentIdentify, ShopifyCreateCustomers, ShopifyUpdateCustomers, ShopifyCreateDraftOrders,
        /// ShopifyUpdateDraftOrders, ShopifyCreateOrders, and ShopifyUpdatedOrders.
        public let objectTypeNames: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM role. The Integration uses this role to make Customer Profiles requests on your behalf.
        public let roleArn: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String
        /// Unique identifier for the workflow.
        public let workflowId: String?

        @inlinable
        public init(createdAt: Date, domainName: String, eventTriggerNames: [String]? = nil, isUnstructured: Bool? = nil, lastUpdatedAt: Date, objectTypeName: String? = nil, objectTypeNames: [String: String]? = nil, roleArn: String? = nil, tags: [String: String]? = nil, uri: String, workflowId: String? = nil) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.eventTriggerNames = eventTriggerNames
            self.isUnstructured = isUnstructured
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.objectTypeNames = objectTypeNames
            self.roleArn = roleArn
            self.tags = tags
            self.uri = uri
            self.workflowId = workflowId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case eventTriggerNames = "EventTriggerNames"
            case isUnstructured = "IsUnstructured"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case objectTypeNames = "ObjectTypeNames"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case uri = "Uri"
            case workflowId = "WorkflowId"
        }
    }

    public struct PutProfileObjectRequest: AWSEncodableShape {
        /// The unique name of the domain.
        public let domainName: String
        /// A string that is serialized from a JSON object.
        public let object: String
        /// The name of the profile object type.
        public let objectTypeName: String

        @inlinable
        public init(domainName: String, object: String, objectTypeName: String) {
            self.domainName = domainName
            self.object = object
            self.objectTypeName = objectTypeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.object, forKey: .object)
            try container.encode(self.objectTypeName, forKey: .objectTypeName)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.object, name: "object", parent: name, max: 256000)
            try self.validate(self.object, name: "object", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
            case objectTypeName = "ObjectTypeName"
        }
    }

    public struct PutProfileObjectResponse: AWSDecodableShape {
        /// The unique identifier of the profile object generated by the service.
        public let profileObjectUniqueKey: String?

        @inlinable
        public init(profileObjectUniqueKey: String? = nil) {
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case profileObjectUniqueKey = "ProfileObjectUniqueKey"
        }
    }

    public struct PutProfileObjectTypeRequest: AWSEncodableShape {
        /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// Description of the profile object type.
        public let description: String
        /// The unique name of the domain.
        public let domainName: String
        /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
        public let encryptionKey: String?
        /// The number of days until the data in the object expires.
        public let expirationDays: Int?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The amount of profile object max count assigned to the object type
        public let maxProfileObjectCount: Int?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The format of your sourceLastUpdatedTimestamp that was previously set up.
        public let sourceLastUpdatedTimestampFormat: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier for the object template. For some attributes in the request, the service will use the default value from the object template when TemplateId is present. If these attributes are present in the request, the service may return a BadRequestException. These attributes include: AllowProfileCreation, SourceLastUpdatedTimestampFormat, Fields, and Keys. For example, if AllowProfileCreation is set to true when TemplateId is set, the service may return a BadRequestException.
        public let templateId: String?

        @inlinable
        public init(allowProfileCreation: Bool? = nil, description: String, domainName: String, encryptionKey: String? = nil, expirationDays: Int? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, maxProfileObjectCount: Int? = nil, objectTypeName: String, sourceLastUpdatedTimestampFormat: String? = nil, tags: [String: String]? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.description = description
            self.domainName = domainName
            self.encryptionKey = encryptionKey
            self.expirationDays = expirationDays
            self.fields = fields
            self.keys = keys
            self.maxProfileObjectCount = maxProfileObjectCount
            self.objectTypeName = objectTypeName
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
            self.tags = tags
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowProfileCreation, forKey: .allowProfileCreation)
            try container.encode(self.description, forKey: .description)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.encryptionKey, forKey: .encryptionKey)
            try container.encodeIfPresent(self.expirationDays, forKey: .expirationDays)
            try container.encodeIfPresent(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.keys, forKey: .keys)
            try container.encodeIfPresent(self.maxProfileObjectCount, forKey: .maxProfileObjectCount)
            request.encodePath(self.objectTypeName, key: "ObjectTypeName")
            try container.encodeIfPresent(self.sourceLastUpdatedTimestampFormat, forKey: .sourceLastUpdatedTimestampFormat)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.templateId, forKey: .templateId)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 255)
            try self.validate(self.expirationDays, name: "expirationDays", parent: name, max: 1098)
            try self.validate(self.expirationDays, name: "expirationDays", parent: name, min: 1)
            try self.fields?.forEach {
                try validate($0.key, name: "fields.key", parent: name, max: 64)
                try validate($0.key, name: "fields.key", parent: name, min: 1)
                try validate($0.key, name: "fields.key", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
                try $0.value.validate(name: "\(name).fields[\"\($0.key)\"]")
            }
            try self.keys?.forEach {
                try validate($0.key, name: "keys.key", parent: name, max: 64)
                try validate($0.key, name: "keys.key", parent: name, min: 1)
                try validate($0.key, name: "keys.key", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.validate(self.maxProfileObjectCount, name: "maxProfileObjectCount", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.sourceLastUpdatedTimestampFormat, name: "sourceLastUpdatedTimestampFormat", parent: name, max: 255)
            try self.validate(self.sourceLastUpdatedTimestampFormat, name: "sourceLastUpdatedTimestampFormat", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 64)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case expirationDays = "ExpirationDays"
            case fields = "Fields"
            case keys = "Keys"
            case maxProfileObjectCount = "MaxProfileObjectCount"
            case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
            case tags = "Tags"
            case templateId = "TemplateId"
        }
    }

    public struct PutProfileObjectTypeResponse: AWSDecodableShape {
        /// Indicates whether a profile should be created when data is received if one doesnt exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// The timestamp of when the domain was created.
        public let createdAt: Date?
        /// Description of the profile object type.
        public let description: String
        /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
        public let encryptionKey: String?
        /// The number of days until the data in the object expires.
        public let expirationDays: Int?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date?
        /// The amount of provisioned profile object max count available.
        public let maxAvailableProfileObjectCount: Int?
        /// The amount of profile object max count assigned to the object type.
        public let maxProfileObjectCount: Int?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The format of your sourceLastUpdatedTimestamp that was previously set up in fields that were parsed using SimpleDateFormat. If you have sourceLastUpdatedTimestamp in your field, you must set up sourceLastUpdatedTimestampFormat.
        public let sourceLastUpdatedTimestampFormat: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier for the object template.
        public let templateId: String?

        @inlinable
        public init(allowProfileCreation: Bool? = nil, createdAt: Date? = nil, description: String, encryptionKey: String? = nil, expirationDays: Int? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, lastUpdatedAt: Date? = nil, maxAvailableProfileObjectCount: Int? = nil, maxProfileObjectCount: Int? = nil, objectTypeName: String, sourceLastUpdatedTimestampFormat: String? = nil, tags: [String: String]? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.createdAt = createdAt
            self.description = description
            self.encryptionKey = encryptionKey
            self.expirationDays = expirationDays
            self.fields = fields
            self.keys = keys
            self.lastUpdatedAt = lastUpdatedAt
            self.maxAvailableProfileObjectCount = maxAvailableProfileObjectCount
            self.maxProfileObjectCount = maxProfileObjectCount
            self.objectTypeName = objectTypeName
            self.sourceLastUpdatedTimestampFormat = sourceLastUpdatedTimestampFormat
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case createdAt = "CreatedAt"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case expirationDays = "ExpirationDays"
            case fields = "Fields"
            case keys = "Keys"
            case lastUpdatedAt = "LastUpdatedAt"
            case maxAvailableProfileObjectCount = "MaxAvailableProfileObjectCount"
            case maxProfileObjectCount = "MaxProfileObjectCount"
            case objectTypeName = "ObjectTypeName"
            case sourceLastUpdatedTimestampFormat = "SourceLastUpdatedTimestampFormat"
            case tags = "Tags"
            case templateId = "TemplateId"
        }
    }

    public struct Range: AWSEncodableShape & AWSDecodableShape {
        /// The unit of time.
        public let unit: Unit
        /// The amount of time of the specified unit.
        public let value: Int

        @inlinable
        public init(unit: Unit, value: Int) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 366)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct RangeOverride: AWSEncodableShape & AWSDecodableShape {
        /// The end time of when to include objects.
        public let end: Int?
        /// The start time of when to include objects.
        public let start: Int
        /// The unit for start and end.
        public let unit: RangeUnit

        @inlinable
        public init(end: Int? = nil, start: Int, unit: RangeUnit) {
            self.end = end
            self.start = start
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.end, name: "end", parent: name, max: 366)
            try self.validate(self.end, name: "end", parent: name, min: 0)
            try self.validate(self.start, name: "start", parent: name, max: 366)
            try self.validate(self.start, name: "start", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
            case unit = "Unit"
        }
    }

    public struct RuleBasedMatchingRequest: AWSEncodableShape {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public let attributeTypesSelector: AttributeTypesSelector?
        public let conflictResolution: ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        public let enabled: Bool
        public let exportingConfig: ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public let matchingRules: [MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public let maxAllowedRuleLevelForMatching: Int?
        ///  MatchingRule
        public let maxAllowedRuleLevelForMerging: Int?

        @inlinable
        public init(attributeTypesSelector: AttributeTypesSelector? = nil, conflictResolution: ConflictResolution? = nil, enabled: Bool, exportingConfig: ExportingConfig? = nil, matchingRules: [MatchingRule]? = nil, maxAllowedRuleLevelForMatching: Int? = nil, maxAllowedRuleLevelForMerging: Int? = nil) {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
        }

        public func validate(name: String) throws {
            try self.attributeTypesSelector?.validate(name: "\(name).attributeTypesSelector")
            try self.conflictResolution?.validate(name: "\(name).conflictResolution")
            try self.exportingConfig?.validate(name: "\(name).exportingConfig")
            try self.matchingRules?.forEach {
                try $0.validate(name: "\(name).matchingRules[]")
            }
            try self.validate(self.matchingRules, name: "matchingRules", parent: name, max: 15)
            try self.validate(self.matchingRules, name: "matchingRules", parent: name, min: 1)
            try self.validate(self.maxAllowedRuleLevelForMatching, name: "maxAllowedRuleLevelForMatching", parent: name, max: 15)
            try self.validate(self.maxAllowedRuleLevelForMatching, name: "maxAllowedRuleLevelForMatching", parent: name, min: 1)
            try self.validate(self.maxAllowedRuleLevelForMerging, name: "maxAllowedRuleLevelForMerging", parent: name, max: 15)
            try self.validate(self.maxAllowedRuleLevelForMerging, name: "maxAllowedRuleLevelForMerging", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeTypesSelector = "AttributeTypesSelector"
            case conflictResolution = "ConflictResolution"
            case enabled = "Enabled"
            case exportingConfig = "ExportingConfig"
            case matchingRules = "MatchingRules"
            case maxAllowedRuleLevelForMatching = "MaxAllowedRuleLevelForMatching"
            case maxAllowedRuleLevelForMerging = "MaxAllowedRuleLevelForMerging"
        }
    }

    public struct RuleBasedMatchingResponse: AWSDecodableShape {
        /// Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        public let attributeTypesSelector: AttributeTypesSelector?
        public let conflictResolution: ConflictResolution?
        /// The flag that enables the rule-based matching process of duplicate profiles.
        public let enabled: Bool?
        public let exportingConfig: ExportingConfig?
        /// Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        public let matchingRules: [MatchingRule]?
        /// Indicates the maximum allowed rule level.
        public let maxAllowedRuleLevelForMatching: Int?
        ///  MatchingRule
        public let maxAllowedRuleLevelForMerging: Int?
        /// PENDING   The first status after configuration a rule-based matching rule. If it is an existing domain, the rule-based Identity Resolution waits one hour before creating the matching rule. If it is a new domain, the system will skip the PENDING stage.   IN_PROGRESS   The system is creating the rule-based matching rule. Under this status, the system is evaluating the existing data and you can no longer change the Rule-based matching configuration.   ACTIVE   The rule is ready to use. You can change the rule a day after the status is in ACTIVE.
        public let status: RuleBasedMatchingStatus?

        @inlinable
        public init(attributeTypesSelector: AttributeTypesSelector? = nil, conflictResolution: ConflictResolution? = nil, enabled: Bool? = nil, exportingConfig: ExportingConfig? = nil, matchingRules: [MatchingRule]? = nil, maxAllowedRuleLevelForMatching: Int? = nil, maxAllowedRuleLevelForMerging: Int? = nil, status: RuleBasedMatchingStatus? = nil) {
            self.attributeTypesSelector = attributeTypesSelector
            self.conflictResolution = conflictResolution
            self.enabled = enabled
            self.exportingConfig = exportingConfig
            self.matchingRules = matchingRules
            self.maxAllowedRuleLevelForMatching = maxAllowedRuleLevelForMatching
            self.maxAllowedRuleLevelForMerging = maxAllowedRuleLevelForMerging
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case attributeTypesSelector = "AttributeTypesSelector"
            case conflictResolution = "ConflictResolution"
            case enabled = "Enabled"
            case exportingConfig = "ExportingConfig"
            case matchingRules = "MatchingRules"
            case maxAllowedRuleLevelForMatching = "MaxAllowedRuleLevelForMatching"
            case maxAllowedRuleLevelForMerging = "MaxAllowedRuleLevelForMerging"
            case status = "Status"
        }
    }

    public struct S3ExportingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket where Identity Resolution Jobs write result files.
        public let s3BucketName: String
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public let s3KeyName: String?

        @inlinable
        public init(s3BucketName: String, s3KeyName: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9.-]+$")
            try self.validate(self.s3KeyName, name: "s3KeyName", parent: name, max: 800)
            try self.validate(self.s3KeyName, name: "s3KeyName", parent: name, min: 1)
            try self.validate(self.s3KeyName, name: "s3KeyName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case s3KeyName = "S3KeyName"
        }
    }

    public struct S3ExportingLocation: AWSDecodableShape {
        /// The name of the S3 bucket name where Identity Resolution Jobs write result files.
        public let s3BucketName: String?
        /// The S3 key name of the location where Identity Resolution Jobs write result files.
        public let s3KeyName: String?

        @inlinable
        public init(s3BucketName: String? = nil, s3KeyName: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3KeyName = s3KeyName
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case s3KeyName = "S3KeyName"
        }
    }

    public struct S3SourceProperties: AWSEncodableShape {
        /// The Amazon S3 bucket name where the source files are stored.
        public let bucketName: String
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public let bucketPrefix: String?

        @inlinable
        public init(bucketName: String, bucketPrefix: String? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^\\S+$")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
        }
    }

    public struct SalesforceSourceProperties: AWSEncodableShape {
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public let enableDynamicFieldUpdate: Bool?
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public let includeDeletedRecords: Bool?
        /// The object specified in the Salesforce flow source.
        public let object: String

        @inlinable
        public init(enableDynamicFieldUpdate: Bool? = nil, includeDeletedRecords: Bool? = nil, object: String) {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case enableDynamicFieldUpdate = "EnableDynamicFieldUpdate"
            case includeDeletedRecords = "IncludeDeletedRecords"
            case object = "Object"
        }
    }

    public struct ScheduledTriggerProperties: AWSEncodableShape {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public let dataPullMode: DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public let firstExecutionFrom: Date?
        /// Specifies the scheduled end time for a scheduled-trigger flow.
        public let scheduleEndTime: Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        public let scheduleExpression: String
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public let scheduleOffset: Int64?
        /// Specifies the scheduled start time for a scheduled-trigger flow.
        public let scheduleStartTime: Date?
        /// Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        public let timezone: String?

        @inlinable
        public init(dataPullMode: DataPullMode? = nil, firstExecutionFrom: Date? = nil, scheduleEndTime: Date? = nil, scheduleExpression: String, scheduleOffset: Int64? = nil, scheduleStartTime: Date? = nil, timezone: String? = nil) {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: ".*")
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, max: 36000)
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, min: 0)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 256)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullMode = "DataPullMode"
            case firstExecutionFrom = "FirstExecutionFrom"
            case scheduleEndTime = "ScheduleEndTime"
            case scheduleExpression = "ScheduleExpression"
            case scheduleOffset = "ScheduleOffset"
            case scheduleStartTime = "ScheduleStartTime"
            case timezone = "Timezone"
        }
    }

    public struct SearchProfilesRequest: AWSEncodableShape {
        /// A list of AdditionalSearchKey objects that are each searchable identifiers of a profile. Each AdditionalSearchKey object contains a KeyName and a list of Values associated with that specific key (i.e., a key-value(s) pair). These additional search keys will be used in conjunction with the LogicalOperator and the required KeyName and Values parameters to search for profiles that satisfy the search criteria.
        public let additionalSearchKeys: [AdditionalSearchKey]?
        /// The unique name of the domain.
        public let domainName: String
        /// A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId, _assetId, _caseId, _orderId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _salesforceAssetId, _zendeskUserId, _zendeskExternalId, _zendeskTicketId, _serviceNowSystemId, _serviceNowIncidentId, _segmentUserId, _shopifyCustomerId, _shopifyOrderId.
        public let keyName: String
        /// Relationship between all specified search keys that will be used to search for profiles. This includes the required KeyName and Values parameters as well as any key-value(s) pairs specified in the AdditionalSearchKeys list. This parameter influences which profiles will be returned in the response in the following manner:    AND - The response only includes profiles that match all of the search keys.    OR - The response includes profiles that match at least one of the search keys.   The OR relationship is the default behavior if this parameter is not included in the request.
        public let logicalOperator: LogicalOperator?
        /// The maximum number of objects returned per page. The default is 20 if this parameter is not included in the request.
        public let maxResults: Int?
        /// The pagination token from the previous SearchProfiles API call.
        public let nextToken: String?
        /// A list of key values.
        public let values: [String]

        @inlinable
        public init(additionalSearchKeys: [AdditionalSearchKey]? = nil, domainName: String, keyName: String, logicalOperator: LogicalOperator? = nil, maxResults: Int? = nil, nextToken: String? = nil, values: [String]) {
            self.additionalSearchKeys = additionalSearchKeys
            self.domainName = domainName
            self.keyName = keyName
            self.logicalOperator = logicalOperator
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalSearchKeys, forKey: .additionalSearchKeys)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.keyName, forKey: .keyName)
            try container.encodeIfPresent(self.logicalOperator, forKey: .logicalOperator)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            try container.encode(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.additionalSearchKeys?.forEach {
                try $0.validate(name: "\(name).additionalSearchKeys[]")
            }
            try self.validate(self.additionalSearchKeys, name: "additionalSearchKeys", parent: name, max: 4)
            try self.validate(self.additionalSearchKeys, name: "additionalSearchKeys", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalSearchKeys = "AdditionalSearchKeys"
            case keyName = "KeyName"
            case logicalOperator = "LogicalOperator"
            case values = "Values"
        }
    }

    public struct SearchProfilesResponse: AWSDecodableShape {
        /// The list of Profiles matching the search criteria.
        public let items: [Profile]?
        /// The pagination token from the previous SearchProfiles API call.
        public let nextToken: String?

        @inlinable
        public init(items: [Profile]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct SegmentDefinitionItem: AWSDecodableShape {
        /// When the segment definition was created.
        public let createdAt: Date?
        /// The description of the segment definition.
        public let description: String?
        /// Display name of the segment definition.
        public let displayName: String?
        /// The arn of the segment definition.
        public let segmentDefinitionArn: String?
        /// Name of the segment definition.
        public let segmentDefinitionName: String?
        /// The tags belonging to the segment definition.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, segmentDefinitionArn: String? = nil, segmentDefinitionName: String? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.segmentDefinitionArn = segmentDefinitionArn
            self.segmentDefinitionName = segmentDefinitionName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case segmentDefinitionArn = "SegmentDefinitionArn"
            case segmentDefinitionName = "SegmentDefinitionName"
            case tags = "Tags"
        }
    }

    public struct SegmentGroup: AWSEncodableShape & AWSDecodableShape {
        /// Holds the list of groups within the segment definition.
        public let groups: [Group]?
        /// Defines whether to include or exclude the profiles that fit the segment criteria.
        public let include: IncludeOptions?

        @inlinable
        public init(groups: [Group]? = nil, include: IncludeOptions? = nil) {
            self.groups = groups
            self.include = include
        }

        public func validate(name: String) throws {
            try self.groups?.forEach {
                try $0.validate(name: "\(name).groups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case include = "Include"
        }
    }

    public struct SegmentGroupStructure: AWSEncodableShape {
        /// Holds the list of groups within the segment definition.
        public let groups: [Group]?
        /// Define whether to include or exclude the profiles that fit the segment criteria.
        public let include: IncludeOptions?

        @inlinable
        public init(groups: [Group]? = nil, include: IncludeOptions? = nil) {
            self.groups = groups
            self.include = include
        }

        public func validate(name: String) throws {
            try self.groups?.forEach {
                try $0.validate(name: "\(name).groups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case include = "Include"
        }
    }

    public struct ServiceNowSourceProperties: AWSEncodableShape {
        /// The object specified in the ServiceNow flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
        }
    }

    public struct SourceConnectorProperties: AWSEncodableShape {
        /// The properties that are applied when Marketo is being used as a source.
        public let marketo: MarketoSourceProperties?
        /// The properties that are applied when Amazon S3 is being used as the flow source.
        public let s3: S3SourceProperties?
        /// The properties that are applied when Salesforce is being used as a source.
        public let salesforce: SalesforceSourceProperties?
        /// The properties that are applied when ServiceNow is being used as a source.
        public let serviceNow: ServiceNowSourceProperties?
        /// The properties that are applied when using Zendesk as a flow source.
        public let zendesk: ZendeskSourceProperties?

        @inlinable
        public init(marketo: MarketoSourceProperties? = nil, s3: S3SourceProperties? = nil, salesforce: SalesforceSourceProperties? = nil, serviceNow: ServiceNowSourceProperties? = nil, zendesk: ZendeskSourceProperties? = nil) {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.marketo?.validate(name: "\(name).marketo")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case zendesk = "Zendesk"
        }
    }

    public struct SourceFlowConfig: AWSEncodableShape {
        /// The name of the AppFlow connector profile. This name must be unique for each connector profile in the AWS account.
        public let connectorProfileName: String?
        /// The type of connector, such as Salesforce, Marketo, and so on.
        public let connectorType: SourceConnectorType
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public let incrementalPullConfig: IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        public let sourceConnectorProperties: SourceConnectorProperties

        @inlinable
        public init(connectorProfileName: String? = nil, connectorType: SourceConnectorType, incrementalPullConfig: IncrementalPullConfig? = nil, sourceConnectorProperties: SourceConnectorProperties) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "^[\\w/!@#+=.-]+$")
            try self.incrementalPullConfig?.validate(name: "\(name).incrementalPullConfig")
            try self.sourceConnectorProperties.validate(name: "\(name).sourceConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "ConnectorProfileName"
            case connectorType = "ConnectorType"
            case incrementalPullConfig = "IncrementalPullConfig"
            case sourceConnectorProperties = "SourceConnectorProperties"
        }
    }

    public struct SourceSegment: AWSEncodableShape & AWSDecodableShape {
        /// The unique name of the segment definition.
        public let segmentDefinitionName: String?

        @inlinable
        public init(segmentDefinitionName: String? = nil) {
            self.segmentDefinitionName = segmentDefinitionName
        }

        public func validate(name: String) throws {
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, max: 64)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, min: 1)
            try self.validate(self.segmentDefinitionName, name: "segmentDefinitionName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case segmentDefinitionName = "SegmentDefinitionName"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource that you're adding tags to.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9]{1,10}:profile$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Task: AWSEncodableShape {
        /// The operation to be performed on the provided source fields.
        public let connectorOperator: ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public let destinationField: String?
        /// The source fields to which a particular task is applied.
        public let sourceFields: [String]
        /// A map used to store task-related information. The service looks for particular information based on the TaskType.
        public let taskProperties: [OperatorPropertiesKeys: String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        public let taskType: TaskType

        @inlinable
        public init(connectorOperator: ConnectorOperator? = nil, destinationField: String? = nil, sourceFields: [String], taskProperties: [OperatorPropertiesKeys: String]? = nil, taskType: TaskType) {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationField, name: "destinationField", parent: name, max: 256)
            try self.validate(self.destinationField, name: "destinationField", parent: name, pattern: ".*")
            try self.sourceFields.forEach {
                try validate($0, name: "sourceFields[]", parent: name, max: 2048)
                try validate($0, name: "sourceFields[]", parent: name, pattern: ".*")
            }
            try self.taskProperties?.forEach {
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, pattern: "^.+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectorOperator = "ConnectorOperator"
            case destinationField = "DestinationField"
            case sourceFields = "SourceFields"
            case taskProperties = "TaskProperties"
            case taskType = "TaskType"
        }
    }

    public struct Threshold: AWSEncodableShape & AWSDecodableShape {
        /// The operator of the threshold.
        public let `operator`: Operator
        /// The value of the threshold.
        public let value: String

        @inlinable
        public init(operator: Operator, value: String) {
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 255)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct TriggerConfig: AWSEncodableShape {
        /// Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        public let triggerProperties: TriggerProperties?
        /// Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        public let triggerType: TriggerType

        @inlinable
        public init(triggerProperties: TriggerProperties? = nil, triggerType: TriggerType) {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }

        public func validate(name: String) throws {
            try self.triggerProperties?.validate(name: "\(name).triggerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case triggerProperties = "TriggerProperties"
            case triggerType = "TriggerType"
        }
    }

    public struct TriggerProperties: AWSEncodableShape {
        /// Specifies the configuration details of a schedule-triggered flow that you define.
        public let scheduled: ScheduledTriggerProperties?

        @inlinable
        public init(scheduled: ScheduledTriggerProperties? = nil) {
            self.scheduled = scheduled
        }

        public func validate(name: String) throws {
            try self.scheduled?.validate(name: "\(name).scheduled")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduled = "Scheduled"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource from which you are removing tags.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9]{1,10}:profile$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAddress: AWSEncodableShape {
        /// The first line of a customer address.
        public let address1: String?
        /// The second line of a customer address.
        public let address2: String?
        /// The third line of a customer address.
        public let address3: String?
        /// The fourth line of a customer address.
        public let address4: String?
        /// The city in which a customer lives.
        public let city: String?
        /// The country in which a customer lives.
        public let country: String?
        /// The county in which a customer lives.
        public let county: String?
        /// The postal code of a customer address.
        public let postalCode: String?
        /// The province in which a customer lives.
        public let province: String?
        /// The state in which a customer lives.
        public let state: String?

        @inlinable
        public init(address1: String? = nil, address2: String? = nil, address3: String? = nil, address4: String? = nil, city: String? = nil, country: String? = nil, county: String? = nil, postalCode: String? = nil, province: String? = nil, state: String? = nil) {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.address1, name: "address1", parent: name, max: 255)
            try self.validate(self.address2, name: "address2", parent: name, max: 255)
            try self.validate(self.address3, name: "address3", parent: name, max: 255)
            try self.validate(self.address4, name: "address4", parent: name, max: 255)
            try self.validate(self.city, name: "city", parent: name, max: 255)
            try self.validate(self.country, name: "country", parent: name, max: 255)
            try self.validate(self.county, name: "county", parent: name, max: 255)
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 255)
            try self.validate(self.province, name: "province", parent: name, max: 255)
            try self.validate(self.state, name: "state", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case address1 = "Address1"
            case address2 = "Address2"
            case address3 = "Address3"
            case address4 = "Address4"
            case city = "City"
            case country = "Country"
            case county = "County"
            case postalCode = "PostalCode"
            case province = "Province"
            case state = "State"
        }
    }

    public struct UpdateCalculatedAttributeDefinitionRequest: AWSEncodableShape {
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String
        /// The conditions including range, object count, and threshold for the calculated attribute.
        public let conditions: Conditions?
        /// The description of the calculated attribute.
        public let description: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// The unique name of the domain.
        public let domainName: String

        @inlinable
        public init(calculatedAttributeName: String, conditions: Conditions? = nil, description: String? = nil, displayName: String? = nil, domainName: String) {
            self.calculatedAttributeName = calculatedAttributeName
            self.conditions = conditions
            self.description = description
            self.displayName = displayName
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.calculatedAttributeName, key: "CalculatedAttributeName")
            try container.encodeIfPresent(self.conditions, forKey: .conditions)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, max: 255)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, min: 1)
            try self.validate(self.calculatedAttributeName, name: "calculatedAttributeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.conditions?.validate(name: "\(name).conditions")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-\\s]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "Conditions"
            case description = "Description"
            case displayName = "DisplayName"
        }
    }

    public struct UpdateCalculatedAttributeDefinitionResponse: AWSDecodableShape {
        /// The mathematical expression and a list of attribute items specified in that expression.
        public let attributeDetails: AttributeDetails?
        /// The unique name of the calculated attribute.
        public let calculatedAttributeName: String?
        /// The conditions including range, object count, and threshold for the calculated attribute.
        public let conditions: Conditions?
        /// The timestamp of when the calculated attribute definition was created.
        public let createdAt: Date?
        /// The description of the calculated attribute.
        public let description: String?
        /// The display name of the calculated attribute.
        public let displayName: String?
        /// The timestamp of when the calculated attribute definition was most recently edited.
        public let lastUpdatedAt: Date?
        /// The aggregation operation to perform for the calculated attribute.
        public let statistic: Statistic?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributeDetails: AttributeDetails? = nil, calculatedAttributeName: String? = nil, conditions: Conditions? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, lastUpdatedAt: Date? = nil, statistic: Statistic? = nil, tags: [String: String]? = nil) {
            self.attributeDetails = attributeDetails
            self.calculatedAttributeName = calculatedAttributeName
            self.conditions = conditions
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.lastUpdatedAt = lastUpdatedAt
            self.statistic = statistic
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributeDetails = "AttributeDetails"
            case calculatedAttributeName = "CalculatedAttributeName"
            case conditions = "Conditions"
            case createdAt = "CreatedAt"
            case description = "Description"
            case displayName = "DisplayName"
            case lastUpdatedAt = "LastUpdatedAt"
            case statistic = "Statistic"
            case tags = "Tags"
        }
    }

    public struct UpdateDomainRequest: AWSEncodableShape {
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. If specified as an empty string, it will clear any existing value. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage. If specified as an empty string, it will clear any existing value.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int?
        /// The unique name of the domain.
        public let domainName: String
        /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly
        /// batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every
        /// Saturday at 12AM UTC to detect duplicate profiles in your domains.  After the Identity Resolution Job completes, use the
        /// GetMatches
        /// API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from
        /// S3.
        public let matching: MatchingRequest?
        /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        public let ruleBasedMatching: RuleBasedMatchingRequest?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int? = nil, domainName: String, matching: MatchingRequest? = nil, ruleBasedMatching: RuleBasedMatchingRequest? = nil, tags: [String: String]? = nil) {
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.matching = matching
            self.ruleBasedMatching = ruleBasedMatching
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deadLetterQueueUrl, forKey: .deadLetterQueueUrl)
            try container.encodeIfPresent(self.defaultEncryptionKey, forKey: .defaultEncryptionKey)
            try container.encodeIfPresent(self.defaultExpirationDays, forKey: .defaultExpirationDays)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.matching, forKey: .matching)
            try container.encodeIfPresent(self.ruleBasedMatching, forKey: .ruleBasedMatching)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.deadLetterQueueUrl, name: "deadLetterQueueUrl", parent: name, max: 255)
            try self.validate(self.defaultEncryptionKey, name: "defaultEncryptionKey", parent: name, max: 255)
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, max: 1098)
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.matching?.validate(name: "\(name).matching")
            try self.ruleBasedMatching?.validate(name: "\(name).ruleBasedMatching")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case matching = "Matching"
            case ruleBasedMatching = "RuleBasedMatching"
            case tags = "Tags"
        }
    }

    public struct UpdateDomainResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int?
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly
        /// batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every
        /// Saturday at 12AM UTC to detect duplicate profiles in your domains.  After the Identity Resolution Job completes, use the
        /// GetMatches
        /// API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from
        /// S3.
        public let matching: MatchingResponse?
        /// The process of matching duplicate profiles using the rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        public let ruleBasedMatching: RuleBasedMatchingResponse?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int? = nil, domainName: String, lastUpdatedAt: Date, matching: MatchingResponse? = nil, ruleBasedMatching: RuleBasedMatchingResponse? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.matching = matching
            self.ruleBasedMatching = ruleBasedMatching
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case matching = "Matching"
            case ruleBasedMatching = "RuleBasedMatching"
            case tags = "Tags"
        }
    }

    public struct UpdateEventTriggerRequest: AWSEncodableShape {
        /// The description of the event trigger.
        public let description: String?
        /// The unique name of the domain.
        public let domainName: String
        /// A list of conditions that determine when an event should trigger the destination.
        public let eventTriggerConditions: [EventTriggerCondition]?
        /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
        public let eventTriggerLimits: EventTriggerLimits?
        /// The unique name of the event trigger.
        public let eventTriggerName: String
        /// The unique name of the object type.
        public let objectTypeName: String?
        /// The destination is triggered only for profiles that meet the criteria of a segment definition.
        public let segmentFilter: String?

        @inlinable
        public init(description: String? = nil, domainName: String, eventTriggerConditions: [EventTriggerCondition]? = nil, eventTriggerLimits: EventTriggerLimits? = nil, eventTriggerName: String, objectTypeName: String? = nil, segmentFilter: String? = nil) {
            self.description = description
            self.domainName = domainName
            self.eventTriggerConditions = eventTriggerConditions
            self.eventTriggerLimits = eventTriggerLimits
            self.eventTriggerName = eventTriggerName
            self.objectTypeName = objectTypeName
            self.segmentFilter = segmentFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.eventTriggerConditions, forKey: .eventTriggerConditions)
            try container.encodeIfPresent(self.eventTriggerLimits, forKey: .eventTriggerLimits)
            request.encodePath(self.eventTriggerName, key: "EventTriggerName")
            try container.encodeIfPresent(self.objectTypeName, forKey: .objectTypeName)
            try container.encodeIfPresent(self.segmentFilter, forKey: .segmentFilter)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.eventTriggerConditions?.forEach {
                try $0.validate(name: "\(name).eventTriggerConditions[]")
            }
            try self.validate(self.eventTriggerConditions, name: "eventTriggerConditions", parent: name, max: 5)
            try self.validate(self.eventTriggerConditions, name: "eventTriggerConditions", parent: name, min: 1)
            try self.eventTriggerLimits?.validate(name: "\(name).eventTriggerLimits")
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, max: 64)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, min: 1)
            try self.validate(self.eventTriggerName, name: "eventTriggerName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.validate(self.segmentFilter, name: "segmentFilter", parent: name, max: 64)
            try self.validate(self.segmentFilter, name: "segmentFilter", parent: name, min: 1)
            try self.validate(self.segmentFilter, name: "segmentFilter", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventTriggerConditions = "EventTriggerConditions"
            case eventTriggerLimits = "EventTriggerLimits"
            case objectTypeName = "ObjectTypeName"
            case segmentFilter = "SegmentFilter"
        }
    }

    public struct UpdateEventTriggerResponse: AWSDecodableShape {
        /// The timestamp of when the event trigger was created.
        public let createdAt: Date?
        /// The description of the event trigger.
        public let description: String?
        /// A list of conditions that determine when an event should trigger the destination.
        public let eventTriggerConditions: [EventTriggerCondition]?
        /// Defines limits controlling whether an event triggers the destination, based on ingestion latency and the number of invocations per profile over specific time periods.
        public let eventTriggerLimits: EventTriggerLimits?
        /// The unique name of the event trigger.
        public let eventTriggerName: String?
        /// The timestamp of when the event trigger was most recently updated.
        public let lastUpdatedAt: Date?
        /// The unique name of the object type.
        public let objectTypeName: String?
        /// The destination is triggered only for profiles that meet the criteria of a segment definition.
        public let segmentFilter: String?
        /// An array of key-value pairs to apply to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, eventTriggerConditions: [EventTriggerCondition]? = nil, eventTriggerLimits: EventTriggerLimits? = nil, eventTriggerName: String? = nil, lastUpdatedAt: Date? = nil, objectTypeName: String? = nil, segmentFilter: String? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.eventTriggerConditions = eventTriggerConditions
            self.eventTriggerLimits = eventTriggerLimits
            self.eventTriggerName = eventTriggerName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.segmentFilter = segmentFilter
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case eventTriggerConditions = "EventTriggerConditions"
            case eventTriggerLimits = "EventTriggerLimits"
            case eventTriggerName = "EventTriggerName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case segmentFilter = "SegmentFilter"
            case tags = "Tags"
        }
    }

    public struct UpdateProfileRequest: AWSEncodableShape {
        /// An account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customers profile.
        public let additionalInformation: String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public let address: UpdateAddress?
        /// A key value pair of attributes of a customer profile.
        public let attributes: [String: String]?
        /// The customers billing address.
        public let billingAddress: UpdateAddress?
        /// The customers birth date.
        public let birthDate: String?
        /// The customers business email address.
        public let businessEmailAddress: String?
        /// The name of the customers business.
        public let businessName: String?
        /// The customers business phone number.
        public let businessPhoneNumber: String?
        /// The unique name of the domain.
        public let domainName: String
        /// The customers email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customers first name.
        public let firstName: String?
        /// The gender with which the customer identifies.
        public let gender: Gender?
        /// An alternative to Gender which accepts any string as input.
        public let genderString: String?
        /// The customers home phone number.
        public let homePhoneNumber: String?
        /// The customers last name.
        public let lastName: String?
        /// The customers mailing address.
        public let mailingAddress: UpdateAddress?
        /// The customers middle name.
        public let middleName: String?
        /// The customers mobile phone number.
        public let mobilePhoneNumber: String?
        /// The type of profile used to describe the customer.
        public let partyType: PartyType?
        /// An alternative to PartyType which accepts any string as input.
        public let partyTypeString: String?
        /// The customers personal email address.
        public let personalEmailAddress: String?
        /// The customers phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// The customers shipping address.
        public let shippingAddress: UpdateAddress?

        @inlinable
        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: UpdateAddress? = nil, attributes: [String: String]? = nil, billingAddress: UpdateAddress? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, domainName: String, emailAddress: String? = nil, firstName: String? = nil, gender: Gender? = nil, genderString: String? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: UpdateAddress? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: PartyType? = nil, partyTypeString: String? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, profileId: String, shippingAddress: UpdateAddress? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.domainName = domainName
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.genderString = genderString
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.partyTypeString = partyTypeString
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.shippingAddress = shippingAddress
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountNumber, forKey: .accountNumber)
            try container.encodeIfPresent(self.additionalInformation, forKey: .additionalInformation)
            try container.encodeIfPresent(self.address, forKey: .address)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encodeIfPresent(self.billingAddress, forKey: .billingAddress)
            try container.encodeIfPresent(self.birthDate, forKey: .birthDate)
            try container.encodeIfPresent(self.businessEmailAddress, forKey: .businessEmailAddress)
            try container.encodeIfPresent(self.businessName, forKey: .businessName)
            try container.encodeIfPresent(self.businessPhoneNumber, forKey: .businessPhoneNumber)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.emailAddress, forKey: .emailAddress)
            try container.encodeIfPresent(self.firstName, forKey: .firstName)
            try container.encodeIfPresent(self.gender, forKey: .gender)
            try container.encodeIfPresent(self.genderString, forKey: .genderString)
            try container.encodeIfPresent(self.homePhoneNumber, forKey: .homePhoneNumber)
            try container.encodeIfPresent(self.lastName, forKey: .lastName)
            try container.encodeIfPresent(self.mailingAddress, forKey: .mailingAddress)
            try container.encodeIfPresent(self.middleName, forKey: .middleName)
            try container.encodeIfPresent(self.mobilePhoneNumber, forKey: .mobilePhoneNumber)
            try container.encodeIfPresent(self.partyType, forKey: .partyType)
            try container.encodeIfPresent(self.partyTypeString, forKey: .partyTypeString)
            try container.encodeIfPresent(self.personalEmailAddress, forKey: .personalEmailAddress)
            try container.encodeIfPresent(self.phoneNumber, forKey: .phoneNumber)
            try container.encode(self.profileId, forKey: .profileId)
            try container.encodeIfPresent(self.shippingAddress, forKey: .shippingAddress)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, max: 255)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, max: 1000)
            try self.address?.validate(name: "\(name).address")
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 255)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 255)
            }
            try self.billingAddress?.validate(name: "\(name).billingAddress")
            try self.validate(self.birthDate, name: "birthDate", parent: name, max: 255)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, max: 255)
            try self.validate(self.businessName, name: "businessName", parent: name, max: 255)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 255)
            try self.validate(self.firstName, name: "firstName", parent: name, max: 255)
            try self.validate(self.genderString, name: "genderString", parent: name, max: 255)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, max: 255)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 255)
            try self.mailingAddress?.validate(name: "\(name).mailingAddress")
            try self.validate(self.middleName, name: "middleName", parent: name, max: 255)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, max: 255)
            try self.validate(self.partyTypeString, name: "partyTypeString", parent: name, max: 255)
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, max: 255)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-f0-9]{32}$")
            try self.shippingAddress?.validate(name: "\(name).shippingAddress")
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case gender = "Gender"
            case genderString = "GenderString"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case partyTypeString = "PartyTypeString"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case profileId = "ProfileId"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct UpdateProfileResponse: AWSDecodableShape {
        /// The unique identifier of a customer profile.
        public let profileId: String

        @inlinable
        public init(profileId: String) {
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
        }
    }

    public struct WorkflowAttributes: AWSDecodableShape {
        /// Workflow attributes specific to APPFLOW_INTEGRATION workflow.
        public let appflowIntegration: AppflowIntegrationWorkflowAttributes?

        @inlinable
        public init(appflowIntegration: AppflowIntegrationWorkflowAttributes? = nil) {
            self.appflowIntegration = appflowIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case appflowIntegration = "AppflowIntegration"
        }
    }

    public struct WorkflowMetrics: AWSDecodableShape {
        /// Workflow execution metrics for APPFLOW_INTEGRATION workflow.
        public let appflowIntegration: AppflowIntegrationWorkflowMetrics?

        @inlinable
        public init(appflowIntegration: AppflowIntegrationWorkflowMetrics? = nil) {
            self.appflowIntegration = appflowIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case appflowIntegration = "AppflowIntegration"
        }
    }

    public struct WorkflowStepItem: AWSDecodableShape {
        /// Workflow step information specific to APPFLOW_INTEGRATION workflow.
        public let appflowIntegration: AppflowIntegrationWorkflowStep?

        @inlinable
        public init(appflowIntegration: AppflowIntegrationWorkflowStep? = nil) {
            self.appflowIntegration = appflowIntegration
        }

        private enum CodingKeys: String, CodingKey {
            case appflowIntegration = "AppflowIntegration"
        }
    }

    public struct ZendeskSourceProperties: AWSEncodableShape {
        /// The object specified in the Zendesk flow source.
        public let object: String

        @inlinable
        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
        }
    }
}

// MARK: - Errors

/// Error enum for CustomerProfiles
public struct CustomerProfilesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CustomerProfiles
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The input you provided is invalid.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// An internal service error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource does not exist, or access was denied.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You exceeded the maximum number of requests.
    public static var throttlingException: Self { .init(.throttlingException) }
}

extension CustomerProfilesErrorType: Equatable {
    public static func == (lhs: CustomerProfilesErrorType, rhs: CustomerProfilesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CustomerProfilesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
