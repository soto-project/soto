//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AppIntegrations {
    // MARK: Enums

    // MARK: Shapes

    public struct ApplicationAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Application.
        public let applicationArn: String?
        /// The Amazon Resource Name (ARN) of the Application Association.
        public let applicationAssociationArn: String?
        /// The identifier for the client that is associated with the Application Association.
        public let clientId: String?

        public init(applicationArn: String? = nil, applicationAssociationArn: String? = nil, clientId: String? = nil) {
            self.applicationArn = applicationArn
            self.applicationAssociationArn = applicationAssociationArn
            self.clientId = clientId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "ApplicationArn"
            case applicationAssociationArn = "ApplicationAssociationArn"
            case clientId = "ClientId"
        }
    }

    public struct ApplicationSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The external URL source for the application.
        public let externalUrlConfig: ExternalUrlConfig?

        public init(externalUrlConfig: ExternalUrlConfig? = nil) {
            self.externalUrlConfig = externalUrlConfig
        }

        public func validate(name: String) throws {
            try self.externalUrlConfig?.validate(name: "\(name).externalUrlConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case externalUrlConfig = "ExternalUrlConfig"
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Application.
        public let arn: String?
        /// The time when the application was created.
        public let createdTime: Date?
        /// A unique identifier for the Application.
        public let id: String?
        /// The time when the application was last modified.
        public let lastModifiedTime: Date?
        /// The name of the application.
        public let name: String?
        /// The namespace of the application.
        public let namespace: String?

        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, namespace: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case namespace = "Namespace"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// The configuration for where the application should be loaded from.
        public let applicationSourceConfig: ApplicationSourceConfig
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the application.
        public let description: String?
        /// The name of the application.
        public let name: String
        /// The namespace of the application.
        public let namespace: String
        /// The configuration of events or requests that the application has access to.
        public let permissions: [String]?
        /// The events that the application publishes.
        public let publications: [Publication]?
        /// The events that the application subscribes.
        public let subscriptions: [Subscription]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(applicationSourceConfig: ApplicationSourceConfig, clientToken: String? = CreateApplicationRequest.idempotencyToken(), description: String? = nil, name: String, namespace: String, permissions: [String]? = nil, tags: [String: String]? = nil) {
            self.applicationSourceConfig = applicationSourceConfig
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.namespace = namespace
            self.permissions = permissions
            self.publications = nil
            self.subscriptions = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members publications, subscriptions have been deprecated")
        public init(applicationSourceConfig: ApplicationSourceConfig, clientToken: String? = CreateApplicationRequest.idempotencyToken(), description: String? = nil, name: String, namespace: String, permissions: [String]? = nil, publications: [Publication]? = nil, subscriptions: [Subscription]? = nil, tags: [String: String]? = nil) {
            self.applicationSourceConfig = applicationSourceConfig
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.namespace = namespace
            self.permissions = permissions
            self.publications = publications
            self.subscriptions = subscriptions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.applicationSourceConfig.validate(name: "\(name).applicationSourceConfig")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._ \\-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 32)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, max: 255)
                try validate($0, name: "permissions[]", parent: name, min: 1)
                try validate($0, name: "permissions[]", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-\\*]+$")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 150)
            try self.publications?.forEach {
                try $0.validate(name: "\(name).publications[]")
            }
            try self.validate(self.publications, name: "publications", parent: name, max: 50)
            try self.subscriptions?.forEach {
                try $0.validate(name: "\(name).subscriptions[]")
            }
            try self.validate(self.subscriptions, name: "subscriptions", parent: name, max: 50)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSourceConfig = "ApplicationSourceConfig"
            case clientToken = "ClientToken"
            case description = "Description"
            case name = "Name"
            case namespace = "Namespace"
            case permissions = "Permissions"
            case publications = "Publications"
            case subscriptions = "Subscriptions"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Application.
        public let arn: String?
        /// A unique identifier for the Application.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateDataIntegrationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A description of the DataIntegration.
        public let description: String?
        /// The configuration for what files should be pulled from the source.
        public let fileConfiguration: FileConfiguration?
        /// The KMS key for the DataIntegration.
        public let kmsKey: String
        /// The name of the DataIntegration.
        public let name: String
        /// The configuration for what data should be pulled from the source.
        public let objectConfiguration: [String: [String: [String]]]?
        /// The name of the data and how often it should be pulled from the source.
        public let scheduleConfig: ScheduleConfiguration?
        /// The URI of the data source.
        public let sourceURI: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDataIntegrationRequest.idempotencyToken(), description: String? = nil, fileConfiguration: FileConfiguration? = nil, kmsKey: String, name: String, objectConfiguration: [String: [String: [String]]]? = nil, scheduleConfig: ScheduleConfiguration? = nil, sourceURI: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.fileConfiguration = fileConfiguration
            self.kmsKey = kmsKey
            self.name = name
            self.objectConfiguration = objectConfiguration
            self.scheduleConfig = scheduleConfig
            self.sourceURI = sourceURI
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.fileConfiguration?.validate(name: "\(name).fileConfiguration")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 255)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.objectConfiguration?.forEach {
                try validate($0.key, name: "objectConfiguration.key", parent: name, max: 255)
                try validate($0.key, name: "objectConfiguration.key", parent: name, min: 1)
                try validate($0.key, name: "objectConfiguration.key", parent: name, pattern: "\\S")
            }
            try self.scheduleConfig?.validate(name: "\(name).scheduleConfig")
            try self.validate(self.sourceURI, name: "sourceURI", parent: name, max: 1000)
            try self.validate(self.sourceURI, name: "sourceURI", parent: name, min: 1)
            try self.validate(self.sourceURI, name: "sourceURI", parent: name, pattern: "^(\\w+\\:\\/\\/[\\w.-]+[\\w/!@#+=.-]+$)|(\\w+\\:\\/\\/[\\w.-]+[\\w/!@#+=.-]+[\\w/!@#+=.-]+[\\w/!@#+=.,-]+$)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case fileConfiguration = "FileConfiguration"
            case kmsKey = "KmsKey"
            case name = "Name"
            case objectConfiguration = "ObjectConfiguration"
            case scheduleConfig = "ScheduleConfig"
            case sourceURI = "SourceURI"
            case tags = "Tags"
        }
    }

    public struct CreateDataIntegrationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A description of the DataIntegration.
        public let description: String?
        /// The configuration for what files should be pulled from the source.
        public let fileConfiguration: FileConfiguration?
        /// A unique identifier.
        public let id: String?
        /// The KMS key for the DataIntegration.
        public let kmsKey: String?
        /// The name of the DataIntegration.
        public let name: String?
        /// The configuration for what data should be pulled from the source.
        public let objectConfiguration: [String: [String: [String]]]?
        /// The name of the data and how often it should be pulled from the source.
        public let scheduleConfiguration: ScheduleConfiguration?
        /// The URI of the data source.
        public let sourceURI: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String? = nil, clientToken: String? = nil, description: String? = nil, fileConfiguration: FileConfiguration? = nil, id: String? = nil, kmsKey: String? = nil, name: String? = nil, objectConfiguration: [String: [String: [String]]]? = nil, scheduleConfiguration: ScheduleConfiguration? = nil, sourceURI: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.clientToken = clientToken
            self.description = description
            self.fileConfiguration = fileConfiguration
            self.id = id
            self.kmsKey = kmsKey
            self.name = name
            self.objectConfiguration = objectConfiguration
            self.scheduleConfiguration = scheduleConfiguration
            self.sourceURI = sourceURI
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case clientToken = "ClientToken"
            case description = "Description"
            case fileConfiguration = "FileConfiguration"
            case id = "Id"
            case kmsKey = "KmsKey"
            case name = "Name"
            case objectConfiguration = "ObjectConfiguration"
            case scheduleConfiguration = "ScheduleConfiguration"
            case sourceURI = "SourceURI"
            case tags = "Tags"
        }
    }

    public struct CreateEventIntegrationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the event integration.
        public let description: String?
        /// The EventBridge bus.
        public let eventBridgeBus: String
        /// The event filter.
        public let eventFilter: EventFilter
        /// The name of the event integration.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateEventIntegrationRequest.idempotencyToken(), description: String? = nil, eventBridgeBus: String, eventFilter: EventFilter, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.eventBridgeBus, name: "eventBridgeBus", parent: name, max: 255)
            try self.validate(self.eventBridgeBus, name: "eventBridgeBus", parent: name, min: 1)
            try self.validate(self.eventBridgeBus, name: "eventBridgeBus", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.eventFilter.validate(name: "\(name).eventFilter")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case eventBridgeBus = "EventBridgeBus"
            case eventFilter = "EventFilter"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateEventIntegrationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the event integration.
        public let eventIntegrationArn: String?

        public init(eventIntegrationArn: String? = nil) {
            self.eventIntegrationArn = eventIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventIntegrationArn = "EventIntegrationArn"
        }
    }

    public struct DataIntegrationAssociationSummary: AWSDecodableShape {
        /// The identifier for the client that is associated with the DataIntegration association.
        public let clientId: String?
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public let dataIntegrationArn: String?
        /// The Amazon Resource Name (ARN) of the DataIntegration association.
        public let dataIntegrationAssociationArn: String?

        public init(clientId: String? = nil, dataIntegrationArn: String? = nil, dataIntegrationAssociationArn: String? = nil) {
            self.clientId = clientId
            self.dataIntegrationArn = dataIntegrationArn
            self.dataIntegrationAssociationArn = dataIntegrationAssociationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case dataIntegrationArn = "DataIntegrationArn"
            case dataIntegrationAssociationArn = "DataIntegrationAssociationArn"
        }
    }

    public struct DataIntegrationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public let arn: String?
        /// The name of the DataIntegration.
        public let name: String?
        /// The URI of the data source.
        public let sourceURI: String?

        public init(arn: String? = nil, name: String? = nil, sourceURI: String? = nil) {
            self.arn = arn
            self.name = name
            self.sourceURI = sourceURI
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case sourceURI = "SourceURI"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Application.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}|[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(:[\\w\\$]+)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataIntegrationRequest: AWSEncodableShape {
        /// A unique identifier for the DataIntegration.
        public let dataIntegrationIdentifier: String

        public init(dataIntegrationIdentifier: String) {
            self.dataIntegrationIdentifier = dataIntegrationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataIntegrationIdentifier, key: "DataIntegrationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, max: 255)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, min: 1)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventIntegrationRequest: AWSEncodableShape {
        /// The name of the event integration.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EventFilter: AWSEncodableShape & AWSDecodableShape {
        /// The source of the events.
        public let source: String

        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 256)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws\\.partner\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "Source"
        }
    }

    public struct EventIntegration: AWSDecodableShape {
        /// The event integration description.
        public let description: String?
        /// The Amazon EventBridge bus for the event integration.
        public let eventBridgeBus: String?
        /// The event integration filter.
        public let eventFilter: EventFilter?
        /// The Amazon Resource Name (ARN) of the event integration.
        public let eventIntegrationArn: String?
        /// The name of the event integration.
        public let name: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, eventBridgeBus: String? = nil, eventFilter: EventFilter? = nil, eventIntegrationArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.eventIntegrationArn = eventIntegrationArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventBridgeBus = "EventBridgeBus"
            case eventFilter = "EventFilter"
            case eventIntegrationArn = "EventIntegrationArn"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct EventIntegrationAssociation: AWSDecodableShape {
        /// The metadata associated with the client.
        public let clientAssociationMetadata: [String: String]?
        /// The identifier for the client that is associated with the event integration.
        public let clientId: String?
        /// The name of the EventBridge rule.
        public let eventBridgeRuleName: String?
        /// The Amazon Resource Name (ARN) for the event integration association.
        public let eventIntegrationAssociationArn: String?
        /// The identifier for the event integration association.
        public let eventIntegrationAssociationId: String?
        /// The name of the event integration.
        public let eventIntegrationName: String?

        public init(clientAssociationMetadata: [String: String]? = nil, clientId: String? = nil, eventBridgeRuleName: String? = nil, eventIntegrationAssociationArn: String? = nil, eventIntegrationAssociationId: String? = nil, eventIntegrationName: String? = nil) {
            self.clientAssociationMetadata = clientAssociationMetadata
            self.clientId = clientId
            self.eventBridgeRuleName = eventBridgeRuleName
            self.eventIntegrationAssociationArn = eventIntegrationAssociationArn
            self.eventIntegrationAssociationId = eventIntegrationAssociationId
            self.eventIntegrationName = eventIntegrationName
        }

        private enum CodingKeys: String, CodingKey {
            case clientAssociationMetadata = "ClientAssociationMetadata"
            case clientId = "ClientId"
            case eventBridgeRuleName = "EventBridgeRuleName"
            case eventIntegrationAssociationArn = "EventIntegrationAssociationArn"
            case eventIntegrationAssociationId = "EventIntegrationAssociationId"
            case eventIntegrationName = "EventIntegrationName"
        }
    }

    public struct ExternalUrlConfig: AWSEncodableShape & AWSDecodableShape {
        /// The URL to access the application.
        public let accessUrl: String
        /// Additional URLs to allow list if different than the access URL.
        public let approvedOrigins: [String]?

        public init(accessUrl: String, approvedOrigins: [String]? = nil) {
            self.accessUrl = accessUrl
            self.approvedOrigins = approvedOrigins
        }

        public func validate(name: String) throws {
            try self.validate(self.accessUrl, name: "accessUrl", parent: name, max: 1000)
            try self.validate(self.accessUrl, name: "accessUrl", parent: name, min: 1)
            try self.validate(self.accessUrl, name: "accessUrl", parent: name, pattern: "^\\w+\\:\\/\\/.*$")
            try self.approvedOrigins?.forEach {
                try validate($0, name: "approvedOrigins[]", parent: name, max: 128)
                try validate($0, name: "approvedOrigins[]", parent: name, min: 1)
                try validate($0, name: "approvedOrigins[]", parent: name, pattern: "^\\w+\\:\\/\\/.*$")
            }
            try self.validate(self.approvedOrigins, name: "approvedOrigins", parent: name, max: 50)
            try self.validate(self.approvedOrigins, name: "approvedOrigins", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accessUrl = "AccessUrl"
            case approvedOrigins = "ApprovedOrigins"
        }
    }

    public struct FileConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Restrictions for what files should be pulled from the source.
        public let filters: [String: [String]]?
        /// Identifiers for the source folders to pull all files from recursively.
        public let folders: [String]

        public init(filters: [String: [String]]? = nil, folders: [String]) {
            self.filters = filters
            self.folders = folders
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try validate($0.key, name: "filters.key", parent: name, max: 255)
                try validate($0.key, name: "filters.key", parent: name, min: 1)
                try validate($0.key, name: "filters.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "filters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "filters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.folders.forEach {
                try validate($0, name: "folders[]", parent: name, max: 200)
                try validate($0, name: "folders[]", parent: name, min: 1)
                try validate($0, name: "folders[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.folders, name: "folders", parent: name, max: 10)
            try self.validate(self.folders, name: "folders", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case folders = "Folders"
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Application.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}|[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(:[\\w\\$]+)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The configuration for where the application should be loaded from.
        public let applicationSourceConfig: ApplicationSourceConfig?
        /// The Amazon Resource Name (ARN) of the Application.
        public let arn: String?
        /// The created time of the Application.
        public let createdTime: Date?
        /// The description of the application.
        public let description: String?
        /// A unique identifier for the Application.
        public let id: String?
        /// The last modified time of the Application.
        public let lastModifiedTime: Date?
        /// The name of the application.
        public let name: String?
        /// The namespace of the application.
        public let namespace: String?
        /// The configuration of events or requests that the application has access to.
        public let permissions: [String]?
        /// The events that the application publishes.
        public let publications: [Publication]?
        /// The events that the application subscribes.
        public let subscriptions: [Subscription]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(applicationSourceConfig: ApplicationSourceConfig? = nil, arn: String? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, namespace: String? = nil, permissions: [String]? = nil, tags: [String: String]? = nil) {
            self.applicationSourceConfig = applicationSourceConfig
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
            self.permissions = permissions
            self.publications = nil
            self.subscriptions = nil
            self.tags = tags
        }

        @available(*, deprecated, message: "Members publications, subscriptions have been deprecated")
        public init(applicationSourceConfig: ApplicationSourceConfig? = nil, arn: String? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, namespace: String? = nil, permissions: [String]? = nil, publications: [Publication]? = nil, subscriptions: [Subscription]? = nil, tags: [String: String]? = nil) {
            self.applicationSourceConfig = applicationSourceConfig
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
            self.permissions = permissions
            self.publications = publications
            self.subscriptions = subscriptions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSourceConfig = "ApplicationSourceConfig"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case namespace = "Namespace"
            case permissions = "Permissions"
            case publications = "Publications"
            case subscriptions = "Subscriptions"
            case tags = "Tags"
        }
    }

    public struct GetDataIntegrationRequest: AWSEncodableShape {
        /// A unique identifier.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 255)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataIntegrationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the DataIntegration.
        public let arn: String?
        /// The KMS key for the DataIntegration.
        public let description: String?
        /// The configuration for what files should be pulled from the source.
        public let fileConfiguration: FileConfiguration?
        /// A unique identifier.
        public let id: String?
        /// The KMS key for the DataIntegration.
        public let kmsKey: String?
        /// The name of the DataIntegration.
        public let name: String?
        /// The configuration for what data should be pulled from the source.
        public let objectConfiguration: [String: [String: [String]]]?
        /// The name of the data and how often it should be pulled from the source.
        public let scheduleConfiguration: ScheduleConfiguration?
        /// The URI of the data source.
        public let sourceURI: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, fileConfiguration: FileConfiguration? = nil, id: String? = nil, kmsKey: String? = nil, name: String? = nil, objectConfiguration: [String: [String: [String]]]? = nil, scheduleConfiguration: ScheduleConfiguration? = nil, sourceURI: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.fileConfiguration = fileConfiguration
            self.id = id
            self.kmsKey = kmsKey
            self.name = name
            self.objectConfiguration = objectConfiguration
            self.scheduleConfiguration = scheduleConfiguration
            self.sourceURI = sourceURI
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case fileConfiguration = "FileConfiguration"
            case id = "Id"
            case kmsKey = "KmsKey"
            case name = "Name"
            case objectConfiguration = "ObjectConfiguration"
            case scheduleConfiguration = "ScheduleConfiguration"
            case sourceURI = "SourceURI"
            case tags = "Tags"
        }
    }

    public struct GetEventIntegrationRequest: AWSEncodableShape {
        /// The name of the event integration.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventIntegrationResponse: AWSDecodableShape {
        /// The description of the event integration.
        public let description: String?
        /// The EventBridge bus.
        public let eventBridgeBus: String?
        /// The event filter.
        public let eventFilter: EventFilter?
        /// The Amazon Resource Name (ARN) for the event integration.
        public let eventIntegrationArn: String?
        /// The name of the event integration.
        public let name: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, eventBridgeBus: String? = nil, eventFilter: EventFilter? = nil, eventIntegrationArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.eventIntegrationArn = eventIntegrationArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventBridgeBus = "EventBridgeBus"
            case eventFilter = "EventFilter"
            case eventIntegrationArn = "EventIntegrationArn"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct ListApplicationAssociationsRequest: AWSEncodableShape {
        /// A unique identifier for the Application.
        public let applicationId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 2048)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 1)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^(arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}|[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(:[\\w\\$]+)?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationAssociationsResponse: AWSDecodableShape {
        /// List of Application Associations for the Application.
        public let applicationAssociations: [ApplicationAssociationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(applicationAssociations: [ApplicationAssociationSummary]? = nil, nextToken: String? = nil) {
            self.applicationAssociations = applicationAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationAssociations = "ApplicationAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// The Applications associated with this account.
        public let applications: [ApplicationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(applications: [ApplicationSummary]? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "Applications"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataIntegrationAssociationsRequest: AWSEncodableShape {
        /// A unique identifier for the DataIntegration.
        public let dataIntegrationIdentifier: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(dataIntegrationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dataIntegrationIdentifier = dataIntegrationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataIntegrationIdentifier, key: "DataIntegrationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, max: 255)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, min: 1)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataIntegrationAssociationsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) and unique ID of the DataIntegration association.
        public let dataIntegrationAssociations: [DataIntegrationAssociationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(dataIntegrationAssociations: [DataIntegrationAssociationSummary]? = nil, nextToken: String? = nil) {
            self.dataIntegrationAssociations = dataIntegrationAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataIntegrationAssociations = "DataIntegrationAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataIntegrationsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataIntegrationsResponse: AWSDecodableShape {
        /// The DataIntegrations associated with this account.
        public let dataIntegrations: [DataIntegrationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(dataIntegrations: [DataIntegrationSummary]? = nil, nextToken: String? = nil) {
            self.dataIntegrations = dataIntegrations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataIntegrations = "DataIntegrations"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventIntegrationAssociationsRequest: AWSEncodableShape {
        /// The name of the event integration.
        public let eventIntegrationName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(eventIntegrationName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.eventIntegrationName = eventIntegrationName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventIntegrationName, key: "EventIntegrationName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.eventIntegrationName, name: "eventIntegrationName", parent: name, max: 255)
            try self.validate(self.eventIntegrationName, name: "eventIntegrationName", parent: name, min: 1)
            try self.validate(self.eventIntegrationName, name: "eventIntegrationName", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventIntegrationAssociationsResponse: AWSDecodableShape {
        /// The event integration associations.
        public let eventIntegrationAssociations: [EventIntegrationAssociation]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(eventIntegrationAssociations: [EventIntegrationAssociation]? = nil, nextToken: String? = nil) {
            self.eventIntegrationAssociations = eventIntegrationAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventIntegrationAssociations = "EventIntegrationAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventIntegrationsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventIntegrationsResponse: AWSDecodableShape {
        /// The event integrations.
        public let eventIntegrations: [EventIntegration]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(eventIntegrations: [EventIntegration]? = nil, nextToken: String? = nil) {
            self.eventIntegrations = eventIntegrations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventIntegrations = "EventIntegrations"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Publication: AWSEncodableShape & AWSDecodableShape {
        /// The description of the publication.
        public let description: String?
        /// The name of the publication.
        public let event: String
        /// The JSON schema of the publication event.
        public let schema: String

        public init(description: String? = nil, event: String, schema: String) {
            self.description = description
            self.event = event
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.event, name: "event", parent: name, max: 255)
            try self.validate(self.event, name: "event", parent: name, min: 1)
            try self.validate(self.event, name: "event", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+::[a-zA-Z0-9\\/\\._\\-]+(?:\\*)?$")
            try self.validate(self.schema, name: "schema", parent: name, max: 10240)
            try self.validate(self.schema, name: "schema", parent: name, min: 1)
            try self.validate(self.schema, name: "schema", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case event = "Event"
            case schema = "Schema"
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The start date for objects to import in the first flow run as an Unix/epoch timestamp in milliseconds or in ISO-8601 format.
        public let firstExecutionFrom: String?
        /// The name of the object to pull from the data source.
        public let object: String?
        /// How often the data should be pulled from data source.
        public let scheduleExpression: String

        public init(firstExecutionFrom: String? = nil, object: String? = nil, scheduleExpression: String) {
            self.firstExecutionFrom = firstExecutionFrom
            self.object = object
            self.scheduleExpression = scheduleExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.firstExecutionFrom, name: "firstExecutionFrom", parent: name, max: 255)
            try self.validate(self.firstExecutionFrom, name: "firstExecutionFrom", parent: name, min: 1)
            try self.validate(self.firstExecutionFrom, name: "firstExecutionFrom", parent: name, pattern: "\\S")
            try self.validate(self.object, name: "object", parent: name, max: 255)
            try self.validate(self.object, name: "object", parent: name, min: 1)
            try self.validate(self.object, name: "object", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 255)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case firstExecutionFrom = "FirstExecutionFrom"
            case object = "Object"
            case scheduleExpression = "ScheduleExpression"
        }
    }

    public struct Subscription: AWSEncodableShape & AWSDecodableShape {
        /// The description of the subscription.
        public let description: String?
        /// The name of the subscription.
        public let event: String

        public init(description: String? = nil, event: String) {
            self.description = description
            self.event = event
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.event, name: "event", parent: name, max: 255)
            try self.validate(self.event, name: "event", parent: name, min: 1)
            try self.validate(self.event, name: "event", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+::[a-zA-Z0-9\\/\\._\\-]+(?:\\*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case event = "Event"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// The configuration for where the application should be loaded from.
        public let applicationSourceConfig: ApplicationSourceConfig?
        /// The Amazon Resource Name (ARN) of the Application.
        public let arn: String
        /// The description of the application.
        public let description: String?
        /// The name of the application.
        public let name: String?
        /// The configuration of events or requests that the application has access to.
        public let permissions: [String]?
        /// The events that the application publishes.
        public let publications: [Publication]?
        /// The events that the application subscribes.
        public let subscriptions: [Subscription]?

        public init(applicationSourceConfig: ApplicationSourceConfig? = nil, arn: String, description: String? = nil, name: String? = nil, permissions: [String]? = nil) {
            self.applicationSourceConfig = applicationSourceConfig
            self.arn = arn
            self.description = description
            self.name = name
            self.permissions = permissions
            self.publications = nil
            self.subscriptions = nil
        }

        @available(*, deprecated, message: "Members publications, subscriptions have been deprecated")
        public init(applicationSourceConfig: ApplicationSourceConfig? = nil, arn: String, description: String? = nil, name: String? = nil, permissions: [String]? = nil, publications: [Publication]? = nil, subscriptions: [Subscription]? = nil) {
            self.applicationSourceConfig = applicationSourceConfig
            self.arn = arn
            self.description = description
            self.name = name
            self.permissions = permissions
            self.publications = publications
            self.subscriptions = subscriptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.applicationSourceConfig, forKey: .applicationSourceConfig)
            request.encodePath(self.arn, key: "Arn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.publications, forKey: .publications)
            try container.encodeIfPresent(self.subscriptions, forKey: .subscriptions)
        }

        public func validate(name: String) throws {
            try self.applicationSourceConfig?.validate(name: "\(name).applicationSourceConfig")
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}|[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(:[\\w\\$]+)?$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._ \\-]+$")
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, max: 255)
                try validate($0, name: "permissions[]", parent: name, min: 1)
                try validate($0, name: "permissions[]", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-\\*]+$")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 150)
            try self.publications?.forEach {
                try $0.validate(name: "\(name).publications[]")
            }
            try self.validate(self.publications, name: "publications", parent: name, max: 50)
            try self.subscriptions?.forEach {
                try $0.validate(name: "\(name).subscriptions[]")
            }
            try self.validate(self.subscriptions, name: "subscriptions", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSourceConfig = "ApplicationSourceConfig"
            case description = "Description"
            case name = "Name"
            case permissions = "Permissions"
            case publications = "Publications"
            case subscriptions = "Subscriptions"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDataIntegrationRequest: AWSEncodableShape {
        /// A description of the DataIntegration.
        public let description: String?
        /// A unique identifier for the DataIntegration.
        public let identifier: String
        /// The name of the DataIntegration.
        public let name: String?

        public init(description: String? = nil, identifier: String, name: String? = nil) {
            self.description = description
            self.identifier = identifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 255)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateDataIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventIntegrationRequest: AWSEncodableShape {
        /// The description of the event integration.
        public let description: String?
        /// The name of the event integration.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateEventIntegrationResponse: AWSDecodableShape {
        public init() {}
    }
}

// MARK: - Errors

/// Error enum for AppIntegrations
public struct AppIntegrationsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case duplicateResourceException = "DuplicateResourceException"
        case internalServiceError = "InternalServiceError"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceQuotaExceededException = "ResourceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unsupportedOperationException = "UnsupportedOperationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppIntegrations
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A resource with the specified name already exists.
    public static var duplicateResourceException: Self { .init(.duplicateResourceException) }
    /// Request processing failed due to an error or failure with the service.
    public static var internalServiceError: Self { .init(.internalServiceError) }
    /// The request is not valid.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The allowed quota for the resource has been exceeded.
    public static var resourceQuotaExceededException: Self { .init(.resourceQuotaExceededException) }
    /// The throttling limit has been exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The operation is not supported.
    public static var unsupportedOperationException: Self { .init(.unsupportedOperationException) }
}

extension AppIntegrationsErrorType: Equatable {
    public static func == (lhs: AppIntegrationsErrorType, rhs: AppIntegrationsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppIntegrationsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
