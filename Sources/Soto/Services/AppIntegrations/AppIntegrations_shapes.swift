//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension AppIntegrations {
    // MARK: Enums

    // MARK: Shapes

    public struct CreateDataIntegrationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// A description of the DataIntegration.
        public let description: String?
        /// The KMS key for the DataIntegration.
        public let kmsKey: String?
        /// The name of the DataIntegration.
        public let name: String
        /// The name of the data and how often it should be pulled from the source.
        public let scheduleConfig: ScheduleConfiguration?
        /// The URI of the data source.
        public let sourceURI: String?
        /// One or more tags.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDataIntegrationRequest.idempotencyToken(), description: String? = nil, kmsKey: String? = nil, name: String, scheduleConfig: ScheduleConfiguration? = nil, sourceURI: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.kmsKey = kmsKey
            self.name = name
            self.scheduleConfig = scheduleConfig
            self.sourceURI = sourceURI
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 255)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.scheduleConfig?.validate(name: "\(name).scheduleConfig")
            try self.validate(self.sourceURI, name: "sourceURI", parent: name, max: 255)
            try self.validate(self.sourceURI, name: "sourceURI", parent: name, min: 1)
            try self.validate(self.sourceURI, name: "sourceURI", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case kmsKey = "KmsKey"
            case name = "Name"
            case scheduleConfig = "ScheduleConfig"
            case sourceURI = "SourceURI"
            case tags = "Tags"
        }
    }

    public struct CreateDataIntegrationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// A description of the DataIntegration.
        public let description: String?
        /// A unique identifier.
        public let id: String?
        /// The KMS key for the DataIntegration.
        public let kmsKey: String?
        /// The name of the DataIntegration.
        public let name: String?
        /// The name of the data and how often it should be pulled from the source.
        public let scheduleConfiguration: ScheduleConfiguration?
        /// The URI of the data source.
        public let sourceURI: String?
        /// One or more tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, clientToken: String? = nil, description: String? = nil, id: String? = nil, kmsKey: String? = nil, name: String? = nil, scheduleConfiguration: ScheduleConfiguration? = nil, sourceURI: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.clientToken = clientToken
            self.description = description
            self.id = id
            self.kmsKey = kmsKey
            self.name = name
            self.scheduleConfiguration = scheduleConfiguration
            self.sourceURI = sourceURI
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case clientToken = "ClientToken"
            case description = "Description"
            case id = "Id"
            case kmsKey = "KmsKey"
            case name = "Name"
            case scheduleConfiguration = "ScheduleConfiguration"
            case sourceURI = "SourceURI"
            case tags = "Tags"
        }
    }

    public struct CreateEventIntegrationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the event integration.
        public let description: String?
        /// The EventBridge bus.
        public let eventBridgeBus: String
        /// The event filter.
        public let eventFilter: EventFilter
        /// The name of the event integration.
        public let name: String
        /// One or more tags.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateEventIntegrationRequest.idempotencyToken(), description: String? = nil, eventBridgeBus: String, eventFilter: EventFilter, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: ".*")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.eventBridgeBus, name: "eventBridgeBus", parent: name, max: 255)
            try self.validate(self.eventBridgeBus, name: "eventBridgeBus", parent: name, min: 1)
            try self.validate(self.eventBridgeBus, name: "eventBridgeBus", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.eventFilter.validate(name: "\(name).eventFilter")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case eventBridgeBus = "EventBridgeBus"
            case eventFilter = "EventFilter"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateEventIntegrationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the event integration.
        public let eventIntegrationArn: String?

        public init(eventIntegrationArn: String? = nil) {
            self.eventIntegrationArn = eventIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventIntegrationArn = "EventIntegrationArn"
        }
    }

    public struct DataIntegrationAssociationSummary: AWSDecodableShape {
        /// The identifier for teh client that is associated with the DataIntegration association.
        public let clientId: String?
        /// The Amazon Resource Name (ARN)of the DataIntegration.
        public let dataIntegrationArn: String?
        /// The Amazon Resource Name (ARN) of the DataIntegration association.
        public let dataIntegrationAssociationArn: String?

        public init(clientId: String? = nil, dataIntegrationArn: String? = nil, dataIntegrationAssociationArn: String? = nil) {
            self.clientId = clientId
            self.dataIntegrationArn = dataIntegrationArn
            self.dataIntegrationAssociationArn = dataIntegrationAssociationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case dataIntegrationArn = "DataIntegrationArn"
            case dataIntegrationAssociationArn = "DataIntegrationAssociationArn"
        }
    }

    public struct DataIntegrationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the DataIntegration.
        public let arn: String?
        /// The name of the DataIntegration.
        public let name: String?
        /// The URI of the data source.
        public let sourceURI: String?

        public init(arn: String? = nil, name: String? = nil, sourceURI: String? = nil) {
            self.arn = arn
            self.name = name
            self.sourceURI = sourceURI
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case sourceURI = "SourceURI"
        }
    }

    public struct DeleteDataIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataIntegrationIdentifier", location: .uri("DataIntegrationIdentifier"))
        ]

        /// A unique identifier for the DataIntegration.
        public let dataIntegrationIdentifier: String

        public init(dataIntegrationIdentifier: String) {
            self.dataIntegrationIdentifier = dataIntegrationIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, max: 255)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, min: 1)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEventIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("Name"))
        ]

        /// The name of the event integration.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EventFilter: AWSEncodableShape & AWSDecodableShape {
        /// The source of the events.
        public let source: String

        public init(source: String) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 256)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^aws\\.partner\\/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "Source"
        }
    }

    public struct EventIntegration: AWSDecodableShape {
        /// The event integration description.
        public let description: String?
        /// The Amazon EventBridge bus for the event integration.
        public let eventBridgeBus: String?
        /// The event integration filter.
        public let eventFilter: EventFilter?
        /// The Amazon Resource Name (ARN) of the event integration.
        public let eventIntegrationArn: String?
        /// The name of the event integration.
        public let name: String?
        /// The tags.
        public let tags: [String: String]?

        public init(description: String? = nil, eventBridgeBus: String? = nil, eventFilter: EventFilter? = nil, eventIntegrationArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.eventIntegrationArn = eventIntegrationArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventBridgeBus = "EventBridgeBus"
            case eventFilter = "EventFilter"
            case eventIntegrationArn = "EventIntegrationArn"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct EventIntegrationAssociation: AWSDecodableShape {
        /// The metadata associated with the client.
        public let clientAssociationMetadata: [String: String]?
        /// The identifier for the client that is associated with the event integration.
        public let clientId: String?
        /// The name of the EventBridge rule.
        public let eventBridgeRuleName: String?
        /// The Amazon Resource Name (ARN) for the event integration association.
        public let eventIntegrationAssociationArn: String?
        /// The identifier for the event integration association.
        public let eventIntegrationAssociationId: String?
        /// The name of the event integration.
        public let eventIntegrationName: String?

        public init(clientAssociationMetadata: [String: String]? = nil, clientId: String? = nil, eventBridgeRuleName: String? = nil, eventIntegrationAssociationArn: String? = nil, eventIntegrationAssociationId: String? = nil, eventIntegrationName: String? = nil) {
            self.clientAssociationMetadata = clientAssociationMetadata
            self.clientId = clientId
            self.eventBridgeRuleName = eventBridgeRuleName
            self.eventIntegrationAssociationArn = eventIntegrationAssociationArn
            self.eventIntegrationAssociationId = eventIntegrationAssociationId
            self.eventIntegrationName = eventIntegrationName
        }

        private enum CodingKeys: String, CodingKey {
            case clientAssociationMetadata = "ClientAssociationMetadata"
            case clientId = "ClientId"
            case eventBridgeRuleName = "EventBridgeRuleName"
            case eventIntegrationAssociationArn = "EventIntegrationAssociationArn"
            case eventIntegrationAssociationId = "EventIntegrationAssociationId"
            case eventIntegrationName = "EventIntegrationName"
        }
    }

    public struct GetDataIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "identifier", location: .uri("Identifier"))
        ]

        /// A unique identifier.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 255)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataIntegrationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the DataIntegration.
        public let arn: String?
        /// The KMS key for the DataIntegration.
        public let description: String?
        /// A unique identifier.
        public let id: String?
        /// The KMS key for the DataIntegration.
        public let kmsKey: String?
        /// The name of the DataIntegration.
        public let name: String?
        /// The name of the data and how often it should be pulled from the source.
        public let scheduleConfiguration: ScheduleConfiguration?
        /// The URI of the data source.
        public let sourceURI: String?
        /// One or more tags.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, id: String? = nil, kmsKey: String? = nil, name: String? = nil, scheduleConfiguration: ScheduleConfiguration? = nil, sourceURI: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.kmsKey = kmsKey
            self.name = name
            self.scheduleConfiguration = scheduleConfiguration
            self.sourceURI = sourceURI
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case kmsKey = "KmsKey"
            case name = "Name"
            case scheduleConfiguration = "ScheduleConfiguration"
            case sourceURI = "SourceURI"
            case tags = "Tags"
        }
    }

    public struct GetEventIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("Name"))
        ]

        /// The name of the event integration.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventIntegrationResponse: AWSDecodableShape {
        /// The description of the event integration.
        public let description: String?
        /// The EventBridge bus.
        public let eventBridgeBus: String?
        /// The event filter.
        public let eventFilter: EventFilter?
        /// The Amazon Resource Name (ARN) for the event integration.
        public let eventIntegrationArn: String?
        /// The name of the event integration.
        public let name: String?
        /// One or more tags.
        public let tags: [String: String]?

        public init(description: String? = nil, eventBridgeBus: String? = nil, eventFilter: EventFilter? = nil, eventIntegrationArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.eventBridgeBus = eventBridgeBus
            self.eventFilter = eventFilter
            self.eventIntegrationArn = eventIntegrationArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case eventBridgeBus = "EventBridgeBus"
            case eventFilter = "EventFilter"
            case eventIntegrationArn = "EventIntegrationArn"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct ListDataIntegrationAssociationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataIntegrationIdentifier", location: .uri("DataIntegrationIdentifier")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// A unique identifier for the DataIntegration.
        public let dataIntegrationIdentifier: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(dataIntegrationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dataIntegrationIdentifier = dataIntegrationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, max: 255)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, min: 1)
            try self.validate(self.dataIntegrationIdentifier, name: "dataIntegrationIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataIntegrationAssociationsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) and unique ID of the DataIntegration association.
        public let dataIntegrationAssociations: [DataIntegrationAssociationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(dataIntegrationAssociations: [DataIntegrationAssociationSummary]? = nil, nextToken: String? = nil) {
            self.dataIntegrationAssociations = dataIntegrationAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataIntegrationAssociations = "DataIntegrationAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataIntegrationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataIntegrationsResponse: AWSDecodableShape {
        /// The DataIntegrations associated with this account.
        public let dataIntegrations: [DataIntegrationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(dataIntegrations: [DataIntegrationSummary]? = nil, nextToken: String? = nil) {
            self.dataIntegrations = dataIntegrations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataIntegrations = "DataIntegrations"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventIntegrationAssociationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eventIntegrationName", location: .uri("EventIntegrationName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The name of the event integration.
        public let eventIntegrationName: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(eventIntegrationName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.eventIntegrationName = eventIntegrationName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.eventIntegrationName, name: "eventIntegrationName", parent: name, max: 255)
            try self.validate(self.eventIntegrationName, name: "eventIntegrationName", parent: name, min: 1)
            try self.validate(self.eventIntegrationName, name: "eventIntegrationName", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventIntegrationAssociationsResponse: AWSDecodableShape {
        /// The event integration associations.
        public let eventIntegrationAssociations: [EventIntegrationAssociation]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(eventIntegrationAssociations: [EventIntegrationAssociation]? = nil, nextToken: String? = nil) {
            self.eventIntegrationAssociations = eventIntegrationAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventIntegrationAssociations = "EventIntegrationAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventIntegrationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventIntegrationsResponse: AWSDecodableShape {
        /// The event integrations.
        public let eventIntegrations: [EventIntegration]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(eventIntegrations: [EventIntegration]? = nil, nextToken: String? = nil) {
            self.eventIntegrations = eventIntegrations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventIntegrations = "EventIntegrations"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The start date for objects to import in the first flow run.
        public let firstExecutionFrom: String?
        /// The name of the object to pull from the data source.
        public let object: String?
        /// How often the data should be pulled from data source.
        public let scheduleExpression: String?

        public init(firstExecutionFrom: String? = nil, object: String? = nil, scheduleExpression: String? = nil) {
            self.firstExecutionFrom = firstExecutionFrom
            self.object = object
            self.scheduleExpression = scheduleExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.firstExecutionFrom, name: "firstExecutionFrom", parent: name, max: 255)
            try self.validate(self.firstExecutionFrom, name: "firstExecutionFrom", parent: name, min: 1)
            try self.validate(self.firstExecutionFrom, name: "firstExecutionFrom", parent: name, pattern: "\\S")
            try self.validate(self.object, name: "object", parent: name, max: 255)
            try self.validate(self.object, name: "object", parent: name, min: 1)
            try self.validate(self.object, name: "object", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 255)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case firstExecutionFrom = "FirstExecutionFrom"
            case object = "Object"
            case scheduleExpression = "ScheduleExpression"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// One or more tags.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9_/.-]{0,63}:[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDataIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "identifier", location: .uri("Identifier"))
        ]

        /// A description of the DataIntegration.
        public let description: String?
        /// A unique identifier for the DataIntegration.
        public let identifier: String
        /// The name of the DataIntegration.
        public let name: String?

        public init(description: String? = nil, identifier: String, name: String? = nil) {
            self.description = description
            self.identifier = identifier
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 255)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateDataIntegrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("Name"))
        ]

        /// The description of the event inegration.
        public let description: String?
        /// The name of the event integration.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\/\\._\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateEventIntegrationResponse: AWSDecodableShape {
        public init() {}
    }
}

// MARK: - Errors

/// Error enum for AppIntegrations
public struct AppIntegrationsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case duplicateResourceException = "DuplicateResourceException"
        case internalServiceError = "InternalServiceError"
        case invalidRequestException = "InvalidRequestException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceQuotaExceededException = "ResourceQuotaExceededException"
        case throttlingException = "ThrottlingException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppIntegrations
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A resource with the specified name already exists.
    public static var duplicateResourceException: Self { .init(.duplicateResourceException) }
    /// Request processing failed due to an error or failure with the service.
    public static var internalServiceError: Self { .init(.internalServiceError) }
    /// The request is not valid.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The allowed quota for the resource has been exceeded.
    public static var resourceQuotaExceededException: Self { .init(.resourceQuotaExceededException) }
    /// The throttling limit has been exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
}

extension AppIntegrationsErrorType: Equatable {
    public static func == (lhs: AppIntegrationsErrorType, rhs: AppIntegrationsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppIntegrationsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
