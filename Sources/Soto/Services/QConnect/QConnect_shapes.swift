//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QConnect {
    // MARK: Enums

    public enum AIAgentAssociationConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum AIAgentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case answerRecommendation = "ANSWER_RECOMMENDATION"
        case manualSearch = "MANUAL_SEARCH"
        public var description: String { return self.rawValue }
    }

    public enum AIPromptAPIFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anthropicClaudeMessages = "ANTHROPIC_CLAUDE_MESSAGES"
        case anthropicClaudeTextCompletions = "ANTHROPIC_CLAUDE_TEXT_COMPLETIONS"
        public var description: String { return self.rawValue }
    }

    public enum AIPromptTemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum AIPromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case answerGeneration = "ANSWER_GENERATION"
        case intentLabelingGeneration = "INTENT_LABELING_GENERATION"
        case queryReformulation = "QUERY_REFORMULATION"
        public var description: String { return self.rawValue }
    }

    public enum AssistantCapabilityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v1 = "V1"
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum AssistantStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssistantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        public var description: String { return self.rawValue }
    }

    public enum AssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum ChunkingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedSize = "FIXED_SIZE"
        case hierarchical = "HIERARCHICAL"
        case none = "NONE"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ContentAssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonConnectGuide = "AMAZON_CONNECT_GUIDE"
        public var description: String { return self.rawValue }
    }

    public enum ContentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ExternalSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonConnect = "AMAZON_CONNECT"
        public var description: String { return self.rawValue }
    }

    public enum FilterField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case failed = "FAILED"
        case startInProgress = "START_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case quickResponses = "QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseSearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "HYBRID"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case external = "EXTERNAL"
        case managed = "MANAGED"
        case messageTemplates = "MESSAGE_TEMPLATES"
        case quickResponses = "QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Origin: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customer = "CUSTOMER"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum ParsingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockFoundationModel = "BEDROCK_FOUNDATION_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum Priority: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum QueryConditionComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum QueryConditionFieldName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case resultType = "RESULT_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum QueryResultType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case generativeAnswer = "GENERATIVE_ANSWER"
        case intentAnswer = "INTENT_ANSWER"
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseQueryOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case containsAndPrefix = "CONTAINS_AND_PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case issueDetection = "ISSUE_DETECTION"
        case other = "OTHER"
        case ruleEvaluation = "RULE_EVALUATION"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationTriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case generative = "GENERATIVE"
        case query = "QUERY"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case detectedIntent = "DETECTED_INTENT"
        case generativeAnswer = "GENERATIVE_ANSWER"
        case generativeResponse = "GENERATIVE_RESPONSE"
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        case webCrawler = "WEB_CRAWLER"
        public var description: String { return self.rawValue }
    }

    public enum Relevance: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case helpful = "HELPFUL"
        case notHelpful = "NOT_HELPFUL"
        public var description: String { return self.rawValue }
    }

    public enum RelevanceLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SessionDataNamespace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "Custom"
        public var description: String { return self.rawValue }
    }

    public enum SourceContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum SyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createInProgress = "CREATE_IN_PROGRESS"
        case syncingInProgress = "SYNCING_IN_PROGRESS"
        case syncFailed = "SYNC_FAILED"
        case syncSuccess = "SYNC_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum TargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case recommendation = "RECOMMENDATION"
        case result = "RESULT"
        public var description: String { return self.rawValue }
    }

    public enum VisibilityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case published = "PUBLISHED"
        case saved = "SAVED"
        public var description: String { return self.rawValue }
    }

    public enum WebScopeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hostOnly = "HOST_ONLY"
        case subdomains = "SUBDOMAINS"
        public var description: String { return self.rawValue }
    }

    public enum AIAgentConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration for AI Agents of type ANSWER_RECOMMENDATION.
        case answerRecommendationAIAgentConfiguration(AnswerRecommendationAIAgentConfiguration)
        /// The configuration for AI Agents of type MANUAL_SEARCH.
        case manualSearchAIAgentConfiguration(ManualSearchAIAgentConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .answerRecommendationAIAgentConfiguration:
                let value = try container.decode(AnswerRecommendationAIAgentConfiguration.self, forKey: .answerRecommendationAIAgentConfiguration)
                self = .answerRecommendationAIAgentConfiguration(value)
            case .manualSearchAIAgentConfiguration:
                let value = try container.decode(ManualSearchAIAgentConfiguration.self, forKey: .manualSearchAIAgentConfiguration)
                self = .manualSearchAIAgentConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .answerRecommendationAIAgentConfiguration(let value):
                try container.encode(value, forKey: .answerRecommendationAIAgentConfiguration)
            case .manualSearchAIAgentConfiguration(let value):
                try container.encode(value, forKey: .manualSearchAIAgentConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .answerRecommendationAIAgentConfiguration(let value):
                try value.validate(name: "\(name).answerRecommendationAIAgentConfiguration")
            case .manualSearchAIAgentConfiguration(let value):
                try value.validate(name: "\(name).manualSearchAIAgentConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case answerRecommendationAIAgentConfiguration = "answerRecommendationAIAgentConfiguration"
            case manualSearchAIAgentConfiguration = "manualSearchAIAgentConfiguration"
        }
    }

    public enum DataDetails: AWSDecodableShape, Sendable {
        /// Details about the content data.
        case contentData(ContentDataDetails)
        ///  Details about the generative data.
        case generativeData(GenerativeDataDetails)
        /// Details about the intent data.
        case intentDetectedData(IntentDetectedDataDetails)
        /// Details about the content data.
        case sourceContentData(SourceContentDataDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentData:
                let value = try container.decode(ContentDataDetails.self, forKey: .contentData)
                self = .contentData(value)
            case .generativeData:
                let value = try container.decode(GenerativeDataDetails.self, forKey: .generativeData)
                self = .generativeData(value)
            case .intentDetectedData:
                let value = try container.decode(IntentDetectedDataDetails.self, forKey: .intentDetectedData)
                self = .intentDetectedData(value)
            case .sourceContentData:
                let value = try container.decode(SourceContentDataDetails.self, forKey: .sourceContentData)
                self = .sourceContentData(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentData = "contentData"
            case generativeData = "generativeData"
            case intentDetectedData = "intentDetectedData"
            case sourceContentData = "sourceContentData"
        }
    }

    public enum DataReference: AWSDecodableShape, Sendable {
        case contentReference(ContentReference)
        /// Reference information about the generative content.
        case generativeReference(GenerativeReference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentReference:
                let value = try container.decode(ContentReference.self, forKey: .contentReference)
                self = .contentReference(value)
            case .generativeReference:
                let value = try container.decode(GenerativeReference.self, forKey: .generativeReference)
                self = .generativeReference(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentReference = "contentReference"
            case generativeReference = "generativeReference"
        }
    }

    public enum OrCondition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A list of conditions which would be applied together with an AND condition.
        case andConditions([TagCondition])
        /// A leaf node condition which can be used to specify a tag condition.
        case tagCondition(TagCondition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .andConditions:
                let value = try container.decode([TagCondition].self, forKey: .andConditions)
                self = .andConditions(value)
            case .tagCondition:
                let value = try container.decode(TagCondition.self, forKey: .tagCondition)
                self = .tagCondition(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andConditions(let value):
                try container.encode(value, forKey: .andConditions)
            case .tagCondition(let value):
                try container.encode(value, forKey: .tagCondition)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andConditions(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andConditions[]")
                }
            case .tagCondition(let value):
                try value.validate(name: "\(name).tagCondition")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "andConditions"
            case tagCondition = "tagCondition"
        }
    }

    public enum QueryInputData: AWSEncodableShape, Sendable {
        /// Input information for the intent.
        case intentInputData(IntentInputData)
        /// Input information for the query.
        case queryTextInputData(QueryTextInputData)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .intentInputData(let value):
                try container.encode(value, forKey: .intentInputData)
            case .queryTextInputData(let value):
                try container.encode(value, forKey: .queryTextInputData)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .intentInputData(let value):
                try value.validate(name: "\(name).intentInputData")
            case .queryTextInputData(let value):
                try value.validate(name: "\(name).queryTextInputData")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case intentInputData = "intentInputData"
            case queryTextInputData = "queryTextInputData"
        }
    }

    public enum SourceConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appIntegrations(AppIntegrationsConfiguration)
        /// Source configuration for managed resources.
        case managedSourceConfiguration(ManagedSourceConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .appIntegrations:
                let value = try container.decode(AppIntegrationsConfiguration.self, forKey: .appIntegrations)
                self = .appIntegrations(value)
            case .managedSourceConfiguration:
                let value = try container.decode(ManagedSourceConfiguration.self, forKey: .managedSourceConfiguration)
                self = .managedSourceConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .appIntegrations(let value):
                try container.encode(value, forKey: .appIntegrations)
            case .managedSourceConfiguration(let value):
                try container.encode(value, forKey: .managedSourceConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .appIntegrations(let value):
                try value.validate(name: "\(name).appIntegrations")
            case .managedSourceConfiguration(let value):
                try value.validate(name: "\(name).managedSourceConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrations = "appIntegrations"
            case managedSourceConfiguration = "managedSourceConfiguration"
        }
    }

    public enum TagFilter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A list of conditions which would be applied together with an AND condition.
        case andConditions([TagCondition])
        /// A list of conditions which would be applied together with an OR condition.
        case orConditions([OrCondition])
        /// A leaf node condition which can be used to specify a tag condition.
        case tagCondition(TagCondition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .andConditions:
                let value = try container.decode([TagCondition].self, forKey: .andConditions)
                self = .andConditions(value)
            case .orConditions:
                let value = try container.decode([OrCondition].self, forKey: .orConditions)
                self = .orConditions(value)
            case .tagCondition:
                let value = try container.decode(TagCondition.self, forKey: .tagCondition)
                self = .tagCondition(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andConditions(let value):
                try container.encode(value, forKey: .andConditions)
            case .orConditions(let value):
                try container.encode(value, forKey: .orConditions)
            case .tagCondition(let value):
                try container.encode(value, forKey: .tagCondition)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andConditions(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andConditions[]")
                }
            case .orConditions(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orConditions[]")
                }
            case .tagCondition(let value):
                try value.validate(name: "\(name).tagCondition")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "andConditions"
            case orConditions = "orConditions"
            case tagCondition = "tagCondition"
        }
    }

    // MARK: Shapes

    public struct AIAgentConfigurationData: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the AI Agent to be configured.
        public let aiAgentId: String

        @inlinable
        public init(aiAgentId: String) {
            self.aiAgentId = aiAgentId
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentId = "aiAgentId"
        }
    }

    public struct AIAgentData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI agent.
        public let aiAgentArn: String
        /// The identifier of the AI Agent.
        public let aiAgentId: String
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// Configuration for the AI Agent.
        public let configuration: AIAgentConfiguration
        /// The description of the AI Agent.
        public let description: String?
        /// The time the AI Agent was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Agent.
        public let name: String
        /// Specifies the origin of the AI Agent. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?
        /// The status of the AI Agent.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the AI Agent.
        public let type: AIAgentType
        /// The visibility status of the AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiAgentArn: String, aiAgentId: String, assistantArn: String, assistantId: String, configuration: AIAgentConfiguration, description: String? = nil, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, type: AIAgentType, visibilityStatus: VisibilityStatus) {
            self.aiAgentArn = aiAgentArn
            self.aiAgentId = aiAgentId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.configuration = configuration
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentArn = "aiAgentArn"
            case aiAgentId = "aiAgentId"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case configuration = "configuration"
            case description = "description"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIAgentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI agent.
        public let aiAgentArn: String
        /// The identifier of the AI Agent.
        public let aiAgentId: String
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The configuration for the AI Agent.
        public let configuration: AIAgentConfiguration?
        /// The description of the AI Agent.
        public let description: String?
        /// The time the AI Agent was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Agent.
        public let name: String
        /// The origin of the AI Agent. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?
        /// The status of the AI Agent.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the AI Agent.
        public let type: AIAgentType
        /// The visibility status of the AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiAgentArn: String, aiAgentId: String, assistantArn: String, assistantId: String, configuration: AIAgentConfiguration? = nil, description: String? = nil, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, type: AIAgentType, visibilityStatus: VisibilityStatus) {
            self.aiAgentArn = aiAgentArn
            self.aiAgentId = aiAgentId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.configuration = configuration
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentArn = "aiAgentArn"
            case aiAgentId = "aiAgentId"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case configuration = "configuration"
            case description = "description"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIAgentVersionSummary: AWSDecodableShape {
        /// The data for the summary of the AI Agent version.
        public let aiAgentSummary: AIAgentSummary?
        /// The version number for this AI Agent version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiAgentSummary: AIAgentSummary? = nil, versionNumber: Int64? = nil) {
            self.aiAgentSummary = aiAgentSummary
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentSummary = "aiAgentSummary"
            case versionNumber = "versionNumber"
        }
    }

    public struct AIPromptData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI Prompt.
        public let aiPromptArn: String
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The API format used for this AI Prompt.
        public let apiFormat: AIPromptAPIFormat
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The description of the AI Prompt.
        public let description: String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: CLAUDE_3_HAIKU_20240307_V1.
        public let modelId: String
        /// The time the AI Prompt was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Prompt
        public let name: String
        /// The origin of the AI Prompt. SYSTEM for a default AI Prompt created by Q in Connect or CUSTOMER for an AI Prompt created by calling AI Prompt creation APIs.
        public let origin: Origin?
        /// The status of the AI Prompt.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The configuration of the prompt template for this AI Prompt.
        public let templateConfiguration: AIPromptTemplateConfiguration
        /// The type of the prompt template for this AI Prompt.
        public let templateType: AIPromptTemplateType
        /// The type of this AI Prompt.
        public let type: AIPromptType
        /// The visibility status of the AI Prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiPromptArn: String, aiPromptId: String, apiFormat: AIPromptAPIFormat, assistantArn: String, assistantId: String, description: String? = nil, modelId: String, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, templateConfiguration: AIPromptTemplateConfiguration, templateType: AIPromptTemplateType, type: AIPromptType, visibilityStatus: VisibilityStatus) {
            self.aiPromptArn = aiPromptArn
            self.aiPromptId = aiPromptId
            self.apiFormat = apiFormat
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modelId = modelId
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptArn = "aiPromptArn"
            case aiPromptId = "aiPromptId"
            case apiFormat = "apiFormat"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case modelId = "modelId"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIPromptSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI Prompt.
        public let aiPromptArn: String
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The API format used for this AI Prompt.
        public let apiFormat: AIPromptAPIFormat
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The description of the AI Prompt.
        public let description: String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: CLAUDE_3_HAIKU_20240307_V1.
        public let modelId: String
        /// The time the AI Prompt was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Prompt.
        public let name: String
        /// The origin of the AI Prompt. SYSTEM for a default AI Prompt created by Q in Connect or CUSTOMER for an AI Prompt created by calling AI Prompt creation APIs.
        public let origin: Origin?
        /// The status of the AI Prompt.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the prompt template for this AI Prompt.
        public let templateType: AIPromptTemplateType
        /// The type of this AI Prompt.
        public let type: AIPromptType
        /// The visibility status of the AI Prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiPromptArn: String, aiPromptId: String, apiFormat: AIPromptAPIFormat, assistantArn: String, assistantId: String, description: String? = nil, modelId: String, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, templateType: AIPromptTemplateType, type: AIPromptType, visibilityStatus: VisibilityStatus) {
            self.aiPromptArn = aiPromptArn
            self.aiPromptId = aiPromptId
            self.apiFormat = apiFormat
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modelId = modelId
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptArn = "aiPromptArn"
            case aiPromptId = "aiPromptId"
            case apiFormat = "apiFormat"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case modelId = "modelId"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case templateType = "templateType"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIPromptVersionSummary: AWSDecodableShape {
        /// The date for the summary of the AI Prompt version.
        public let aiPromptSummary: AIPromptSummary?
        /// The version number for this AI Prompt version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiPromptSummary: AIPromptSummary? = nil, versionNumber: Int64? = nil) {
            self.aiPromptSummary = aiPromptSummary
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptSummary = "aiPromptSummary"
            case versionNumber = "versionNumber"
        }
    }

    public struct AmazonConnectGuideAssociationData: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Connect flow. Step-by-step guides are a type of flow.
        public let flowId: String?

        @inlinable
        public init(flowId: String? = nil) {
            self.flowId = flowId
        }

        public func validate(name: String) throws {
            try self.validate(self.flowId, name: "flowId", parent: name, max: 2048)
            try self.validate(self.flowId, name: "flowId", parent: name, min: 1)
            try self.validate(self.flowId, name: "flowId", parent: name, pattern: "^arn:[a-z-]+?:[a-z-]+?:[a-z0-9-]*?:([0-9]{12})?:[a-zA-Z0-9-:/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "flowId"
        }
    }

    public struct AnswerRecommendationAIAgentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The AI Prompt identifier for the Answer Generation prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public let answerGenerationAIPromptId: String?
        /// The association configurations for overriding behavior on this AI Agent.
        public let associationConfigurations: [AssociationConfiguration]?
        /// The AI Prompt identifier for the Intent Labeling prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public let intentLabelingGenerationAIPromptId: String?
        /// The AI Prompt identifier for the Query Reformulation prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public let queryReformulationAIPromptId: String?

        @inlinable
        public init(answerGenerationAIPromptId: String? = nil, associationConfigurations: [AssociationConfiguration]? = nil, intentLabelingGenerationAIPromptId: String? = nil, queryReformulationAIPromptId: String? = nil) {
            self.answerGenerationAIPromptId = answerGenerationAIPromptId
            self.associationConfigurations = associationConfigurations
            self.intentLabelingGenerationAIPromptId = intentLabelingGenerationAIPromptId
            self.queryReformulationAIPromptId = queryReformulationAIPromptId
        }

        public func validate(name: String) throws {
            try self.validate(self.answerGenerationAIPromptId, name: "answerGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.associationConfigurations?.forEach {
                try $0.validate(name: "\(name).associationConfigurations[]")
            }
            try self.validate(self.intentLabelingGenerationAIPromptId, name: "intentLabelingGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.queryReformulationAIPromptId, name: "queryReformulationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case answerGenerationAIPromptId = "answerGenerationAIPromptId"
            case associationConfigurations = "associationConfigurations"
            case intentLabelingGenerationAIPromptId = "intentLabelingGenerationAIPromptId"
            case queryReformulationAIPromptId = "queryReformulationAIPromptId"
        }
    }

    public struct AppIntegrationsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.   For  Salesforce, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted as source fields.    For  ServiceNow, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least number, short_description, sys_mod_count, workflow_state, and active as source fields.    For  Zendesk, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least id, title, updated_at, and draft as source fields.    For SharePoint, your AppIntegrations DataIntegration must have a FileConfiguration, including only file extensions that are among docx, pdf, html, htm, and txt.    For Amazon S3, the ObjectConfiguration and FileConfiguration of your AppIntegrations DataIntegration must be null. The SourceURI of your DataIntegration must use the following format: s3://your_s3_bucket_name.  The bucket policy of the corresponding S3 bucket must allow the Amazon Web Services principal app-integrations.amazonaws.com to perform s3:ListBucket, s3:GetObject, and s3:GetBucketLocation against the bucket.
        public let appIntegrationArn: String
        /// The fields from the source that are made available to your agents in Amazon Q in Connect. Optional if ObjectConfiguration is included in the provided DataIntegration.    For  Salesforce, you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.    For  ServiceNow, you must include at least number, short_description, sys_mod_count, workflow_state, and active.    For  Zendesk, you must include at least id, title, updated_at, and draft.    Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public let objectFields: [String]?

        @inlinable
        public init(appIntegrationArn: String, objectFields: [String]? = nil) {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }

        public func validate(name: String) throws {
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, max: 2048)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, min: 1)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, pattern: "^arn:[a-z-]+?:[a-z-]+?:[a-z0-9-]*?:([0-9]{12})?:[a-zA-Z0-9-:/]+$")
            try self.objectFields?.forEach {
                try validate($0, name: "objectFields[]", parent: name, max: 4096)
                try validate($0, name: "objectFields[]", parent: name, min: 1)
            }
            try self.validate(self.objectFields, name: "objectFields", parent: name, max: 100)
            try self.validate(self.objectFields, name: "objectFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrationArn = "appIntegrationArn"
            case objectFields = "objectFields"
        }
    }

    public struct AssistantAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// A union type that currently has a single argument, the knowledge base ID.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantAssociationArn = "assistantAssociationArn"
            case assistantAssociationId = "assistantAssociationId"
            case assistantId = "assistantId"
            case associationData = "associationData"
            case associationType = "associationType"
            case tags = "tags"
        }
    }

    public struct AssistantAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The association data.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantAssociationArn = "assistantAssociationArn"
            case assistantAssociationId = "assistantAssociationId"
            case assistantId = "assistantId"
            case associationData = "associationData"
            case associationType = "associationType"
            case tags = "tags"
        }
    }

    public struct AssistantCapabilityConfiguration: AWSDecodableShape {
        /// The type of Amazon Q in Connect assistant capability.
        public let type: AssistantCapabilityType?

        @inlinable
        public init(type: AssistantCapabilityType? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct AssistantData: AWSDecodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that is set on the Amazon Q in Connect Assistant.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The configuration information for the Amazon Q in Connect assistant capability.
        public let capabilityConfiguration: AssistantCapabilityConfiguration?
        /// The description.
        public let description: String?
        /// The configuration information for the Amazon Q in Connect assistant integration.
        public let integrationConfiguration: AssistantIntegrationConfiguration?
        /// The name.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantArn: String, assistantId: String, capabilityConfiguration: AssistantCapabilityConfiguration? = nil, description: String? = nil, integrationConfiguration: AssistantIntegrationConfiguration? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case capabilityConfiguration = "capabilityConfiguration"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct AssistantIntegrationConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public let topicIntegrationArn: String?

        @inlinable
        public init(topicIntegrationArn: String? = nil) {
            self.topicIntegrationArn = topicIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicIntegrationArn = "topicIntegrationArn"
        }
    }

    public struct AssistantSummary: AWSDecodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that is set on the Amazon Q in Connect Assistant.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The configuration information for the Amazon Q in Connect assistant capability.
        public let capabilityConfiguration: AssistantCapabilityConfiguration?
        /// The description of the assistant.
        public let description: String?
        /// The configuration information for the Amazon Q in Connect assistant integration.
        public let integrationConfiguration: AssistantIntegrationConfiguration?
        /// The name of the assistant.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the assistant.
        public let type: AssistantType

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantArn: String, assistantId: String, capabilityConfiguration: AssistantCapabilityConfiguration? = nil, description: String? = nil, integrationConfiguration: AssistantIntegrationConfiguration? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case capabilityConfiguration = "capabilityConfiguration"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct AssociationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data of the configuration for an Amazon Q in Connect Assistant Association.
        public let associationConfigurationData: AssociationConfigurationData?
        /// The identifier of the association for this Association Configuration.
        public let associationId: String?
        /// The type of the association for this Association Configuration.
        public let associationType: AIAgentAssociationConfigurationType?

        @inlinable
        public init(associationConfigurationData: AssociationConfigurationData? = nil, associationId: String? = nil, associationType: AIAgentAssociationConfigurationType? = nil) {
            self.associationConfigurationData = associationConfigurationData
            self.associationId = associationId
            self.associationType = associationType
        }

        public func validate(name: String) throws {
            try self.associationConfigurationData?.validate(name: "\(name).associationConfigurationData")
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationConfigurationData = "associationConfigurationData"
            case associationId = "associationId"
            case associationType = "associationType"
        }
    }

    public struct BedrockFoundationModelConfigurationForParsing: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the foundation model.
        public let modelArn: String
        /// Instructions for interpreting the contents of a document.
        public let parsingPrompt: ParsingPrompt?

        @inlinable
        public init(modelArn: String, parsingPrompt: ParsingPrompt? = nil) {
            self.modelArn = modelArn
            self.parsingPrompt = parsingPrompt
        }

        public func validate(name: String) throws {
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/anthropic.claude-3-haiku-20240307-v1:0$")
            try self.parsingPrompt?.validate(name: "\(name).parsingPrompt")
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "modelArn"
            case parsingPrompt = "parsingPrompt"
        }
    }

    public struct ChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
        public let chunkingStrategy: ChunkingStrategy
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public let fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration?
        /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        public let hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration?
        /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into smaller documents based on groups of similar content derived from the text with natural language processing.
        public let semanticChunkingConfiguration: SemanticChunkingConfiguration?

        @inlinable
        public init(chunkingStrategy: ChunkingStrategy, fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration? = nil, hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration? = nil, semanticChunkingConfiguration: SemanticChunkingConfiguration? = nil) {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
            self.hierarchicalChunkingConfiguration = hierarchicalChunkingConfiguration
            self.semanticChunkingConfiguration = semanticChunkingConfiguration
        }

        public func validate(name: String) throws {
            try self.hierarchicalChunkingConfiguration?.validate(name: "\(name).hierarchicalChunkingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingStrategy = "chunkingStrategy"
            case fixedSizeChunkingConfiguration = "fixedSizeChunkingConfiguration"
            case hierarchicalChunkingConfiguration = "hierarchicalChunkingConfiguration"
            case semanticChunkingConfiguration = "semanticChunkingConfiguration"
        }
    }

    public struct CitationSpan: AWSDecodableShape {
        /// Where the text with a citation starts in the generated output.
        public let beginOffsetInclusive: Int?
        /// Where the text with a citation ends in the generated output.
        public let endOffsetExclusive: Int?

        @inlinable
        public init(beginOffsetInclusive: Int? = nil, endOffsetExclusive: Int? = nil) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetInclusive = "beginOffsetInclusive"
            case endOffsetExclusive = "endOffsetExclusive"
        }
    }

    public struct ConnectConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?

        @inlinable
        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "instanceId"
        }
    }

    public struct ContentAssociationData: AWSDecodableShape {
        /// The content association.
        public let associationData: ContentAssociationContents
        /// The type of association.
        public let associationType: ContentAssociationType
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The Amazon Resource Name (ARN) of the content association.
        public let contentAssociationArn: String
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(associationData: ContentAssociationContents, associationType: ContentAssociationType, contentArn: String, contentAssociationArn: String, contentAssociationId: String, contentId: String, knowledgeBaseArn: String, knowledgeBaseId: String, tags: [String: String]? = nil) {
            self.associationData = associationData
            self.associationType = associationType
            self.contentArn = contentArn
            self.contentAssociationArn = contentAssociationArn
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associationData = "associationData"
            case associationType = "associationType"
            case contentArn = "contentArn"
            case contentAssociationArn = "contentAssociationArn"
            case contentAssociationId = "contentAssociationId"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case tags = "tags"
        }
    }

    public struct ContentAssociationSummary: AWSDecodableShape {
        /// The content association.
        public let associationData: ContentAssociationContents
        /// The type of association.
        public let associationType: ContentAssociationType
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The Amazon Resource Name (ARN) of the content association.
        public let contentAssociationArn: String
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(associationData: ContentAssociationContents, associationType: ContentAssociationType, contentArn: String, contentAssociationArn: String, contentAssociationId: String, contentId: String, knowledgeBaseArn: String, knowledgeBaseId: String, tags: [String: String]? = nil) {
            self.associationData = associationData
            self.associationType = associationType
            self.contentArn = contentArn
            self.contentAssociationArn = contentAssociationArn
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associationData = "associationData"
            case associationType = "associationType"
            case contentArn = "contentArn"
            case contentAssociationArn = "contentAssociationArn"
            case contentAssociationId = "contentAssociationId"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case tags = "tags"
        }
    }

    public struct ContentData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The URI of the content.
        public let linkOutUri: String?
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the content revision.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String
        /// The URL of the content.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        @inlinable
        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, linkOutUri: String? = nil, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String, url: String, urlExpiry: Date) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case contentType = "contentType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case linkOutUri = "linkOutUri"
            case metadata = "metadata"
            case name = "name"
            case revisionId = "revisionId"
            case status = "status"
            case tags = "tags"
            case title = "title"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct ContentDataDetails: AWSDecodableShape {
        /// Details about the content ranking data.
        public let rankingData: RankingData
        /// Details about the content text data.
        public let textData: TextData

        @inlinable
        public init(rankingData: RankingData, textData: TextData) {
            self.rankingData = rankingData
            self.textData = textData
        }

        private enum CodingKeys: String, CodingKey {
            case rankingData = "rankingData"
            case textData = "textData"
        }
    }

    public struct ContentReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String?
        /// The identifier of the content.
        public let contentId: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String?
        /// The type of reference content.
        public let referenceType: ReferenceType?
        /// The web URL of the source content.
        public let sourceURL: String?

        @inlinable
        public init(contentArn: String? = nil, contentId: String? = nil, knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil, referenceType: ReferenceType? = nil, sourceURL: String? = nil) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.referenceType = referenceType
            self.sourceURL = sourceURL
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case referenceType = "referenceType"
            case sourceURL = "sourceURL"
        }
    }

    public struct ContentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the revision of the content.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String

        @inlinable
        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case contentType = "contentType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case metadata = "metadata"
            case name = "name"
            case revisionId = "revisionId"
            case status = "status"
            case tags = "tags"
            case title = "title"
        }
    }

    public struct CreateAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The configuration of the AI Agent.
        public let configuration: AIAgentConfiguration
        /// The description of the AI Agent.
        public let description: String?
        /// The name of the AI Agent.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the AI Agent.
        public let type: AIAgentType
        /// The visibility status of the AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(assistantId: String, clientToken: String? = CreateAIAgentRequest.idempotencyToken(), configuration: AIAgentConfiguration, description: String? = nil, name: String, tags: [String: String]? = nil, type: AIAgentType, visibilityStatus: VisibilityStatus) {
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.name = name
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct CreateAIAgentResponse: AWSDecodableShape {
        /// The data of the created AI Agent.
        public let aiAgent: AIAgentData?

        @inlinable
        public init(aiAgent: AIAgentData? = nil) {
            self.aiAgent = aiAgent
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
        }
    }

    public struct CreateAIAgentVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The modification time of the AI Agent should be tracked for version creation. This field should be specified to avoid version creation when simultaneous update to the underlying AI Agent are possible. The value should be the modifiedTime returned from the request to create or update an AI Agent so that version creation can fail if an update to the AI Agent post the specified modification time has been made.
        public let modifiedTime: Date?

        @inlinable
        public init(aiAgentId: String, assistantId: String, clientToken: String? = CreateAIAgentVersionRequest.idempotencyToken(), modifiedTime: Date? = nil) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.modifiedTime = modifiedTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.modifiedTime, forKey: .modifiedTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case modifiedTime = "modifiedTime"
        }
    }

    public struct CreateAIAgentVersionResponse: AWSDecodableShape {
        /// The data of the AI Agent version.
        public let aiAgent: AIAgentData?
        /// The version number of the AI Agent version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiAgent: AIAgentData? = nil, versionNumber: Int64? = nil) {
            self.aiAgent = aiAgent
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
            case versionNumber = "versionNumber"
        }
    }

    public struct CreateAIPromptRequest: AWSEncodableShape {
        /// The API Format of the AI Prompt.
        public let apiFormat: AIPromptAPIFormat
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the AI Prompt.
        public let description: String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: CLAUDE_3_HAIKU_20240307_V1
        public let modelId: String
        /// The name of the AI Prompt.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The configuration of the prompt template for this AI Prompt.
        public let templateConfiguration: AIPromptTemplateConfiguration
        /// The type of the prompt template for this AI Prompt.
        public let templateType: AIPromptTemplateType
        /// The type of this AI Prompt.
        public let type: AIPromptType
        /// The visibility status of the AI Prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(apiFormat: AIPromptAPIFormat, assistantId: String, clientToken: String? = CreateAIPromptRequest.idempotencyToken(), description: String? = nil, modelId: String, name: String, tags: [String: String]? = nil, templateConfiguration: AIPromptTemplateConfiguration, templateType: AIPromptTemplateType, type: AIPromptType, visibilityStatus: VisibilityStatus) {
            self.apiFormat = apiFormat
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.modelId = modelId
            self.name = name
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.apiFormat, forKey: .apiFormat)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.modelId, forKey: .modelId)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.templateConfiguration, forKey: .templateConfiguration)
            try container.encode(self.templateType, forKey: .templateType)
            try container.encode(self.type, forKey: .type)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.templateConfiguration.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case apiFormat = "apiFormat"
            case clientToken = "clientToken"
            case description = "description"
            case modelId = "modelId"
            case name = "name"
            case tags = "tags"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct CreateAIPromptResponse: AWSDecodableShape {
        /// The data of the AI Prompt.
        public let aiPrompt: AIPromptData?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil) {
            self.aiPrompt = aiPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
        }
    }

    public struct CreateAIPromptVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The time the AI Prompt was last modified.
        public let modifiedTime: Date?

        @inlinable
        public init(aiPromptId: String, assistantId: String, clientToken: String? = CreateAIPromptVersionRequest.idempotencyToken(), modifiedTime: Date? = nil) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.modifiedTime = modifiedTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.modifiedTime, forKey: .modifiedTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case modifiedTime = "modifiedTime"
        }
    }

    public struct CreateAIPromptVersionResponse: AWSDecodableShape {
        /// The data of the AI Prompt version.
        public let aiPrompt: AIPromptData?
        /// The version number of the AI Prompt version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil, versionNumber: Int64? = nil) {
            self.aiPrompt = aiPrompt
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
            case versionNumber = "versionNumber"
        }
    }

    public struct CreateAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the associated resource.
        public let association: AssistantAssociationInputData
        /// The type of association.
        public let associationType: AssociationType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(assistantId: String, association: AssistantAssociationInputData, associationType: AssociationType, clientToken: String? = CreateAssistantAssociationRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assistantId = assistantId
            self.association = association
            self.associationType = associationType
            self.clientToken = clientToken
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.association, forKey: .association)
            try container.encode(self.associationType, forKey: .associationType)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.association.validate(name: "\(name).association")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case association = "association"
            case associationType = "associationType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        @inlinable
        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation = "assistantAssociation"
        }
    }

    public struct CreateAssistantRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the assistant.
        public let description: String?
        /// The name of the assistant.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  The customer managed key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        @inlinable
        public init(clientToken: String? = CreateAssistantRequest.idempotencyToken(), description: String? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, tags: [String: String]? = nil, type: AssistantType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        @inlinable
        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct CreateContentAssociationRequest: AWSEncodableShape {
        /// The identifier of the associated resource.
        public let association: ContentAssociationContents
        /// The type of association.
        public let associationType: ContentAssociationType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(association: ContentAssociationContents, associationType: ContentAssociationType, clientToken: String? = CreateContentAssociationRequest.idempotencyToken(), contentId: String, knowledgeBaseId: String, tags: [String: String]? = nil) {
            self.association = association
            self.associationType = associationType
            self.clientToken = clientToken
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.association, forKey: .association)
            try container.encode(self.associationType, forKey: .associationType)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.association.validate(name: "\(name).association")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case association = "association"
            case associationType = "associationType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateContentAssociationResponse: AWSDecodableShape {
        /// The association between Amazon Q in Connect content and another resource.
        public let contentAssociation: ContentAssociationData?

        @inlinable
        public init(contentAssociation: ContentAssociationData? = nil) {
            self.contentAssociation = contentAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case contentAssociation = "contentAssociation"
        }
    }

    public struct CreateContentRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the SearchContent API.
        public let name: String
        /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
        public let overrideLinkOutUri: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content. If not set, the title is equal to the name.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        @inlinable
        public init(clientToken: String? = CreateContentRequest.idempotencyToken(), knowledgeBaseId: String, metadata: [String: String]? = nil, name: String, overrideLinkOutUri: String? = nil, tags: [String: String]? = nil, title: String? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.overrideLinkOutUri = overrideLinkOutUri
            self.tags = tags
            self.title = title
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.overrideLinkOutUri, forKey: .overrideLinkOutUri)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encode(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case metadata = "metadata"
            case name = "name"
            case overrideLinkOutUri = "overrideLinkOutUri"
            case tags = "tags"
            case title = "title"
            case uploadId = "uploadId"
        }
    }

    public struct CreateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        @inlinable
        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge bases.
        public let sourceConfiguration: SourceConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about how to ingest the documents in a data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, tags: [String: String]? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.renderingConfiguration?.validate(name: "\(name).renderingConfiguration")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.vectorIngestionConfiguration?.validate(name: "\(name).vectorIngestionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case knowledgeBaseType = "knowledgeBaseType"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case tags = "tags"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        @inlinable
        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct CreateQuickResponseRequest: AWSEncodableShape {
        /// The Amazon Connect channels this quick response applies to.
        public let channels: [String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The content of the quick response.
        public let content: QuickResponseDataProvider
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for a quick response written in plain text.   Use application/x.quickresponse;format=markdown for a quick response written in richtext.
        public let contentType: String?
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the quick response.
        public let name: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channels: [String]? = nil, clientToken: String? = CreateQuickResponseRequest.idempotencyToken(), content: QuickResponseDataProvider, contentType: String? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseId: String, language: String? = nil, name: String, shortcutKey: String? = nil, tags: [String: String]? = nil) {
            self.channels = channels
            self.clientToken = clientToken
            self.content = content
            self.contentType = contentType
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.shortcutKey = shortcutKey
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.channels, forKey: .channels)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortcutKey, forKey: .shortcutKey)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.channels?.forEach {
                try validate($0, name: "channels[]", parent: name, max: 10)
                try validate($0, name: "channels[]", parent: name, min: 1)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(application/x\\.quickresponse;format=(plain|markdown))$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, max: 10)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case clientToken = "clientToken"
            case content = "content"
            case contentType = "contentType"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case language = "language"
            case name = "name"
            case shortcutKey = "shortcutKey"
            case tags = "tags"
        }
    }

    public struct CreateQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        @inlinable
        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct CreateSessionRequest: AWSEncodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name of the session.
        public let name: String
        /// An object that can be used to specify Tag conditions.
        public let tagFilter: TagFilter?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantId: String, clientToken: String? = CreateSessionRequest.idempotencyToken(), description: String? = nil, name: String, tagFilter: TagFilter? = nil, tags: [String: String]? = nil) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tagFilter = tagFilter
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.aiAgentConfiguration, forKey: .aiAgentConfiguration)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tagFilter, forKey: .tagFilter)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.aiAgentConfiguration?.forEach {
                try $0.value.validate(name: "\(name).aiAgentConfiguration[\"\($0.key)\"]")
            }
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tagFilter?.validate(name: "\(name).tagFilter")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tagFilter = "tagFilter"
            case tags = "tags"
        }
    }

    public struct CreateSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        @inlinable
        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct DataSummary: AWSDecodableShape {
        /// Details about the data.
        public let details: DataDetails
        /// Reference information about the content.
        public let reference: DataReference

        @inlinable
        public init(details: DataDetails, reference: DataReference) {
            self.details = details
            self.reference = reference
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case reference = "reference"
        }
    }

    public struct DeleteAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiAgentId: String, assistantId: String) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIAgentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIAgentVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The version number of the AI Agent version.
        public let versionNumber: Int64

        @inlinable
        public init(aiAgentId: String, assistantId: String, versionNumber: Int64) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.versionNumber, key: "versionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIAgentVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIPromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiPromptId: String, assistantId: String) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIPromptResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIPromptVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The version number of the AI Prompt version to be deleted.
        public let versionNumber: Int64

        @inlinable
        public init(aiPromptId: String, assistantId: String, versionNumber: Int64) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.versionNumber, key: "versionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIPromptVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantAssociationId, key: "assistantAssociationId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssistantRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContentAssociationRequest: AWSEncodableShape {
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentAssociationId: String, contentId: String, knowledgeBaseId: String) {
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentAssociationId, key: "contentAssociationId")
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentAssociationId, name: "contentAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContentAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job to be deleted.
        public let importJobId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String

        @inlinable
        public init(importJobId: String, knowledgeBaseId: String) {
            self.importJobId = importJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importJobId, key: "importJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importJobId, name: "importJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQuickResponseRequest: AWSEncodableShape {
        /// The knowledge base from which the quick response is deleted. The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The identifier of the quick response to delete.
        public let quickResponseId: String

        @inlinable
        public init(knowledgeBaseId: String, quickResponseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.quickResponseId = quickResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.quickResponseId, key: "quickResponseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQuickResponseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Document: AWSDecodableShape {
        /// A reference to the content resource.
        public let contentReference: ContentReference
        /// The excerpt from the document.
        public let excerpt: DocumentText?
        /// The title of the document.
        public let title: DocumentText?

        @inlinable
        public init(contentReference: ContentReference, excerpt: DocumentText? = nil, title: DocumentText? = nil) {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentReference = "contentReference"
            case excerpt = "excerpt"
            case title = "title"
        }
    }

    public struct DocumentText: AWSDecodableShape {
        /// Highlights in the document text.
        public let highlights: [Highlight]?
        /// Text in the document.
        public let text: String?

        @inlinable
        public init(highlights: [Highlight]? = nil, text: String? = nil) {
            self.highlights = highlights
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case highlights = "highlights"
            case text = "text"
        }
    }

    public struct ExternalSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information of the external data source.
        public let configuration: Configuration
        /// The type of the external data source.
        public let source: ExternalSource

        @inlinable
        public init(configuration: Configuration, source: ExternalSource) {
            self.configuration = configuration
            self.source = source
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case source = "source"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The field on which to filter.
        public let field: FilterField
        /// The operator to use for comparing the field’s value with the provided value.
        public let `operator`: FilterOperator
        /// The desired field value on which to filter.
        public let value: String

        @inlinable
        public init(field: FilterField, operator: FilterOperator, value: String) {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct FixedSizeChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to include in a chunk.
        public let maxTokens: Int
        /// The percentage of overlap between adjacent chunks of a data source.
        public let overlapPercentage: Int

        @inlinable
        public init(maxTokens: Int, overlapPercentage: Int) {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case overlapPercentage = "overlapPercentage"
        }
    }

    public struct GenerativeContentFeedbackData: AWSEncodableShape & AWSDecodableShape {
        /// The relevance of the feedback.
        public let relevance: Relevance

        @inlinable
        public init(relevance: Relevance) {
            self.relevance = relevance
        }

        private enum CodingKeys: String, CodingKey {
            case relevance = "relevance"
        }
    }

    public struct GenerativeDataDetails: AWSDecodableShape {
        /// The LLM response.
        public let completion: String
        /// Details about the generative content ranking data.
        public let rankingData: RankingData
        /// The references used to generative the LLM response.
        public let references: [DataSummary]

        @inlinable
        public init(completion: String, rankingData: RankingData, references: [DataSummary]) {
            self.completion = completion
            self.rankingData = rankingData
            self.references = references
        }

        private enum CodingKeys: String, CodingKey {
            case completion = "completion"
            case rankingData = "rankingData"
            case references = "references"
        }
    }

    public struct GenerativeReference: AWSDecodableShape {
        ///  The identifier of the LLM model.
        public let generationId: String?
        /// The identifier of the LLM model.
        public let modelId: String?

        @inlinable
        public init(generationId: String? = nil, modelId: String? = nil) {
            self.generationId = generationId
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case generationId = "generationId"
            case modelId = "modelId"
        }
    }

    public struct GetAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent (with or without a version qualifier). Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiAgentId: String, assistantId: String) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAIAgentResponse: AWSDecodableShape {
        /// The data of the AI Agent.
        public let aiAgent: AIAgentData?
        /// The version number of the AI Agent version (returned if an AI Agent version was specified via use of a qualifier for the aiAgentId on the request).
        public let versionNumber: Int64?

        @inlinable
        public init(aiAgent: AIAgentData? = nil, versionNumber: Int64? = nil) {
            self.aiAgent = aiAgent
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
            case versionNumber = "versionNumber"
        }
    }

    public struct GetAIPromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiPromptId: String, assistantId: String) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAIPromptResponse: AWSDecodableShape {
        /// The data of the AI Prompt.
        public let aiPrompt: AIPromptData?
        /// The version number of the AI Prompt version (returned if an AI Prompt version was specified via use of a qualifier for the aiPromptId on the request).
        public let versionNumber: Int64?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil, versionNumber: Int64? = nil) {
            self.aiPrompt = aiPrompt
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
            case versionNumber = "versionNumber"
        }
    }

    public struct GetAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantAssociationId, key: "assistantAssociationId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        @inlinable
        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation = "assistantAssociation"
        }
    }

    public struct GetAssistantRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        @inlinable
        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct GetContentAssociationRequest: AWSEncodableShape {
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentAssociationId: String, contentId: String, knowledgeBaseId: String) {
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentAssociationId, key: "contentAssociationId")
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentAssociationId, name: "contentAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentAssociationResponse: AWSDecodableShape {
        /// The association between Amazon Q in Connect content and another resource.
        public let contentAssociation: ContentAssociationData?

        @inlinable
        public init(contentAssociation: ContentAssociationData? = nil) {
            self.contentAssociation = contentAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case contentAssociation = "contentAssociation"
        }
    }

    public struct GetContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        @inlinable
        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct GetContentSummaryRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentSummaryResponse: AWSDecodableShape {
        /// The content summary.
        public let contentSummary: ContentSummary?

        @inlinable
        public init(contentSummary: ContentSummary? = nil) {
            self.contentSummary = contentSummary
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummary = "contentSummary"
        }
    }

    public struct GetImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job to retrieve.
        public let importJobId: String
        /// The identifier of the knowledge base that the import job belongs to.
        public let knowledgeBaseId: String

        @inlinable
        public init(importJobId: String, knowledgeBaseId: String) {
            self.importJobId = importJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importJobId, key: "importJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importJobId, name: "importJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportJobResponse: AWSDecodableShape {
        /// The import job.
        public let importJob: ImportJobData?

        @inlinable
        public init(importJob: ImportJobData? = nil) {
            self.importJob = importJob
        }

        private enum CodingKeys: String, CodingKey {
            case importJob = "importJob"
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        @inlinable
        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct GetQuickResponseRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// The identifier of the quick response.
        public let quickResponseId: String

        @inlinable
        public init(knowledgeBaseId: String, quickResponseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.quickResponseId = quickResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.quickResponseId, key: "quickResponseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        @inlinable
        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct GetRecommendationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String
        /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
        public let waitTimeSeconds: Int?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, sessionId: String, waitTimeSeconds: Int? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.sessionId = sessionId
            self.waitTimeSeconds = waitTimeSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodeQuery(self.waitTimeSeconds, key: "waitTimeSeconds")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, max: 20)
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsResponse: AWSDecodableShape {
        /// The recommendations.
        public let recommendations: [RecommendationData]
        /// The triggers corresponding to recommendations.
        public let triggers: [RecommendationTrigger]?

        @inlinable
        public init(recommendations: [RecommendationData], triggers: [RecommendationTrigger]? = nil) {
            self.recommendations = recommendations
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case recommendations = "recommendations"
            case triggers = "triggers"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, sessionId: String) {
            self.assistantId = assistantId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        @inlinable
        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct GroupingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The criteria used for grouping Amazon Q in Connect users. The following is the list of supported criteria values.    RoutingProfileArn: Grouping the users by their Amazon Connect routing profile ARN. User should have SearchRoutingProfile and DescribeRoutingProfile permissions when setting criteria to this value.
        public let criteria: String?
        /// The list of values that define different groups of Amazon Q in Connect users.   When setting criteria to RoutingProfileArn, you need to provide a list of ARNs of Amazon Connect routing profiles as values of this parameter.
        public let values: [String]?

        @inlinable
        public init(criteria: String? = nil, values: [String]? = nil) {
            self.criteria = criteria
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.criteria, name: "criteria", parent: name, max: 100)
            try self.validate(self.criteria, name: "criteria", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
            case values = "values"
        }
    }

    public struct HierarchicalChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Token settings for each layer.
        public let levelConfigurations: [HierarchicalChunkingLevelConfiguration]
        /// The number of tokens to repeat across chunks in the same layer.
        public let overlapTokens: Int

        @inlinable
        public init(levelConfigurations: [HierarchicalChunkingLevelConfiguration], overlapTokens: Int) {
            self.levelConfigurations = levelConfigurations
            self.overlapTokens = overlapTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, max: 2)
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case levelConfigurations = "levelConfigurations"
            case overlapTokens = "overlapTokens"
        }
    }

    public struct HierarchicalChunkingLevelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens that a chunk can contain in this layer.
        public let maxTokens: Int

        @inlinable
        public init(maxTokens: Int) {
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
        }
    }

    public struct Highlight: AWSDecodableShape {
        /// The offset for the start of the highlight.
        public let beginOffsetInclusive: Int?
        /// The offset for the end of the highlight.
        public let endOffsetExclusive: Int?

        @inlinable
        public init(beginOffsetInclusive: Int? = nil, endOffsetExclusive: Int? = nil) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetInclusive = "beginOffsetInclusive"
            case endOffsetExclusive = "endOffsetExclusive"
        }
    }

    public struct ImportJobData: AWSDecodableShape {
        /// The timestamp when the import job was created.
        public let createdTime: Date
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The link to download the information of resource data that failed to be imported.
        public let failedRecordReport: String?
        /// The identifier of the import job.
        public let importJobId: String
        /// The type of the import job.
        public let importJobType: ImportJobType
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The timestamp when the import job data was last modified.
        public let lastModifiedTime: Date
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public let metadata: [String: String]?
        /// The status of the import job.
        public let status: ImportJobStatus
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String
        /// The download link to the resource file that is uploaded to the import job.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        @inlinable
        public init(createdTime: Date, externalSourceConfiguration: ExternalSourceConfiguration? = nil, failedRecordReport: String? = nil, importJobId: String, importJobType: ImportJobType, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedTime: Date, metadata: [String: String]? = nil, status: ImportJobStatus, uploadId: String, url: String, urlExpiry: Date) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.failedRecordReport = failedRecordReport
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case failedRecordReport = "failedRecordReport"
            case importJobId = "importJobId"
            case importJobType = "importJobType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedTime = "lastModifiedTime"
            case metadata = "metadata"
            case status = "status"
            case uploadId = "uploadId"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct ImportJobSummary: AWSDecodableShape {
        /// The timestamp when the import job was created.
        public let createdTime: Date
        /// The configuration information of the external source that the resource data are imported from.
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The identifier of the import job.
        public let importJobId: String
        /// The type of import job.
        public let importJobType: ImportJobType
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The timestamp when the import job was last modified.
        public let lastModifiedTime: Date
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public let metadata: [String: String]?
        /// The status of the import job.
        public let status: ImportJobStatus
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        @inlinable
        public init(createdTime: Date, externalSourceConfiguration: ExternalSourceConfiguration? = nil, importJobId: String, importJobType: ImportJobType, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedTime: Date, metadata: [String: String]? = nil, status: ImportJobStatus, uploadId: String) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case importJobId = "importJobId"
            case importJobType = "importJobType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedTime = "lastModifiedTime"
            case metadata = "metadata"
            case status = "status"
            case uploadId = "uploadId"
        }
    }

    public struct IntentDetectedDataDetails: AWSDecodableShape {
        /// The detected intent.
        public let intent: String
        /// The identifier of the detected intent.
        public let intentId: String

        @inlinable
        public init(intent: String, intentId: String) {
            self.intent = intent
            self.intentId = intentId
        }

        private enum CodingKeys: String, CodingKey {
            case intent = "intent"
            case intentId = "intentId"
        }
    }

    public struct IntentInputData: AWSEncodableShape {
        /// The identifier of the Amazon Q intent.
        public let intentId: String

        @inlinable
        public init(intentId: String) {
            self.intentId = intentId
        }

        public func validate(name: String) throws {
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case intentId = "intentId"
        }
    }

    public struct KnowledgeBaseAssociationConfigurationData: AWSEncodableShape & AWSDecodableShape {
        public let contentTagFilter: TagFilter?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The search type to be used against the Knowledge Base for this request. The values can be SEMANTIC which uses vector embeddings or HYBRID which use vector embeddings and raw text
        public let overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType?

        @inlinable
        public init(contentTagFilter: TagFilter? = nil, maxResults: Int? = nil, overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType? = nil) {
            self.contentTagFilter = contentTagFilter
            self.maxResults = maxResults
            self.overrideKnowledgeBaseSearchType = overrideKnowledgeBaseSearchType
        }

        public func validate(name: String) throws {
            try self.contentTagFilter?.validate(name: "\(name).contentTagFilter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentTagFilter = "contentTagFilter"
            case maxResults = "maxResults"
            case overrideKnowledgeBaseSearchType = "overrideKnowledgeBaseSearchType"
        }
    }

    public struct KnowledgeBaseAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String?

        @inlinable
        public init(knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil) {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct KnowledgeBaseData: AWSDecodableShape {
        /// The description.
        public let description: String?
        /// List of failure reasons on ingestion per file.
        public let ingestionFailureReasons: [String]?
        /// Status of ingestion on data source.
        public let ingestionStatus: SyncStatus?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public let lastContentModificationTime: Date?
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about how to ingest the documents in a data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(description: String? = nil, ingestionFailureReasons: [String]? = nil, ingestionStatus: SyncStatus? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, lastContentModificationTime: Date? = nil, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.description = description
            self.ingestionFailureReasons = ingestionFailureReasons
            self.ingestionStatus = ingestionStatus
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case ingestionFailureReasons = "ingestionFailureReasons"
            case ingestionStatus = "ingestionStatus"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseType = "knowledgeBaseType"
            case lastContentModificationTime = "lastContentModificationTime"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case status = "status"
            case tags = "tags"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base summary.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about how to ingest the documents in a data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseType = "knowledgeBaseType"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case status = "status"
            case tags = "tags"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct ListAIAgentVersionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent for which versions are to be listed.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Agent versions to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(aiAgentId: String, assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIAgentVersionsResponse: AWSDecodableShape {
        /// The summaries of AI Agent versions.
        public let aiAgentVersionSummaries: [AIAgentVersionSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiAgentVersionSummaries: [AIAgentVersionSummary], nextToken: String? = nil) {
            self.aiAgentVersionSummaries = aiAgentVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentVersionSummaries = "aiAgentVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIAgentsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Agents to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIAgentsResponse: AWSDecodableShape {
        /// The summaries of AI Agents.
        public let aiAgentSummaries: [AIAgentSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiAgentSummaries: [AIAgentSummary], nextToken: String? = nil) {
            self.aiAgentSummaries = aiAgentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentSummaries = "aiAgentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIPromptVersionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt for which versions are to be listed.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Prompt versions to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(aiPromptId: String, assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIPromptVersionsResponse: AWSDecodableShape {
        /// The summaries of the AI Prompt versions.
        public let aiPromptVersionSummaries: [AIPromptVersionSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiPromptVersionSummaries: [AIPromptVersionSummary], nextToken: String? = nil) {
            self.aiPromptVersionSummaries = aiPromptVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptVersionSummaries = "aiPromptVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIPromptsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Prompts to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIPromptsResponse: AWSDecodableShape {
        /// The summaries of the AI Prompts.
        public let aiPromptSummaries: [AIPromptSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiPromptSummaries: [AIPromptSummary], nextToken: String? = nil) {
            self.aiPromptSummaries = aiPromptSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptSummaries = "aiPromptSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssistantAssociationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantAssociationsResponse: AWSDecodableShape {
        /// Summary information about assistant associations.
        public let assistantAssociationSummaries: [AssistantAssociationSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantAssociationSummaries: [AssistantAssociationSummary], nextToken: String? = nil) {
            self.assistantAssociationSummaries = assistantAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociationSummaries = "assistantAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssistantsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantsResponse: AWSDecodableShape {
        /// Information about the assistants.
        public let assistantSummaries: [AssistantSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantSummaries: [AssistantSummary], nextToken: String? = nil) {
            self.assistantSummaries = assistantSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantSummaries = "assistantSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListContentAssociationsRequest: AWSEncodableShape {
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentId: String, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContentAssociationsResponse: AWSDecodableShape {
        /// Summary information about content associations.
        public let contentAssociationSummaries: [ContentAssociationSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentAssociationSummaries: [ContentAssociationSummary], nextToken: String? = nil) {
            self.contentAssociationSummaries = contentAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentAssociationSummaries = "contentAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListContentsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContentsResponse: AWSDecodableShape {
        /// Information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries = "contentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportJobsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportJobsResponse: AWSDecodableShape {
        /// Summary information about the import jobs.
        public let importJobSummaries: [ImportJobSummary]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(importJobSummaries: [ImportJobSummary], nextToken: String? = nil) {
            self.importJobSummaries = importJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobSummaries = "importJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// Information about the knowledge bases.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries = "knowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListQuickResponsesRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQuickResponsesResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// Summary information about the quick responses.
        public let quickResponseSummaries: [QuickResponseSummary]

        @inlinable
        public init(nextToken: String? = nil, quickResponseSummaries: [QuickResponseSummary]) {
            self.nextToken = nextToken
            self.quickResponseSummaries = quickResponseSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case quickResponseSummaries = "quickResponseSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManualSearchAIAgentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The AI Prompt identifier for the Answer Generation prompt used by the MANUAL_SEARCH AI Agent.
        public let answerGenerationAIPromptId: String?
        /// The association configurations for overriding behavior on this AI Agent.
        public let associationConfigurations: [AssociationConfiguration]?

        @inlinable
        public init(answerGenerationAIPromptId: String? = nil, associationConfigurations: [AssociationConfiguration]? = nil) {
            self.answerGenerationAIPromptId = answerGenerationAIPromptId
            self.associationConfigurations = associationConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.answerGenerationAIPromptId, name: "answerGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.associationConfigurations?.forEach {
                try $0.validate(name: "\(name).associationConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case answerGenerationAIPromptId = "answerGenerationAIPromptId"
            case associationConfigurations = "associationConfigurations"
        }
    }

    public struct NotifyRecommendationsReceivedError: AWSDecodableShape {
        /// A recommendation is causing an error.
        public let message: String?
        /// The identifier of the recommendation that is in error.
        public let recommendationId: String?

        @inlinable
        public init(message: String? = nil, recommendationId: String? = nil) {
            self.message = message
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case recommendationId = "recommendationId"
        }
    }

    public struct NotifyRecommendationsReceivedRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, recommendationIds: [String], sessionId: String) {
            self.assistantId = assistantId
            self.recommendationIds = recommendationIds
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.recommendationIds, forKey: .recommendationIds)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.recommendationIds.forEach {
                try validate($0, name: "recommendationIds[]", parent: name, max: 2048)
                try validate($0, name: "recommendationIds[]", parent: name, min: 1)
            }
            try self.validate(self.recommendationIds, name: "recommendationIds", parent: name, max: 25)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendationIds = "recommendationIds"
        }
    }

    public struct NotifyRecommendationsReceivedResponse: AWSDecodableShape {
        /// The identifiers of recommendations that are causing errors.
        public let errors: [NotifyRecommendationsReceivedError]?
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]?

        @inlinable
        public init(errors: [NotifyRecommendationsReceivedError]? = nil, recommendationIds: [String]? = nil) {
            self.errors = errors
            self.recommendationIds = recommendationIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case recommendationIds = "recommendationIds"
        }
    }

    public struct ParsingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Settings for a foundation model used to parse documents for a data source.
        public let bedrockFoundationModelConfiguration: BedrockFoundationModelConfigurationForParsing?
        /// The parsing strategy for the data source.
        public let parsingStrategy: ParsingStrategy

        @inlinable
        public init(bedrockFoundationModelConfiguration: BedrockFoundationModelConfigurationForParsing? = nil, parsingStrategy: ParsingStrategy) {
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.parsingStrategy = parsingStrategy
        }

        public func validate(name: String) throws {
            try self.bedrockFoundationModelConfiguration?.validate(name: "\(name).bedrockFoundationModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockFoundationModelConfiguration = "bedrockFoundationModelConfiguration"
            case parsingStrategy = "parsingStrategy"
        }
    }

    public struct ParsingPrompt: AWSEncodableShape & AWSDecodableShape {
        /// Instructions for interpreting the contents of a document.
        public let parsingPromptText: String

        @inlinable
        public init(parsingPromptText: String) {
            self.parsingPromptText = parsingPromptText
        }

        public func validate(name: String) throws {
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, max: 10000)
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parsingPromptText = "parsingPromptText"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// Information about the feedback provided.
        public let contentFeedback: ContentFeedbackData
        /// The identifier of the feedback target.
        public let targetId: String
        /// The type of the feedback target.
        public let targetType: TargetType

        @inlinable
        public init(assistantId: String, contentFeedback: ContentFeedbackData, targetId: String, targetType: TargetType) {
            self.assistantId = assistantId
            self.contentFeedback = contentFeedback
            self.targetId = targetId
            self.targetType = targetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.contentFeedback, forKey: .contentFeedback)
            try container.encode(self.targetId, forKey: .targetId)
            try container.encode(self.targetType, forKey: .targetType)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentFeedback = "contentFeedback"
            case targetId = "targetId"
            case targetType = "targetType"
        }
    }

    public struct PutFeedbackResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// Information about the feedback provided.
        public let contentFeedback: ContentFeedbackData
        /// The identifier of the feedback target.
        public let targetId: String
        /// The type of the feedback target.
        public let targetType: TargetType

        @inlinable
        public init(assistantArn: String, assistantId: String, contentFeedback: ContentFeedbackData, targetId: String, targetType: TargetType) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.contentFeedback = contentFeedback
            self.targetId = targetId
            self.targetType = targetType
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case contentFeedback = "contentFeedback"
            case targetId = "targetId"
            case targetType = "targetType"
        }
    }

    public struct QueryAssistantRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search type to be used against the Knowledge Base for this request. The values can be SEMANTIC which uses vector embeddings or HYBRID which use vector embeddings and raw text.
        public let overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType?
        /// Information about how to query content.
        public let queryCondition: [QueryCondition]?
        /// Information about the query.
        public let queryInputData: QueryInputData?
        /// The text to search for.
        public let queryText: String?
        /// The identifier of the Amazon Q in Connect session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType? = nil, queryCondition: [QueryCondition]? = nil, queryInputData: QueryInputData? = nil, queryText: String? = nil, sessionId: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.overrideKnowledgeBaseSearchType = overrideKnowledgeBaseSearchType
            self.queryCondition = queryCondition
            self.queryInputData = queryInputData
            self.queryText = queryText
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.overrideKnowledgeBaseSearchType, forKey: .overrideKnowledgeBaseSearchType)
            try container.encodeIfPresent(self.queryCondition, forKey: .queryCondition)
            try container.encodeIfPresent(self.queryInputData, forKey: .queryInputData)
            try container.encodeIfPresent(self.queryText, forKey: .queryText)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.queryCondition?.forEach {
                try $0.validate(name: "\(name).queryCondition[]")
            }
            try self.validate(self.queryCondition, name: "queryCondition", parent: name, max: 1)
            try self.queryInputData?.validate(name: "\(name).queryInputData")
            try self.validate(self.queryText, name: "queryText", parent: name, max: 512)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case overrideKnowledgeBaseSearchType = "overrideKnowledgeBaseSearchType"
            case queryCondition = "queryCondition"
            case queryInputData = "queryInputData"
            case queryText = "queryText"
            case sessionId = "sessionId"
        }
    }

    public struct QueryAssistantResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The results of the query.
        public let results: [ResultData]

        @inlinable
        public init(nextToken: String? = nil, results: [ResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct QueryConditionItem: AWSEncodableShape {
        /// The comparison operator for query condition to query on.
        public let comparator: QueryConditionComparisonOperator
        ///  The name of the field for query condition to query on.
        public let field: QueryConditionFieldName
        /// The value for the query condition to query on.
        public let value: String

        @inlinable
        public init(comparator: QueryConditionComparisonOperator, field: QueryConditionFieldName, value: String) {
            self.comparator = comparator
            self.field = field
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "comparator"
            case field = "field"
            case value = "value"
        }
    }

    public struct QueryRecommendationTriggerData: AWSDecodableShape {
        /// The text associated with the recommendation trigger.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct QueryTextInputData: AWSEncodableShape {
        /// The text to search for.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 512)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct QuickResponseContents: AWSDecodableShape {
        public let markdown: QuickResponseContentProvider?
        public let plainText: QuickResponseContentProvider?

        @inlinable
        public init(markdown: QuickResponseContentProvider? = nil, plainText: QuickResponseContentProvider? = nil) {
            self.markdown = markdown
            self.plainText = plainText
        }

        private enum CodingKeys: String, CodingKey {
            case markdown = "markdown"
            case plainText = "plainText"
        }
    }

    public struct QuickResponseData: AWSDecodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The contents of the quick response.
        public let contents: QuickResponseContents?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written.
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response data was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The status of the quick response data.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channels: [String]? = nil, contents: QuickResponseContents? = nil, contentType: String, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, shortcutKey: String? = nil, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.channels = channels
            self.contents = contents
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case contents = "contents"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case shortcutKey = "shortcutKey"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct QuickResponseFilterField: AWSEncodableShape {
        /// Whether to treat null value as a match for the attribute field.
        public let includeNoExistence: Bool?
        /// The name of the attribute field to filter the quick responses by.
        public let name: String
        /// The operator to use for filtering.
        public let `operator`: QuickResponseFilterOperator
        /// The values of attribute field to filter the quick response by.
        public let values: [String]?

        @inlinable
        public init(includeNoExistence: Bool? = nil, name: String, operator: QuickResponseFilterOperator, values: [String]? = nil) {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeNoExistence = "includeNoExistence"
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct QuickResponseOrderField: AWSEncodableShape {
        /// The name of the attribute to order the quick response query results by.
        public let name: String
        /// The order at which the quick responses are sorted by.
        public let order: Order?

        @inlinable
        public init(name: String, order: Order? = nil) {
            self.name = name
            self.order = order
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
        }
    }

    public struct QuickResponseQueryField: AWSEncodableShape {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public let allowFuzziness: Bool?
        /// The name of the attribute to query the quick responses by.
        public let name: String
        /// The operator to use for matching attribute field values in the query.
        public let `operator`: QuickResponseQueryOperator
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public let priority: Priority?
        /// The values of the attribute to query the quick responses by.
        public let values: [String]

        @inlinable
        public init(allowFuzziness: Bool? = nil, name: String, operator: QuickResponseQueryOperator, priority: Priority? = nil, values: [String]) {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowFuzziness = "allowFuzziness"
            case name = "name"
            case `operator` = "operator"
            case priority = "priority"
            case values = "values"
        }
    }

    public struct QuickResponseSearchExpression: AWSEncodableShape {
        /// The configuration of filtering rules applied to quick response query results.
        public let filters: [QuickResponseFilterField]?
        /// The quick response attribute fields on which the query results are ordered.
        public let orderOnField: QuickResponseOrderField?
        /// The quick response query expressions.
        public let queries: [QuickResponseQueryField]?

        @inlinable
        public init(filters: [QuickResponseFilterField]? = nil, orderOnField: QuickResponseOrderField? = nil, queries: [QuickResponseQueryField]? = nil) {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.orderOnField?.validate(name: "\(name).orderOnField")
            try self.queries?.forEach {
                try $0.validate(name: "\(name).queries[]")
            }
            try self.validate(self.queries, name: "queries", parent: name, max: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case orderOnField = "orderOnField"
            case queries = "queries"
        }
    }

    public struct QuickResponseSearchResultData: AWSDecodableShape {
        /// The user defined contact attributes that are resolved when the search result is returned.
        public let attributesInterpolated: [String]?
        /// The user defined contact attributes that are not resolved when the search result is returned.
        public let attributesNotInterpolated: [String]?
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The contents of the quick response.
        public let contents: QuickResponseContents
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written.
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response search result data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response search result data was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The resource status of the quick response.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributesInterpolated: [String]? = nil, attributesNotInterpolated: [String]? = nil, channels: [String]? = nil, contents: QuickResponseContents, contentType: String, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, shortcutKey: String? = nil, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.attributesInterpolated = attributesInterpolated
            self.attributesNotInterpolated = attributesNotInterpolated
            self.channels = channels
            self.contents = contents
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributesInterpolated = "attributesInterpolated"
            case attributesNotInterpolated = "attributesNotInterpolated"
            case channels = "channels"
            case contents = "contents"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case shortcutKey = "shortcutKey"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct QuickResponseSummary: AWSDecodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response summary was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The resource status of the quick response.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channels: [String]? = nil, contentType: String, createdTime: Date, description: String? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.channels = channels
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct RankingData: AWSDecodableShape {
        /// The relevance score of the content.
        public let relevanceLevel: RelevanceLevel?
        /// The relevance level of the recommendation.
        public let relevanceScore: Double?

        @inlinable
        public init(relevanceLevel: RelevanceLevel? = nil, relevanceScore: Double? = nil) {
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
        }

        private enum CodingKeys: String, CodingKey {
            case relevanceLevel = "relevanceLevel"
            case relevanceScore = "relevanceScore"
        }
    }

    public struct RecommendationData: AWSDecodableShape {
        ///  Summary of the recommended content.
        public let data: DataSummary?
        /// The recommended document.
        public let document: Document?
        /// The identifier of the recommendation.
        public let recommendationId: String
        /// The relevance level of the recommendation.
        public let relevanceLevel: RelevanceLevel?
        /// The relevance score of the recommendation.
        public let relevanceScore: Double?
        /// The type of recommendation.
        public let type: RecommendationType?

        @inlinable
        public init(data: DataSummary? = nil, document: Document? = nil, recommendationId: String, relevanceLevel: RelevanceLevel? = nil, relevanceScore: Double? = nil, type: RecommendationType? = nil) {
            self.data = data
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case document = "document"
            case recommendationId = "recommendationId"
            case relevanceLevel = "relevanceLevel"
            case relevanceScore = "relevanceScore"
            case type = "type"
        }
    }

    public struct RecommendationTrigger: AWSDecodableShape {
        /// A union type containing information related to the trigger.
        public let data: RecommendationTriggerData
        /// The identifier of the recommendation trigger.
        public let id: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The source of the recommendation trigger.   ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.   RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        public let source: RecommendationSourceType
        /// The type of recommendation trigger.
        public let type: RecommendationTriggerType

        @inlinable
        public init(data: RecommendationTriggerData, id: String, recommendationIds: [String], source: RecommendationSourceType, type: RecommendationTriggerType) {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case id = "id"
            case recommendationIds = "recommendationIds"
            case source = "source"
            case type = "type"
        }
    }

    public struct RemoveAssistantAIAgentRequest: AWSEncodableShape {
        /// The type of the AI Agent being removed for use by default from the Amazon Q in Connect Assistant.
        public let aiAgentType: AIAgentType
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiAgentType: AIAgentType, assistantId: String) {
            self.aiAgentType = aiAgentType
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aiAgentType, key: "aiAgentType")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveAssistantAIAgentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RemoveKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RenderingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:   Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted    ServiceNow: number, short_description, sys_mod_count, workflow_state, or active    Zendesk: id, title, updated_at, or draft    The variable is replaced with the actual value for a piece of content when calling GetContent.
        public let templateUri: String?

        @inlinable
        public init(templateUri: String? = nil) {
            self.templateUri = templateUri
        }

        public func validate(name: String) throws {
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri = "templateUri"
        }
    }

    public struct ResultData: AWSDecodableShape {
        ///  Summary of the recommended content.
        public let data: DataSummary?
        /// The document.
        public let document: Document?
        /// The relevance score of the results.
        public let relevanceScore: Double?
        /// The identifier of the result data.
        public let resultId: String
        /// The type of the query result.
        public let type: QueryResultType?

        @inlinable
        public init(data: DataSummary? = nil, document: Document? = nil, relevanceScore: Double? = nil, resultId: String, type: QueryResultType? = nil) {
            self.data = data
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case document = "document"
            case relevanceScore = "relevanceScore"
            case resultId = "resultId"
            case type = "type"
        }
    }

    public struct RuntimeSessionData: AWSEncodableShape & AWSDecodableShape {
        /// The key of the data stored on the session.
        public let key: String
        /// The value of the data stored on the session.
        public let value: RuntimeSessionDataValue

        @inlinable
        public init(key: String, value: RuntimeSessionDataValue) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 4096)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct SearchContentRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchContentResponse: AWSDecodableShape {
        /// Summary information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries = "contentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct SearchExpression: AWSEncodableShape {
        /// The search expression filters.
        public let filters: [Filter]

        @inlinable
        public init(filters: [Filter]) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct SearchQuickResponsesRequest: AWSEncodableShape {
        /// The user-defined Amazon Connect contact attributes to be resolved when search results are returned.
        public let attributes: [String: String]?
        /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression for querying the quick response.
        public let searchExpression: QuickResponseSearchExpression

        @inlinable
        public init(attributes: [String: String]? = nil, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: QuickResponseSearchExpression) {
            self.attributes = attributes
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchQuickResponsesResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The results of the quick response search.
        public let results: [QuickResponseSearchResultData]

        @inlinable
        public init(nextToken: String? = nil, results: [QuickResponseSearchResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct SearchSessionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchSessionsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary information about the sessions.
        public let sessionSummaries: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionSummaries = "sessionSummaries"
        }
    }

    public struct SeedUrl: AWSEncodableShape & AWSDecodableShape {
        /// URL for crawling
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.url, name: "url", parent: name, pattern: "^https?://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct SemanticChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dissimilarity threshold for splitting chunks.
        public let breakpointPercentileThreshold: Int
        /// The buffer size.
        public let bufferSize: Int
        /// The maximum number of tokens that a chunk can contain.
        public let maxTokens: Int

        @inlinable
        public init(breakpointPercentileThreshold: Int, bufferSize: Int, maxTokens: Int) {
            self.breakpointPercentileThreshold = breakpointPercentileThreshold
            self.bufferSize = bufferSize
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case breakpointPercentileThreshold = "breakpointPercentileThreshold"
            case bufferSize = "bufferSize"
            case maxTokens = "maxTokens"
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The customer managed key used for encryption. For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance. For information about valid ID values, see Key identifiers (KeyId).
        public let kmsKeyId: String?

        @inlinable
        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 4096)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct SessionData: AWSDecodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The description of the session.
        public let description: String?
        /// The configuration information for the session integration.
        public let integrationConfiguration: SessionIntegrationConfiguration?
        /// The name of the session.
        public let name: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String
        /// An object that can be used to specify Tag conditions.
        public let tagFilter: TagFilter?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, description: String? = nil, integrationConfiguration: SessionIntegrationConfiguration? = nil, name: String, sessionArn: String, sessionId: String, tagFilter: TagFilter? = nil, tags: [String: String]? = nil) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tagFilter = tagFilter
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case tagFilter = "tagFilter"
            case tags = "tags"
        }
    }

    public struct SessionIntegrationConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public let topicIntegrationArn: String?

        @inlinable
        public init(topicIntegrationArn: String? = nil) {
            self.topicIntegrationArn = topicIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicIntegrationArn = "topicIntegrationArn"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String

        @inlinable
        public init(assistantArn: String, assistantId: String, sessionArn: String, sessionId: String) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct SourceContentDataDetails: AWSDecodableShape {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public let citationSpan: CitationSpan?
        /// The identifier of the source content.
        public let id: String
        /// Details about the source content ranking data.
        public let rankingData: RankingData
        ///  Details about the source content text data.
        public let textData: TextData
        /// The type of the source content.
        public let type: SourceContentType

        @inlinable
        public init(citationSpan: CitationSpan? = nil, id: String, rankingData: RankingData, textData: TextData, type: SourceContentType) {
            self.citationSpan = citationSpan
            self.id = id
            self.rankingData = rankingData
            self.textData = textData
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case citationSpan = "citationSpan"
            case id = "id"
            case rankingData = "rankingData"
            case textData = "textData"
            case type = "type"
        }
    }

    public struct StartContentUploadRequest: AWSEncodableShape {
        /// The type of content to upload.
        public let contentType: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The expected expiration time of the generated presigned URL, specified in minutes.
        public let presignedUrlTimeToLive: Int?

        @inlinable
        public init(contentType: String, knowledgeBaseId: String, presignedUrlTimeToLive: Int? = nil) {
            self.contentType = contentType
            self.knowledgeBaseId = knowledgeBaseId
            self.presignedUrlTimeToLive = presignedUrlTimeToLive
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contentType, forKey: .contentType)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.presignedUrlTimeToLive, forKey: .presignedUrlTimeToLive)
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(text/(plain|html|csv))|(application/(pdf|vnd\\.openxmlformats-officedocument\\.wordprocessingml\\.document))|(application/x\\.wisdom-json;source=(salesforce|servicenow|zendesk))$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.presignedUrlTimeToLive, name: "presignedUrlTimeToLive", parent: name, max: 60)
            try self.validate(self.presignedUrlTimeToLive, name: "presignedUrlTimeToLive", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case presignedUrlTimeToLive = "presignedUrlTimeToLive"
        }
    }

    public struct StartContentUploadResponse: AWSDecodableShape {
        /// The headers to include in the upload.
        public let headersToInclude: [String: String]
        /// The identifier of the upload.
        public let uploadId: String
        /// The URL of the upload.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        @inlinable
        public init(headersToInclude: [String: String], uploadId: String, url: String, urlExpiry: Date) {
            self.headersToInclude = headersToInclude
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case headersToInclude = "headersToInclude"
            case uploadId = "uploadId"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct StartImportJobRequest: AWSEncodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let clientToken: String?
        /// The configuration information of the external source that the resource data are imported from.
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The type of the import job.   For importing quick response resource, set the value to QUICK_RESPONSES.
        public let importJobType: ImportJobType
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.   For importing Amazon Q in Connect quick responses, this should be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public let metadata: [String: String]?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        @inlinable
        public init(clientToken: String? = StartImportJobRequest.idempotencyToken(), externalSourceConfiguration: ExternalSourceConfiguration? = nil, importJobType: ImportJobType, knowledgeBaseId: String, metadata: [String: String]? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobType = importJobType
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.externalSourceConfiguration, forKey: .externalSourceConfiguration)
            try container.encode(self.importJobType, forKey: .importJobType)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.externalSourceConfiguration?.validate(name: "\(name).externalSourceConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case importJobType = "importJobType"
            case metadata = "metadata"
            case uploadId = "uploadId"
        }
    }

    public struct StartImportJobResponse: AWSDecodableShape {
        /// The import job.
        public let importJob: ImportJobData?

        @inlinable
        public init(importJob: ImportJobData? = nil) {
            self.importJob = importJob
        }

        private enum CodingKeys: String, CodingKey {
            case importJob = "importJob"
        }
    }

    public struct TagCondition: AWSEncodableShape & AWSDecodableShape {
        /// The tag key in the tag condition.
        public let key: String
        /// The tag value in the tag condition.
        public let value: String?

        @inlinable
        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextData: AWSDecodableShape {
        public let excerpt: DocumentText?
        public let title: DocumentText?

        @inlinable
        public init(excerpt: DocumentText? = nil, title: DocumentText? = nil) {
            self.excerpt = excerpt
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case excerpt = "excerpt"
            case title = "title"
        }
    }

    public struct TextFullAIPromptEditTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The YAML text for the AI Prompt template.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 200000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The configuration of the Amazon Q in Connect AI Agent.
        public let configuration: AIAgentConfiguration?
        /// The description of the Amazon Q in Connect AI Agent.
        public let description: String?
        /// The visbility status of the Amazon Q in Connect AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiAgentId: String, assistantId: String, clientToken: String? = UpdateAIAgentRequest.idempotencyToken(), configuration: AIAgentConfiguration? = nil, description: String? = nil, visibilityStatus: VisibilityStatus) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct UpdateAIAgentResponse: AWSDecodableShape {
        /// The data of the updated Amazon Q in Connect AI Agent.
        public let aiAgent: AIAgentData?

        @inlinable
        public init(aiAgent: AIAgentData? = nil) {
            self.aiAgent = aiAgent
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
        }
    }

    public struct UpdateAIPromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the Amazon Q in Connect AI Prompt.
        public let description: String?
        /// The configuration of the prompt template for this AI Prompt.
        public let templateConfiguration: AIPromptTemplateConfiguration?
        /// The visibility status of the Amazon Q in Connect AI prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiPromptId: String, assistantId: String, clientToken: String? = UpdateAIPromptRequest.idempotencyToken(), description: String? = nil, templateConfiguration: AIPromptTemplateConfiguration? = nil, visibilityStatus: VisibilityStatus) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.templateConfiguration = templateConfiguration
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.templateConfiguration, forKey: .templateConfiguration)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.templateConfiguration?.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case templateConfiguration = "templateConfiguration"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct UpdateAIPromptResponse: AWSDecodableShape {
        /// The data of the updated Amazon Q in Connect AI Prompt.
        public let aiPrompt: AIPromptData?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil) {
            self.aiPrompt = aiPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
        }
    }

    public struct UpdateAssistantAIAgentRequest: AWSEncodableShape {
        /// The type of the AI Agent being updated for use by default on the Amazon Q in Connect Assistant.
        public let aiAgentType: AIAgentType
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The configuration of the AI Agent being updated for use by default on the Amazon Q in Connect Assistant.
        public let configuration: AIAgentConfigurationData

        @inlinable
        public init(aiAgentType: AIAgentType, assistantId: String, configuration: AIAgentConfigurationData) {
            self.aiAgentType = aiAgentType
            self.assistantId = assistantId
            self.configuration = configuration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.aiAgentType, forKey: .aiAgentType)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.configuration, forKey: .configuration)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentType = "aiAgentType"
            case configuration = "configuration"
        }
    }

    public struct UpdateAssistantAIAgentResponse: AWSDecodableShape {
        public let assistant: AssistantData?

        @inlinable
        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct UpdateContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
        public let overrideLinkOutUri: String?
        /// Unset the existing overrideLinkOutUri if it exists.
        public let removeOverrideLinkOutUri: Bool?
        /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
        public let revisionId: String?
        /// The title of the content.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String?

        @inlinable
        public init(contentId: String, knowledgeBaseId: String, metadata: [String: String]? = nil, overrideLinkOutUri: String? = nil, removeOverrideLinkOutUri: Bool? = nil, revisionId: String? = nil, title: String? = nil, uploadId: String? = nil) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.overrideLinkOutUri = overrideLinkOutUri
            self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
            self.revisionId = revisionId
            self.title = title
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encodeIfPresent(self.overrideLinkOutUri, forKey: .overrideLinkOutUri)
            try container.encodeIfPresent(self.removeOverrideLinkOutUri, forKey: .removeOverrideLinkOutUri)
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encodeIfPresent(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.validate(self.revisionId, name: "revisionId", parent: name, max: 4096)
            try self.validate(self.revisionId, name: "revisionId", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case overrideLinkOutUri = "overrideLinkOutUri"
            case removeOverrideLinkOutUri = "removeOverrideLinkOutUri"
            case revisionId = "revisionId"
            case title = "title"
            case uploadId = "uploadId"
        }
    }

    public struct UpdateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        @inlinable
        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The template URI to update.
        public let templateUri: String

        @inlinable
        public init(knowledgeBaseId: String, templateUri: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.templateUri = templateUri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.templateUri, forKey: .templateUri)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri = "templateUri"
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        /// The knowledge base to update.
        public let knowledgeBase: KnowledgeBaseData?

        @inlinable
        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct UpdateQuickResponseRequest: AWSEncodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The updated content of the quick response.
        public let content: QuickResponseDataProvider?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String?
        /// The updated description of the quick response.
        public let description: String?
        /// The updated grouping configuration of the quick response.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the quick response.
        public let name: String?
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// Whether to remove the description from the quick response.
        public let removeDescription: Bool?
        /// Whether to remove the grouping configuration of the quick response.
        public let removeGroupingConfiguration: Bool?
        /// Whether to remove the shortcut key of the quick response.
        public let removeShortcutKey: Bool?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?

        @inlinable
        public init(channels: [String]? = nil, content: QuickResponseDataProvider? = nil, contentType: String? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseId: String, language: String? = nil, name: String? = nil, quickResponseId: String, removeDescription: Bool? = nil, removeGroupingConfiguration: Bool? = nil, removeShortcutKey: Bool? = nil, shortcutKey: String? = nil) {
            self.channels = channels
            self.content = content
            self.contentType = contentType
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.quickResponseId = quickResponseId
            self.removeDescription = removeDescription
            self.removeGroupingConfiguration = removeGroupingConfiguration
            self.removeShortcutKey = removeShortcutKey
            self.shortcutKey = shortcutKey
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.channels, forKey: .channels)
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.quickResponseId, key: "quickResponseId")
            try container.encodeIfPresent(self.removeDescription, forKey: .removeDescription)
            try container.encodeIfPresent(self.removeGroupingConfiguration, forKey: .removeGroupingConfiguration)
            try container.encodeIfPresent(self.removeShortcutKey, forKey: .removeShortcutKey)
            try container.encodeIfPresent(self.shortcutKey, forKey: .shortcutKey)
        }

        public func validate(name: String) throws {
            try self.channels?.forEach {
                try validate($0, name: "channels[]", parent: name, max: 10)
                try validate($0, name: "channels[]", parent: name, min: 1)
            }
            try self.content?.validate(name: "\(name).content")
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(application/x\\.quickresponse;format=(plain|markdown))$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, max: 10)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case content = "content"
            case contentType = "contentType"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case language = "language"
            case name = "name"
            case removeDescription = "removeDescription"
            case removeGroupingConfiguration = "removeGroupingConfiguration"
            case removeShortcutKey = "removeShortcutKey"
            case shortcutKey = "shortcutKey"
        }
    }

    public struct UpdateQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        @inlinable
        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct UpdateSessionDataRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The data stored on the Amazon Q in Connect Session.
        public let data: [RuntimeSessionData]
        /// The namespace into which the session data is stored. Supported namespaces are: Custom
        public let namespace: SessionDataNamespace?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, data: [RuntimeSessionData], namespace: SessionDataNamespace? = nil, sessionId: String) {
            self.assistantId = assistantId
            self.data = data
            self.namespace = namespace
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.data, forKey: .data)
            try container.encodeIfPresent(self.namespace, forKey: .namespace)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.data.forEach {
                try $0.validate(name: "\(name).data[]")
            }
            try self.validate(self.data, name: "data", parent: name, max: 50)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case namespace = "namespace"
        }
    }

    public struct UpdateSessionDataResponse: AWSDecodableShape {
        /// Data stored in the session.
        public let data: [RuntimeSessionData]
        /// The namespace into which the session data is stored. Supported namespaces are: Custom
        public let namespace: SessionDataNamespace
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String

        @inlinable
        public init(data: [RuntimeSessionData], namespace: SessionDataNamespace, sessionArn: String, sessionId: String) {
            self.data = data
            self.namespace = namespace
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case namespace = "namespace"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct UpdateSessionRequest: AWSEncodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The description.
        public let description: String?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String
        /// An object that can be used to specify Tag conditions.
        public let tagFilter: TagFilter?

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantId: String, description: String? = nil, sessionId: String, tagFilter: TagFilter? = nil) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantId = assistantId
            self.description = description
            self.sessionId = sessionId
            self.tagFilter = tagFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.aiAgentConfiguration, forKey: .aiAgentConfiguration)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.tagFilter, forKey: .tagFilter)
        }

        public func validate(name: String) throws {
            try self.aiAgentConfiguration?.forEach {
                try $0.value.validate(name: "\(name).aiAgentConfiguration[\"\($0.key)\"]")
            }
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tagFilter?.validate(name: "\(name).tagFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case description = "description"
            case tagFilter = "tagFilter"
        }
    }

    public struct UpdateSessionResponse: AWSDecodableShape {
        public let session: SessionData?

        @inlinable
        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct UrlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// List of URLs for crawling.
        public let seedUrls: [SeedUrl]?

        @inlinable
        public init(seedUrls: [SeedUrl]? = nil) {
            self.seedUrls = seedUrls
        }

        public func validate(name: String) throws {
            try self.seedUrls?.forEach {
                try $0.validate(name: "\(name).seedUrls[]")
            }
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, max: 100)
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case seedUrls = "seedUrls"
        }
    }

    public struct VectorIngestionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public let chunkingConfiguration: ChunkingConfiguration?
        /// A custom parser for data source documents.
        public let parsingConfiguration: ParsingConfiguration?

        @inlinable
        public init(chunkingConfiguration: ChunkingConfiguration? = nil, parsingConfiguration: ParsingConfiguration? = nil) {
            self.chunkingConfiguration = chunkingConfiguration
            self.parsingConfiguration = parsingConfiguration
        }

        public func validate(name: String) throws {
            try self.chunkingConfiguration?.validate(name: "\(name).chunkingConfiguration")
            try self.parsingConfiguration?.validate(name: "\(name).parsingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingConfiguration = "chunkingConfiguration"
            case parsingConfiguration = "parsingConfiguration"
        }
    }

    public struct WebCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of crawl limits for the web URLs.
        public let crawlerLimits: WebCrawlerLimits?
        /// A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        public let exclusionFilters: [String]?
        /// A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        public let inclusionFilters: [String]?
        /// The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL https://docs.aws.amazon.com/bedrock/latest/userguide/ and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain aws.amazon.com can also include sub domain docs.aws.amazon.com.
        public let scope: WebScopeType?
        /// The configuration of the URL/URLs for the web content that you want to crawl. You should be authorized to crawl the URLs.
        public let urlConfiguration: UrlConfiguration

        @inlinable
        public init(crawlerLimits: WebCrawlerLimits? = nil, exclusionFilters: [String]? = nil, inclusionFilters: [String]? = nil, scope: WebScopeType? = nil, urlConfiguration: UrlConfiguration) {
            self.crawlerLimits = crawlerLimits
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.scope = scope
            self.urlConfiguration = urlConfiguration
        }

        public func validate(name: String) throws {
            try self.exclusionFilters?.forEach {
                try validate($0, name: "exclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "exclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, max: 25)
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, min: 1)
            try self.inclusionFilters?.forEach {
                try validate($0, name: "inclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "inclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, max: 25)
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, min: 1)
            try self.urlConfiguration.validate(name: "\(name).urlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerLimits = "crawlerLimits"
            case exclusionFilters = "exclusionFilters"
            case inclusionFilters = "inclusionFilters"
            case scope = "scope"
            case urlConfiguration = "urlConfiguration"
        }
    }

    public struct WebCrawlerLimits: AWSEncodableShape & AWSDecodableShape {
        /// Rate of web URLs retrieved per minute.
        public let rateLimit: Int?

        @inlinable
        public init(rateLimit: Int? = nil) {
            self.rateLimit = rateLimit
        }

        private enum CodingKeys: String, CodingKey {
            case rateLimit = "rateLimit"
        }
    }

    public struct AIPromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for a prompt template that supports full textual prompt configuration using a YAML prompt.
        public let textFullAIPromptEditTemplateConfiguration: TextFullAIPromptEditTemplateConfiguration?

        @inlinable
        public init(textFullAIPromptEditTemplateConfiguration: TextFullAIPromptEditTemplateConfiguration? = nil) {
            self.textFullAIPromptEditTemplateConfiguration = textFullAIPromptEditTemplateConfiguration
        }

        public func validate(name: String) throws {
            try self.textFullAIPromptEditTemplateConfiguration?.validate(name: "\(name).textFullAIPromptEditTemplateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case textFullAIPromptEditTemplateConfiguration = "textFullAIPromptEditTemplateConfiguration"
        }
    }

    public struct AssistantAssociationInputData: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String?

        @inlinable
        public init(knowledgeBaseId: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct AssistantAssociationOutputData: AWSDecodableShape {
        /// The knowledge base where output data is sent.
        public let knowledgeBaseAssociation: KnowledgeBaseAssociationData?

        @inlinable
        public init(knowledgeBaseAssociation: KnowledgeBaseAssociationData? = nil) {
            self.knowledgeBaseAssociation = knowledgeBaseAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseAssociation = "knowledgeBaseAssociation"
        }
    }

    public struct AssociationConfigurationData: AWSEncodableShape & AWSDecodableShape {
        /// The data of the configuration for a KNOWLEDGE_BASE type Amazon Q in Connect Assistant Association.
        public let knowledgeBaseAssociationConfigurationData: KnowledgeBaseAssociationConfigurationData?

        @inlinable
        public init(knowledgeBaseAssociationConfigurationData: KnowledgeBaseAssociationConfigurationData? = nil) {
            self.knowledgeBaseAssociationConfigurationData = knowledgeBaseAssociationConfigurationData
        }

        public func validate(name: String) throws {
            try self.knowledgeBaseAssociationConfigurationData?.validate(name: "\(name).knowledgeBaseAssociationConfigurationData")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseAssociationConfigurationData = "knowledgeBaseAssociationConfigurationData"
        }
    }

    public struct Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information of the Amazon Connect data source.
        public let connectConfiguration: ConnectConfiguration?

        @inlinable
        public init(connectConfiguration: ConnectConfiguration? = nil) {
            self.connectConfiguration = connectConfiguration
        }

        public func validate(name: String) throws {
            try self.connectConfiguration?.validate(name: "\(name).connectConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case connectConfiguration = "connectConfiguration"
        }
    }

    public struct ContentAssociationContents: AWSEncodableShape & AWSDecodableShape {
        /// The data of the step-by-step guide association.
        public let amazonConnectGuideAssociation: AmazonConnectGuideAssociationData?

        @inlinable
        public init(amazonConnectGuideAssociation: AmazonConnectGuideAssociationData? = nil) {
            self.amazonConnectGuideAssociation = amazonConnectGuideAssociation
        }

        public func validate(name: String) throws {
            try self.amazonConnectGuideAssociation?.validate(name: "\(name).amazonConnectGuideAssociation")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonConnectGuideAssociation = "amazonConnectGuideAssociation"
        }
    }

    public struct ContentFeedbackData: AWSEncodableShape & AWSDecodableShape {
        /// Information about the feedback for a generative target type.
        public let generativeContentFeedbackData: GenerativeContentFeedbackData?

        @inlinable
        public init(generativeContentFeedbackData: GenerativeContentFeedbackData? = nil) {
            self.generativeContentFeedbackData = generativeContentFeedbackData
        }

        private enum CodingKeys: String, CodingKey {
            case generativeContentFeedbackData = "generativeContentFeedbackData"
        }
    }

    public struct ManagedSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration data for web crawler data source.
        public let webCrawlerConfiguration: WebCrawlerConfiguration?

        @inlinable
        public init(webCrawlerConfiguration: WebCrawlerConfiguration? = nil) {
            self.webCrawlerConfiguration = webCrawlerConfiguration
        }

        public func validate(name: String) throws {
            try self.webCrawlerConfiguration?.validate(name: "\(name).webCrawlerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case webCrawlerConfiguration = "webCrawlerConfiguration"
        }
    }

    public struct QueryCondition: AWSEncodableShape {
        /// The condition for the query.
        public let single: QueryConditionItem?

        @inlinable
        public init(single: QueryConditionItem? = nil) {
            self.single = single
        }

        public func validate(name: String) throws {
            try self.single?.validate(name: "\(name).single")
        }

        private enum CodingKeys: String, CodingKey {
            case single = "single"
        }
    }

    public struct QuickResponseContentProvider: AWSDecodableShape {
        /// The content of the quick response.
        public let content: String?

        @inlinable
        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct QuickResponseDataProvider: AWSEncodableShape {
        /// The content of the quick response.
        public let content: String?

        @inlinable
        public init(content: String? = nil) {
            self.content = content
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 1024)
            try self.validate(self.content, name: "content", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct RecommendationTriggerData: AWSDecodableShape {
        /// Data associated with the QUERY RecommendationTriggerType.
        public let query: QueryRecommendationTriggerData?

        @inlinable
        public init(query: QueryRecommendationTriggerData? = nil) {
            self.query = query
        }

        private enum CodingKeys: String, CodingKey {
            case query = "query"
        }
    }

    public struct RuntimeSessionDataValue: AWSEncodableShape & AWSDecodableShape {
        /// The string value of the data stored on the session.
        public let stringValue: String?

        @inlinable
        public init(stringValue: String? = nil) {
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 4096)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stringValue = "stringValue"
        }
    }
}

// MARK: - Errors

/// Error enum for QConnect
public struct QConnectErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case preconditionFailedException = "PreconditionFailedException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QConnect
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
    public static var conflictException: Self { .init(.conflictException) }
    /// The provided revisionId does not match, indicating the content has been modified since it was last read.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The request reached the service more than 15 minutes after the date stamp on the request or more than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp on the request is more than 15 minutes in the future.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The throttling limit has been exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Amazon Q in Connect throws this exception if you have too many tags in your tag set.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input fails to satisfy the constraints specified by a service.
    public static var validationException: Self { .init(.validationException) }
}

extension QConnectErrorType: Equatable {
    public static func == (lhs: QConnectErrorType, rhs: QConnectErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QConnectErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
