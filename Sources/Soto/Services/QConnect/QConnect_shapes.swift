//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QConnect {
    // MARK: Enums

    public enum AIAgentAssociationConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum AIAgentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case answerRecommendation = "ANSWER_RECOMMENDATION"
        case manualSearch = "MANUAL_SEARCH"
        case selfService = "SELF_SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum AIPromptAPIFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anthropicClaudeMessages = "ANTHROPIC_CLAUDE_MESSAGES"
        case anthropicClaudeTextCompletions = "ANTHROPIC_CLAUDE_TEXT_COMPLETIONS"
        public var description: String { return self.rawValue }
    }

    public enum AIPromptTemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum AIPromptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case answerGeneration = "ANSWER_GENERATION"
        case intentLabelingGeneration = "INTENT_LABELING_GENERATION"
        case queryReformulation = "QUERY_REFORMULATION"
        case selfServiceAnswerGeneration = "SELF_SERVICE_ANSWER_GENERATION"
        case selfServicePreProcessing = "SELF_SERVICE_PRE_PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum AssistantCapabilityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v1 = "V1"
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum AssistantStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssistantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        public var description: String { return self.rawValue }
    }

    public enum AssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum ChannelSubtype: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case email = "EMAIL"
        case sms = "SMS"
        public var description: String { return self.rawValue }
    }

    public enum ChunkingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixedSize = "FIXED_SIZE"
        case hierarchical = "HIERARCHICAL"
        case none = "NONE"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum ContentAssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonConnectGuide = "AMAZON_CONNECT_GUIDE"
        public var description: String { return self.rawValue }
    }

    public enum ContentDisposition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachment = "ATTACHMENT"
        public var description: String { return self.rawValue }
    }

    public enum ContentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ConversationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closed = "CLOSED"
        case processing = "PROCESSING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum ConversationStatusReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case rejected = "REJECTED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ExternalSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonConnect = "AMAZON_CONNECT"
        public var description: String { return self.rawValue }
    }

    public enum FilterField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hate = "HATE"
        case insults = "INSULTS"
        case misconduct = "MISCONDUCT"
        case promptAttack = "PROMPT_ATTACK"
        case sexual = "SEXUAL"
        case violence = "VIOLENCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContextualGroundingFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grounding = "GROUNDING"
        case relevance = "RELEVANCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailFilterStrength: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailManagedWordsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case profanity = "PROFANITY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailPiiEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case age = "AGE"
        case awsAccessKey = "AWS_ACCESS_KEY"
        case awsSecretKey = "AWS_SECRET_KEY"
        case caHealthNumber = "CA_HEALTH_NUMBER"
        case caSocialInsuranceNumber = "CA_SOCIAL_INSURANCE_NUMBER"
        case creditDebitCardCvv = "CREDIT_DEBIT_CARD_CVV"
        case creditDebitCardExpiry = "CREDIT_DEBIT_CARD_EXPIRY"
        case creditDebitCardNumber = "CREDIT_DEBIT_CARD_NUMBER"
        case driverId = "DRIVER_ID"
        case email = "EMAIL"
        case internationalBankAccountNumber = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
        case ipAddress = "IP_ADDRESS"
        case licensePlate = "LICENSE_PLATE"
        case macAddress = "MAC_ADDRESS"
        case name = "NAME"
        case password = "PASSWORD"
        case phone = "PHONE"
        case pin = "PIN"
        case swiftCode = "SWIFT_CODE"
        case ukNationalHealthServiceNumber = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
        case ukNationalInsuranceNumber = "UK_NATIONAL_INSURANCE_NUMBER"
        case ukUniqueTaxpayerReferenceNumber = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
        case url = "URL"
        case username = "USERNAME"
        case usBankAccountNumber = "US_BANK_ACCOUNT_NUMBER"
        case usBankRoutingNumber = "US_BANK_ROUTING_NUMBER"
        case usIndividualTaxIdentificationNumber = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
        case usPassportNumber = "US_PASSPORT_NUMBER"
        case usSocialSecurityNumber = "US_SOCIAL_SECURITY_NUMBER"
        case vehicleIdentificationNumber = "VEHICLE_IDENTIFICATION_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailSensitiveInformationAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymize = "ANONYMIZE"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case failed = "FAILED"
        case startInProgress = "START_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case quickResponses = "QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseSearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "HYBRID"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case external = "EXTERNAL"
        case managed = "MANAGED"
        case messageTemplates = "MESSAGE_TEMPLATES"
        case quickResponses = "QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum MessageTemplateAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case custom = "CUSTOM"
        case customerProfile = "CUSTOMER_PROFILE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum MessageTemplateFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum MessageTemplateQueryOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case containsAndPrefix = "CONTAINS_AND_PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Origin: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customer = "CUSTOMER"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum ParsingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bedrockFoundationModel = "BEDROCK_FOUNDATION_MODEL"
        public var description: String { return self.rawValue }
    }

    public enum Participant: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case bot = "BOT"
        case customer = "CUSTOMER"
        public var description: String { return self.rawValue }
    }

    public enum Priority: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum QueryConditionComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum QueryConditionFieldName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case resultType = "RESULT_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum QueryResultType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case generativeAnswer = "GENERATIVE_ANSWER"
        case intentAnswer = "INTENT_ANSWER"
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseQueryOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case containsAndPrefix = "CONTAINS_AND_PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case issueDetection = "ISSUE_DETECTION"
        case other = "OTHER"
        case ruleEvaluation = "RULE_EVALUATION"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationTriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case generative = "GENERATIVE"
        case query = "QUERY"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case detectedIntent = "DETECTED_INTENT"
        case generativeAnswer = "GENERATIVE_ANSWER"
        case generativeResponse = "GENERATIVE_RESPONSE"
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        case webCrawler = "WEB_CRAWLER"
        public var description: String { return self.rawValue }
    }

    public enum Relevance: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case helpful = "HELPFUL"
        case notHelpful = "NOT_HELPFUL"
        public var description: String { return self.rawValue }
    }

    public enum RelevanceLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SessionDataNamespace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "Custom"
        public var description: String { return self.rawValue }
    }

    public enum SourceContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum SyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createInProgress = "CREATE_IN_PROGRESS"
        case syncingInProgress = "SYNCING_IN_PROGRESS"
        case syncFailed = "SYNC_FAILED"
        case syncSuccess = "SYNC_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum TargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case recommendation = "RECOMMENDATION"
        case result = "RESULT"
        public var description: String { return self.rawValue }
    }

    public enum VisibilityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case published = "PUBLISHED"
        case saved = "SAVED"
        public var description: String { return self.rawValue }
    }

    public enum WebScopeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hostOnly = "HOST_ONLY"
        case subdomains = "SUBDOMAINS"
        public var description: String { return self.rawValue }
    }

    public enum AIAgentConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration for AI Agents of type ANSWER_RECOMMENDATION.
        case answerRecommendationAIAgentConfiguration(AnswerRecommendationAIAgentConfiguration)
        /// The configuration for AI Agents of type MANUAL_SEARCH.
        case manualSearchAIAgentConfiguration(ManualSearchAIAgentConfiguration)
        /// The configuration for AI Agents of type SELF_SERVICE.
        case selfServiceAIAgentConfiguration(SelfServiceAIAgentConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .answerRecommendationAIAgentConfiguration:
                let value = try container.decode(AnswerRecommendationAIAgentConfiguration.self, forKey: .answerRecommendationAIAgentConfiguration)
                self = .answerRecommendationAIAgentConfiguration(value)
            case .manualSearchAIAgentConfiguration:
                let value = try container.decode(ManualSearchAIAgentConfiguration.self, forKey: .manualSearchAIAgentConfiguration)
                self = .manualSearchAIAgentConfiguration(value)
            case .selfServiceAIAgentConfiguration:
                let value = try container.decode(SelfServiceAIAgentConfiguration.self, forKey: .selfServiceAIAgentConfiguration)
                self = .selfServiceAIAgentConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .answerRecommendationAIAgentConfiguration(let value):
                try container.encode(value, forKey: .answerRecommendationAIAgentConfiguration)
            case .manualSearchAIAgentConfiguration(let value):
                try container.encode(value, forKey: .manualSearchAIAgentConfiguration)
            case .selfServiceAIAgentConfiguration(let value):
                try container.encode(value, forKey: .selfServiceAIAgentConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .answerRecommendationAIAgentConfiguration(let value):
                try value.validate(name: "\(name).answerRecommendationAIAgentConfiguration")
            case .manualSearchAIAgentConfiguration(let value):
                try value.validate(name: "\(name).manualSearchAIAgentConfiguration")
            case .selfServiceAIAgentConfiguration(let value):
                try value.validate(name: "\(name).selfServiceAIAgentConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case answerRecommendationAIAgentConfiguration = "answerRecommendationAIAgentConfiguration"
            case manualSearchAIAgentConfiguration = "manualSearchAIAgentConfiguration"
            case selfServiceAIAgentConfiguration = "selfServiceAIAgentConfiguration"
        }
    }

    public enum DataDetails: AWSDecodableShape, Sendable {
        /// Details about the content data.
        case contentData(ContentDataDetails)
        ///  Details about the generative data.
        case generativeData(GenerativeDataDetails)
        /// Details about the intent data.
        case intentDetectedData(IntentDetectedDataDetails)
        /// Details about the content data.
        case sourceContentData(SourceContentDataDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentData:
                let value = try container.decode(ContentDataDetails.self, forKey: .contentData)
                self = .contentData(value)
            case .generativeData:
                let value = try container.decode(GenerativeDataDetails.self, forKey: .generativeData)
                self = .generativeData(value)
            case .intentDetectedData:
                let value = try container.decode(IntentDetectedDataDetails.self, forKey: .intentDetectedData)
                self = .intentDetectedData(value)
            case .sourceContentData:
                let value = try container.decode(SourceContentDataDetails.self, forKey: .sourceContentData)
                self = .sourceContentData(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentData = "contentData"
            case generativeData = "generativeData"
            case intentDetectedData = "intentDetectedData"
            case sourceContentData = "sourceContentData"
        }
    }

    public enum DataReference: AWSDecodableShape, Sendable {
        case contentReference(ContentReference)
        /// Reference information about the generative content.
        case generativeReference(GenerativeReference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentReference:
                let value = try container.decode(ContentReference.self, forKey: .contentReference)
                self = .contentReference(value)
            case .generativeReference:
                let value = try container.decode(GenerativeReference.self, forKey: .generativeReference)
                self = .generativeReference(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentReference = "contentReference"
            case generativeReference = "generativeReference"
        }
    }

    public enum MessageTemplateContentProvider: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The content of the message template that applies to the email channel subtype.
        case email(EmailMessageTemplateContent)
        /// The content of the message template that applies to the SMS channel subtype.
        case sms(SMSMessageTemplateContent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .email:
                let value = try container.decode(EmailMessageTemplateContent.self, forKey: .email)
                self = .email(value)
            case .sms:
                let value = try container.decode(SMSMessageTemplateContent.self, forKey: .sms)
                self = .sms(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .email(let value):
                try container.encode(value, forKey: .email)
            case .sms(let value):
                try container.encode(value, forKey: .sms)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .email(let value):
                try value.validate(name: "\(name).email")
            case .sms(let value):
                try value.validate(name: "\(name).sms")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case email = "email"
            case sms = "sms"
        }
    }

    public enum OrCondition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A list of conditions which would be applied together with an AND condition.
        case andConditions([TagCondition])
        /// A leaf node condition which can be used to specify a tag condition.
        case tagCondition(TagCondition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .andConditions:
                let value = try container.decode([TagCondition].self, forKey: .andConditions)
                self = .andConditions(value)
            case .tagCondition:
                let value = try container.decode(TagCondition.self, forKey: .tagCondition)
                self = .tagCondition(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andConditions(let value):
                try container.encode(value, forKey: .andConditions)
            case .tagCondition(let value):
                try container.encode(value, forKey: .tagCondition)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andConditions(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andConditions[]")
                }
            case .tagCondition(let value):
                try value.validate(name: "\(name).tagCondition")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "andConditions"
            case tagCondition = "tagCondition"
        }
    }

    public enum QueryInputData: AWSEncodableShape, Sendable {
        /// Input information for the intent.
        case intentInputData(IntentInputData)
        /// Input information for the query.
        case queryTextInputData(QueryTextInputData)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .intentInputData(let value):
                try container.encode(value, forKey: .intentInputData)
            case .queryTextInputData(let value):
                try container.encode(value, forKey: .queryTextInputData)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .intentInputData(let value):
                try value.validate(name: "\(name).intentInputData")
            case .queryTextInputData(let value):
                try value.validate(name: "\(name).queryTextInputData")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case intentInputData = "intentInputData"
            case queryTextInputData = "queryTextInputData"
        }
    }

    public enum SourceConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appIntegrations(AppIntegrationsConfiguration)
        /// Source configuration for managed resources.
        case managedSourceConfiguration(ManagedSourceConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .appIntegrations:
                let value = try container.decode(AppIntegrationsConfiguration.self, forKey: .appIntegrations)
                self = .appIntegrations(value)
            case .managedSourceConfiguration:
                let value = try container.decode(ManagedSourceConfiguration.self, forKey: .managedSourceConfiguration)
                self = .managedSourceConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .appIntegrations(let value):
                try container.encode(value, forKey: .appIntegrations)
            case .managedSourceConfiguration(let value):
                try container.encode(value, forKey: .managedSourceConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .appIntegrations(let value):
                try value.validate(name: "\(name).appIntegrations")
            case .managedSourceConfiguration(let value):
                try value.validate(name: "\(name).managedSourceConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrations = "appIntegrations"
            case managedSourceConfiguration = "managedSourceConfiguration"
        }
    }

    public enum TagFilter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A list of conditions which would be applied together with an AND condition.
        case andConditions([TagCondition])
        /// A list of conditions which would be applied together with an OR condition.
        case orConditions([OrCondition])
        /// A leaf node condition which can be used to specify a tag condition.
        case tagCondition(TagCondition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .andConditions:
                let value = try container.decode([TagCondition].self, forKey: .andConditions)
                self = .andConditions(value)
            case .orConditions:
                let value = try container.decode([OrCondition].self, forKey: .orConditions)
                self = .orConditions(value)
            case .tagCondition:
                let value = try container.decode(TagCondition.self, forKey: .tagCondition)
                self = .tagCondition(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andConditions(let value):
                try container.encode(value, forKey: .andConditions)
            case .orConditions(let value):
                try container.encode(value, forKey: .orConditions)
            case .tagCondition(let value):
                try container.encode(value, forKey: .tagCondition)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andConditions(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andConditions[]")
                }
            case .orConditions(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orConditions[]")
                }
            case .tagCondition(let value):
                try value.validate(name: "\(name).tagCondition")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "andConditions"
            case orConditions = "orConditions"
            case tagCondition = "tagCondition"
        }
    }

    // MARK: Shapes

    public struct AIAgentConfigurationData: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the AI Agent to be configured.
        public let aiAgentId: String

        @inlinable
        public init(aiAgentId: String) {
            self.aiAgentId = aiAgentId
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentId = "aiAgentId"
        }
    }

    public struct AIAgentData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI agent.
        public let aiAgentArn: String
        /// The identifier of the AI Agent.
        public let aiAgentId: String
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// Configuration for the AI Agent.
        public let configuration: AIAgentConfiguration
        /// The description of the AI Agent.
        public let description: String?
        /// The time the AI Agent was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Agent.
        public let name: String
        /// Specifies the origin of the AI Agent. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?
        /// The status of the AI Agent.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the AI Agent.
        public let type: AIAgentType
        /// The visibility status of the AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiAgentArn: String, aiAgentId: String, assistantArn: String, assistantId: String, configuration: AIAgentConfiguration, description: String? = nil, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, type: AIAgentType, visibilityStatus: VisibilityStatus) {
            self.aiAgentArn = aiAgentArn
            self.aiAgentId = aiAgentId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.configuration = configuration
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentArn = "aiAgentArn"
            case aiAgentId = "aiAgentId"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case configuration = "configuration"
            case description = "description"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIAgentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI agent.
        public let aiAgentArn: String
        /// The identifier of the AI Agent.
        public let aiAgentId: String
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The configuration for the AI Agent.
        public let configuration: AIAgentConfiguration?
        /// The description of the AI Agent.
        public let description: String?
        /// The time the AI Agent was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Agent.
        public let name: String
        /// The origin of the AI Agent. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?
        /// The status of the AI Agent.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the AI Agent.
        public let type: AIAgentType
        /// The visibility status of the AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiAgentArn: String, aiAgentId: String, assistantArn: String, assistantId: String, configuration: AIAgentConfiguration? = nil, description: String? = nil, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, type: AIAgentType, visibilityStatus: VisibilityStatus) {
            self.aiAgentArn = aiAgentArn
            self.aiAgentId = aiAgentId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.configuration = configuration
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentArn = "aiAgentArn"
            case aiAgentId = "aiAgentId"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case configuration = "configuration"
            case description = "description"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIAgentVersionSummary: AWSDecodableShape {
        /// The data for the summary of the AI Agent version.
        public let aiAgentSummary: AIAgentSummary?
        /// The version number for this AI Agent version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiAgentSummary: AIAgentSummary? = nil, versionNumber: Int64? = nil) {
            self.aiAgentSummary = aiAgentSummary
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentSummary = "aiAgentSummary"
            case versionNumber = "versionNumber"
        }
    }

    public struct AIGuardrailContentPolicyConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public let filtersConfig: [GuardrailContentFilterConfig]

        @inlinable
        public init(filtersConfig: [GuardrailContentFilterConfig]) {
            self.filtersConfig = filtersConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.filtersConfig, name: "filtersConfig", parent: name, max: 6)
            try self.validate(self.filtersConfig, name: "filtersConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filtersConfig = "filtersConfig"
        }
    }

    public struct AIGuardrailContextualGroundingPolicyConfig: AWSEncodableShape & AWSDecodableShape {
        /// The filter configuration details for the AI Guardrails contextual grounding policy.
        public let filtersConfig: [GuardrailContextualGroundingFilterConfig]

        @inlinable
        public init(filtersConfig: [GuardrailContextualGroundingFilterConfig]) {
            self.filtersConfig = filtersConfig
        }

        public func validate(name: String) throws {
            try self.filtersConfig.forEach {
                try $0.validate(name: "\(name).filtersConfig[]")
            }
            try self.validate(self.filtersConfig, name: "filtersConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filtersConfig = "filtersConfig"
        }
    }

    public struct AIGuardrailData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI Guardrail.
        public let aiGuardrailArn: String
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        public let aiGuardrailId: String
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The message to return when the AI Guardrail blocks a prompt.
        public let blockedInputMessaging: String
        /// The message to return when the AI Guardrail blocks a model response.
        public let blockedOutputsMessaging: String
        /// Contains details about how to handle harmful content.
        public let contentPolicyConfig: AIGuardrailContentPolicyConfig?
        /// The policy configuration details for the AI Guardrail's contextual grounding policy.
        public let contextualGroundingPolicyConfig: AIGuardrailContextualGroundingPolicyConfig?
        /// A description of the AI Guardrail.
        public let description: String?
        /// The time the AI Guardrail was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Guardrail.
        public let name: String
        /// Contains details about PII entities and regular expressions to configure for the AI Guardrail.
        public let sensitiveInformationPolicyConfig: AIGuardrailSensitiveInformationPolicyConfig?
        /// The status of the AI Guardrail.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about topics that the AI Guardrail should identify and deny.
        public let topicPolicyConfig: AIGuardrailTopicPolicyConfig?
        /// The visibility status of the AI Guardrail.
        public let visibilityStatus: VisibilityStatus
        /// Contains details about the word policy to configured for the AI Guardrail.
        public let wordPolicyConfig: AIGuardrailWordPolicyConfig?

        @inlinable
        public init(aiGuardrailArn: String, aiGuardrailId: String, assistantArn: String, assistantId: String, blockedInputMessaging: String, blockedOutputsMessaging: String, contentPolicyConfig: AIGuardrailContentPolicyConfig? = nil, contextualGroundingPolicyConfig: AIGuardrailContextualGroundingPolicyConfig? = nil, description: String? = nil, modifiedTime: Date? = nil, name: String, sensitiveInformationPolicyConfig: AIGuardrailSensitiveInformationPolicyConfig? = nil, status: Status? = nil, tags: [String: String]? = nil, topicPolicyConfig: AIGuardrailTopicPolicyConfig? = nil, visibilityStatus: VisibilityStatus, wordPolicyConfig: AIGuardrailWordPolicyConfig? = nil) {
            self.aiGuardrailArn = aiGuardrailArn
            self.aiGuardrailId = aiGuardrailId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.contentPolicyConfig = contentPolicyConfig
            self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
            self.status = status
            self.tags = tags
            self.topicPolicyConfig = topicPolicyConfig
            self.visibilityStatus = visibilityStatus
            self.wordPolicyConfig = wordPolicyConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrailArn = "aiGuardrailArn"
            case aiGuardrailId = "aiGuardrailId"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case blockedInputMessaging = "blockedInputMessaging"
            case blockedOutputsMessaging = "blockedOutputsMessaging"
            case contentPolicyConfig = "contentPolicyConfig"
            case contextualGroundingPolicyConfig = "contextualGroundingPolicyConfig"
            case description = "description"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case sensitiveInformationPolicyConfig = "sensitiveInformationPolicyConfig"
            case status = "status"
            case tags = "tags"
            case topicPolicyConfig = "topicPolicyConfig"
            case visibilityStatus = "visibilityStatus"
            case wordPolicyConfig = "wordPolicyConfig"
        }
    }

    public struct AIGuardrailSensitiveInformationPolicyConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of PII entities to configure to the AI Guardrail.
        public let piiEntitiesConfig: [GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the AI Guardrail.
        public let regexesConfig: [GuardrailRegexConfig]?

        @inlinable
        public init(piiEntitiesConfig: [GuardrailPiiEntityConfig]? = nil, regexesConfig: [GuardrailRegexConfig]? = nil) {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.piiEntitiesConfig, name: "piiEntitiesConfig", parent: name, min: 1)
            try self.regexesConfig?.forEach {
                try $0.validate(name: "\(name).regexesConfig[]")
            }
            try self.validate(self.regexesConfig, name: "regexesConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntitiesConfig = "piiEntitiesConfig"
            case regexesConfig = "regexesConfig"
        }
    }

    public struct AIGuardrailSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI Guardrail.
        public let aiGuardrailArn: String
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        public let aiGuardrailId: String
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A description of the AI Guardrail.
        public let description: String?
        /// The time the AI Guardrail was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Guardrail.
        public let name: String
        /// The status of the AI Guardrail.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The visibility status of the AI Guardrail.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiGuardrailArn: String, aiGuardrailId: String, assistantArn: String, assistantId: String, description: String? = nil, modifiedTime: Date? = nil, name: String, status: Status? = nil, tags: [String: String]? = nil, visibilityStatus: VisibilityStatus) {
            self.aiGuardrailArn = aiGuardrailArn
            self.aiGuardrailId = aiGuardrailId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.status = status
            self.tags = tags
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrailArn = "aiGuardrailArn"
            case aiGuardrailId = "aiGuardrailId"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case status = "status"
            case tags = "tags"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIGuardrailTopicPolicyConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of policies related to topics that the AI Guardrail should deny.
        public let topicsConfig: [GuardrailTopicConfig]

        @inlinable
        public init(topicsConfig: [GuardrailTopicConfig]) {
            self.topicsConfig = topicsConfig
        }

        public func validate(name: String) throws {
            try self.topicsConfig.forEach {
                try $0.validate(name: "\(name).topicsConfig[]")
            }
            try self.validate(self.topicsConfig, name: "topicsConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case topicsConfig = "topicsConfig"
        }
    }

    public struct AIGuardrailVersionSummary: AWSDecodableShape {
        /// The data for the summary of the AI Guardrail version.
        public let aiGuardrailSummary: AIGuardrailSummary?
        /// The version number for this AI Guardrail version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiGuardrailSummary: AIGuardrailSummary? = nil, versionNumber: Int64? = nil) {
            self.aiGuardrailSummary = aiGuardrailSummary
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrailSummary = "aiGuardrailSummary"
            case versionNumber = "versionNumber"
        }
    }

    public struct AIGuardrailWordPolicyConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of managed words to configure for the AI Guardrail.
        public let managedWordListsConfig: [GuardrailManagedWordsConfig]?
        /// A list of words to configure for the AI Guardrail.
        public let wordsConfig: [GuardrailWordConfig]?

        @inlinable
        public init(managedWordListsConfig: [GuardrailManagedWordsConfig]? = nil, wordsConfig: [GuardrailWordConfig]? = nil) {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }

        public func validate(name: String) throws {
            try self.wordsConfig?.forEach {
                try $0.validate(name: "\(name).wordsConfig[]")
            }
            try self.validate(self.wordsConfig, name: "wordsConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case managedWordListsConfig = "managedWordListsConfig"
            case wordsConfig = "wordsConfig"
        }
    }

    public struct AIPromptData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI Prompt.
        public let aiPromptArn: String
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The API format used for this AI Prompt.
        public let apiFormat: AIPromptAPIFormat
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The description of the AI Prompt.
        public let description: String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: anthropic.claude-3-haiku-20240307-v1:0.
        public let modelId: String
        /// The time the AI Prompt was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Prompt
        public let name: String
        /// The origin of the AI Prompt. SYSTEM for a default AI Prompt created by Q in Connect or CUSTOMER for an AI Prompt created by calling AI Prompt creation APIs.
        public let origin: Origin?
        /// The status of the AI Prompt.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The configuration of the prompt template for this AI Prompt.
        public let templateConfiguration: AIPromptTemplateConfiguration
        /// The type of the prompt template for this AI Prompt.
        public let templateType: AIPromptTemplateType
        /// The type of this AI Prompt.
        public let type: AIPromptType
        /// The visibility status of the AI Prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiPromptArn: String, aiPromptId: String, apiFormat: AIPromptAPIFormat, assistantArn: String, assistantId: String, description: String? = nil, modelId: String, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, templateConfiguration: AIPromptTemplateConfiguration, templateType: AIPromptTemplateType, type: AIPromptType, visibilityStatus: VisibilityStatus) {
            self.aiPromptArn = aiPromptArn
            self.aiPromptId = aiPromptId
            self.apiFormat = apiFormat
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modelId = modelId
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptArn = "aiPromptArn"
            case aiPromptId = "aiPromptId"
            case apiFormat = "apiFormat"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case modelId = "modelId"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIPromptSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AI Prompt.
        public let aiPromptArn: String
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The API format used for this AI Prompt.
        public let apiFormat: AIPromptAPIFormat
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The description of the AI Prompt.
        public let description: String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: anthropic.claude-3-haiku-20240307-v1:0.
        public let modelId: String
        /// The time the AI Prompt was last modified.
        public let modifiedTime: Date?
        /// The name of the AI Prompt.
        public let name: String
        /// The origin of the AI Prompt. SYSTEM for a default AI Prompt created by Q in Connect or CUSTOMER for an AI Prompt created by calling AI Prompt creation APIs.
        public let origin: Origin?
        /// The status of the AI Prompt.
        public let status: Status?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the prompt template for this AI Prompt.
        public let templateType: AIPromptTemplateType
        /// The type of this AI Prompt.
        public let type: AIPromptType
        /// The visibility status of the AI Prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiPromptArn: String, aiPromptId: String, apiFormat: AIPromptAPIFormat, assistantArn: String, assistantId: String, description: String? = nil, modelId: String, modifiedTime: Date? = nil, name: String, origin: Origin? = nil, status: Status? = nil, tags: [String: String]? = nil, templateType: AIPromptTemplateType, type: AIPromptType, visibilityStatus: VisibilityStatus) {
            self.aiPromptArn = aiPromptArn
            self.aiPromptId = aiPromptId
            self.apiFormat = apiFormat
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modelId = modelId
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptArn = "aiPromptArn"
            case aiPromptId = "aiPromptId"
            case apiFormat = "apiFormat"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case modelId = "modelId"
            case modifiedTime = "modifiedTime"
            case name = "name"
            case origin = "origin"
            case status = "status"
            case tags = "tags"
            case templateType = "templateType"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct AIPromptVersionSummary: AWSDecodableShape {
        /// The date for the summary of the AI Prompt version.
        public let aiPromptSummary: AIPromptSummary?
        /// The version number for this AI Prompt version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiPromptSummary: AIPromptSummary? = nil, versionNumber: Int64? = nil) {
            self.aiPromptSummary = aiPromptSummary
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptSummary = "aiPromptSummary"
            case versionNumber = "versionNumber"
        }
    }

    public struct ActivateMessageTemplateRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String
        /// The version number of the message template version to activate.
        public let versionNumber: Int64

        @inlinable
        public init(knowledgeBaseId: String, messageTemplateId: String, versionNumber: Int64) {
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
            try container.encode(self.versionNumber, forKey: .versionNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case versionNumber = "versionNumber"
        }
    }

    public struct ActivateMessageTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The version number of the message template version that is activated.
        public let versionNumber: Int64

        @inlinable
        public init(messageTemplateArn: String, messageTemplateId: String, versionNumber: Int64) {
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateId = "messageTemplateId"
            case versionNumber = "versionNumber"
        }
    }

    public struct AgentAttributes: AWSEncodableShape & AWSDecodableShape {
        /// The agents first name as entered in their Amazon Connect user account.
        public let firstName: String?
        /// The agents last name as entered in their Amazon Connect user account.
        public let lastName: String?

        @inlinable
        public init(firstName: String? = nil, lastName: String? = nil) {
            self.firstName = firstName
            self.lastName = lastName
        }

        public func validate(name: String) throws {
            try self.validate(self.firstName, name: "firstName", parent: name, max: 32767)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 32767)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case firstName = "firstName"
            case lastName = "lastName"
        }
    }

    public struct AmazonConnectGuideAssociationData: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Connect flow. Step-by-step guides are a type of flow.
        public let flowId: String?

        @inlinable
        public init(flowId: String? = nil) {
            self.flowId = flowId
        }

        public func validate(name: String) throws {
            try self.validate(self.flowId, name: "flowId", parent: name, max: 2048)
            try self.validate(self.flowId, name: "flowId", parent: name, min: 1)
            try self.validate(self.flowId, name: "flowId", parent: name, pattern: "^arn:[a-z-]+?:[a-z-]+?:[a-z0-9-]*?:([0-9]{12})?:[a-zA-Z0-9-:/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "flowId"
        }
    }

    public struct AnswerRecommendationAIAgentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The AI Guardrail identifier for the Answer Generation Guardrail used by the ANSWER_RECOMMENDATION AI Agent.
        public let answerGenerationAIGuardrailId: String?
        /// The AI Prompt identifier for the Answer Generation prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public let answerGenerationAIPromptId: String?
        /// The association configurations for overriding behavior on this AI Agent.
        public let associationConfigurations: [AssociationConfiguration]?
        /// The AI Prompt identifier for the Intent Labeling prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public let intentLabelingGenerationAIPromptId: String?
        /// The locale to which specifies the language and region settings that determine the response language for QueryAssistant.  Changing this locale to anything other than en_US, en_GB, or en_AU will turn off recommendations triggered by contact transcripts for agent assistance, as this feature is not supported in multiple languages.
        public let locale: String?
        /// The AI Prompt identifier for the Query Reformulation prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public let queryReformulationAIPromptId: String?

        @inlinable
        public init(answerGenerationAIGuardrailId: String? = nil, answerGenerationAIPromptId: String? = nil, associationConfigurations: [AssociationConfiguration]? = nil, intentLabelingGenerationAIPromptId: String? = nil, locale: String? = nil, queryReformulationAIPromptId: String? = nil) {
            self.answerGenerationAIGuardrailId = answerGenerationAIGuardrailId
            self.answerGenerationAIPromptId = answerGenerationAIPromptId
            self.associationConfigurations = associationConfigurations
            self.intentLabelingGenerationAIPromptId = intentLabelingGenerationAIPromptId
            self.locale = locale
            self.queryReformulationAIPromptId = queryReformulationAIPromptId
        }

        public func validate(name: String) throws {
            try self.validate(self.answerGenerationAIGuardrailId, name: "answerGenerationAIGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.answerGenerationAIPromptId, name: "answerGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.associationConfigurations?.forEach {
                try $0.validate(name: "\(name).associationConfigurations[]")
            }
            try self.validate(self.intentLabelingGenerationAIPromptId, name: "intentLabelingGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.locale, name: "locale", parent: name, max: 4096)
            try self.validate(self.locale, name: "locale", parent: name, min: 1)
            try self.validate(self.queryReformulationAIPromptId, name: "queryReformulationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case answerGenerationAIGuardrailId = "answerGenerationAIGuardrailId"
            case answerGenerationAIPromptId = "answerGenerationAIPromptId"
            case associationConfigurations = "associationConfigurations"
            case intentLabelingGenerationAIPromptId = "intentLabelingGenerationAIPromptId"
            case locale = "locale"
            case queryReformulationAIPromptId = "queryReformulationAIPromptId"
        }
    }

    public struct AppIntegrationsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.   For  Salesforce, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted as source fields.    For  ServiceNow, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least number, short_description, sys_mod_count, workflow_state, and active as source fields.    For  Zendesk, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least id, title, updated_at, and draft as source fields.    For SharePoint, your AppIntegrations DataIntegration must have a FileConfiguration, including only file extensions that are among docx, pdf, html, htm, and txt.    For Amazon S3, the ObjectConfiguration and FileConfiguration of your AppIntegrations DataIntegration must be null. The SourceURI of your DataIntegration must use the following format: s3://your_s3_bucket_name.  The bucket policy of the corresponding S3 bucket must allow the Amazon Web Services principal app-integrations.amazonaws.com to perform s3:ListBucket, s3:GetObject, and s3:GetBucketLocation against the bucket.
        public let appIntegrationArn: String
        /// The fields from the source that are made available to your agents in Amazon Q in Connect. Optional if ObjectConfiguration is included in the provided DataIntegration.    For  Salesforce, you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.    For  ServiceNow, you must include at least number, short_description, sys_mod_count, workflow_state, and active.    For  Zendesk, you must include at least id, title, updated_at, and draft.    Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public let objectFields: [String]?

        @inlinable
        public init(appIntegrationArn: String, objectFields: [String]? = nil) {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }

        public func validate(name: String) throws {
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, max: 2048)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, min: 1)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, pattern: "^arn:[a-z-]+?:[a-z-]+?:[a-z0-9-]*?:([0-9]{12})?:[a-zA-Z0-9-:/]+$")
            try self.objectFields?.forEach {
                try validate($0, name: "objectFields[]", parent: name, max: 4096)
                try validate($0, name: "objectFields[]", parent: name, min: 1)
            }
            try self.validate(self.objectFields, name: "objectFields", parent: name, max: 100)
            try self.validate(self.objectFields, name: "objectFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrationArn = "appIntegrationArn"
            case objectFields = "objectFields"
        }
    }

    public struct AssistantAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// A union type that currently has a single argument, the knowledge base ID.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantAssociationArn = "assistantAssociationArn"
            case assistantAssociationId = "assistantAssociationId"
            case assistantId = "assistantId"
            case associationData = "associationData"
            case associationType = "associationType"
            case tags = "tags"
        }
    }

    public struct AssistantAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The association data.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantAssociationArn = "assistantAssociationArn"
            case assistantAssociationId = "assistantAssociationId"
            case assistantId = "assistantId"
            case associationData = "associationData"
            case associationType = "associationType"
            case tags = "tags"
        }
    }

    public struct AssistantCapabilityConfiguration: AWSDecodableShape {
        /// The type of Amazon Q in Connect assistant capability.
        public let type: AssistantCapabilityType?

        @inlinable
        public init(type: AssistantCapabilityType? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct AssistantData: AWSDecodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that is set on the Amazon Q in Connect Assistant.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The configuration information for the Amazon Q in Connect assistant capability.
        public let capabilityConfiguration: AssistantCapabilityConfiguration?
        /// The description.
        public let description: String?
        /// The configuration information for the Amazon Q in Connect assistant integration.
        public let integrationConfiguration: AssistantIntegrationConfiguration?
        /// The name.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantArn: String, assistantId: String, capabilityConfiguration: AssistantCapabilityConfiguration? = nil, description: String? = nil, integrationConfiguration: AssistantIntegrationConfiguration? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case capabilityConfiguration = "capabilityConfiguration"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct AssistantIntegrationConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public let topicIntegrationArn: String?

        @inlinable
        public init(topicIntegrationArn: String? = nil) {
            self.topicIntegrationArn = topicIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicIntegrationArn = "topicIntegrationArn"
        }
    }

    public struct AssistantSummary: AWSDecodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that is set on the Amazon Q in Connect Assistant.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The configuration information for the Amazon Q in Connect assistant capability.
        public let capabilityConfiguration: AssistantCapabilityConfiguration?
        /// The description of the assistant.
        public let description: String?
        /// The configuration information for the Amazon Q in Connect assistant integration.
        public let integrationConfiguration: AssistantIntegrationConfiguration?
        /// The name of the assistant.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the assistant.
        public let type: AssistantType

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantArn: String, assistantId: String, capabilityConfiguration: AssistantCapabilityConfiguration? = nil, description: String? = nil, integrationConfiguration: AssistantIntegrationConfiguration? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case capabilityConfiguration = "capabilityConfiguration"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct AssociationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data of the configuration for an Amazon Q in Connect Assistant Association.
        public let associationConfigurationData: AssociationConfigurationData?
        /// The identifier of the association for this Association Configuration.
        public let associationId: String?
        /// The type of the association for this Association Configuration.
        public let associationType: AIAgentAssociationConfigurationType?

        @inlinable
        public init(associationConfigurationData: AssociationConfigurationData? = nil, associationId: String? = nil, associationType: AIAgentAssociationConfigurationType? = nil) {
            self.associationConfigurationData = associationConfigurationData
            self.associationId = associationId
            self.associationType = associationType
        }

        public func validate(name: String) throws {
            try self.associationConfigurationData?.validate(name: "\(name).associationConfigurationData")
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationConfigurationData = "associationConfigurationData"
            case associationId = "associationId"
            case associationType = "associationType"
        }
    }

    public struct BedrockFoundationModelConfigurationForParsing: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the foundation model.
        public let modelArn: String
        /// Instructions for interpreting the contents of a document.
        public let parsingPrompt: ParsingPrompt?

        @inlinable
        public init(modelArn: String, parsingPrompt: ParsingPrompt? = nil) {
            self.modelArn = modelArn
            self.parsingPrompt = parsingPrompt
        }

        public func validate(name: String) throws {
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/anthropic.claude-3-haiku-20240307-v1:0$")
            try self.parsingPrompt?.validate(name: "\(name).parsingPrompt")
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "modelArn"
            case parsingPrompt = "parsingPrompt"
        }
    }

    public struct ChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
        public let chunkingStrategy: ChunkingStrategy
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public let fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration?
        /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        public let hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration?
        /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into smaller documents based on groups of similar content derived from the text with natural language processing.
        public let semanticChunkingConfiguration: SemanticChunkingConfiguration?

        @inlinable
        public init(chunkingStrategy: ChunkingStrategy, fixedSizeChunkingConfiguration: FixedSizeChunkingConfiguration? = nil, hierarchicalChunkingConfiguration: HierarchicalChunkingConfiguration? = nil, semanticChunkingConfiguration: SemanticChunkingConfiguration? = nil) {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
            self.hierarchicalChunkingConfiguration = hierarchicalChunkingConfiguration
            self.semanticChunkingConfiguration = semanticChunkingConfiguration
        }

        public func validate(name: String) throws {
            try self.hierarchicalChunkingConfiguration?.validate(name: "\(name).hierarchicalChunkingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingStrategy = "chunkingStrategy"
            case fixedSizeChunkingConfiguration = "fixedSizeChunkingConfiguration"
            case hierarchicalChunkingConfiguration = "hierarchicalChunkingConfiguration"
            case semanticChunkingConfiguration = "semanticChunkingConfiguration"
        }
    }

    public struct CitationSpan: AWSDecodableShape {
        /// Where the text with a citation starts in the generated output.
        public let beginOffsetInclusive: Int?
        /// Where the text with a citation ends in the generated output.
        public let endOffsetExclusive: Int?

        @inlinable
        public init(beginOffsetInclusive: Int? = nil, endOffsetExclusive: Int? = nil) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetInclusive = "beginOffsetInclusive"
            case endOffsetExclusive = "endOffsetExclusive"
        }
    }

    public struct ConnectConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?

        @inlinable
        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "instanceId"
        }
    }

    public struct ContentAssociationData: AWSDecodableShape {
        /// The content association.
        public let associationData: ContentAssociationContents
        /// The type of association.
        public let associationType: ContentAssociationType
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The Amazon Resource Name (ARN) of the content association.
        public let contentAssociationArn: String
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(associationData: ContentAssociationContents, associationType: ContentAssociationType, contentArn: String, contentAssociationArn: String, contentAssociationId: String, contentId: String, knowledgeBaseArn: String, knowledgeBaseId: String, tags: [String: String]? = nil) {
            self.associationData = associationData
            self.associationType = associationType
            self.contentArn = contentArn
            self.contentAssociationArn = contentAssociationArn
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associationData = "associationData"
            case associationType = "associationType"
            case contentArn = "contentArn"
            case contentAssociationArn = "contentAssociationArn"
            case contentAssociationId = "contentAssociationId"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case tags = "tags"
        }
    }

    public struct ContentAssociationSummary: AWSDecodableShape {
        /// The content association.
        public let associationData: ContentAssociationContents
        /// The type of association.
        public let associationType: ContentAssociationType
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The Amazon Resource Name (ARN) of the content association.
        public let contentAssociationArn: String
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(associationData: ContentAssociationContents, associationType: ContentAssociationType, contentArn: String, contentAssociationArn: String, contentAssociationId: String, contentId: String, knowledgeBaseArn: String, knowledgeBaseId: String, tags: [String: String]? = nil) {
            self.associationData = associationData
            self.associationType = associationType
            self.contentArn = contentArn
            self.contentAssociationArn = contentAssociationArn
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associationData = "associationData"
            case associationType = "associationType"
            case contentArn = "contentArn"
            case contentAssociationArn = "contentAssociationArn"
            case contentAssociationId = "contentAssociationId"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case tags = "tags"
        }
    }

    public struct ContentData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The URI of the content.
        public let linkOutUri: String?
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the content revision.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String
        /// The URL of the content.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        @inlinable
        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, linkOutUri: String? = nil, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String, url: String, urlExpiry: Date) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case contentType = "contentType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case linkOutUri = "linkOutUri"
            case metadata = "metadata"
            case name = "name"
            case revisionId = "revisionId"
            case status = "status"
            case tags = "tags"
            case title = "title"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct ContentDataDetails: AWSDecodableShape {
        /// Details about the content ranking data.
        public let rankingData: RankingData
        /// Details about the content text data.
        public let textData: TextData

        @inlinable
        public init(rankingData: RankingData, textData: TextData) {
            self.rankingData = rankingData
            self.textData = textData
        }

        private enum CodingKeys: String, CodingKey {
            case rankingData = "rankingData"
            case textData = "textData"
        }
    }

    public struct ContentReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String?
        /// The identifier of the content.
        public let contentId: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String?
        /// The type of reference content.
        public let referenceType: ReferenceType?
        /// The web URL of the source content.
        public let sourceURL: String?

        @inlinable
        public init(contentArn: String? = nil, contentId: String? = nil, knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil, referenceType: ReferenceType? = nil, sourceURL: String? = nil) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.referenceType = referenceType
            self.sourceURL = sourceURL
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case referenceType = "referenceType"
            case sourceURL = "sourceURL"
        }
    }

    public struct ContentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the revision of the content.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String

        @inlinable
        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case contentType = "contentType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case metadata = "metadata"
            case name = "name"
            case revisionId = "revisionId"
            case status = "status"
            case tags = "tags"
            case title = "title"
        }
    }

    public struct ConversationContext: AWSEncodableShape {
        /// The self service conversation history before the Amazon Q in Connect session.
        public let selfServiceConversationHistory: [SelfServiceConversationHistory]

        @inlinable
        public init(selfServiceConversationHistory: [SelfServiceConversationHistory]) {
            self.selfServiceConversationHistory = selfServiceConversationHistory
        }

        public func validate(name: String) throws {
            try self.validate(self.selfServiceConversationHistory, name: "selfServiceConversationHistory", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case selfServiceConversationHistory = "selfServiceConversationHistory"
        }
    }

    public struct ConversationState: AWSDecodableShape {
        /// The reason of the conversation state.
        public let reason: ConversationStatusReason?
        /// The status of the conversation state.
        public let status: ConversationStatus

        @inlinable
        public init(reason: ConversationStatusReason? = nil, status: ConversationStatus) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct CreateAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The configuration of the AI Agent.
        public let configuration: AIAgentConfiguration
        /// The description of the AI Agent.
        public let description: String?
        /// The name of the AI Agent.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the AI Agent.
        public let type: AIAgentType
        /// The visibility status of the AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(assistantId: String, clientToken: String? = CreateAIAgentRequest.idempotencyToken(), configuration: AIAgentConfiguration, description: String? = nil, name: String, tags: [String: String]? = nil, type: AIAgentType, visibilityStatus: VisibilityStatus) {
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.name = name
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct CreateAIAgentResponse: AWSDecodableShape {
        /// The data of the created AI Agent.
        public let aiAgent: AIAgentData?

        @inlinable
        public init(aiAgent: AIAgentData? = nil) {
            self.aiAgent = aiAgent
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
        }
    }

    public struct CreateAIAgentVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The modification time of the AI Agent should be tracked for version creation. This field should be specified to avoid version creation when simultaneous update to the underlying AI Agent are possible. The value should be the modifiedTime returned from the request to create or update an AI Agent so that version creation can fail if an update to the AI Agent post the specified modification time has been made.
        public let modifiedTime: Date?

        @inlinable
        public init(aiAgentId: String, assistantId: String, clientToken: String? = CreateAIAgentVersionRequest.idempotencyToken(), modifiedTime: Date? = nil) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.modifiedTime = modifiedTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.modifiedTime, forKey: .modifiedTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case modifiedTime = "modifiedTime"
        }
    }

    public struct CreateAIAgentVersionResponse: AWSDecodableShape {
        /// The data of the AI Agent version.
        public let aiAgent: AIAgentData?
        /// The version number of the AI Agent version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiAgent: AIAgentData? = nil, versionNumber: Int64? = nil) {
            self.aiAgent = aiAgent
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
            case versionNumber = "versionNumber"
        }
    }

    public struct CreateAIGuardrailRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The message to return when the AI Guardrail blocks a prompt.
        public let blockedInputMessaging: String
        /// The message to return when the AI Guardrail blocks a model response.
        public let blockedOutputsMessaging: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The content filter policies to configure for the AI Guardrail.
        public let contentPolicyConfig: AIGuardrailContentPolicyConfig?
        /// The contextual grounding policy configuration used to create an AI Guardrail.
        public let contextualGroundingPolicyConfig: AIGuardrailContextualGroundingPolicyConfig?
        /// A description of the AI Guardrail.
        public let description: String?
        /// The name of the AI Guardrail.
        public let name: String
        /// The sensitive information policy to configure for the AI Guardrail.
        public let sensitiveInformationPolicyConfig: AIGuardrailSensitiveInformationPolicyConfig?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The topic policies to configure for the AI Guardrail.
        public let topicPolicyConfig: AIGuardrailTopicPolicyConfig?
        /// The visibility status of the AI Guardrail.
        public let visibilityStatus: VisibilityStatus
        /// The word policy you configure for the AI Guardrail.
        public let wordPolicyConfig: AIGuardrailWordPolicyConfig?

        @inlinable
        public init(assistantId: String, blockedInputMessaging: String, blockedOutputsMessaging: String, clientToken: String? = CreateAIGuardrailRequest.idempotencyToken(), contentPolicyConfig: AIGuardrailContentPolicyConfig? = nil, contextualGroundingPolicyConfig: AIGuardrailContextualGroundingPolicyConfig? = nil, description: String? = nil, name: String, sensitiveInformationPolicyConfig: AIGuardrailSensitiveInformationPolicyConfig? = nil, tags: [String: String]? = nil, topicPolicyConfig: AIGuardrailTopicPolicyConfig? = nil, visibilityStatus: VisibilityStatus, wordPolicyConfig: AIGuardrailWordPolicyConfig? = nil) {
            self.assistantId = assistantId
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.clientToken = clientToken
            self.contentPolicyConfig = contentPolicyConfig
            self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
            self.description = description
            self.name = name
            self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
            self.tags = tags
            self.topicPolicyConfig = topicPolicyConfig
            self.visibilityStatus = visibilityStatus
            self.wordPolicyConfig = wordPolicyConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.blockedInputMessaging, forKey: .blockedInputMessaging)
            try container.encode(self.blockedOutputsMessaging, forKey: .blockedOutputsMessaging)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.contentPolicyConfig, forKey: .contentPolicyConfig)
            try container.encodeIfPresent(self.contextualGroundingPolicyConfig, forKey: .contextualGroundingPolicyConfig)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.sensitiveInformationPolicyConfig, forKey: .sensitiveInformationPolicyConfig)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.topicPolicyConfig, forKey: .topicPolicyConfig)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
            try container.encodeIfPresent(self.wordPolicyConfig, forKey: .wordPolicyConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, max: 500)
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, min: 1)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, max: 500)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.contentPolicyConfig?.validate(name: "\(name).contentPolicyConfig")
            try self.contextualGroundingPolicyConfig?.validate(name: "\(name).contextualGroundingPolicyConfig")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.sensitiveInformationPolicyConfig?.validate(name: "\(name).sensitiveInformationPolicyConfig")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.topicPolicyConfig?.validate(name: "\(name).topicPolicyConfig")
            try self.wordPolicyConfig?.validate(name: "\(name).wordPolicyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case blockedInputMessaging = "blockedInputMessaging"
            case blockedOutputsMessaging = "blockedOutputsMessaging"
            case clientToken = "clientToken"
            case contentPolicyConfig = "contentPolicyConfig"
            case contextualGroundingPolicyConfig = "contextualGroundingPolicyConfig"
            case description = "description"
            case name = "name"
            case sensitiveInformationPolicyConfig = "sensitiveInformationPolicyConfig"
            case tags = "tags"
            case topicPolicyConfig = "topicPolicyConfig"
            case visibilityStatus = "visibilityStatus"
            case wordPolicyConfig = "wordPolicyConfig"
        }
    }

    public struct CreateAIGuardrailResponse: AWSDecodableShape {
        /// The data of the AI Guardrail.
        public let aiGuardrail: AIGuardrailData?

        @inlinable
        public init(aiGuardrail: AIGuardrailData? = nil) {
            self.aiGuardrail = aiGuardrail
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrail = "aiGuardrail"
        }
    }

    public struct CreateAIGuardrailVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        public let aiGuardrailId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The time the AI Guardrail was last modified.
        public let modifiedTime: Date?

        @inlinable
        public init(aiGuardrailId: String, assistantId: String, clientToken: String? = CreateAIGuardrailVersionRequest.idempotencyToken(), modifiedTime: Date? = nil) {
            self.aiGuardrailId = aiGuardrailId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.modifiedTime = modifiedTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiGuardrailId, key: "aiGuardrailId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.modifiedTime, forKey: .modifiedTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiGuardrailId, name: "aiGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case modifiedTime = "modifiedTime"
        }
    }

    public struct CreateAIGuardrailVersionResponse: AWSDecodableShape {
        /// The data of the AI Guardrail version.
        public let aiGuardrail: AIGuardrailData?
        /// The version number of the AI Guardrail version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiGuardrail: AIGuardrailData? = nil, versionNumber: Int64? = nil) {
            self.aiGuardrail = aiGuardrail
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrail = "aiGuardrail"
            case versionNumber = "versionNumber"
        }
    }

    public struct CreateAIPromptRequest: AWSEncodableShape {
        /// The API Format of the AI Prompt.
        public let apiFormat: AIPromptAPIFormat
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The description of the AI Prompt.
        public let description: String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: anthropic.claude-3-haiku-20240307-v1:0
        public let modelId: String
        /// The name of the AI Prompt.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The configuration of the prompt template for this AI Prompt.
        public let templateConfiguration: AIPromptTemplateConfiguration
        /// The type of the prompt template for this AI Prompt.
        public let templateType: AIPromptTemplateType
        /// The type of this AI Prompt.
        public let type: AIPromptType
        /// The visibility status of the AI Prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(apiFormat: AIPromptAPIFormat, assistantId: String, clientToken: String? = CreateAIPromptRequest.idempotencyToken(), description: String? = nil, modelId: String, name: String, tags: [String: String]? = nil, templateConfiguration: AIPromptTemplateConfiguration, templateType: AIPromptTemplateType, type: AIPromptType, visibilityStatus: VisibilityStatus) {
            self.apiFormat = apiFormat
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.modelId = modelId
            self.name = name
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.apiFormat, forKey: .apiFormat)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.modelId, forKey: .modelId)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.templateConfiguration, forKey: .templateConfiguration)
            try container.encode(self.templateType, forKey: .templateType)
            try container.encode(self.type, forKey: .type)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.templateConfiguration.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case apiFormat = "apiFormat"
            case clientToken = "clientToken"
            case description = "description"
            case modelId = "modelId"
            case name = "name"
            case tags = "tags"
            case templateConfiguration = "templateConfiguration"
            case templateType = "templateType"
            case type = "type"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct CreateAIPromptResponse: AWSDecodableShape {
        /// The data of the AI Prompt.
        public let aiPrompt: AIPromptData?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil) {
            self.aiPrompt = aiPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
        }
    }

    public struct CreateAIPromptVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The time the AI Prompt was last modified.
        public let modifiedTime: Date?

        @inlinable
        public init(aiPromptId: String, assistantId: String, clientToken: String? = CreateAIPromptVersionRequest.idempotencyToken(), modifiedTime: Date? = nil) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.modifiedTime = modifiedTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.modifiedTime, forKey: .modifiedTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case modifiedTime = "modifiedTime"
        }
    }

    public struct CreateAIPromptVersionResponse: AWSDecodableShape {
        /// The data of the AI Prompt version.
        public let aiPrompt: AIPromptData?
        /// The version number of the AI Prompt version.
        public let versionNumber: Int64?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil, versionNumber: Int64? = nil) {
            self.aiPrompt = aiPrompt
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
            case versionNumber = "versionNumber"
        }
    }

    public struct CreateAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the associated resource.
        public let association: AssistantAssociationInputData
        /// The type of association.
        public let associationType: AssociationType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(assistantId: String, association: AssistantAssociationInputData, associationType: AssociationType, clientToken: String? = CreateAssistantAssociationRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assistantId = assistantId
            self.association = association
            self.associationType = associationType
            self.clientToken = clientToken
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.association, forKey: .association)
            try container.encode(self.associationType, forKey: .associationType)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.association.validate(name: "\(name).association")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case association = "association"
            case associationType = "associationType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        @inlinable
        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation = "assistantAssociation"
        }
    }

    public struct CreateAssistantRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the assistant.
        public let description: String?
        /// The name of the assistant.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  The customer managed key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        @inlinable
        public init(clientToken: String? = CreateAssistantRequest.idempotencyToken(), description: String? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, tags: [String: String]? = nil, type: AssistantType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        @inlinable
        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct CreateContentAssociationRequest: AWSEncodableShape {
        /// The identifier of the associated resource.
        public let association: ContentAssociationContents
        /// The type of association.
        public let associationType: ContentAssociationType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(association: ContentAssociationContents, associationType: ContentAssociationType, clientToken: String? = CreateContentAssociationRequest.idempotencyToken(), contentId: String, knowledgeBaseId: String, tags: [String: String]? = nil) {
            self.association = association
            self.associationType = associationType
            self.clientToken = clientToken
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.association, forKey: .association)
            try container.encode(self.associationType, forKey: .associationType)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.association.validate(name: "\(name).association")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case association = "association"
            case associationType = "associationType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateContentAssociationResponse: AWSDecodableShape {
        /// The association between Amazon Q in Connect content and another resource.
        public let contentAssociation: ContentAssociationData?

        @inlinable
        public init(contentAssociation: ContentAssociationData? = nil) {
            self.contentAssociation = contentAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case contentAssociation = "contentAssociation"
        }
    }

    public struct CreateContentRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the SearchContent API.
        public let name: String
        /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
        public let overrideLinkOutUri: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content. If not set, the title is equal to the name.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        @inlinable
        public init(clientToken: String? = CreateContentRequest.idempotencyToken(), knowledgeBaseId: String, metadata: [String: String]? = nil, name: String, overrideLinkOutUri: String? = nil, tags: [String: String]? = nil, title: String? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.overrideLinkOutUri = overrideLinkOutUri
            self.tags = tags
            self.title = title
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.overrideLinkOutUri, forKey: .overrideLinkOutUri)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encode(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case metadata = "metadata"
            case name = "name"
            case overrideLinkOutUri = "overrideLinkOutUri"
            case tags = "tags"
            case title = "title"
            case uploadId = "uploadId"
        }
    }

    public struct CreateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        @inlinable
        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The source of the knowledge base content. Only set this argument for EXTERNAL or Managed knowledge bases.
        public let sourceConfiguration: SourceConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about how to ingest the documents in a data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, tags: [String: String]? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.renderingConfiguration?.validate(name: "\(name).renderingConfiguration")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.vectorIngestionConfiguration?.validate(name: "\(name).vectorIngestionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case knowledgeBaseType = "knowledgeBaseType"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case tags = "tags"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        @inlinable
        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct CreateMessageTemplateAttachmentRequest: AWSEncodableShape {
        /// The body of the attachment file being uploaded. It should be encoded using base64 encoding.
        public let body: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The presentation information for the attachment file.
        public let contentDisposition: ContentDisposition
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String
        /// The name of the attachment file being uploaded. The name should include the file extension.
        public let name: String

        @inlinable
        public init(body: String, clientToken: String? = nil, contentDisposition: ContentDisposition, knowledgeBaseId: String, messageTemplateId: String, name: String) {
            self.body = body
            self.clientToken = clientToken
            self.contentDisposition = contentDisposition
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.body, forKey: .body)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.contentDisposition, forKey: .contentDisposition)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{M}\\p{N}_\\s&@()+,;=\\-]+\\.[A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case clientToken = "clientToken"
            case contentDisposition = "contentDisposition"
            case name = "name"
        }
    }

    public struct CreateMessageTemplateAttachmentResponse: AWSDecodableShape {
        /// The message template attachment.
        public let attachment: MessageTemplateAttachment?

        @inlinable
        public init(attachment: MessageTemplateAttachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "attachment"
        }
    }

    public struct CreateMessageTemplateRequest: AWSEncodableShape {
        /// The channel subtype this message template applies to.
        public let channelSubtype: ChannelSubtype
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The content of the message template.
        public let content: MessageTemplateContentProvider
        /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        public let defaultAttributes: MessageTemplateAttributes?
        /// The description of the message template.
        public let description: String?
        public let groupingConfiguration: GroupingConfiguration?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the message template.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channelSubtype: ChannelSubtype, clientToken: String? = CreateMessageTemplateRequest.idempotencyToken(), content: MessageTemplateContentProvider, defaultAttributes: MessageTemplateAttributes? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, knowledgeBaseId: String, language: String? = nil, name: String, tags: [String: String]? = nil) {
            self.channelSubtype = channelSubtype
            self.clientToken = clientToken
            self.content = content
            self.defaultAttributes = defaultAttributes
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.channelSubtype, forKey: .channelSubtype)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.defaultAttributes, forKey: .defaultAttributes)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.defaultAttributes?.validate(name: "\(name).defaultAttributes")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case channelSubtype = "channelSubtype"
            case clientToken = "clientToken"
            case content = "content"
            case defaultAttributes = "defaultAttributes"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case language = "language"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateMessageTemplateResponse: AWSDecodableShape {
        /// The message template.
        public let messageTemplate: MessageTemplateData?

        @inlinable
        public init(messageTemplate: MessageTemplateData? = nil) {
            self.messageTemplate = messageTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplate = "messageTemplate"
        }
    }

    public struct CreateMessageTemplateVersionRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The checksum value of the message template content that is referenced by the $LATEST qualifier. It can be returned in MessageTemplateData or ExtendedMessageTemplateData. Its calculated by content, language, defaultAttributes and Attachments of the message template. If not supplied, the message template version will be created based on the message template content that is referenced by the $LATEST qualifier by default.
        public let messageTemplateContentSha256: String?
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String

        @inlinable
        public init(knowledgeBaseId: String, messageTemplateContentSha256: String? = nil, messageTemplateId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateContentSha256 = messageTemplateContentSha256
            self.messageTemplateId = messageTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.messageTemplateContentSha256, forKey: .messageTemplateContentSha256)
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateContentSha256, name: "messageTemplateContentSha256", parent: name, max: 64)
            try self.validate(self.messageTemplateContentSha256, name: "messageTemplateContentSha256", parent: name, min: 1)
            try self.validate(self.messageTemplateContentSha256, name: "messageTemplateContentSha256", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplateContentSha256 = "messageTemplateContentSha256"
        }
    }

    public struct CreateMessageTemplateVersionResponse: AWSDecodableShape {
        /// The message template.
        public let messageTemplate: ExtendedMessageTemplateData?

        @inlinable
        public init(messageTemplate: ExtendedMessageTemplateData? = nil) {
            self.messageTemplate = messageTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplate = "messageTemplate"
        }
    }

    public struct CreateQuickResponseRequest: AWSEncodableShape {
        /// The Amazon Connect channels this quick response applies to.
        public let channels: [String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The content of the quick response.
        public let content: QuickResponseDataProvider
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for a quick response written in plain text.   Use application/x.quickresponse;format=markdown for a quick response written in richtext.
        public let contentType: String?
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the quick response.
        public let name: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channels: [String]? = nil, clientToken: String? = CreateQuickResponseRequest.idempotencyToken(), content: QuickResponseDataProvider, contentType: String? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseId: String, language: String? = nil, name: String, shortcutKey: String? = nil, tags: [String: String]? = nil) {
            self.channels = channels
            self.clientToken = clientToken
            self.content = content
            self.contentType = contentType
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.shortcutKey = shortcutKey
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.channels, forKey: .channels)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortcutKey, forKey: .shortcutKey)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.channels?.forEach {
                try validate($0, name: "channels[]", parent: name, max: 10)
                try validate($0, name: "channels[]", parent: name, min: 1)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(application/x\\.quickresponse;format=(plain|markdown))$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, max: 10)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case clientToken = "clientToken"
            case content = "content"
            case contentType = "contentType"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case language = "language"
            case name = "name"
            case shortcutKey = "shortcutKey"
            case tags = "tags"
        }
    }

    public struct CreateQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        @inlinable
        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct CreateSessionRequest: AWSEncodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name of the session.
        public let name: String
        /// An object that can be used to specify Tag conditions.
        public let tagFilter: TagFilter?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantId: String, clientToken: String? = CreateSessionRequest.idempotencyToken(), description: String? = nil, name: String, tagFilter: TagFilter? = nil, tags: [String: String]? = nil) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tagFilter = tagFilter
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.aiAgentConfiguration, forKey: .aiAgentConfiguration)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tagFilter, forKey: .tagFilter)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.aiAgentConfiguration?.forEach {
                try $0.value.validate(name: "\(name).aiAgentConfiguration[\"\($0.key)\"]")
            }
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tagFilter?.validate(name: "\(name).tagFilter")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tagFilter = "tagFilter"
            case tags = "tags"
        }
    }

    public struct CreateSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        @inlinable
        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct CustomerProfileAttributes: AWSEncodableShape & AWSDecodableShape {
        /// A unique account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customer's profile.
        public let additionalInformation: String?
        /// The first line of a customer address.
        public let address1: String?
        /// The second line of a customer address.
        public let address2: String?
        /// The third line of a customer address.
        public let address3: String?
        /// The fourth line of a customer address.
        public let address4: String?
        /// The first line of a customers billing address.
        public let billingAddress1: String?
        /// The second line of a customers billing address.
        public let billingAddress2: String?
        /// The third line of a customers billing address.
        public let billingAddress3: String?
        /// The fourth line of a customers billing address.
        public let billingAddress4: String?
        /// The city of a customers billing address.
        public let billingCity: String?
        /// The country of a customers billing address.
        public let billingCountry: String?
        /// The county of a customers billing address.
        public let billingCounty: String?
        /// The postal code of a customers billing address.
        public let billingPostalCode: String?
        /// The province of a customers billing address.
        public let billingProvince: String?
        /// The state of a customers billing address.
        public let billingState: String?
        /// The customer's birth date.
        public let birthDate: String?
        /// The customer's business email address.
        public let businessEmailAddress: String?
        /// The name of the customer's business.
        public let businessName: String?
        /// The customer's business phone number.
        public let businessPhoneNumber: String?
        /// The city in which a customer lives.
        public let city: String?
        /// The country in which a customer lives.
        public let country: String?
        /// The county in which a customer lives.
        public let county: String?
        /// The custom attributes in customer profile attributes.
        public let custom: [String: String]?
        /// The customer's email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customer's first name.
        public let firstName: String?
        /// The customer's gender.
        public let gender: String?
        /// The customer's mobile phone number.
        public let homePhoneNumber: String?
        /// The customer's last name.
        public let lastName: String?
        /// The first line of a customers mailing address.
        public let mailingAddress1: String?
        /// The second line of a customers mailing address.
        public let mailingAddress2: String?
        /// The third line of a customers mailing address.
        public let mailingAddress3: String?
        /// The fourth line of a customers mailing address.
        public let mailingAddress4: String?
        /// The city of a customers mailing address.
        public let mailingCity: String?
        /// The country of a customers mailing address.
        public let mailingCountry: String?
        /// The county of a customers mailing address.
        public let mailingCounty: String?
        /// The postal code of a customers mailing address.
        public let mailingPostalCode: String?
        /// The province of a customers mailing address.
        public let mailingProvince: String?
        /// The state of a customers mailing address.
        public let mailingState: String?
        /// The customer's middle name.
        public let middleName: String?
        /// The customer's mobile phone number.
        public let mobilePhoneNumber: String?
        /// The customer's party type.
        public let partyType: String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The postal code of a customer address.
        public let postalCode: String?
        /// The ARN of a customer profile.
        public let profileARN: String?
        /// The unique identifier of a customer profile.
        public let profileId: String?
        /// The province in which a customer lives.
        public let province: String?
        /// The first line of a customers shipping address.
        public let shippingAddress1: String?
        /// The second line of a customers shipping address.
        public let shippingAddress2: String?
        /// The third line of a customers shipping address.
        public let shippingAddress3: String?
        /// The fourth line of a customers shipping address.
        public let shippingAddress4: String?
        /// The city of a customers shipping address.
        public let shippingCity: String?
        /// The country of a customers shipping address.
        public let shippingCountry: String?
        /// The county of a customers shipping address.
        public let shippingCounty: String?
        /// The postal code of a customers shipping address.
        public let shippingPostalCode: String?
        /// The province of a customers shipping address.
        public let shippingProvince: String?
        /// The state of a customers shipping address.
        public let shippingState: String?
        /// The state in which a customer lives.
        public let state: String?

        @inlinable
        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address1: String? = nil, address2: String? = nil, address3: String? = nil, address4: String? = nil, billingAddress1: String? = nil, billingAddress2: String? = nil, billingAddress3: String? = nil, billingAddress4: String? = nil, billingCity: String? = nil, billingCountry: String? = nil, billingCounty: String? = nil, billingPostalCode: String? = nil, billingProvince: String? = nil, billingState: String? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, city: String? = nil, country: String? = nil, county: String? = nil, custom: [String: String]? = nil, emailAddress: String? = nil, firstName: String? = nil, gender: String? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress1: String? = nil, mailingAddress2: String? = nil, mailingAddress3: String? = nil, mailingAddress4: String? = nil, mailingCity: String? = nil, mailingCountry: String? = nil, mailingCounty: String? = nil, mailingPostalCode: String? = nil, mailingProvince: String? = nil, mailingState: String? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: String? = nil, phoneNumber: String? = nil, postalCode: String? = nil, profileARN: String? = nil, profileId: String? = nil, province: String? = nil, shippingAddress1: String? = nil, shippingAddress2: String? = nil, shippingAddress3: String? = nil, shippingAddress4: String? = nil, shippingCity: String? = nil, shippingCountry: String? = nil, shippingCounty: String? = nil, shippingPostalCode: String? = nil, shippingProvince: String? = nil, shippingState: String? = nil, state: String? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.billingAddress1 = billingAddress1
            self.billingAddress2 = billingAddress2
            self.billingAddress3 = billingAddress3
            self.billingAddress4 = billingAddress4
            self.billingCity = billingCity
            self.billingCountry = billingCountry
            self.billingCounty = billingCounty
            self.billingPostalCode = billingPostalCode
            self.billingProvince = billingProvince
            self.billingState = billingState
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.city = city
            self.country = country
            self.county = county
            self.custom = custom
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress1 = mailingAddress1
            self.mailingAddress2 = mailingAddress2
            self.mailingAddress3 = mailingAddress3
            self.mailingAddress4 = mailingAddress4
            self.mailingCity = mailingCity
            self.mailingCountry = mailingCountry
            self.mailingCounty = mailingCounty
            self.mailingPostalCode = mailingPostalCode
            self.mailingProvince = mailingProvince
            self.mailingState = mailingState
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.profileARN = profileARN
            self.profileId = profileId
            self.province = province
            self.shippingAddress1 = shippingAddress1
            self.shippingAddress2 = shippingAddress2
            self.shippingAddress3 = shippingAddress3
            self.shippingAddress4 = shippingAddress4
            self.shippingCity = shippingCity
            self.shippingCountry = shippingCountry
            self.shippingCounty = shippingCounty
            self.shippingPostalCode = shippingPostalCode
            self.shippingProvince = shippingProvince
            self.shippingState = shippingState
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, max: 32767)
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, min: 1)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, max: 32767)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, min: 1)
            try self.validate(self.address1, name: "address1", parent: name, max: 32767)
            try self.validate(self.address1, name: "address1", parent: name, min: 1)
            try self.validate(self.address2, name: "address2", parent: name, max: 32767)
            try self.validate(self.address2, name: "address2", parent: name, min: 1)
            try self.validate(self.address3, name: "address3", parent: name, max: 32767)
            try self.validate(self.address3, name: "address3", parent: name, min: 1)
            try self.validate(self.address4, name: "address4", parent: name, max: 32767)
            try self.validate(self.address4, name: "address4", parent: name, min: 1)
            try self.validate(self.billingAddress1, name: "billingAddress1", parent: name, max: 32767)
            try self.validate(self.billingAddress1, name: "billingAddress1", parent: name, min: 1)
            try self.validate(self.billingAddress2, name: "billingAddress2", parent: name, max: 32767)
            try self.validate(self.billingAddress2, name: "billingAddress2", parent: name, min: 1)
            try self.validate(self.billingAddress3, name: "billingAddress3", parent: name, max: 32767)
            try self.validate(self.billingAddress3, name: "billingAddress3", parent: name, min: 1)
            try self.validate(self.billingAddress4, name: "billingAddress4", parent: name, max: 32767)
            try self.validate(self.billingAddress4, name: "billingAddress4", parent: name, min: 1)
            try self.validate(self.billingCity, name: "billingCity", parent: name, max: 32767)
            try self.validate(self.billingCity, name: "billingCity", parent: name, min: 1)
            try self.validate(self.billingCountry, name: "billingCountry", parent: name, max: 32767)
            try self.validate(self.billingCountry, name: "billingCountry", parent: name, min: 1)
            try self.validate(self.billingCounty, name: "billingCounty", parent: name, max: 32767)
            try self.validate(self.billingCounty, name: "billingCounty", parent: name, min: 1)
            try self.validate(self.billingPostalCode, name: "billingPostalCode", parent: name, max: 32767)
            try self.validate(self.billingPostalCode, name: "billingPostalCode", parent: name, min: 1)
            try self.validate(self.billingProvince, name: "billingProvince", parent: name, max: 32767)
            try self.validate(self.billingProvince, name: "billingProvince", parent: name, min: 1)
            try self.validate(self.billingState, name: "billingState", parent: name, max: 32767)
            try self.validate(self.billingState, name: "billingState", parent: name, min: 1)
            try self.validate(self.birthDate, name: "birthDate", parent: name, max: 32767)
            try self.validate(self.birthDate, name: "birthDate", parent: name, min: 1)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, max: 32767)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, min: 1)
            try self.validate(self.businessName, name: "businessName", parent: name, max: 32767)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, max: 32767)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, min: 1)
            try self.validate(self.city, name: "city", parent: name, max: 32767)
            try self.validate(self.city, name: "city", parent: name, min: 1)
            try self.validate(self.country, name: "country", parent: name, max: 32767)
            try self.validate(self.country, name: "country", parent: name, min: 1)
            try self.validate(self.county, name: "county", parent: name, max: 32767)
            try self.validate(self.county, name: "county", parent: name, min: 1)
            try self.custom?.forEach {
                try validate($0.key, name: "custom.key", parent: name, max: 32767)
                try validate($0.key, name: "custom.key", parent: name, min: 1)
                try validate($0.value, name: "custom[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name: "custom[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 32767)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, max: 32767)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.gender, name: "gender", parent: name, max: 32767)
            try self.validate(self.gender, name: "gender", parent: name, min: 1)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, max: 32767)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 32767)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.mailingAddress1, name: "mailingAddress1", parent: name, max: 32767)
            try self.validate(self.mailingAddress1, name: "mailingAddress1", parent: name, min: 1)
            try self.validate(self.mailingAddress2, name: "mailingAddress2", parent: name, max: 32767)
            try self.validate(self.mailingAddress2, name: "mailingAddress2", parent: name, min: 1)
            try self.validate(self.mailingAddress3, name: "mailingAddress3", parent: name, max: 32767)
            try self.validate(self.mailingAddress3, name: "mailingAddress3", parent: name, min: 1)
            try self.validate(self.mailingAddress4, name: "mailingAddress4", parent: name, max: 32767)
            try self.validate(self.mailingAddress4, name: "mailingAddress4", parent: name, min: 1)
            try self.validate(self.mailingCity, name: "mailingCity", parent: name, max: 32767)
            try self.validate(self.mailingCity, name: "mailingCity", parent: name, min: 1)
            try self.validate(self.mailingCountry, name: "mailingCountry", parent: name, max: 32767)
            try self.validate(self.mailingCountry, name: "mailingCountry", parent: name, min: 1)
            try self.validate(self.mailingCounty, name: "mailingCounty", parent: name, max: 32767)
            try self.validate(self.mailingCounty, name: "mailingCounty", parent: name, min: 1)
            try self.validate(self.mailingPostalCode, name: "mailingPostalCode", parent: name, max: 32767)
            try self.validate(self.mailingPostalCode, name: "mailingPostalCode", parent: name, min: 1)
            try self.validate(self.mailingProvince, name: "mailingProvince", parent: name, max: 32767)
            try self.validate(self.mailingProvince, name: "mailingProvince", parent: name, min: 1)
            try self.validate(self.mailingState, name: "mailingState", parent: name, max: 32767)
            try self.validate(self.mailingState, name: "mailingState", parent: name, min: 1)
            try self.validate(self.middleName, name: "middleName", parent: name, max: 32767)
            try self.validate(self.middleName, name: "middleName", parent: name, min: 1)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, max: 32767)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, min: 1)
            try self.validate(self.partyType, name: "partyType", parent: name, max: 32767)
            try self.validate(self.partyType, name: "partyType", parent: name, min: 1)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 32767)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 1)
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 32767)
            try self.validate(self.postalCode, name: "postalCode", parent: name, min: 1)
            try self.validate(self.profileARN, name: "profileARN", parent: name, max: 32767)
            try self.validate(self.profileARN, name: "profileARN", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, max: 32767)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.province, name: "province", parent: name, max: 32767)
            try self.validate(self.province, name: "province", parent: name, min: 1)
            try self.validate(self.shippingAddress1, name: "shippingAddress1", parent: name, max: 32767)
            try self.validate(self.shippingAddress1, name: "shippingAddress1", parent: name, min: 1)
            try self.validate(self.shippingAddress2, name: "shippingAddress2", parent: name, max: 32767)
            try self.validate(self.shippingAddress2, name: "shippingAddress2", parent: name, min: 1)
            try self.validate(self.shippingAddress3, name: "shippingAddress3", parent: name, max: 32767)
            try self.validate(self.shippingAddress3, name: "shippingAddress3", parent: name, min: 1)
            try self.validate(self.shippingAddress4, name: "shippingAddress4", parent: name, max: 32767)
            try self.validate(self.shippingAddress4, name: "shippingAddress4", parent: name, min: 1)
            try self.validate(self.shippingCity, name: "shippingCity", parent: name, max: 32767)
            try self.validate(self.shippingCity, name: "shippingCity", parent: name, min: 1)
            try self.validate(self.shippingCountry, name: "shippingCountry", parent: name, max: 32767)
            try self.validate(self.shippingCountry, name: "shippingCountry", parent: name, min: 1)
            try self.validate(self.shippingCounty, name: "shippingCounty", parent: name, max: 32767)
            try self.validate(self.shippingCounty, name: "shippingCounty", parent: name, min: 1)
            try self.validate(self.shippingPostalCode, name: "shippingPostalCode", parent: name, max: 32767)
            try self.validate(self.shippingPostalCode, name: "shippingPostalCode", parent: name, min: 1)
            try self.validate(self.shippingProvince, name: "shippingProvince", parent: name, max: 32767)
            try self.validate(self.shippingProvince, name: "shippingProvince", parent: name, min: 1)
            try self.validate(self.shippingState, name: "shippingState", parent: name, max: 32767)
            try self.validate(self.shippingState, name: "shippingState", parent: name, min: 1)
            try self.validate(self.state, name: "state", parent: name, max: 32767)
            try self.validate(self.state, name: "state", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "accountNumber"
            case additionalInformation = "additionalInformation"
            case address1 = "address1"
            case address2 = "address2"
            case address3 = "address3"
            case address4 = "address4"
            case billingAddress1 = "billingAddress1"
            case billingAddress2 = "billingAddress2"
            case billingAddress3 = "billingAddress3"
            case billingAddress4 = "billingAddress4"
            case billingCity = "billingCity"
            case billingCountry = "billingCountry"
            case billingCounty = "billingCounty"
            case billingPostalCode = "billingPostalCode"
            case billingProvince = "billingProvince"
            case billingState = "billingState"
            case birthDate = "birthDate"
            case businessEmailAddress = "businessEmailAddress"
            case businessName = "businessName"
            case businessPhoneNumber = "businessPhoneNumber"
            case city = "city"
            case country = "country"
            case county = "county"
            case custom = "custom"
            case emailAddress = "emailAddress"
            case firstName = "firstName"
            case gender = "gender"
            case homePhoneNumber = "homePhoneNumber"
            case lastName = "lastName"
            case mailingAddress1 = "mailingAddress1"
            case mailingAddress2 = "mailingAddress2"
            case mailingAddress3 = "mailingAddress3"
            case mailingAddress4 = "mailingAddress4"
            case mailingCity = "mailingCity"
            case mailingCountry = "mailingCountry"
            case mailingCounty = "mailingCounty"
            case mailingPostalCode = "mailingPostalCode"
            case mailingProvince = "mailingProvince"
            case mailingState = "mailingState"
            case middleName = "middleName"
            case mobilePhoneNumber = "mobilePhoneNumber"
            case partyType = "partyType"
            case phoneNumber = "phoneNumber"
            case postalCode = "postalCode"
            case profileARN = "profileARN"
            case profileId = "profileId"
            case province = "province"
            case shippingAddress1 = "shippingAddress1"
            case shippingAddress2 = "shippingAddress2"
            case shippingAddress3 = "shippingAddress3"
            case shippingAddress4 = "shippingAddress4"
            case shippingCity = "shippingCity"
            case shippingCountry = "shippingCountry"
            case shippingCounty = "shippingCounty"
            case shippingPostalCode = "shippingPostalCode"
            case shippingProvince = "shippingProvince"
            case shippingState = "shippingState"
            case state = "state"
        }
    }

    public struct DataSummary: AWSDecodableShape {
        /// Details about the data.
        public let details: DataDetails
        /// Reference information about the content.
        public let reference: DataReference

        @inlinable
        public init(details: DataDetails, reference: DataReference) {
            self.details = details
            self.reference = reference
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case reference = "reference"
        }
    }

    public struct DeactivateMessageTemplateRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String
        /// The version number of the message template version to deactivate.
        public let versionNumber: Int64

        @inlinable
        public init(knowledgeBaseId: String, messageTemplateId: String, versionNumber: Int64) {
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
            try container.encode(self.versionNumber, forKey: .versionNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case versionNumber = "versionNumber"
        }
    }

    public struct DeactivateMessageTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The version number of the message template version that has been deactivated.
        public let versionNumber: Int64

        @inlinable
        public init(messageTemplateArn: String, messageTemplateId: String, versionNumber: Int64) {
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateId = "messageTemplateId"
            case versionNumber = "versionNumber"
        }
    }

    public struct DeleteAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiAgentId: String, assistantId: String) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIAgentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIAgentVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The version number of the AI Agent version.
        public let versionNumber: Int64

        @inlinable
        public init(aiAgentId: String, assistantId: String, versionNumber: Int64) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.versionNumber, key: "versionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIAgentVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIGuardrailRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Guardrail. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiGuardrailId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiGuardrailId: String, assistantId: String) {
            self.aiGuardrailId = aiGuardrailId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiGuardrailId, key: "aiGuardrailId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiGuardrailId, name: "aiGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIGuardrailResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIGuardrailVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        public let aiGuardrailId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The version number of the AI Guardrail version to be deleted.
        public let versionNumber: Int64

        @inlinable
        public init(aiGuardrailId: String, assistantId: String, versionNumber: Int64) {
            self.aiGuardrailId = aiGuardrailId
            self.assistantId = assistantId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiGuardrailId, key: "aiGuardrailId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.versionNumber, key: "versionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiGuardrailId, name: "aiGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIGuardrailVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIPromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiPromptId: String, assistantId: String) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIPromptResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAIPromptVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The version number of the AI Prompt version to be deleted.
        public let versionNumber: Int64

        @inlinable
        public init(aiPromptId: String, assistantId: String, versionNumber: Int64) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.versionNumber, key: "versionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAIPromptVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantAssociationId, key: "assistantAssociationId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssistantRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContentAssociationRequest: AWSEncodableShape {
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentAssociationId: String, contentId: String, knowledgeBaseId: String) {
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentAssociationId, key: "contentAssociationId")
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentAssociationId, name: "contentAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContentAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job to be deleted.
        public let importJobId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String

        @inlinable
        public init(importJobId: String, knowledgeBaseId: String) {
            self.importJobId = importJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importJobId, key: "importJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importJobId, name: "importJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMessageTemplateAttachmentRequest: AWSEncodableShape {
        /// The identifier of the attachment file.
        public let attachmentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String

        @inlinable
        public init(attachmentId: String, knowledgeBaseId: String, messageTemplateId: String) {
            self.attachmentId = attachmentId
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "attachmentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMessageTemplateAttachmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMessageTemplateRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN.
        public let messageTemplateId: String

        @inlinable
        public init(knowledgeBaseId: String, messageTemplateId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMessageTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQuickResponseRequest: AWSEncodableShape {
        /// The knowledge base from which the quick response is deleted. The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The identifier of the quick response to delete.
        public let quickResponseId: String

        @inlinable
        public init(knowledgeBaseId: String, quickResponseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.quickResponseId = quickResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.quickResponseId, key: "quickResponseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQuickResponseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Document: AWSDecodableShape {
        /// A reference to the content resource.
        public let contentReference: ContentReference
        /// The excerpt from the document.
        public let excerpt: DocumentText?
        /// The title of the document.
        public let title: DocumentText?

        @inlinable
        public init(contentReference: ContentReference, excerpt: DocumentText? = nil, title: DocumentText? = nil) {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentReference = "contentReference"
            case excerpt = "excerpt"
            case title = "title"
        }
    }

    public struct DocumentText: AWSDecodableShape {
        /// Highlights in the document text.
        public let highlights: [Highlight]?
        /// Text in the document.
        public let text: String?

        @inlinable
        public init(highlights: [Highlight]? = nil, text: String? = nil) {
            self.highlights = highlights
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case highlights = "highlights"
            case text = "text"
        }
    }

    public struct EmailHeader: AWSEncodableShape & AWSDecodableShape {
        /// The name of the email header.
        public let name: String?
        /// The value of the email header.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 126)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[!-9;-@A-~]+$")
            try self.validate(self.value, name: "value", parent: name, max: 870)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "[ -~]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct EmailMessageTemplateContent: AWSEncodableShape & AWSDecodableShape {
        /// The body to use in email messages.
        public let body: EmailMessageTemplateContentBody?
        /// The email headers to include in email messages.
        public let headers: [EmailHeader]?
        /// The subject line, or title, to use in email messages.
        public let subject: String?

        @inlinable
        public init(body: EmailMessageTemplateContentBody? = nil, headers: [EmailHeader]? = nil, subject: String? = nil) {
            self.body = body
            self.headers = headers
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.body?.validate(name: "\(name).body")
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 15)
            try self.validate(self.subject, name: "subject", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case headers = "headers"
            case subject = "subject"
        }
    }

    public struct EmailMessageTemplateContentBody: AWSEncodableShape & AWSDecodableShape {
        /// The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        public let html: MessageTemplateBodyContentProvider?
        /// The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        public let plainText: MessageTemplateBodyContentProvider?

        @inlinable
        public init(html: MessageTemplateBodyContentProvider? = nil, plainText: MessageTemplateBodyContentProvider? = nil) {
            self.html = html
            self.plainText = plainText
        }

        public func validate(name: String) throws {
            try self.html?.validate(name: "\(name).html")
            try self.plainText?.validate(name: "\(name).plainText")
        }

        private enum CodingKeys: String, CodingKey {
            case html = "html"
            case plainText = "plainText"
        }
    }

    public struct ExtendedMessageTemplateData: AWSDecodableShape {
        /// The message template attachments.
        public let attachments: [MessageTemplateAttachment]?
        /// The types of attributes contain the message template.
        public let attributeTypes: [MessageTemplateAttributeType]?
        /// The channel subtype this message template applies to.
        public let channelSubtype: ChannelSubtype
        /// The content of the message template.
        public let content: MessageTemplateContentProvider
        /// The timestamp when the message template was created.
        public let createdTime: Date
        /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        public let defaultAttributes: MessageTemplateAttributes?
        /// The description of the message template.
        public let description: String?
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the version of the message template is activated.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        public let lastModifiedBy: String
        /// The timestamp when the message template data was last modified.
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The checksum value of the message template content that is referenced by the $LATEST qualifier. It can be returned in MessageTemplateData or ExtendedMessageTemplateData. Its calculated by content, language, defaultAttributes and Attachments of the message template.
        public let messageTemplateContentSha256: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The name of the message template.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The version number of the message template version.
        public let versionNumber: Int64?

        @inlinable
        public init(attachments: [MessageTemplateAttachment]? = nil, attributeTypes: [MessageTemplateAttributeType]? = nil, channelSubtype: ChannelSubtype, content: MessageTemplateContentProvider, createdTime: Date, defaultAttributes: MessageTemplateAttributes? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String, lastModifiedTime: Date, messageTemplateArn: String, messageTemplateContentSha256: String, messageTemplateId: String, name: String, tags: [String: String]? = nil, versionNumber: Int64? = nil) {
            self.attachments = attachments
            self.attributeTypes = attributeTypes
            self.channelSubtype = channelSubtype
            self.content = content
            self.createdTime = createdTime
            self.defaultAttributes = defaultAttributes
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateContentSha256 = messageTemplateContentSha256
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "attachments"
            case attributeTypes = "attributeTypes"
            case channelSubtype = "channelSubtype"
            case content = "content"
            case createdTime = "createdTime"
            case defaultAttributes = "defaultAttributes"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateContentSha256 = "messageTemplateContentSha256"
            case messageTemplateId = "messageTemplateId"
            case name = "name"
            case tags = "tags"
            case versionNumber = "versionNumber"
        }
    }

    public struct ExternalSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information of the external data source.
        public let configuration: Configuration
        /// The type of the external data source.
        public let source: ExternalSource

        @inlinable
        public init(configuration: Configuration, source: ExternalSource) {
            self.configuration = configuration
            self.source = source
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case source = "source"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The field on which to filter.
        public let field: FilterField
        /// The operator to use for comparing the fields value with the provided value.
        public let `operator`: FilterOperator
        /// The desired field value on which to filter.
        public let value: String

        @inlinable
        public init(field: FilterField, operator: FilterOperator, value: String) {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct FixedSizeChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to include in a chunk.
        public let maxTokens: Int
        /// The percentage of overlap between adjacent chunks of a data source.
        public let overlapPercentage: Int

        @inlinable
        public init(maxTokens: Int, overlapPercentage: Int) {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case overlapPercentage = "overlapPercentage"
        }
    }

    public struct GenerativeContentFeedbackData: AWSEncodableShape & AWSDecodableShape {
        /// The relevance of the feedback.
        public let relevance: Relevance

        @inlinable
        public init(relevance: Relevance) {
            self.relevance = relevance
        }

        private enum CodingKeys: String, CodingKey {
            case relevance = "relevance"
        }
    }

    public struct GenerativeDataDetails: AWSDecodableShape {
        /// The LLM response.
        public let completion: String
        /// Details about the generative content ranking data.
        public let rankingData: RankingData
        /// The references used to generative the LLM response.
        public let references: [DataSummary]

        @inlinable
        public init(completion: String, rankingData: RankingData, references: [DataSummary]) {
            self.completion = completion
            self.rankingData = rankingData
            self.references = references
        }

        private enum CodingKeys: String, CodingKey {
            case completion = "completion"
            case rankingData = "rankingData"
            case references = "references"
        }
    }

    public struct GenerativeReference: AWSDecodableShape {
        ///  The identifier of the LLM model.
        public let generationId: String?
        /// The identifier of the LLM model.
        public let modelId: String?

        @inlinable
        public init(generationId: String? = nil, modelId: String? = nil) {
            self.generationId = generationId
            self.modelId = modelId
        }

        private enum CodingKeys: String, CodingKey {
            case generationId = "generationId"
            case modelId = "modelId"
        }
    }

    public struct GetAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent (with or without a version qualifier). Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiAgentId: String, assistantId: String) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAIAgentResponse: AWSDecodableShape {
        /// The data of the AI Agent.
        public let aiAgent: AIAgentData?
        /// The version number of the AI Agent version (returned if an AI Agent version was specified via use of a qualifier for the aiAgentId on the request).
        public let versionNumber: Int64?

        @inlinable
        public init(aiAgent: AIAgentData? = nil, versionNumber: Int64? = nil) {
            self.aiAgent = aiAgent
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
            case versionNumber = "versionNumber"
        }
    }

    public struct GetAIGuardrailRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        public let aiGuardrailId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiGuardrailId: String, assistantId: String) {
            self.aiGuardrailId = aiGuardrailId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiGuardrailId, key: "aiGuardrailId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiGuardrailId, name: "aiGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAIGuardrailResponse: AWSDecodableShape {
        /// The data of the AI Guardrail.
        public let aiGuardrail: AIGuardrailData?
        /// The version number of the AI Guardrail version (returned if an AI Guardrail version was specified via use of a qualifier for the aiGuardrailId on the request).
        public let versionNumber: Int64?

        @inlinable
        public init(aiGuardrail: AIGuardrailData? = nil, versionNumber: Int64? = nil) {
            self.aiGuardrail = aiGuardrail
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrail = "aiGuardrail"
            case versionNumber = "versionNumber"
        }
    }

    public struct GetAIPromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiPromptId: String, assistantId: String) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAIPromptResponse: AWSDecodableShape {
        /// The data of the AI Prompt.
        public let aiPrompt: AIPromptData?
        /// The version number of the AI Prompt version (returned if an AI Prompt version was specified via use of a qualifier for the aiPromptId on the request).
        public let versionNumber: Int64?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil, versionNumber: Int64? = nil) {
            self.aiPrompt = aiPrompt
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
            case versionNumber = "versionNumber"
        }
    }

    public struct GetAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantAssociationId, key: "assistantAssociationId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        @inlinable
        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation = "assistantAssociation"
        }
    }

    public struct GetAssistantRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        @inlinable
        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct GetContentAssociationRequest: AWSEncodableShape {
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentAssociationId: String
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentAssociationId: String, contentId: String, knowledgeBaseId: String) {
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentAssociationId, key: "contentAssociationId")
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentAssociationId, name: "contentAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentAssociationResponse: AWSDecodableShape {
        /// The association between Amazon Q in Connect content and another resource.
        public let contentAssociation: ContentAssociationData?

        @inlinable
        public init(contentAssociation: ContentAssociationData? = nil) {
            self.contentAssociation = contentAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case contentAssociation = "contentAssociation"
        }
    }

    public struct GetContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        @inlinable
        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct GetContentSummaryRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentSummaryResponse: AWSDecodableShape {
        /// The content summary.
        public let contentSummary: ContentSummary?

        @inlinable
        public init(contentSummary: ContentSummary? = nil) {
            self.contentSummary = contentSummary
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummary = "contentSummary"
        }
    }

    public struct GetImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job to retrieve.
        public let importJobId: String
        /// The identifier of the knowledge base that the import job belongs to.
        public let knowledgeBaseId: String

        @inlinable
        public init(importJobId: String, knowledgeBaseId: String) {
            self.importJobId = importJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importJobId, key: "importJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importJobId, name: "importJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportJobResponse: AWSDecodableShape {
        /// The import job.
        public let importJob: ImportJobData?

        @inlinable
        public init(importJob: ImportJobData? = nil) {
            self.importJob = importJob
        }

        private enum CodingKeys: String, CodingKey {
            case importJob = "importJob"
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        @inlinable
        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct GetMessageTemplateRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN.
        public let messageTemplateId: String

        @inlinable
        public init(knowledgeBaseId: String, messageTemplateId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMessageTemplateResponse: AWSDecodableShape {
        /// The message template.
        public let messageTemplate: ExtendedMessageTemplateData?

        @inlinable
        public init(messageTemplate: ExtendedMessageTemplateData? = nil) {
            self.messageTemplate = messageTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplate = "messageTemplate"
        }
    }

    public struct GetNextMessageRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The token for the next message. Use the value returned in the SendMessage or previous response in the next request to retrieve the next message.
        public let nextMessageToken: String
        /// The identifier of the Amazon Q in Connect session.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, nextMessageToken: String, sessionId: String) {
            self.assistantId = assistantId
            self.nextMessageToken = nextMessageToken
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.nextMessageToken, key: "nextMessageToken")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.nextMessageToken, name: "nextMessageToken", parent: name, max: 2048)
            try self.validate(self.nextMessageToken, name: "nextMessageToken", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNextMessageResponse: AWSDecodableShape {
        /// The conversation data stored on an Amazon Q in Connect Session.
        public let conversationSessionData: [RuntimeSessionData]?
        /// The state of current conversation.
        public let conversationState: ConversationState
        /// The token for the next message.
        public let nextMessageToken: String?
        /// The identifier of the submitted message.
        public let requestMessageId: String
        /// The message response to the requested message.
        public let response: MessageOutput
        /// The type of message response.
        public let type: MessageType

        @inlinable
        public init(conversationSessionData: [RuntimeSessionData]? = nil, conversationState: ConversationState, nextMessageToken: String? = nil, requestMessageId: String, response: MessageOutput, type: MessageType) {
            self.conversationSessionData = conversationSessionData
            self.conversationState = conversationState
            self.nextMessageToken = nextMessageToken
            self.requestMessageId = requestMessageId
            self.response = response
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case conversationSessionData = "conversationSessionData"
            case conversationState = "conversationState"
            case nextMessageToken = "nextMessageToken"
            case requestMessageId = "requestMessageId"
            case response = "response"
            case type = "type"
        }
    }

    public struct GetQuickResponseRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// The identifier of the quick response.
        public let quickResponseId: String

        @inlinable
        public init(knowledgeBaseId: String, quickResponseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.quickResponseId = quickResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.quickResponseId, key: "quickResponseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        @inlinable
        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct GetRecommendationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String
        /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
        public let waitTimeSeconds: Int?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, sessionId: String, waitTimeSeconds: Int? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.sessionId = sessionId
            self.waitTimeSeconds = waitTimeSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodeQuery(self.waitTimeSeconds, key: "waitTimeSeconds")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, max: 20)
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsResponse: AWSDecodableShape {
        /// The recommendations.
        public let recommendations: [RecommendationData]
        /// The triggers corresponding to recommendations.
        public let triggers: [RecommendationTrigger]?

        @inlinable
        public init(recommendations: [RecommendationData], triggers: [RecommendationTrigger]? = nil) {
            self.recommendations = recommendations
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case recommendations = "recommendations"
            case triggers = "triggers"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, sessionId: String) {
            self.assistantId = assistantId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        @inlinable
        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct GroupingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The criteria used for grouping Amazon Q in Connect users. The following is the list of supported criteria values.    RoutingProfileArn: Grouping the users by their Amazon Connect routing profile ARN. User should have SearchRoutingProfile and DescribeRoutingProfile permissions when setting criteria to this value.
        public let criteria: String?
        /// The list of values that define different groups of Amazon Q in Connect users.   When setting criteria to RoutingProfileArn, you need to provide a list of ARNs of Amazon Connect routing profiles as values of this parameter.
        public let values: [String]?

        @inlinable
        public init(criteria: String? = nil, values: [String]? = nil) {
            self.criteria = criteria
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.criteria, name: "criteria", parent: name, max: 100)
            try self.validate(self.criteria, name: "criteria", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
            case values = "values"
        }
    }

    public struct GuardrailContentFilterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        public let inputStrength: GuardrailFilterStrength
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        public let outputStrength: GuardrailFilterStrength
        /// The harmful category that the content filter is applied to.
        public let type: GuardrailContentFilterType

        @inlinable
        public init(inputStrength: GuardrailFilterStrength, outputStrength: GuardrailFilterStrength, type: GuardrailContentFilterType) {
            self.inputStrength = inputStrength
            self.outputStrength = outputStrength
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inputStrength = "inputStrength"
            case outputStrength = "outputStrength"
            case type = "type"
        }
    }

    public struct GuardrailContextualGroundingFilterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The threshold details for the AI Guardrail's contextual grounding filter.
        public let threshold: Double
        /// The filter type for the AI Guardrail's contextual grounding filter.
        public let type: GuardrailContextualGroundingFilterType

        @inlinable
        public init(threshold: Double, type: GuardrailContextualGroundingFilterType) {
            self.threshold = threshold
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.threshold, name: "threshold", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case threshold = "threshold"
            case type = "type"
        }
    }

    public struct GuardrailManagedWordsConfig: AWSEncodableShape & AWSDecodableShape {
        /// The managed word type to configure for the AI Guardrail.
        public let type: GuardrailManagedWordsType

        @inlinable
        public init(type: GuardrailManagedWordsType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct GuardrailPiiEntityConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configure AI Guardrail's action when the PII entity is detected.
        public let action: GuardrailSensitiveInformationAction
        /// Configure AI Guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information:    General     ADDRESS  A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.     AGE  An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guarrails recognizes "40 years" as an age.     NAME  An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. AI Guardrail doesn't apply this entity type to names that are part of organizations or addresses. For example, AI Guardrail recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.     EMAIL  An email address, such as marymajor@email.com.    PHONE  A phone number. This entity type also includes fax and pager numbers.     USERNAME  A user name that identifies an account, such as a login name, screen name, nick name, or handle.     PASSWORD  An alphanumeric string that is used as a password, such as "* very20special#pass*".     DRIVER_ID  The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.     LICENSE_PLATE  A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.     VEHICLE_IDENTIFICATION_NUMBER  A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the ISO 3779 specification. Each country has specific codes and formats for VINs.       Finance     CREDIT_DEBIT_CARD_CVV  A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.     CREDIT_DEBIT_CARD_EXPIRY  The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as month/year or MM/YY. AI Guardrail recognizes expiration dates such as 01/21, 01/2021, and Jan 2021.     CREDIT_DEBIT_CARD_NUMBER  The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.     PIN  A four-digit personal identification number (PIN) with which you can access your bank account.     INTERNATIONAL_BANK_ACCOUNT_NUMBER  An International Bank Account Number has specific formats in each country. For more information, see  www.iban.com/structure.    SWIFT_CODE  A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.      IT     IP_ADDRESS  An IPv4 address, such as 198.51.100.0.     MAC_ADDRESS  A media access control (MAC) address is a unique identifier assigned to a network interface controller (NIC).     URL  A web address, such as www.example.com.     AWS_ACCESS_KEY  A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.     AWS_SECRET_KEY  A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.       USA specific     US_BANK_ACCOUNT_NUMBER  A US bank account number, which is typically 10 to 12 digits long.     US_BANK_ROUTING_NUMBER  A US bank account routing number. These are typically nine digits long,     US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER  A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.     US_PASSPORT_NUMBER  A US passport number. Passport numbers range from six to nine alphanumeric characters.     US_SOCIAL_SECURITY_NUMBER  A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.       Canada specific     CA_HEALTH_NUMBER  A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.     CA_SOCIAL_INSURANCE_NUMBER  A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as  123-456-789. A SIN can be validated through a simple check-digit process called the Luhn algorithm .      UK Specific     UK_NATIONAL_HEALTH_SERVICE_NUMBER  A UK National Health Service Number is a 10-17 digit number, such as 485 555 3456. The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.    UK_NATIONAL_INSURANCE_NUMBER  A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.    UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER  A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.       Custom     Regex filter - You can use a regular expressions to define patterns for an AI Guardrail to recognize and act upon such as serial number, booking ID etc..
        public let type: GuardrailPiiEntityType

        @inlinable
        public init(action: GuardrailSensitiveInformationAction, type: GuardrailPiiEntityType) {
            self.action = action
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case type = "type"
        }
    }

    public struct GuardrailRegexConfig: AWSEncodableShape & AWSDecodableShape {
        /// The AI Guardrail action to configure when matching regular expression is detected.
        public let action: GuardrailSensitiveInformationAction
        /// The description of the regular expression to configure for the AI Guardrail.
        public let description: String?
        /// The name of the regular expression to configure for the AI Guardrail.
        public let name: String
        /// The regular expression pattern to configure for the AI Guardrail.
        public let pattern: String

        @inlinable
        public init(action: GuardrailSensitiveInformationAction, description: String? = nil, name: String, pattern: String) {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case name = "name"
            case pattern = "pattern"
        }
    }

    public struct GuardrailTopicConfig: AWSEncodableShape & AWSDecodableShape {
        /// A definition of the topic to deny.
        public let definition: String
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public let examples: [String]?
        /// The name of the topic to deny.
        public let name: String
        /// Specifies to deny the topic.
        public let type: GuardrailTopicType

        @inlinable
        public init(definition: String, examples: [String]? = nil, name: String, type: GuardrailTopicType) {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.definition, name: "definition", parent: name, max: 200)
            try self.validate(self.definition, name: "definition", parent: name, min: 1)
            try self.examples?.forEach {
                try validate($0, name: "examples[]", parent: name, max: 100)
                try validate($0, name: "examples[]", parent: name, min: 1)
            }
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_ !?.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case examples = "examples"
            case name = "name"
            case type = "type"
        }
    }

    public struct GuardrailWordConfig: AWSEncodableShape & AWSDecodableShape {
        /// Text of the word configured for the AI Guardrail to block.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct HierarchicalChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Token settings for each layer.
        public let levelConfigurations: [HierarchicalChunkingLevelConfiguration]
        /// The number of tokens to repeat across chunks in the same layer.
        public let overlapTokens: Int

        @inlinable
        public init(levelConfigurations: [HierarchicalChunkingLevelConfiguration], overlapTokens: Int) {
            self.levelConfigurations = levelConfigurations
            self.overlapTokens = overlapTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, max: 2)
            try self.validate(self.levelConfigurations, name: "levelConfigurations", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case levelConfigurations = "levelConfigurations"
            case overlapTokens = "overlapTokens"
        }
    }

    public struct HierarchicalChunkingLevelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens that a chunk can contain in this layer.
        public let maxTokens: Int

        @inlinable
        public init(maxTokens: Int) {
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
        }
    }

    public struct Highlight: AWSDecodableShape {
        /// The offset for the start of the highlight.
        public let beginOffsetInclusive: Int?
        /// The offset for the end of the highlight.
        public let endOffsetExclusive: Int?

        @inlinable
        public init(beginOffsetInclusive: Int? = nil, endOffsetExclusive: Int? = nil) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetInclusive = "beginOffsetInclusive"
            case endOffsetExclusive = "endOffsetExclusive"
        }
    }

    public struct ImportJobData: AWSDecodableShape {
        /// The timestamp when the import job was created.
        public let createdTime: Date
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The link to download the information of resource data that failed to be imported.
        public let failedRecordReport: String?
        /// The identifier of the import job.
        public let importJobId: String
        /// The type of the import job.
        public let importJobType: ImportJobType
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The timestamp when the import job data was last modified.
        public let lastModifiedTime: Date
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public let metadata: [String: String]?
        /// The status of the import job.
        public let status: ImportJobStatus
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String
        /// The download link to the resource file that is uploaded to the import job.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        @inlinable
        public init(createdTime: Date, externalSourceConfiguration: ExternalSourceConfiguration? = nil, failedRecordReport: String? = nil, importJobId: String, importJobType: ImportJobType, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedTime: Date, metadata: [String: String]? = nil, status: ImportJobStatus, uploadId: String, url: String, urlExpiry: Date) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.failedRecordReport = failedRecordReport
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case failedRecordReport = "failedRecordReport"
            case importJobId = "importJobId"
            case importJobType = "importJobType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedTime = "lastModifiedTime"
            case metadata = "metadata"
            case status = "status"
            case uploadId = "uploadId"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct ImportJobSummary: AWSDecodableShape {
        /// The timestamp when the import job was created.
        public let createdTime: Date
        /// The configuration information of the external source that the resource data are imported from.
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The identifier of the import job.
        public let importJobId: String
        /// The type of import job.
        public let importJobType: ImportJobType
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The timestamp when the import job was last modified.
        public let lastModifiedTime: Date
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public let metadata: [String: String]?
        /// The status of the import job.
        public let status: ImportJobStatus
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        @inlinable
        public init(createdTime: Date, externalSourceConfiguration: ExternalSourceConfiguration? = nil, importJobId: String, importJobType: ImportJobType, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedTime: Date, metadata: [String: String]? = nil, status: ImportJobStatus, uploadId: String) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case importJobId = "importJobId"
            case importJobType = "importJobType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedTime = "lastModifiedTime"
            case metadata = "metadata"
            case status = "status"
            case uploadId = "uploadId"
        }
    }

    public struct IntentDetectedDataDetails: AWSDecodableShape {
        /// The detected intent.
        public let intent: String
        /// The identifier of the detected intent.
        public let intentId: String

        @inlinable
        public init(intent: String, intentId: String) {
            self.intent = intent
            self.intentId = intentId
        }

        private enum CodingKeys: String, CodingKey {
            case intent = "intent"
            case intentId = "intentId"
        }
    }

    public struct IntentInputData: AWSEncodableShape {
        /// The identifier of the Amazon Q intent.
        public let intentId: String

        @inlinable
        public init(intentId: String) {
            self.intentId = intentId
        }

        public func validate(name: String) throws {
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case intentId = "intentId"
        }
    }

    public struct KnowledgeBaseAssociationConfigurationData: AWSEncodableShape & AWSDecodableShape {
        public let contentTagFilter: TagFilter?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The search type to be used against the Knowledge Base for this request. The values can be SEMANTIC which uses vector embeddings or HYBRID which use vector embeddings and raw text
        public let overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType?

        @inlinable
        public init(contentTagFilter: TagFilter? = nil, maxResults: Int? = nil, overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType? = nil) {
            self.contentTagFilter = contentTagFilter
            self.maxResults = maxResults
            self.overrideKnowledgeBaseSearchType = overrideKnowledgeBaseSearchType
        }

        public func validate(name: String) throws {
            try self.contentTagFilter?.validate(name: "\(name).contentTagFilter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentTagFilter = "contentTagFilter"
            case maxResults = "maxResults"
            case overrideKnowledgeBaseSearchType = "overrideKnowledgeBaseSearchType"
        }
    }

    public struct KnowledgeBaseAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String?

        @inlinable
        public init(knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil) {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct KnowledgeBaseData: AWSDecodableShape {
        /// The description.
        public let description: String?
        /// List of failure reasons on ingestion per file.
        public let ingestionFailureReasons: [String]?
        /// Status of ingestion on data source.
        public let ingestionStatus: SyncStatus?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public let lastContentModificationTime: Date?
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about how to ingest the documents in a data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(description: String? = nil, ingestionFailureReasons: [String]? = nil, ingestionStatus: SyncStatus? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, lastContentModificationTime: Date? = nil, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.description = description
            self.ingestionFailureReasons = ingestionFailureReasons
            self.ingestionStatus = ingestionStatus
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case ingestionFailureReasons = "ingestionFailureReasons"
            case ingestionStatus = "ingestionStatus"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseType = "knowledgeBaseType"
            case lastContentModificationTime = "lastContentModificationTime"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case status = "status"
            case tags = "tags"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect.  For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base summary.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Contains details about how to ingest the documents in a data source.
        public let vectorIngestionConfiguration: VectorIngestionConfiguration?

        @inlinable
        public init(description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil, vectorIngestionConfiguration: VectorIngestionConfiguration? = nil) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseType = "knowledgeBaseType"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case status = "status"
            case tags = "tags"
            case vectorIngestionConfiguration = "vectorIngestionConfiguration"
        }
    }

    public struct ListAIAgentVersionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent for which versions are to be listed.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Agent versions to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(aiAgentId: String, assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIAgentVersionsResponse: AWSDecodableShape {
        /// The summaries of AI Agent versions.
        public let aiAgentVersionSummaries: [AIAgentVersionSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiAgentVersionSummaries: [AIAgentVersionSummary], nextToken: String? = nil) {
            self.aiAgentVersionSummaries = aiAgentVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentVersionSummaries = "aiAgentVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIAgentsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Agents to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIAgentsResponse: AWSDecodableShape {
        /// The summaries of AI Agents.
        public let aiAgentSummaries: [AIAgentSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiAgentSummaries: [AIAgentSummary], nextToken: String? = nil) {
            self.aiAgentSummaries = aiAgentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentSummaries = "aiAgentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIGuardrailVersionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Guardrail for which versions are to be listed.
        public let aiGuardrailId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiGuardrailId: String, assistantId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.aiGuardrailId = aiGuardrailId
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiGuardrailId, key: "aiGuardrailId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiGuardrailId, name: "aiGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIGuardrailVersionsResponse: AWSDecodableShape {
        /// The summaries of the AI Guardrail versions.
        public let aiGuardrailVersionSummaries: [AIGuardrailVersionSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiGuardrailVersionSummaries: [AIGuardrailVersionSummary], nextToken: String? = nil) {
            self.aiGuardrailVersionSummaries = aiGuardrailVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrailVersionSummaries = "aiGuardrailVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIGuardrailsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIGuardrailsResponse: AWSDecodableShape {
        /// The summaries of the AI Guardrails.
        public let aiGuardrailSummaries: [AIGuardrailSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiGuardrailSummaries: [AIGuardrailSummary], nextToken: String? = nil) {
            self.aiGuardrailSummaries = aiGuardrailSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrailSummaries = "aiGuardrailSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIPromptVersionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI prompt for which versions are to be listed.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Prompt versions to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(aiPromptId: String, assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIPromptVersionsResponse: AWSDecodableShape {
        /// The summaries of the AI Prompt versions.
        public let aiPromptVersionSummaries: [AIPromptVersionSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiPromptVersionSummaries: [AIPromptVersionSummary], nextToken: String? = nil) {
            self.aiPromptVersionSummaries = aiPromptVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptVersionSummaries = "aiPromptVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAIPromptsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The origin of the AI Prompts to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public let origin: Origin?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, origin: Origin? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAIPromptsResponse: AWSDecodableShape {
        /// The summaries of the AI Prompts.
        public let aiPromptSummaries: [AIPromptSummary]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(aiPromptSummaries: [AIPromptSummary], nextToken: String? = nil) {
            self.aiPromptSummaries = aiPromptSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aiPromptSummaries = "aiPromptSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssistantAssociationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantAssociationsResponse: AWSDecodableShape {
        /// Summary information about assistant associations.
        public let assistantAssociationSummaries: [AssistantAssociationSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantAssociationSummaries: [AssistantAssociationSummary], nextToken: String? = nil) {
            self.assistantAssociationSummaries = assistantAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociationSummaries = "assistantAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssistantsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantsResponse: AWSDecodableShape {
        /// Information about the assistants.
        public let assistantSummaries: [AssistantSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(assistantSummaries: [AssistantSummary], nextToken: String? = nil) {
            self.assistantSummaries = assistantSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantSummaries = "assistantSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListContentAssociationsRequest: AWSEncodableShape {
        /// The identifier of the content.
        public let contentId: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentId: String, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContentAssociationsResponse: AWSDecodableShape {
        /// Summary information about content associations.
        public let contentAssociationSummaries: [ContentAssociationSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentAssociationSummaries: [ContentAssociationSummary], nextToken: String? = nil) {
            self.contentAssociationSummaries = contentAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentAssociationSummaries = "contentAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListContentsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContentsResponse: AWSDecodableShape {
        /// Information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries = "contentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportJobsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportJobsResponse: AWSDecodableShape {
        /// Summary information about the import jobs.
        public let importJobSummaries: [ImportJobSummary]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(importJobSummaries: [ImportJobSummary], nextToken: String? = nil) {
            self.importJobSummaries = importJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobSummaries = "importJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// Information about the knowledge bases.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries = "knowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMessageTemplateVersionsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, messageTemplateId: String, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.messageTemplateId = messageTemplateId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMessageTemplateVersionsResponse: AWSDecodableShape {
        /// Summary information about the versions of a message template.
        public let messageTemplateVersionSummaries: [MessageTemplateVersionSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(messageTemplateVersionSummaries: [MessageTemplateVersionSummary], nextToken: String? = nil) {
            self.messageTemplateVersionSummaries = messageTemplateVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplateVersionSummaries = "messageTemplateVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMessageTemplatesRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMessageTemplatesResponse: AWSDecodableShape {
        /// Summary information about the message template.
        public let messageTemplateSummaries: [MessageTemplateSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(messageTemplateSummaries: [MessageTemplateSummary], nextToken: String? = nil) {
            self.messageTemplateSummaries = messageTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplateSummaries = "messageTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMessagesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the Amazon Q in Connect session.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, sessionId: String) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMessagesResponse: AWSDecodableShape {
        /// The message information.
        public let messages: [MessageOutput]
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(messages: [MessageOutput], nextToken: String? = nil) {
            self.messages = messages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case nextToken = "nextToken"
        }
    }

    public struct ListQuickResponsesRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQuickResponsesResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// Summary information about the quick responses.
        public let quickResponseSummaries: [QuickResponseSummary]

        @inlinable
        public init(nextToken: String? = nil, quickResponseSummaries: [QuickResponseSummary]) {
            self.nextToken = nextToken
            self.quickResponseSummaries = quickResponseSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case quickResponseSummaries = "quickResponseSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManualSearchAIAgentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The AI Guardrail identifier for the Answer Generation guardrail used by the MANUAL_SEARCH AI Agent.
        public let answerGenerationAIGuardrailId: String?
        /// The AI Prompt identifier for the Answer Generation prompt used by the MANUAL_SEARCH AI Agent.
        public let answerGenerationAIPromptId: String?
        /// The association configurations for overriding behavior on this AI Agent.
        public let associationConfigurations: [AssociationConfiguration]?
        /// The locale to which specifies the language and region settings that determine the response language for QueryAssistant.
        public let locale: String?

        @inlinable
        public init(answerGenerationAIGuardrailId: String? = nil, answerGenerationAIPromptId: String? = nil, associationConfigurations: [AssociationConfiguration]? = nil, locale: String? = nil) {
            self.answerGenerationAIGuardrailId = answerGenerationAIGuardrailId
            self.answerGenerationAIPromptId = answerGenerationAIPromptId
            self.associationConfigurations = associationConfigurations
            self.locale = locale
        }

        public func validate(name: String) throws {
            try self.validate(self.answerGenerationAIGuardrailId, name: "answerGenerationAIGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.answerGenerationAIPromptId, name: "answerGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.associationConfigurations?.forEach {
                try $0.validate(name: "\(name).associationConfigurations[]")
            }
            try self.validate(self.locale, name: "locale", parent: name, max: 4096)
            try self.validate(self.locale, name: "locale", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case answerGenerationAIGuardrailId = "answerGenerationAIGuardrailId"
            case answerGenerationAIPromptId = "answerGenerationAIPromptId"
            case associationConfigurations = "associationConfigurations"
            case locale = "locale"
        }
    }

    public struct MessageInput: AWSEncodableShape {
        /// The message input value.
        public let value: MessageData

        @inlinable
        public init(value: MessageData) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct MessageOutput: AWSDecodableShape {
        /// The identifier of a message.
        public let messageId: String
        /// The participant of a message.
        public let participant: Participant
        /// The timestamp of a message.
        public let timestamp: Date
        /// The value of a message data.
        public let value: MessageData

        @inlinable
        public init(messageId: String, participant: Participant, timestamp: Date, value: MessageData) {
            self.messageId = messageId
            self.participant = participant
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "messageId"
            case participant = "participant"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct MessageTemplateAttachment: AWSDecodableShape {
        /// The identifier of the attachment file.
        public let attachmentId: String
        /// The presentation information for the attachment file.
        public let contentDisposition: ContentDisposition
        /// The name of the attachment file being uploaded. The name should include the file extension.
        public let name: String
        /// The timestamp when the attachment file was uploaded.
        public let uploadedTime: Date
        /// A pre-signed Amazon S3 URL that can be used to download the attachment file.
        public let url: String
        /// The expiration time of the pre-signed Amazon S3 URL.
        public let urlExpiry: Date

        @inlinable
        public init(attachmentId: String, contentDisposition: ContentDisposition, name: String, uploadedTime: Date, url: String, urlExpiry: Date) {
            self.attachmentId = attachmentId
            self.contentDisposition = contentDisposition
            self.name = name
            self.uploadedTime = uploadedTime
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "attachmentId"
            case contentDisposition = "contentDisposition"
            case name = "name"
            case uploadedTime = "uploadedTime"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct MessageTemplateAttributes: AWSEncodableShape & AWSDecodableShape {
        /// The agent attributes that are used with the message template.
        public let agentAttributes: AgentAttributes?
        /// The custom attributes that are used with the message template.
        public let customAttributes: [String: String]?
        /// The customer profile attributes that are used with the message template.
        public let customerProfileAttributes: CustomerProfileAttributes?
        /// The system attributes that are used with the message template.
        public let systemAttributes: SystemAttributes?

        @inlinable
        public init(agentAttributes: AgentAttributes? = nil, customAttributes: [String: String]? = nil, customerProfileAttributes: CustomerProfileAttributes? = nil, systemAttributes: SystemAttributes? = nil) {
            self.agentAttributes = agentAttributes
            self.customAttributes = customAttributes
            self.customerProfileAttributes = customerProfileAttributes
            self.systemAttributes = systemAttributes
        }

        public func validate(name: String) throws {
            try self.agentAttributes?.validate(name: "\(name).agentAttributes")
            try self.customAttributes?.forEach {
                try validate($0.key, name: "customAttributes.key", parent: name, max: 32767)
                try validate($0.key, name: "customAttributes.key", parent: name, min: 1)
                try validate($0.value, name: "customAttributes[\"\($0.key)\"]", parent: name, max: 32767)
                try validate($0.value, name: "customAttributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.customerProfileAttributes?.validate(name: "\(name).customerProfileAttributes")
            try self.systemAttributes?.validate(name: "\(name).systemAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case agentAttributes = "agentAttributes"
            case customAttributes = "customAttributes"
            case customerProfileAttributes = "customerProfileAttributes"
            case systemAttributes = "systemAttributes"
        }
    }

    public struct MessageTemplateData: AWSDecodableShape {
        /// The types of attributes that the message template contains.
        public let attributeTypes: [MessageTemplateAttributeType]?
        /// The channel subtype this message template applies to.
        public let channelSubtype: ChannelSubtype
        /// The content of the message template.
        public let content: MessageTemplateContentProvider
        /// The timestamp when the message template was created.
        public let createdTime: Date
        /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        public let defaultAttributes: MessageTemplateAttributes?
        /// The description of the message template.
        public let description: String?
        public let groupingConfiguration: GroupingConfiguration?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        public let lastModifiedBy: String
        /// The timestamp when the message template data was last modified.
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The checksum value of the message template content that is referenced by the $LATEST qualifier. It can be returned in MessageTemplateData or ExtendedMessageTemplateData. Its calculated by content, language, defaultAttributes and Attachments of the message template.
        public let messageTemplateContentSha256: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The name of the message template.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributeTypes: [MessageTemplateAttributeType]? = nil, channelSubtype: ChannelSubtype, content: MessageTemplateContentProvider, createdTime: Date, defaultAttributes: MessageTemplateAttributes? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String, lastModifiedTime: Date, messageTemplateArn: String, messageTemplateContentSha256: String, messageTemplateId: String, name: String, tags: [String: String]? = nil) {
            self.attributeTypes = attributeTypes
            self.channelSubtype = channelSubtype
            self.content = content
            self.createdTime = createdTime
            self.defaultAttributes = defaultAttributes
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateContentSha256 = messageTemplateContentSha256
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributeTypes = "attributeTypes"
            case channelSubtype = "channelSubtype"
            case content = "content"
            case createdTime = "createdTime"
            case defaultAttributes = "defaultAttributes"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateContentSha256 = "messageTemplateContentSha256"
            case messageTemplateId = "messageTemplateId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct MessageTemplateFilterField: AWSEncodableShape {
        /// Whether to treat null value as a match for the attribute field.
        public let includeNoExistence: Bool?
        /// The name of the attribute field to filter the message templates by.
        public let name: String
        /// The operator to use for filtering.
        public let `operator`: MessageTemplateFilterOperator
        /// The values of attribute field to filter the message template by.
        public let values: [String]?

        @inlinable
        public init(includeNoExistence: Bool? = nil, name: String, operator: MessageTemplateFilterOperator, values: [String]? = nil) {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeNoExistence = "includeNoExistence"
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct MessageTemplateOrderField: AWSEncodableShape {
        /// The name of the message template.
        public let name: String
        /// The order at which the message templates are sorted by.
        public let order: Order?

        @inlinable
        public init(name: String, order: Order? = nil) {
            self.name = name
            self.order = order
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
        }
    }

    public struct MessageTemplateQueryField: AWSEncodableShape {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public let allowFuzziness: Bool?
        /// The name of the attribute to query the message templates by.
        public let name: String
        /// The operator to use for matching attribute field values in the query.
        public let `operator`: MessageTemplateQueryOperator
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public let priority: Priority?
        /// The values of the attribute to query the message templates by.
        public let values: [String]

        @inlinable
        public init(allowFuzziness: Bool? = nil, name: String, operator: MessageTemplateQueryOperator, priority: Priority? = nil, values: [String]) {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowFuzziness = "allowFuzziness"
            case name = "name"
            case `operator` = "operator"
            case priority = "priority"
            case values = "values"
        }
    }

    public struct MessageTemplateSearchExpression: AWSEncodableShape {
        /// The configuration of filtering rules applied to message template query results.
        public let filters: [MessageTemplateFilterField]?
        /// The message template attribute fields on which the query results are ordered.
        public let orderOnField: MessageTemplateOrderField?
        /// The message template query expressions.
        public let queries: [MessageTemplateQueryField]?

        @inlinable
        public init(filters: [MessageTemplateFilterField]? = nil, orderOnField: MessageTemplateOrderField? = nil, queries: [MessageTemplateQueryField]? = nil) {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.orderOnField?.validate(name: "\(name).orderOnField")
            try self.queries?.forEach {
                try $0.validate(name: "\(name).queries[]")
            }
            try self.validate(self.queries, name: "queries", parent: name, max: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case orderOnField = "orderOnField"
            case queries = "queries"
        }
    }

    public struct MessageTemplateSearchResultData: AWSDecodableShape {
        /// The channel subtype this message template applies to.
        public let channelSubtype: ChannelSubtype
        /// The timestamp when the message template was created.
        public let createdTime: Date
        /// The description of the message template.
        public let description: String?
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the version of the message template is activated.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        public let lastModifiedBy: String
        /// The timestamp when the message template data was last modified.
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The name of the message template.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The version number of the message template version.
        public let versionNumber: Int64?

        @inlinable
        public init(channelSubtype: ChannelSubtype, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String, lastModifiedTime: Date, messageTemplateArn: String, messageTemplateId: String, name: String, tags: [String: String]? = nil, versionNumber: Int64? = nil) {
            self.channelSubtype = channelSubtype
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case channelSubtype = "channelSubtype"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateId = "messageTemplateId"
            case name = "name"
            case tags = "tags"
            case versionNumber = "versionNumber"
        }
    }

    public struct MessageTemplateSummary: AWSDecodableShape {
        /// The version number of the message template version that is activated.
        public let activeVersionNumber: Int64?
        /// The channel subtype this message template applies to.
        public let channelSubtype: ChannelSubtype
        /// The timestamp when the message template was created.
        public let createdTime: Date
        /// The description of the message template.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        public let lastModifiedBy: String
        /// The timestamp when the message template data was last modified.
        public let lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The name of the message template.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(activeVersionNumber: Int64? = nil, channelSubtype: ChannelSubtype, createdTime: Date, description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedBy: String, lastModifiedTime: Date, messageTemplateArn: String, messageTemplateId: String, name: String, tags: [String: String]? = nil) {
            self.activeVersionNumber = activeVersionNumber
            self.channelSubtype = channelSubtype
            self.createdTime = createdTime
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeVersionNumber = "activeVersionNumber"
            case channelSubtype = "channelSubtype"
            case createdTime = "createdTime"
            case description = "description"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateId = "messageTemplateId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct MessageTemplateVersionSummary: AWSDecodableShape {
        /// The channel subtype this message template applies to.
        public let channelSubtype: ChannelSubtype
        /// Whether the version of the message template is activated.
        public let isActive: Bool
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The Amazon Resource Name (ARN) of the message template.
        public let messageTemplateArn: String
        /// The identifier of the message template.
        public let messageTemplateId: String
        /// The name of the message template.
        public let name: String
        /// The version number of the message template version.
        public let versionNumber: Int64

        @inlinable
        public init(channelSubtype: ChannelSubtype, isActive: Bool, knowledgeBaseArn: String, knowledgeBaseId: String, messageTemplateArn: String, messageTemplateId: String, name: String, versionNumber: Int64) {
            self.channelSubtype = channelSubtype
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case channelSubtype = "channelSubtype"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case messageTemplateArn = "messageTemplateArn"
            case messageTemplateId = "messageTemplateId"
            case name = "name"
            case versionNumber = "versionNumber"
        }
    }

    public struct NotifyRecommendationsReceivedError: AWSDecodableShape {
        /// A recommendation is causing an error.
        public let message: String?
        /// The identifier of the recommendation that is in error.
        public let recommendationId: String?

        @inlinable
        public init(message: String? = nil, recommendationId: String? = nil) {
            self.message = message
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case recommendationId = "recommendationId"
        }
    }

    public struct NotifyRecommendationsReceivedRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, recommendationIds: [String], sessionId: String) {
            self.assistantId = assistantId
            self.recommendationIds = recommendationIds
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.recommendationIds, forKey: .recommendationIds)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.recommendationIds.forEach {
                try validate($0, name: "recommendationIds[]", parent: name, max: 2048)
                try validate($0, name: "recommendationIds[]", parent: name, min: 1)
            }
            try self.validate(self.recommendationIds, name: "recommendationIds", parent: name, max: 25)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendationIds = "recommendationIds"
        }
    }

    public struct NotifyRecommendationsReceivedResponse: AWSDecodableShape {
        /// The identifiers of recommendations that are causing errors.
        public let errors: [NotifyRecommendationsReceivedError]?
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]?

        @inlinable
        public init(errors: [NotifyRecommendationsReceivedError]? = nil, recommendationIds: [String]? = nil) {
            self.errors = errors
            self.recommendationIds = recommendationIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case recommendationIds = "recommendationIds"
        }
    }

    public struct ParsingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Settings for a foundation model used to parse documents for a data source.
        public let bedrockFoundationModelConfiguration: BedrockFoundationModelConfigurationForParsing?
        /// The parsing strategy for the data source.
        public let parsingStrategy: ParsingStrategy

        @inlinable
        public init(bedrockFoundationModelConfiguration: BedrockFoundationModelConfigurationForParsing? = nil, parsingStrategy: ParsingStrategy) {
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.parsingStrategy = parsingStrategy
        }

        public func validate(name: String) throws {
            try self.bedrockFoundationModelConfiguration?.validate(name: "\(name).bedrockFoundationModelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockFoundationModelConfiguration = "bedrockFoundationModelConfiguration"
            case parsingStrategy = "parsingStrategy"
        }
    }

    public struct ParsingPrompt: AWSEncodableShape & AWSDecodableShape {
        /// Instructions for interpreting the contents of a document.
        public let parsingPromptText: String

        @inlinable
        public init(parsingPromptText: String) {
            self.parsingPromptText = parsingPromptText
        }

        public func validate(name: String) throws {
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, max: 10000)
            try self.validate(self.parsingPromptText, name: "parsingPromptText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parsingPromptText = "parsingPromptText"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// Information about the feedback provided.
        public let contentFeedback: ContentFeedbackData
        /// The identifier of the feedback target.
        public let targetId: String
        /// The type of the feedback target.
        public let targetType: TargetType

        @inlinable
        public init(assistantId: String, contentFeedback: ContentFeedbackData, targetId: String, targetType: TargetType) {
            self.assistantId = assistantId
            self.contentFeedback = contentFeedback
            self.targetId = targetId
            self.targetType = targetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.contentFeedback, forKey: .contentFeedback)
            try container.encode(self.targetId, forKey: .targetId)
            try container.encode(self.targetType, forKey: .targetType)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.targetId, name: "targetId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentFeedback = "contentFeedback"
            case targetId = "targetId"
            case targetType = "targetType"
        }
    }

    public struct PutFeedbackResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// Information about the feedback provided.
        public let contentFeedback: ContentFeedbackData
        /// The identifier of the feedback target.
        public let targetId: String
        /// The type of the feedback target.
        public let targetType: TargetType

        @inlinable
        public init(assistantArn: String, assistantId: String, contentFeedback: ContentFeedbackData, targetId: String, targetType: TargetType) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.contentFeedback = contentFeedback
            self.targetId = targetId
            self.targetType = targetType
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case contentFeedback = "contentFeedback"
            case targetId = "targetId"
            case targetType = "targetType"
        }
    }

    public struct QueryAssistantRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search type to be used against the Knowledge Base for this request. The values can be SEMANTIC which uses vector embeddings or HYBRID which use vector embeddings and raw text.
        public let overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType?
        /// Information about how to query content.
        public let queryCondition: [QueryCondition]?
        /// Information about the query.
        public let queryInputData: QueryInputData?
        /// The text to search for.
        public let queryText: String?
        /// The identifier of the Amazon Q in Connect session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String?

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, overrideKnowledgeBaseSearchType: KnowledgeBaseSearchType? = nil, queryCondition: [QueryCondition]? = nil, queryInputData: QueryInputData? = nil, queryText: String? = nil, sessionId: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.overrideKnowledgeBaseSearchType = overrideKnowledgeBaseSearchType
            self.queryCondition = queryCondition
            self.queryInputData = queryInputData
            self.queryText = queryText
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.overrideKnowledgeBaseSearchType, forKey: .overrideKnowledgeBaseSearchType)
            try container.encodeIfPresent(self.queryCondition, forKey: .queryCondition)
            try container.encodeIfPresent(self.queryInputData, forKey: .queryInputData)
            try container.encodeIfPresent(self.queryText, forKey: .queryText)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.queryCondition?.forEach {
                try $0.validate(name: "\(name).queryCondition[]")
            }
            try self.validate(self.queryCondition, name: "queryCondition", parent: name, max: 1)
            try self.queryInputData?.validate(name: "\(name).queryInputData")
            try self.validate(self.queryText, name: "queryText", parent: name, max: 512)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case overrideKnowledgeBaseSearchType = "overrideKnowledgeBaseSearchType"
            case queryCondition = "queryCondition"
            case queryInputData = "queryInputData"
            case queryText = "queryText"
            case sessionId = "sessionId"
        }
    }

    public struct QueryAssistantResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The results of the query.
        public let results: [ResultData]

        @inlinable
        public init(nextToken: String? = nil, results: [ResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct QueryConditionItem: AWSEncodableShape {
        /// The comparison operator for query condition to query on.
        public let comparator: QueryConditionComparisonOperator
        ///  The name of the field for query condition to query on.
        public let field: QueryConditionFieldName
        /// The value for the query condition to query on.
        public let value: String

        @inlinable
        public init(comparator: QueryConditionComparisonOperator, field: QueryConditionFieldName, value: String) {
            self.comparator = comparator
            self.field = field
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "comparator"
            case field = "field"
            case value = "value"
        }
    }

    public struct QueryRecommendationTriggerData: AWSDecodableShape {
        /// The text associated with the recommendation trigger.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct QueryTextInputData: AWSEncodableShape {
        /// The text to search for.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 512)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct QuickResponseContents: AWSDecodableShape {
        public let markdown: QuickResponseContentProvider?
        public let plainText: QuickResponseContentProvider?

        @inlinable
        public init(markdown: QuickResponseContentProvider? = nil, plainText: QuickResponseContentProvider? = nil) {
            self.markdown = markdown
            self.plainText = plainText
        }

        private enum CodingKeys: String, CodingKey {
            case markdown = "markdown"
            case plainText = "plainText"
        }
    }

    public struct QuickResponseData: AWSDecodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The contents of the quick response.
        public let contents: QuickResponseContents?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response data was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The status of the quick response data.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channels: [String]? = nil, contents: QuickResponseContents? = nil, contentType: String, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, shortcutKey: String? = nil, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.channels = channels
            self.contents = contents
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case contents = "contents"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case shortcutKey = "shortcutKey"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct QuickResponseFilterField: AWSEncodableShape {
        /// Whether to treat null value as a match for the attribute field.
        public let includeNoExistence: Bool?
        /// The name of the attribute field to filter the quick responses by.
        public let name: String
        /// The operator to use for filtering.
        public let `operator`: QuickResponseFilterOperator
        /// The values of attribute field to filter the quick response by.
        public let values: [String]?

        @inlinable
        public init(includeNoExistence: Bool? = nil, name: String, operator: QuickResponseFilterOperator, values: [String]? = nil) {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeNoExistence = "includeNoExistence"
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct QuickResponseOrderField: AWSEncodableShape {
        /// The name of the attribute to order the quick response query results by.
        public let name: String
        /// The order at which the quick responses are sorted by.
        public let order: Order?

        @inlinable
        public init(name: String, order: Order? = nil) {
            self.name = name
            self.order = order
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
        }
    }

    public struct QuickResponseQueryField: AWSEncodableShape {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public let allowFuzziness: Bool?
        /// The name of the attribute to query the quick responses by.
        public let name: String
        /// The operator to use for matching attribute field values in the query.
        public let `operator`: QuickResponseQueryOperator
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public let priority: Priority?
        /// The values of the attribute to query the quick responses by.
        public let values: [String]

        @inlinable
        public init(allowFuzziness: Bool? = nil, name: String, operator: QuickResponseQueryOperator, priority: Priority? = nil, values: [String]) {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowFuzziness = "allowFuzziness"
            case name = "name"
            case `operator` = "operator"
            case priority = "priority"
            case values = "values"
        }
    }

    public struct QuickResponseSearchExpression: AWSEncodableShape {
        /// The configuration of filtering rules applied to quick response query results.
        public let filters: [QuickResponseFilterField]?
        /// The quick response attribute fields on which the query results are ordered.
        public let orderOnField: QuickResponseOrderField?
        /// The quick response query expressions.
        public let queries: [QuickResponseQueryField]?

        @inlinable
        public init(filters: [QuickResponseFilterField]? = nil, orderOnField: QuickResponseOrderField? = nil, queries: [QuickResponseQueryField]? = nil) {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.orderOnField?.validate(name: "\(name).orderOnField")
            try self.queries?.forEach {
                try $0.validate(name: "\(name).queries[]")
            }
            try self.validate(self.queries, name: "queries", parent: name, max: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case orderOnField = "orderOnField"
            case queries = "queries"
        }
    }

    public struct QuickResponseSearchResultData: AWSDecodableShape {
        /// The user defined contact attributes that are resolved when the search result is returned.
        public let attributesInterpolated: [String]?
        /// The user defined contact attributes that are not resolved when the search result is returned.
        public let attributesNotInterpolated: [String]?
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The contents of the quick response.
        public let contents: QuickResponseContents
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written.
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response search result data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response search result data was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The resource status of the quick response.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(attributesInterpolated: [String]? = nil, attributesNotInterpolated: [String]? = nil, channels: [String]? = nil, contents: QuickResponseContents, contentType: String, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, shortcutKey: String? = nil, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.attributesInterpolated = attributesInterpolated
            self.attributesNotInterpolated = attributesNotInterpolated
            self.channels = channels
            self.contents = contents
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributesInterpolated = "attributesInterpolated"
            case attributesNotInterpolated = "attributesNotInterpolated"
            case channels = "channels"
            case contents = "contents"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case shortcutKey = "shortcutKey"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct QuickResponseSummary: AWSDecodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response summary was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The resource status of the quick response.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(channels: [String]? = nil, contentType: String, createdTime: Date, description: String? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.channels = channels
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct RankingData: AWSDecodableShape {
        /// The relevance score of the content.
        public let relevanceLevel: RelevanceLevel?
        /// The relevance level of the recommendation.
        public let relevanceScore: Double?

        @inlinable
        public init(relevanceLevel: RelevanceLevel? = nil, relevanceScore: Double? = nil) {
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
        }

        private enum CodingKeys: String, CodingKey {
            case relevanceLevel = "relevanceLevel"
            case relevanceScore = "relevanceScore"
        }
    }

    public struct RecommendationData: AWSDecodableShape {
        ///  Summary of the recommended content.
        public let data: DataSummary?
        /// The recommended document.
        public let document: Document?
        /// The identifier of the recommendation.
        public let recommendationId: String
        /// The relevance level of the recommendation.
        public let relevanceLevel: RelevanceLevel?
        /// The relevance score of the recommendation.
        public let relevanceScore: Double?
        /// The type of recommendation.
        public let type: RecommendationType?

        @inlinable
        public init(data: DataSummary? = nil, document: Document? = nil, recommendationId: String, relevanceLevel: RelevanceLevel? = nil, relevanceScore: Double? = nil, type: RecommendationType? = nil) {
            self.data = data
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case document = "document"
            case recommendationId = "recommendationId"
            case relevanceLevel = "relevanceLevel"
            case relevanceScore = "relevanceScore"
            case type = "type"
        }
    }

    public struct RecommendationTrigger: AWSDecodableShape {
        /// A union type containing information related to the trigger.
        public let data: RecommendationTriggerData
        /// The identifier of the recommendation trigger.
        public let id: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The source of the recommendation trigger.   ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.   RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        public let source: RecommendationSourceType
        /// The type of recommendation trigger.
        public let type: RecommendationTriggerType

        @inlinable
        public init(data: RecommendationTriggerData, id: String, recommendationIds: [String], source: RecommendationSourceType, type: RecommendationTriggerType) {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case id = "id"
            case recommendationIds = "recommendationIds"
            case source = "source"
            case type = "type"
        }
    }

    public struct RemoveAssistantAIAgentRequest: AWSEncodableShape {
        /// The type of the AI Agent being removed for use by default from the Amazon Q in Connect Assistant.
        public let aiAgentType: AIAgentType
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        @inlinable
        public init(aiAgentType: AIAgentType, assistantId: String) {
            self.aiAgentType = aiAgentType
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aiAgentType, key: "aiAgentType")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveAssistantAIAgentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RemoveKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        @inlinable
        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RenderMessageTemplateRequest: AWSEncodableShape {
        /// An object that specifies the values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the value for that variable.
        public let attributes: MessageTemplateAttributes
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN.
        public let messageTemplateId: String

        @inlinable
        public init(attributes: MessageTemplateAttributes, knowledgeBaseId: String, messageTemplateId: String) {
            self.attributes = attributes
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attributes, forKey: .attributes)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
        }

        public func validate(name: String) throws {
            try self.attributes.validate(name: "\(name).attributes")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
        }
    }

    public struct RenderMessageTemplateResponse: AWSDecodableShape {
        /// The message template attachments.
        public let attachments: [MessageTemplateAttachment]?
        /// The attribute keys that are not resolved.
        public let attributesNotInterpolated: [String]?
        /// The content of the message template.
        public let content: MessageTemplateContentProvider

        @inlinable
        public init(attachments: [MessageTemplateAttachment]? = nil, attributesNotInterpolated: [String]? = nil, content: MessageTemplateContentProvider) {
            self.attachments = attachments
            self.attributesNotInterpolated = attributesNotInterpolated
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "attachments"
            case attributesNotInterpolated = "attributesNotInterpolated"
            case content = "content"
        }
    }

    public struct RenderingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:   Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted    ServiceNow: number, short_description, sys_mod_count, workflow_state, or active    Zendesk: id, title, updated_at, or draft    The variable is replaced with the actual value for a piece of content when calling GetContent.
        public let templateUri: String?

        @inlinable
        public init(templateUri: String? = nil) {
            self.templateUri = templateUri
        }

        public func validate(name: String) throws {
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri = "templateUri"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The specified resource name.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ResultData: AWSDecodableShape {
        ///  Summary of the recommended content.
        public let data: DataSummary?
        /// The document.
        public let document: Document?
        /// The relevance score of the results.
        public let relevanceScore: Double?
        /// The identifier of the result data.
        public let resultId: String
        /// The type of the query result.
        public let type: QueryResultType?

        @inlinable
        public init(data: DataSummary? = nil, document: Document? = nil, relevanceScore: Double? = nil, resultId: String, type: QueryResultType? = nil) {
            self.data = data
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case document = "document"
            case relevanceScore = "relevanceScore"
            case resultId = "resultId"
            case type = "type"
        }
    }

    public struct RuntimeSessionData: AWSEncodableShape & AWSDecodableShape {
        /// The key of the data stored on the session.
        public let key: String
        /// The value of the data stored on the session.
        public let value: RuntimeSessionDataValue

        @inlinable
        public init(key: String, value: RuntimeSessionDataValue) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 4096)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct SMSMessageTemplateContent: AWSEncodableShape & AWSDecodableShape {
        /// The body to use in SMS messages.
        public let body: SMSMessageTemplateContentBody?

        @inlinable
        public init(body: SMSMessageTemplateContentBody? = nil) {
            self.body = body
        }

        public func validate(name: String) throws {
            try self.body?.validate(name: "\(name).body")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
        }
    }

    public struct SMSMessageTemplateContentBody: AWSEncodableShape & AWSDecodableShape {
        /// The message body to use in SMS messages.
        public let plainText: MessageTemplateBodyContentProvider?

        @inlinable
        public init(plainText: MessageTemplateBodyContentProvider? = nil) {
            self.plainText = plainText
        }

        public func validate(name: String) throws {
            try self.plainText?.validate(name: "\(name).plainText")
        }

        private enum CodingKeys: String, CodingKey {
            case plainText = "plainText"
        }
    }

    public struct SearchContentRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchContentResponse: AWSDecodableShape {
        /// Summary information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries = "contentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct SearchExpression: AWSEncodableShape {
        /// The search expression filters.
        public let filters: [Filter]

        @inlinable
        public init(filters: [Filter]) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct SearchMessageTemplatesRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression for querying the message template.
        public let searchExpression: MessageTemplateSearchExpression

        @inlinable
        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: MessageTemplateSearchExpression) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchMessageTemplatesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The results of the message template search.
        public let results: [MessageTemplateSearchResultData]

        @inlinable
        public init(nextToken: String? = nil, results: [MessageTemplateSearchResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct SearchQuickResponsesRequest: AWSEncodableShape {
        /// The user-defined Amazon Connect contact attributes to be resolved when search results are returned.
        public let attributes: [String: String]?
        /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression for querying the quick response.
        public let searchExpression: QuickResponseSearchExpression

        @inlinable
        public init(attributes: [String: String]? = nil, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: QuickResponseSearchExpression) {
            self.attributes = attributes
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchQuickResponsesResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The results of the quick response search.
        public let results: [QuickResponseSearchResultData]

        @inlinable
        public init(nextToken: String? = nil, results: [QuickResponseSearchResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct SearchSessionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        @inlinable
        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchSessionsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary information about the sessions.
        public let sessionSummaries: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionSummaries = "sessionSummaries"
        }
    }

    public struct SeedUrl: AWSEncodableShape & AWSDecodableShape {
        /// URL for crawling
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.url, name: "url", parent: name, pattern: "^https?://[A-Za-z0-9][^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct SelfServiceAIAgentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The association configurations for overriding behavior on this AI Agent.
        public let associationConfigurations: [AssociationConfiguration]?
        /// The AI Guardrail identifier used by the SELF_SERVICE AI Agent.
        public let selfServiceAIGuardrailId: String?
        /// The AI Prompt identifier for the Self Service Answer Generation prompt used by the SELF_SERVICE AI Agent
        public let selfServiceAnswerGenerationAIPromptId: String?
        /// The AI Prompt identifier for the Self Service Pre-Processing prompt used by the SELF_SERVICE AI Agent
        public let selfServicePreProcessingAIPromptId: String?

        @inlinable
        public init(associationConfigurations: [AssociationConfiguration]? = nil, selfServiceAIGuardrailId: String? = nil, selfServiceAnswerGenerationAIPromptId: String? = nil, selfServicePreProcessingAIPromptId: String? = nil) {
            self.associationConfigurations = associationConfigurations
            self.selfServiceAIGuardrailId = selfServiceAIGuardrailId
            self.selfServiceAnswerGenerationAIPromptId = selfServiceAnswerGenerationAIPromptId
            self.selfServicePreProcessingAIPromptId = selfServicePreProcessingAIPromptId
        }

        public func validate(name: String) throws {
            try self.associationConfigurations?.forEach {
                try $0.validate(name: "\(name).associationConfigurations[]")
            }
            try self.validate(self.selfServiceAIGuardrailId, name: "selfServiceAIGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.selfServiceAnswerGenerationAIPromptId, name: "selfServiceAnswerGenerationAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.selfServicePreProcessingAIPromptId, name: "selfServicePreProcessingAIPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationConfigurations = "associationConfigurations"
            case selfServiceAIGuardrailId = "selfServiceAIGuardrailId"
            case selfServiceAnswerGenerationAIPromptId = "selfServiceAnswerGenerationAIPromptId"
            case selfServicePreProcessingAIPromptId = "selfServicePreProcessingAIPromptId"
        }
    }

    public struct SelfServiceConversationHistory: AWSEncodableShape {
        /// The bot response of the conversation history data.
        public let botResponse: String?
        /// The input transcript of the conversation history data.
        public let inputTranscript: String?
        /// The number of turn of the conversation history data.
        public let turnNumber: Int

        @inlinable
        public init(botResponse: String? = nil, inputTranscript: String? = nil, turnNumber: Int) {
            self.botResponse = botResponse
            self.inputTranscript = inputTranscript
            self.turnNumber = turnNumber
        }

        private enum CodingKeys: String, CodingKey {
            case botResponse = "botResponse"
            case inputTranscript = "inputTranscript"
            case turnNumber = "turnNumber"
        }
    }

    public struct SemanticChunkingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The dissimilarity threshold for splitting chunks.
        public let breakpointPercentileThreshold: Int
        /// The buffer size.
        public let bufferSize: Int
        /// The maximum number of tokens that a chunk can contain.
        public let maxTokens: Int

        @inlinable
        public init(breakpointPercentileThreshold: Int, bufferSize: Int, maxTokens: Int) {
            self.breakpointPercentileThreshold = breakpointPercentileThreshold
            self.bufferSize = bufferSize
            self.maxTokens = maxTokens
        }

        private enum CodingKeys: String, CodingKey {
            case breakpointPercentileThreshold = "breakpointPercentileThreshold"
            case bufferSize = "bufferSize"
            case maxTokens = "maxTokens"
        }
    }

    public struct SendMessageRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field.For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The conversation context before the Amazon Q in Connect session.
        public let conversationContext: ConversationContext?
        /// The message data to submit to the Amazon Q in Connect session.
        public let message: MessageInput
        /// The identifier of the Amazon Q in Connect session.
        public let sessionId: String
        /// The message type.
        public let type: MessageType

        @inlinable
        public init(assistantId: String, clientToken: String? = SendMessageRequest.idempotencyToken(), conversationContext: ConversationContext? = nil, message: MessageInput, sessionId: String, type: MessageType) {
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.conversationContext = conversationContext
            self.message = message
            self.sessionId = sessionId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.conversationContext, forKey: .conversationContext)
            try container.encode(self.message, forKey: .message)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.conversationContext?.validate(name: "\(name).conversationContext")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case conversationContext = "conversationContext"
            case message = "message"
            case type = "type"
        }
    }

    public struct SendMessageResponse: AWSDecodableShape {
        /// The token for the next message, used by GetNextMessage.
        public let nextMessageToken: String
        /// The identifier of the submitted message.
        public let requestMessageId: String

        @inlinable
        public init(nextMessageToken: String, requestMessageId: String) {
            self.nextMessageToken = nextMessageToken
            self.requestMessageId = requestMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case nextMessageToken = "nextMessageToken"
            case requestMessageId = "requestMessageId"
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The customer managed key used for encryption. For more information about setting up a customer managed key for Amazon Q in Connect, see Enable Amazon Q in Connect for your instance. For information about valid ID values, see Key identifiers (KeyId).
        public let kmsKeyId: String?

        @inlinable
        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 4096)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct SessionData: AWSDecodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The description of the session.
        public let description: String?
        /// The configuration information for the session integration.
        public let integrationConfiguration: SessionIntegrationConfiguration?
        /// The name of the session.
        public let name: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String
        /// An object that can be used to specify Tag conditions.
        public let tagFilter: TagFilter?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, description: String? = nil, integrationConfiguration: SessionIntegrationConfiguration? = nil, name: String, sessionArn: String, sessionId: String, tagFilter: TagFilter? = nil, tags: [String: String]? = nil) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tagFilter = tagFilter
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case tagFilter = "tagFilter"
            case tags = "tags"
        }
    }

    public struct SessionIntegrationConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public let topicIntegrationArn: String?

        @inlinable
        public init(topicIntegrationArn: String? = nil) {
            self.topicIntegrationArn = topicIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicIntegrationArn = "topicIntegrationArn"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        public let assistantArn: String
        /// The identifier of the Amazon Q in Connect assistant.
        public let assistantId: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String

        @inlinable
        public init(assistantArn: String, assistantId: String, sessionArn: String, sessionId: String) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct SourceContentDataDetails: AWSDecodableShape {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public let citationSpan: CitationSpan?
        /// The identifier of the source content.
        public let id: String
        /// Details about the source content ranking data.
        public let rankingData: RankingData
        ///  Details about the source content text data.
        public let textData: TextData
        /// The type of the source content.
        public let type: SourceContentType

        @inlinable
        public init(citationSpan: CitationSpan? = nil, id: String, rankingData: RankingData, textData: TextData, type: SourceContentType) {
            self.citationSpan = citationSpan
            self.id = id
            self.rankingData = rankingData
            self.textData = textData
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case citationSpan = "citationSpan"
            case id = "id"
            case rankingData = "rankingData"
            case textData = "textData"
            case type = "type"
        }
    }

    public struct StartContentUploadRequest: AWSEncodableShape {
        /// The type of content to upload.
        public let contentType: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The expected expiration time of the generated presigned URL, specified in minutes.
        public let presignedUrlTimeToLive: Int?

        @inlinable
        public init(contentType: String, knowledgeBaseId: String, presignedUrlTimeToLive: Int? = nil) {
            self.contentType = contentType
            self.knowledgeBaseId = knowledgeBaseId
            self.presignedUrlTimeToLive = presignedUrlTimeToLive
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contentType, forKey: .contentType)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.presignedUrlTimeToLive, forKey: .presignedUrlTimeToLive)
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(text/(plain|html|csv))|(application/(pdf|vnd\\.openxmlformats-officedocument\\.wordprocessingml\\.document))|(application/x\\.wisdom-json;source=(salesforce|servicenow|zendesk))$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.presignedUrlTimeToLive, name: "presignedUrlTimeToLive", parent: name, max: 60)
            try self.validate(self.presignedUrlTimeToLive, name: "presignedUrlTimeToLive", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case presignedUrlTimeToLive = "presignedUrlTimeToLive"
        }
    }

    public struct StartContentUploadResponse: AWSDecodableShape {
        /// The headers to include in the upload.
        public let headersToInclude: [String: String]
        /// The identifier of the upload.
        public let uploadId: String
        /// The URL of the upload.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        @inlinable
        public init(headersToInclude: [String: String], uploadId: String, url: String, urlExpiry: Date) {
            self.headersToInclude = headersToInclude
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case headersToInclude = "headersToInclude"
            case uploadId = "uploadId"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct StartImportJobRequest: AWSEncodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let clientToken: String?
        /// The configuration information of the external source that the resource data are imported from.
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The type of the import job.   For importing quick response resource, set the value to QUICK_RESPONSES.
        public let importJobType: ImportJobType
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.   For importing Amazon Q in Connect quick responses, this should be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public let metadata: [String: String]?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        @inlinable
        public init(clientToken: String? = StartImportJobRequest.idempotencyToken(), externalSourceConfiguration: ExternalSourceConfiguration? = nil, importJobType: ImportJobType, knowledgeBaseId: String, metadata: [String: String]? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobType = importJobType
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.externalSourceConfiguration, forKey: .externalSourceConfiguration)
            try container.encode(self.importJobType, forKey: .importJobType)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.externalSourceConfiguration?.validate(name: "\(name).externalSourceConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case importJobType = "importJobType"
            case metadata = "metadata"
            case uploadId = "uploadId"
        }
    }

    public struct StartImportJobResponse: AWSDecodableShape {
        /// The import job.
        public let importJob: ImportJobData?

        @inlinable
        public init(importJob: ImportJobData? = nil) {
            self.importJob = importJob
        }

        private enum CodingKeys: String, CodingKey {
            case importJob = "importJob"
        }
    }

    public struct SystemAttributes: AWSEncodableShape & AWSDecodableShape {
        /// The CustomerEndpoint attribute.
        public let customerEndpoint: SystemEndpointAttributes?
        /// The name of the task.
        public let name: String?
        /// The SystemEndpoint attribute.
        public let systemEndpoint: SystemEndpointAttributes?

        @inlinable
        public init(customerEndpoint: SystemEndpointAttributes? = nil, name: String? = nil, systemEndpoint: SystemEndpointAttributes? = nil) {
            self.customerEndpoint = customerEndpoint
            self.name = name
            self.systemEndpoint = systemEndpoint
        }

        public func validate(name: String) throws {
            try self.customerEndpoint?.validate(name: "\(name).customerEndpoint")
            try self.validate(self.name, name: "name", parent: name, max: 32767)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.systemEndpoint?.validate(name: "\(name).systemEndpoint")
        }

        private enum CodingKeys: String, CodingKey {
            case customerEndpoint = "customerEndpoint"
            case name = "name"
            case systemEndpoint = "systemEndpoint"
        }
    }

    public struct SystemEndpointAttributes: AWSEncodableShape & AWSDecodableShape {
        /// The customer's phone number if used with customerEndpoint, or the number the customer dialed to call your contact center if used with systemEndpoint.
        public let address: String?

        @inlinable
        public init(address: String? = nil) {
            self.address = address
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 32767)
            try self.validate(self.address, name: "address", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
        }
    }

    public struct TagCondition: AWSEncodableShape & AWSDecodableShape {
        /// The tag key in the tag condition.
        public let key: String
        /// The tag value in the tag condition.
        public let value: String?

        @inlinable
        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextData: AWSDecodableShape {
        public let excerpt: DocumentText?
        public let title: DocumentText?

        @inlinable
        public init(excerpt: DocumentText? = nil, title: DocumentText? = nil) {
            self.excerpt = excerpt
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case excerpt = "excerpt"
            case title = "title"
        }
    }

    public struct TextFullAIPromptEditTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The YAML text for the AI Prompt template.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 200000)
            try self.validate(self.text, name: "text", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct TextMessage: AWSEncodableShape & AWSDecodableShape {
        /// The value of the message data in text type.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct TooManyTagsException: AWSErrorShape {
        public let message: String?
        /// The specified resource name.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAIAgentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Agent.
        public let aiAgentId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The configuration of the Amazon Q in Connect AI Agent.
        public let configuration: AIAgentConfiguration?
        /// The description of the Amazon Q in Connect AI Agent.
        public let description: String?
        /// The visbility status of the Amazon Q in Connect AI Agent.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiAgentId: String, assistantId: String, clientToken: String? = UpdateAIAgentRequest.idempotencyToken(), configuration: AIAgentConfiguration? = nil, description: String? = nil, visibilityStatus: VisibilityStatus) {
            self.aiAgentId = aiAgentId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiAgentId, key: "aiAgentId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiAgentId, name: "aiAgentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct UpdateAIAgentResponse: AWSDecodableShape {
        /// The data of the updated Amazon Q in Connect AI Agent.
        public let aiAgent: AIAgentData?

        @inlinable
        public init(aiAgent: AIAgentData? = nil) {
            self.aiAgent = aiAgent
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgent = "aiAgent"
        }
    }

    public struct UpdateAIGuardrailRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        public let aiGuardrailId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The message to return when the AI Guardrail blocks a prompt.
        public let blockedInputMessaging: String
        /// The message to return when the AI Guardrail blocks a model response.
        public let blockedOutputsMessaging: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The content filter policies to configure for the AI Guardrail.
        public let contentPolicyConfig: AIGuardrailContentPolicyConfig?
        /// The contextual grounding policy configuration used to create an AI Guardrail.
        public let contextualGroundingPolicyConfig: AIGuardrailContextualGroundingPolicyConfig?
        /// A description of the AI Guardrail.
        public let description: String?
        /// The sensitive information policy to configure for the AI Guardrail.
        public let sensitiveInformationPolicyConfig: AIGuardrailSensitiveInformationPolicyConfig?
        /// The topic policies to configure for the AI Guardrail.
        public let topicPolicyConfig: AIGuardrailTopicPolicyConfig?
        /// The visibility status of the Amazon Q in Connect AI Guardrail.
        public let visibilityStatus: VisibilityStatus
        /// The word policy you configure for the AI Guardrail.
        public let wordPolicyConfig: AIGuardrailWordPolicyConfig?

        @inlinable
        public init(aiGuardrailId: String, assistantId: String, blockedInputMessaging: String, blockedOutputsMessaging: String, clientToken: String? = UpdateAIGuardrailRequest.idempotencyToken(), contentPolicyConfig: AIGuardrailContentPolicyConfig? = nil, contextualGroundingPolicyConfig: AIGuardrailContextualGroundingPolicyConfig? = nil, description: String? = nil, sensitiveInformationPolicyConfig: AIGuardrailSensitiveInformationPolicyConfig? = nil, topicPolicyConfig: AIGuardrailTopicPolicyConfig? = nil, visibilityStatus: VisibilityStatus, wordPolicyConfig: AIGuardrailWordPolicyConfig? = nil) {
            self.aiGuardrailId = aiGuardrailId
            self.assistantId = assistantId
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.clientToken = clientToken
            self.contentPolicyConfig = contentPolicyConfig
            self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
            self.description = description
            self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
            self.topicPolicyConfig = topicPolicyConfig
            self.visibilityStatus = visibilityStatus
            self.wordPolicyConfig = wordPolicyConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiGuardrailId, key: "aiGuardrailId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.blockedInputMessaging, forKey: .blockedInputMessaging)
            try container.encode(self.blockedOutputsMessaging, forKey: .blockedOutputsMessaging)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.contentPolicyConfig, forKey: .contentPolicyConfig)
            try container.encodeIfPresent(self.contextualGroundingPolicyConfig, forKey: .contextualGroundingPolicyConfig)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.sensitiveInformationPolicyConfig, forKey: .sensitiveInformationPolicyConfig)
            try container.encodeIfPresent(self.topicPolicyConfig, forKey: .topicPolicyConfig)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
            try container.encodeIfPresent(self.wordPolicyConfig, forKey: .wordPolicyConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiGuardrailId, name: "aiGuardrailId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, max: 500)
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, min: 1)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, max: 500)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.contentPolicyConfig?.validate(name: "\(name).contentPolicyConfig")
            try self.contextualGroundingPolicyConfig?.validate(name: "\(name).contextualGroundingPolicyConfig")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.sensitiveInformationPolicyConfig?.validate(name: "\(name).sensitiveInformationPolicyConfig")
            try self.topicPolicyConfig?.validate(name: "\(name).topicPolicyConfig")
            try self.wordPolicyConfig?.validate(name: "\(name).wordPolicyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case blockedInputMessaging = "blockedInputMessaging"
            case blockedOutputsMessaging = "blockedOutputsMessaging"
            case clientToken = "clientToken"
            case contentPolicyConfig = "contentPolicyConfig"
            case contextualGroundingPolicyConfig = "contextualGroundingPolicyConfig"
            case description = "description"
            case sensitiveInformationPolicyConfig = "sensitiveInformationPolicyConfig"
            case topicPolicyConfig = "topicPolicyConfig"
            case visibilityStatus = "visibilityStatus"
            case wordPolicyConfig = "wordPolicyConfig"
        }
    }

    public struct UpdateAIGuardrailResponse: AWSDecodableShape {
        /// The data of the updated Amazon Q in Connect AI Guardrail.
        public let aiGuardrail: AIGuardrailData?

        @inlinable
        public init(aiGuardrail: AIGuardrailData? = nil) {
            self.aiGuardrail = aiGuardrail
        }

        private enum CodingKeys: String, CodingKey {
            case aiGuardrail = "aiGuardrail"
        }
    }

    public struct UpdateAIPromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect AI Prompt.
        public let aiPromptId: String
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs..
        public let clientToken: String?
        /// The description of the Amazon Q in Connect AI Prompt.
        public let description: String?
        /// The configuration of the prompt template for this AI Prompt.
        public let templateConfiguration: AIPromptTemplateConfiguration?
        /// The visibility status of the Amazon Q in Connect AI prompt.
        public let visibilityStatus: VisibilityStatus

        @inlinable
        public init(aiPromptId: String, assistantId: String, clientToken: String? = UpdateAIPromptRequest.idempotencyToken(), description: String? = nil, templateConfiguration: AIPromptTemplateConfiguration? = nil, visibilityStatus: VisibilityStatus) {
            self.aiPromptId = aiPromptId
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.templateConfiguration = templateConfiguration
            self.visibilityStatus = visibilityStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aiPromptId, key: "aiPromptId")
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.templateConfiguration, forKey: .templateConfiguration)
            try container.encode(self.visibilityStatus, forKey: .visibilityStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.aiPromptId, name: "aiPromptId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.templateConfiguration?.validate(name: "\(name).templateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case templateConfiguration = "templateConfiguration"
            case visibilityStatus = "visibilityStatus"
        }
    }

    public struct UpdateAIPromptResponse: AWSDecodableShape {
        /// The data of the updated Amazon Q in Connect AI Prompt.
        public let aiPrompt: AIPromptData?

        @inlinable
        public init(aiPrompt: AIPromptData? = nil) {
            self.aiPrompt = aiPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case aiPrompt = "aiPrompt"
        }
    }

    public struct UpdateAssistantAIAgentRequest: AWSEncodableShape {
        /// The type of the AI Agent being updated for use by default on the Amazon Q in Connect Assistant.
        public let aiAgentType: AIAgentType
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The configuration of the AI Agent being updated for use by default on the Amazon Q in Connect Assistant.
        public let configuration: AIAgentConfigurationData

        @inlinable
        public init(aiAgentType: AIAgentType, assistantId: String, configuration: AIAgentConfigurationData) {
            self.aiAgentType = aiAgentType
            self.assistantId = assistantId
            self.configuration = configuration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.aiAgentType, forKey: .aiAgentType)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.configuration, forKey: .configuration)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentType = "aiAgentType"
            case configuration = "configuration"
        }
    }

    public struct UpdateAssistantAIAgentResponse: AWSDecodableShape {
        public let assistant: AssistantData?

        @inlinable
        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct UpdateContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
        public let overrideLinkOutUri: String?
        /// Unset the existing overrideLinkOutUri if it exists.
        public let removeOverrideLinkOutUri: Bool?
        /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
        public let revisionId: String?
        /// The title of the content.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String?

        @inlinable
        public init(contentId: String, knowledgeBaseId: String, metadata: [String: String]? = nil, overrideLinkOutUri: String? = nil, removeOverrideLinkOutUri: Bool? = nil, revisionId: String? = nil, title: String? = nil, uploadId: String? = nil) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.overrideLinkOutUri = overrideLinkOutUri
            self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
            self.revisionId = revisionId
            self.title = title
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encodeIfPresent(self.overrideLinkOutUri, forKey: .overrideLinkOutUri)
            try container.encodeIfPresent(self.removeOverrideLinkOutUri, forKey: .removeOverrideLinkOutUri)
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encodeIfPresent(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.validate(self.revisionId, name: "revisionId", parent: name, max: 4096)
            try self.validate(self.revisionId, name: "revisionId", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case overrideLinkOutUri = "overrideLinkOutUri"
            case removeOverrideLinkOutUri = "removeOverrideLinkOutUri"
            case revisionId = "revisionId"
            case title = "title"
            case uploadId = "uploadId"
        }
    }

    public struct UpdateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        @inlinable
        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The template URI to update.
        public let templateUri: String

        @inlinable
        public init(knowledgeBaseId: String, templateUri: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.templateUri = templateUri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.templateUri, forKey: .templateUri)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri = "templateUri"
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        /// The knowledge base to update.
        public let knowledgeBase: KnowledgeBaseData?

        @inlinable
        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct UpdateMessageTemplateMetadataRequest: AWSEncodableShape {
        /// The description of the message template.
        public let description: String?
        public let groupingConfiguration: GroupingConfiguration?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String
        /// The name of the message template.
        public let name: String?

        @inlinable
        public init(description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, knowledgeBaseId: String, messageTemplateId: String, name: String? = nil) {
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case name = "name"
        }
    }

    public struct UpdateMessageTemplateMetadataResponse: AWSDecodableShape {
        /// The message template.
        public let messageTemplate: MessageTemplateData?

        @inlinable
        public init(messageTemplate: MessageTemplateData? = nil) {
            self.messageTemplate = messageTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplate = "messageTemplate"
        }
    }

    public struct UpdateMessageTemplateRequest: AWSEncodableShape {
        /// The content of the message template.
        public let content: MessageTemplateContentProvider?
        /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        public let defaultAttributes: MessageTemplateAttributes?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
        public let messageTemplateId: String

        @inlinable
        public init(content: MessageTemplateContentProvider? = nil, defaultAttributes: MessageTemplateAttributes? = nil, knowledgeBaseId: String, language: String? = nil, messageTemplateId: String) {
            self.content = content
            self.defaultAttributes = defaultAttributes
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.messageTemplateId = messageTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encodeIfPresent(self.defaultAttributes, forKey: .defaultAttributes)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            request.encodePath(self.messageTemplateId, key: "messageTemplateId")
        }

        public func validate(name: String) throws {
            try self.content?.validate(name: "\(name).content")
            try self.defaultAttributes?.validate(name: "\(name).defaultAttributes")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:[A-Z0-9_$]+){0,1}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}(:[A-Z0-9_$]+){0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case defaultAttributes = "defaultAttributes"
            case language = "language"
        }
    }

    public struct UpdateMessageTemplateResponse: AWSDecodableShape {
        /// The message template.
        public let messageTemplate: MessageTemplateData?

        @inlinable
        public init(messageTemplate: MessageTemplateData? = nil) {
            self.messageTemplate = messageTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case messageTemplate = "messageTemplate"
        }
    }

    public struct UpdateQuickResponseRequest: AWSEncodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The updated content of the quick response.
        public let content: QuickResponseDataProvider?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String?
        /// The updated description of the quick response.
        public let description: String?
        /// The updated grouping configuration of the quick response.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the quick response.
        public let name: String?
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// Whether to remove the description from the quick response.
        public let removeDescription: Bool?
        /// Whether to remove the grouping configuration of the quick response.
        public let removeGroupingConfiguration: Bool?
        /// Whether to remove the shortcut key of the quick response.
        public let removeShortcutKey: Bool?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?

        @inlinable
        public init(channels: [String]? = nil, content: QuickResponseDataProvider? = nil, contentType: String? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseId: String, language: String? = nil, name: String? = nil, quickResponseId: String, removeDescription: Bool? = nil, removeGroupingConfiguration: Bool? = nil, removeShortcutKey: Bool? = nil, shortcutKey: String? = nil) {
            self.channels = channels
            self.content = content
            self.contentType = contentType
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.quickResponseId = quickResponseId
            self.removeDescription = removeDescription
            self.removeGroupingConfiguration = removeGroupingConfiguration
            self.removeShortcutKey = removeShortcutKey
            self.shortcutKey = shortcutKey
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.channels, forKey: .channels)
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.quickResponseId, key: "quickResponseId")
            try container.encodeIfPresent(self.removeDescription, forKey: .removeDescription)
            try container.encodeIfPresent(self.removeGroupingConfiguration, forKey: .removeGroupingConfiguration)
            try container.encodeIfPresent(self.removeShortcutKey, forKey: .removeShortcutKey)
            try container.encodeIfPresent(self.shortcutKey, forKey: .shortcutKey)
        }

        public func validate(name: String) throws {
            try self.channels?.forEach {
                try validate($0, name: "channels[]", parent: name, max: 10)
                try validate($0, name: "channels[]", parent: name, min: 1)
            }
            try self.content?.validate(name: "\(name).content")
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(application/x\\.quickresponse;format=(plain|markdown))$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, max: 10)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case content = "content"
            case contentType = "contentType"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case language = "language"
            case name = "name"
            case removeDescription = "removeDescription"
            case removeGroupingConfiguration = "removeGroupingConfiguration"
            case removeShortcutKey = "removeShortcutKey"
            case shortcutKey = "shortcutKey"
        }
    }

    public struct UpdateQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        @inlinable
        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct UpdateSessionDataRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The data stored on the Amazon Q in Connect Session.
        public let data: [RuntimeSessionData]
        /// The namespace into which the session data is stored. Supported namespaces are: Custom
        public let namespace: SessionDataNamespace?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        @inlinable
        public init(assistantId: String, data: [RuntimeSessionData], namespace: SessionDataNamespace? = nil, sessionId: String) {
            self.assistantId = assistantId
            self.data = data
            self.namespace = namespace
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.data, forKey: .data)
            try container.encodeIfPresent(self.namespace, forKey: .namespace)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.data.forEach {
                try $0.validate(name: "\(name).data[]")
            }
            try self.validate(self.data, name: "data", parent: name, max: 50)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case namespace = "namespace"
        }
    }

    public struct UpdateSessionDataResponse: AWSDecodableShape {
        /// Data stored in the session.
        public let data: [RuntimeSessionData]
        /// The namespace into which the session data is stored. Supported namespaces are: Custom
        public let namespace: SessionDataNamespace
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String

        @inlinable
        public init(data: [RuntimeSessionData], namespace: SessionDataNamespace, sessionArn: String, sessionId: String) {
            self.data = data
            self.namespace = namespace
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case namespace = "namespace"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct UpdateSessionRequest: AWSEncodableShape {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public let aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The description.
        public let description: String?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String
        /// An object that can be used to specify Tag conditions.
        public let tagFilter: TagFilter?

        @inlinable
        public init(aiAgentConfiguration: [AIAgentType: AIAgentConfigurationData]? = nil, assistantId: String, description: String? = nil, sessionId: String, tagFilter: TagFilter? = nil) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantId = assistantId
            self.description = description
            self.sessionId = sessionId
            self.tagFilter = tagFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.aiAgentConfiguration, forKey: .aiAgentConfiguration)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encodeIfPresent(self.tagFilter, forKey: .tagFilter)
        }

        public func validate(name: String) throws {
            try self.aiAgentConfiguration?.forEach {
                try $0.value.validate(name: "\(name).aiAgentConfiguration[\"\($0.key)\"]")
            }
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
            try self.tagFilter?.validate(name: "\(name).tagFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case aiAgentConfiguration = "aiAgentConfiguration"
            case description = "description"
            case tagFilter = "tagFilter"
        }
    }

    public struct UpdateSessionResponse: AWSDecodableShape {
        public let session: SessionData?

        @inlinable
        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct UrlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// List of URLs for crawling.
        public let seedUrls: [SeedUrl]?

        @inlinable
        public init(seedUrls: [SeedUrl]? = nil) {
            self.seedUrls = seedUrls
        }

        public func validate(name: String) throws {
            try self.seedUrls?.forEach {
                try $0.validate(name: "\(name).seedUrls[]")
            }
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, max: 100)
            try self.validate(self.seedUrls, name: "seedUrls", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case seedUrls = "seedUrls"
        }
    }

    public struct VectorIngestionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public let chunkingConfiguration: ChunkingConfiguration?
        /// A custom parser for data source documents.
        public let parsingConfiguration: ParsingConfiguration?

        @inlinable
        public init(chunkingConfiguration: ChunkingConfiguration? = nil, parsingConfiguration: ParsingConfiguration? = nil) {
            self.chunkingConfiguration = chunkingConfiguration
            self.parsingConfiguration = parsingConfiguration
        }

        public func validate(name: String) throws {
            try self.chunkingConfiguration?.validate(name: "\(name).chunkingConfiguration")
            try self.parsingConfiguration?.validate(name: "\(name).parsingConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chunkingConfiguration = "chunkingConfiguration"
            case parsingConfiguration = "parsingConfiguration"
        }
    }

    public struct WebCrawlerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of crawl limits for the web URLs.
        public let crawlerLimits: WebCrawlerLimits?
        /// A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        public let exclusionFilters: [String]?
        /// A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        public let inclusionFilters: [String]?
        /// The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL https://docs.aws.amazon.com/bedrock/latest/userguide/ and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain aws.amazon.com can also include sub domain docs.aws.amazon.com.
        public let scope: WebScopeType?
        /// The configuration of the URL/URLs for the web content that you want to crawl. You should be authorized to crawl the URLs.
        public let urlConfiguration: UrlConfiguration

        @inlinable
        public init(crawlerLimits: WebCrawlerLimits? = nil, exclusionFilters: [String]? = nil, inclusionFilters: [String]? = nil, scope: WebScopeType? = nil, urlConfiguration: UrlConfiguration) {
            self.crawlerLimits = crawlerLimits
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.scope = scope
            self.urlConfiguration = urlConfiguration
        }

        public func validate(name: String) throws {
            try self.exclusionFilters?.forEach {
                try validate($0, name: "exclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "exclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, max: 25)
            try self.validate(self.exclusionFilters, name: "exclusionFilters", parent: name, min: 1)
            try self.inclusionFilters?.forEach {
                try validate($0, name: "inclusionFilters[]", parent: name, max: 1000)
                try validate($0, name: "inclusionFilters[]", parent: name, min: 1)
            }
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, max: 25)
            try self.validate(self.inclusionFilters, name: "inclusionFilters", parent: name, min: 1)
            try self.urlConfiguration.validate(name: "\(name).urlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerLimits = "crawlerLimits"
            case exclusionFilters = "exclusionFilters"
            case inclusionFilters = "inclusionFilters"
            case scope = "scope"
            case urlConfiguration = "urlConfiguration"
        }
    }

    public struct WebCrawlerLimits: AWSEncodableShape & AWSDecodableShape {
        /// Rate of web URLs retrieved per minute.
        public let rateLimit: Int?

        @inlinable
        public init(rateLimit: Int? = nil) {
            self.rateLimit = rateLimit
        }

        private enum CodingKeys: String, CodingKey {
            case rateLimit = "rateLimit"
        }
    }

    public struct AIPromptTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for a prompt template that supports full textual prompt configuration using a YAML prompt.
        public let textFullAIPromptEditTemplateConfiguration: TextFullAIPromptEditTemplateConfiguration?

        @inlinable
        public init(textFullAIPromptEditTemplateConfiguration: TextFullAIPromptEditTemplateConfiguration? = nil) {
            self.textFullAIPromptEditTemplateConfiguration = textFullAIPromptEditTemplateConfiguration
        }

        public func validate(name: String) throws {
            try self.textFullAIPromptEditTemplateConfiguration?.validate(name: "\(name).textFullAIPromptEditTemplateConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case textFullAIPromptEditTemplateConfiguration = "textFullAIPromptEditTemplateConfiguration"
        }
    }

    public struct AssistantAssociationInputData: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String?

        @inlinable
        public init(knowledgeBaseId: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct AssistantAssociationOutputData: AWSDecodableShape {
        /// The knowledge base where output data is sent.
        public let knowledgeBaseAssociation: KnowledgeBaseAssociationData?

        @inlinable
        public init(knowledgeBaseAssociation: KnowledgeBaseAssociationData? = nil) {
            self.knowledgeBaseAssociation = knowledgeBaseAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseAssociation = "knowledgeBaseAssociation"
        }
    }

    public struct AssociationConfigurationData: AWSEncodableShape & AWSDecodableShape {
        /// The data of the configuration for a KNOWLEDGE_BASE type Amazon Q in Connect Assistant Association.
        public let knowledgeBaseAssociationConfigurationData: KnowledgeBaseAssociationConfigurationData?

        @inlinable
        public init(knowledgeBaseAssociationConfigurationData: KnowledgeBaseAssociationConfigurationData? = nil) {
            self.knowledgeBaseAssociationConfigurationData = knowledgeBaseAssociationConfigurationData
        }

        public func validate(name: String) throws {
            try self.knowledgeBaseAssociationConfigurationData?.validate(name: "\(name).knowledgeBaseAssociationConfigurationData")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseAssociationConfigurationData = "knowledgeBaseAssociationConfigurationData"
        }
    }

    public struct Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information of the Amazon Connect data source.
        public let connectConfiguration: ConnectConfiguration?

        @inlinable
        public init(connectConfiguration: ConnectConfiguration? = nil) {
            self.connectConfiguration = connectConfiguration
        }

        public func validate(name: String) throws {
            try self.connectConfiguration?.validate(name: "\(name).connectConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case connectConfiguration = "connectConfiguration"
        }
    }

    public struct ContentAssociationContents: AWSEncodableShape & AWSDecodableShape {
        /// The data of the step-by-step guide association.
        public let amazonConnectGuideAssociation: AmazonConnectGuideAssociationData?

        @inlinable
        public init(amazonConnectGuideAssociation: AmazonConnectGuideAssociationData? = nil) {
            self.amazonConnectGuideAssociation = amazonConnectGuideAssociation
        }

        public func validate(name: String) throws {
            try self.amazonConnectGuideAssociation?.validate(name: "\(name).amazonConnectGuideAssociation")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonConnectGuideAssociation = "amazonConnectGuideAssociation"
        }
    }

    public struct ContentFeedbackData: AWSEncodableShape & AWSDecodableShape {
        /// Information about the feedback for a generative target type.
        public let generativeContentFeedbackData: GenerativeContentFeedbackData?

        @inlinable
        public init(generativeContentFeedbackData: GenerativeContentFeedbackData? = nil) {
            self.generativeContentFeedbackData = generativeContentFeedbackData
        }

        private enum CodingKeys: String, CodingKey {
            case generativeContentFeedbackData = "generativeContentFeedbackData"
        }
    }

    public struct ManagedSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration data for web crawler data source.
        public let webCrawlerConfiguration: WebCrawlerConfiguration?

        @inlinable
        public init(webCrawlerConfiguration: WebCrawlerConfiguration? = nil) {
            self.webCrawlerConfiguration = webCrawlerConfiguration
        }

        public func validate(name: String) throws {
            try self.webCrawlerConfiguration?.validate(name: "\(name).webCrawlerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case webCrawlerConfiguration = "webCrawlerConfiguration"
        }
    }

    public struct MessageData: AWSEncodableShape & AWSDecodableShape {
        /// The message data in text type.
        public let text: TextMessage?

        @inlinable
        public init(text: TextMessage? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct MessageTemplateBodyContentProvider: AWSEncodableShape & AWSDecodableShape {
        /// The content of the message template.
        public let content: String?

        @inlinable
        public init(content: String? = nil) {
            self.content = content
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct QueryCondition: AWSEncodableShape {
        /// The condition for the query.
        public let single: QueryConditionItem?

        @inlinable
        public init(single: QueryConditionItem? = nil) {
            self.single = single
        }

        public func validate(name: String) throws {
            try self.single?.validate(name: "\(name).single")
        }

        private enum CodingKeys: String, CodingKey {
            case single = "single"
        }
    }

    public struct QuickResponseContentProvider: AWSDecodableShape {
        /// The content of the quick response.
        public let content: String?

        @inlinable
        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct QuickResponseDataProvider: AWSEncodableShape {
        /// The content of the quick response.
        public let content: String?

        @inlinable
        public init(content: String? = nil) {
            self.content = content
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 1024)
            try self.validate(self.content, name: "content", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct RecommendationTriggerData: AWSDecodableShape {
        /// Data associated with the QUERY RecommendationTriggerType.
        public let query: QueryRecommendationTriggerData?

        @inlinable
        public init(query: QueryRecommendationTriggerData? = nil) {
            self.query = query
        }

        private enum CodingKeys: String, CodingKey {
            case query = "query"
        }
    }

    public struct RuntimeSessionDataValue: AWSEncodableShape & AWSDecodableShape {
        /// The string value of the data stored on the session.
        public let stringValue: String?

        @inlinable
        public init(stringValue: String? = nil) {
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 4096)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stringValue = "stringValue"
        }
    }
}

// MARK: - Errors

/// Error enum for QConnect
public struct QConnectErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case preconditionFailedException = "PreconditionFailedException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QConnect
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
    public static var conflictException: Self { .init(.conflictException) }
    /// The provided revisionId does not match, indicating the content has been modified since it was last read.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The request reached the service more than 15 minutes after the date stamp on the request or more than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp on the request is more than 15 minutes in the future.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The throttling limit has been exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Amazon Q in Connect throws this exception if you have too many tags in your tag set.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input fails to satisfy the constraints specified by a service.
    public static var validationException: Self { .init(.validationException) }
}

extension QConnectErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": QConnect.ResourceNotFoundException.self,
        "TooManyTagsException": QConnect.TooManyTagsException.self
    ]
}

extension QConnectErrorType: Equatable {
    public static func == (lhs: QConnectErrorType, rhs: QConnectErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QConnectErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
