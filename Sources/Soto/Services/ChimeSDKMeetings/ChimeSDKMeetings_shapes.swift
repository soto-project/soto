//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ChimeSDKMeetings {
    // MARK: Enums

    public enum ContentResolution: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fhd = "FHD"
        case none = "None"
        case uhd = "UHD"
        public var description: String { return self.rawValue }
    }

    public enum MediaCapabilities: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "None"
        case receive = "Receive"
        case send = "Send"
        case sendReceive = "SendReceive"
        public var description: String { return self.rawValue }
    }

    public enum MeetingFeatureStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeContentIdentificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pii = "PII"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeContentRedactionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pii = "PII"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeLanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deDe = "de-DE"
        case enAu = "en-AU"
        case enGb = "en-GB"
        case enUs = "en-US"
        case esUs = "es-US"
        case frCa = "fr-CA"
        case frFr = "fr-FR"
        case hiIn = "hi-IN"
        case itIt = "it-IT"
        case jaJp = "ja-JP"
        case koKr = "ko-KR"
        case ptBr = "pt-BR"
        case thTh = "th-TH"
        case zhCn = "zh-CN"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeMedicalContentIdentificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case phi = "PHI"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeMedicalLanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enUs = "en-US"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeMedicalRegion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apSoutheast2 = "ap-southeast-2"
        case auto = "auto"
        case caCentral1 = "ca-central-1"
        case euWest1 = "eu-west-1"
        case usEast1 = "us-east-1"
        case usEast2 = "us-east-2"
        case usWest2 = "us-west-2"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeMedicalSpecialty: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cardiology = "CARDIOLOGY"
        case neurology = "NEUROLOGY"
        case oncology = "ONCOLOGY"
        case primarycare = "PRIMARYCARE"
        case radiology = "RADIOLOGY"
        case urology = "UROLOGY"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeMedicalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conversation = "CONVERSATION"
        case dictation = "DICTATION"
        public var description: String { return self.rawValue }
    }

    public enum TranscribePartialResultsStability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "high"
        case low = "low"
        case medium = "medium"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeRegion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apNortheast1 = "ap-northeast-1"
        case apNortheast2 = "ap-northeast-2"
        case apSoutheast2 = "ap-southeast-2"
        case auto = "auto"
        case caCentral1 = "ca-central-1"
        case euCentral1 = "eu-central-1"
        case euWest1 = "eu-west-1"
        case euWest2 = "eu-west-2"
        case saEast1 = "sa-east-1"
        case usEast1 = "us-east-1"
        case usEast2 = "us-east-2"
        case usGovWest1 = "us-gov-west-1"
        case usWest2 = "us-west-2"
        public var description: String { return self.rawValue }
    }

    public enum TranscribeVocabularyFilterMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mask = "mask"
        case remove = "remove"
        case tag = "tag"
        public var description: String { return self.rawValue }
    }

    public enum VideoResolution: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fhd = "FHD"
        case hd = "HD"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Attendee: AWSDecodableShape {
        /// The Amazon Chime SDK attendee ID.
        public let attendeeId: String?
        /// The capabilities assigned to an attendee: audio, video, or content.  You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see  .  When using capabilities, be aware of these corner cases:   If you specify MeetingFeatures:Video:MaxResolution:None when you create a meeting, all API requests  that include SendReceive, Send, or Receive for AttendeeCapabilities:Video will be rejected with ValidationError 400.   If you specify MeetingFeatures:Content:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or  Receive for AttendeeCapabilities:Content will be rejected with ValidationError 400.   You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive  or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability  to receive and you set your content capability to not receive.   When you change an audio capability from None or Receive to Send or SendReceive ,  and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.   When you change a video or content capability from None or Receive to Send or SendReceive ,  and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
        public let capabilities: AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.  Case insensitive.
        public let externalUserId: String?
        /// The join token used by the Amazon Chime SDK attendee.
        public let joinToken: String?

        public init(attendeeId: String? = nil, capabilities: AttendeeCapabilities? = nil, externalUserId: String? = nil, joinToken: String? = nil) {
            self.attendeeId = attendeeId
            self.capabilities = capabilities
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }

        private enum CodingKeys: String, CodingKey {
            case attendeeId = "AttendeeId"
            case capabilities = "Capabilities"
            case externalUserId = "ExternalUserId"
            case joinToken = "JoinToken"
        }
    }

    public struct AttendeeCapabilities: AWSEncodableShape & AWSDecodableShape {
        /// The audio capability assigned to an attendee.
        public let audio: MediaCapabilities
        /// The content capability assigned to an attendee.
        public let content: MediaCapabilities
        /// The video capability assigned to an attendee.
        public let video: MediaCapabilities

        public init(audio: MediaCapabilities, content: MediaCapabilities, video: MediaCapabilities) {
            self.audio = audio
            self.content = content
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
            case content = "Content"
            case video = "Video"
        }
    }

    public struct AttendeeFeatures: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of attendees allowed into the meeting.
        public let maxCount: Int?

        public init(maxCount: Int? = nil) {
            self.maxCount = maxCount
        }

        public func validate(name: String) throws {
            try self.validate(self.maxCount, name: "maxCount", parent: name, max: 250)
            try self.validate(self.maxCount, name: "maxCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxCount = "MaxCount"
        }
    }

    public struct AttendeeIdItem: AWSEncodableShape {
        /// A list of one or more attendee IDs.
        public let attendeeId: String

        public init(attendeeId: String) {
            self.attendeeId = attendeeId
        }

        public func validate(name: String) throws {
            try self.validate(self.attendeeId, name: "attendeeId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attendeeId = "AttendeeId"
        }
    }

    public struct AudioFeatures: AWSEncodableShape & AWSDecodableShape {
        /// Makes echo reduction available to clients who connect to the meeting.
        public let echoReduction: MeetingFeatureStatus?

        public init(echoReduction: MeetingFeatureStatus? = nil) {
            self.echoReduction = echoReduction
        }

        private enum CodingKeys: String, CodingKey {
            case echoReduction = "EchoReduction"
        }
    }

    public struct BatchCreateAttendeeRequest: AWSEncodableShape {
        /// The attendee information, including attendees' IDs and join tokens.
        public let attendees: [CreateAttendeeRequestItem]
        /// The Amazon Chime SDK ID of the meeting to which you're adding attendees.
        public let meetingId: String

        public init(attendees: [CreateAttendeeRequestItem], meetingId: String) {
            self.attendees = attendees
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attendees, forKey: .attendees)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.attendees.forEach {
                try $0.validate(name: "\(name).attendees[]")
            }
            try self.validate(self.attendees, name: "attendees", parent: name, max: 100)
            try self.validate(self.attendees, name: "attendees", parent: name, min: 1)
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attendees = "Attendees"
        }
    }

    public struct BatchCreateAttendeeResponse: AWSDecodableShape {
        /// The attendee information, including attendees' IDs and join tokens.
        public let attendees: [Attendee]?
        /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
        public let errors: [CreateAttendeeError]?

        public init(attendees: [Attendee]? = nil, errors: [CreateAttendeeError]? = nil) {
            self.attendees = attendees
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case attendees = "Attendees"
            case errors = "Errors"
        }
    }

    public struct BatchUpdateAttendeeCapabilitiesExceptRequest: AWSEncodableShape {
        /// The capabilities (audio, video, or content) that you want to update.
        public let capabilities: AttendeeCapabilities
        /// The AttendeeIDs that you want to exclude from one or more capabilities.
        public let excludedAttendeeIds: [AttendeeIdItem]
        /// The ID of the meeting associated with the update request.
        public let meetingId: String

        public init(capabilities: AttendeeCapabilities, excludedAttendeeIds: [AttendeeIdItem], meetingId: String) {
            self.capabilities = capabilities
            self.excludedAttendeeIds = excludedAttendeeIds
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.capabilities, forKey: .capabilities)
            try container.encode(self.excludedAttendeeIds, forKey: .excludedAttendeeIds)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.excludedAttendeeIds.forEach {
                try $0.validate(name: "\(name).excludedAttendeeIds[]")
            }
            try self.validate(self.excludedAttendeeIds, name: "excludedAttendeeIds", parent: name, max: 250)
            try self.validate(self.excludedAttendeeIds, name: "excludedAttendeeIds", parent: name, min: 1)
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case excludedAttendeeIds = "ExcludedAttendeeIds"
        }
    }

    public struct ContentFeatures: AWSEncodableShape & AWSDecodableShape {
        /// The maximum resolution for the meeting content.  Defaults to FHD. To use UHD, you must also provide a MeetingFeatures:Attendee:MaxCount value and override the default size limit of 250 attendees.
        public let maxResolution: ContentResolution?

        public init(maxResolution: ContentResolution? = nil) {
            self.maxResolution = maxResolution
        }

        private enum CodingKeys: String, CodingKey {
            case maxResolution = "MaxResolution"
        }
    }

    public struct CreateAttendeeError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let errorMessage: String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.  Case insensitive.
        public let externalUserId: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, externalUserId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case externalUserId = "ExternalUserId"
        }
    }

    public struct CreateAttendeeRequest: AWSEncodableShape {
        /// The capabilities (audio, video, or content) that you want to grant an attendee. If you don't specify capabilities, all users have send and receive capabilities on  all media channels by default.  You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see  .  When using capabilities, be aware of these corner cases:   If you specify MeetingFeatures:Video:MaxResolution:None when you create a meeting, all API requests  that include SendReceive, Send, or Receive for AttendeeCapabilities:Video will be rejected with ValidationError 400.   If you specify MeetingFeatures:Content:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or  Receive for AttendeeCapabilities:Content will be rejected with ValidationError 400.   You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive  or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability  to receive and you set your content capability to not receive.   When you change an audio capability from None or Receive to Send or SendReceive ,  and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.   When you change a video or content capability from None or Receive to Send or SendReceive ,  and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
        public let capabilities: AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.
        public let externalUserId: String
        /// The unique ID of the meeting.
        public let meetingId: String

        public init(capabilities: AttendeeCapabilities? = nil, externalUserId: String, meetingId: String) {
            self.capabilities = capabilities
            self.externalUserId = externalUserId
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encode(self.externalUserId, forKey: .externalUserId)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.externalUserId, name: "externalUserId", parent: name, max: 64)
            try self.validate(self.externalUserId, name: "externalUserId", parent: name, min: 2)
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case externalUserId = "ExternalUserId"
        }
    }

    public struct CreateAttendeeRequestItem: AWSEncodableShape {
        /// A list of one or more capabilities.
        public let capabilities: AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.  Case insensitive.
        public let externalUserId: String

        public init(capabilities: AttendeeCapabilities? = nil, externalUserId: String) {
            self.capabilities = capabilities
            self.externalUserId = externalUserId
        }

        public func validate(name: String) throws {
            try self.validate(self.externalUserId, name: "externalUserId", parent: name, max: 64)
            try self.validate(self.externalUserId, name: "externalUserId", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case externalUserId = "ExternalUserId"
        }
    }

    public struct CreateAttendeeResponse: AWSDecodableShape {
        /// The attendee information, including attendee ID and join token.
        public let attendee: Attendee?

        public init(attendee: Attendee? = nil) {
            self.attendee = attendee
        }

        private enum CodingKeys: String, CodingKey {
            case attendee = "Attendee"
        }
    }

    public struct CreateMeetingRequest: AWSEncodableShape {
        /// The unique identifier for the client request. Use a different token for different meetings.
        public let clientRequestToken: String
        /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.  Case insensitive.
        public let externalMeetingId: String
        /// The Region in which to create the meeting.  Available values:  af-south-1,  ap-northeast-1,  ap-northeast-2,  ap-south-1,  ap-southeast-1,  ap-southeast-2,            ca-central-1,  eu-central-1,  eu-north-1,  eu-south-1,  eu-west-1,  eu-west-2,  eu-west-3,             sa-east-1,  us-east-1,  us-east-2,  us-west-1,  us-west-2.  Available values in Amazon Web Services GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
        public let mediaRegion: String
        /// Lists the audio and video features enabled for a meeting, such as echo reduction.
        public let meetingFeatures: MeetingFeaturesConfiguration?
        /// Reserved.
        public let meetingHostId: String?
        /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
        public let notificationsConfiguration: NotificationsConfiguration?
        /// When specified, replicates the media from the primary meeting to the new meeting.
        public let primaryMeetingId: String?
        /// Applies one or more tags to an Amazon Chime SDK meeting. Note the following:   Not all resources have tags. For a list of services with resources that support tagging using this operation, see  Services that support the Resource Groups Tagging API. If the resource  doesn't yet support this operation, the resource's service might support tagging using its own API operations. For more information, refer to the documentation for that service.   Each resource can have up to 50 tags. For other limits, see Tag Naming and Usage Conventions in the  AWS General Reference.   You can only tag resources that are located in the specified Amazon Web Services Region for the Amazon Web Services account.   To add tags to a resource, you need the necessary permissions for the service that the resource belongs to as well as permissions for adding tags. For more information, see the  documentation for each service.    Do not store personally identifiable information (PII) or other confidential or sensitive information in tags. We use tags to provide you with billing and administration services. Tags are not intended to be  used for private or sensitive data.   Minimum permissions  In addition to the tag:TagResources permission required by this operation, you must also have the tagging permission defined by the service that created the resource. For example,  to tag a ChimeSDKMeetings instance using the TagResources operation, you must have both of the following permissions:  tag:TagResources   ChimeSDKMeetings:CreateTags   Some services might have specific requirements for tagging some resources. For example, to tag an Amazon S3 bucket, you must also have the s3:GetBucketTagging permission.  If the expected minimum permissions don't work, check the documentation for that service's tagging APIs for more information.
        public let tags: [Tag]?
        /// A consistent and opaque identifier, created and maintained by the builder to represent a segment of their users.
        public let tenantIds: [String]?

        public init(clientRequestToken: String = CreateMeetingRequest.idempotencyToken(), externalMeetingId: String, mediaRegion: String, meetingFeatures: MeetingFeaturesConfiguration? = nil, meetingHostId: String? = nil, notificationsConfiguration: NotificationsConfiguration? = nil, primaryMeetingId: String? = nil, tags: [Tag]? = nil, tenantIds: [String]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.externalMeetingId = externalMeetingId
            self.mediaRegion = mediaRegion
            self.meetingFeatures = meetingFeatures
            self.meetingHostId = meetingHostId
            self.notificationsConfiguration = notificationsConfiguration
            self.primaryMeetingId = primaryMeetingId
            self.tags = tags
            self.tenantIds = tenantIds
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.externalMeetingId, name: "externalMeetingId", parent: name, max: 64)
            try self.validate(self.externalMeetingId, name: "externalMeetingId", parent: name, min: 2)
            try self.validate(self.mediaRegion, name: "mediaRegion", parent: name, max: 64)
            try self.validate(self.mediaRegion, name: "mediaRegion", parent: name, min: 2)
            try self.meetingFeatures?.validate(name: "\(name).meetingFeatures")
            try self.validate(self.meetingHostId, name: "meetingHostId", parent: name, max: 64)
            try self.validate(self.meetingHostId, name: "meetingHostId", parent: name, min: 2)
            try self.notificationsConfiguration?.validate(name: "\(name).notificationsConfiguration")
            try self.validate(self.primaryMeetingId, name: "primaryMeetingId", parent: name, max: 64)
            try self.validate(self.primaryMeetingId, name: "primaryMeetingId", parent: name, min: 2)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.tenantIds?.forEach {
                try validate($0, name: "tenantIds[]", parent: name, max: 256)
                try validate($0, name: "tenantIds[]", parent: name, min: 2)
                try validate($0, name: "tenantIds[]", parent: name, pattern: "^(?!.*?(.)\\1{3})[-_!@#$a-zA-Z0-9]*$")
            }
            try self.validate(self.tenantIds, name: "tenantIds", parent: name, max: 5)
            try self.validate(self.tenantIds, name: "tenantIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case externalMeetingId = "ExternalMeetingId"
            case mediaRegion = "MediaRegion"
            case meetingFeatures = "MeetingFeatures"
            case meetingHostId = "MeetingHostId"
            case notificationsConfiguration = "NotificationsConfiguration"
            case primaryMeetingId = "PrimaryMeetingId"
            case tags = "Tags"
            case tenantIds = "TenantIds"
        }
    }

    public struct CreateMeetingResponse: AWSDecodableShape {
        /// The meeting information, including the meeting ID and  MediaPlacement.
        public let meeting: Meeting?

        public init(meeting: Meeting? = nil) {
            self.meeting = meeting
        }

        private enum CodingKeys: String, CodingKey {
            case meeting = "Meeting"
        }
    }

    public struct CreateMeetingWithAttendeesRequest: AWSEncodableShape {
        /// The attendee information, including attendees' IDs and join tokens.
        public let attendees: [CreateAttendeeRequestItem]
        /// The unique identifier for the client request. Use a different token for different meetings.
        public let clientRequestToken: String
        /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.  Case insensitive.
        public let externalMeetingId: String
        /// The Region in which to create the meeting.  Available values:  af-south-1,  ap-northeast-1,  ap-northeast-2,  ap-south-1,  ap-southeast-1,  ap-southeast-2,            ca-central-1,  eu-central-1,  eu-north-1,  eu-south-1,  eu-west-1,  eu-west-2,  eu-west-3,             sa-east-1,  us-east-1,  us-east-2,  us-west-1,  us-west-2.  Available values in Amazon Web Services GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
        public let mediaRegion: String
        /// Lists the audio and video features enabled for a meeting, such as echo reduction.
        public let meetingFeatures: MeetingFeaturesConfiguration?
        /// Reserved.
        public let meetingHostId: String?
        /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
        public let notificationsConfiguration: NotificationsConfiguration?
        /// When specified, replicates the media from the primary meeting to the new meeting.
        public let primaryMeetingId: String?
        /// The tags in the request.
        public let tags: [Tag]?
        /// A consistent and opaque identifier, created and maintained by the builder to represent a segment of their users.
        public let tenantIds: [String]?

        public init(attendees: [CreateAttendeeRequestItem], clientRequestToken: String = CreateMeetingWithAttendeesRequest.idempotencyToken(), externalMeetingId: String, mediaRegion: String, meetingFeatures: MeetingFeaturesConfiguration? = nil, meetingHostId: String? = nil, notificationsConfiguration: NotificationsConfiguration? = nil, primaryMeetingId: String? = nil, tags: [Tag]? = nil, tenantIds: [String]? = nil) {
            self.attendees = attendees
            self.clientRequestToken = clientRequestToken
            self.externalMeetingId = externalMeetingId
            self.mediaRegion = mediaRegion
            self.meetingFeatures = meetingFeatures
            self.meetingHostId = meetingHostId
            self.notificationsConfiguration = notificationsConfiguration
            self.primaryMeetingId = primaryMeetingId
            self.tags = tags
            self.tenantIds = tenantIds
        }

        public func validate(name: String) throws {
            try self.attendees.forEach {
                try $0.validate(name: "\(name).attendees[]")
            }
            try self.validate(self.attendees, name: "attendees", parent: name, max: 20)
            try self.validate(self.attendees, name: "attendees", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.externalMeetingId, name: "externalMeetingId", parent: name, max: 64)
            try self.validate(self.externalMeetingId, name: "externalMeetingId", parent: name, min: 2)
            try self.validate(self.mediaRegion, name: "mediaRegion", parent: name, max: 64)
            try self.validate(self.mediaRegion, name: "mediaRegion", parent: name, min: 2)
            try self.meetingFeatures?.validate(name: "\(name).meetingFeatures")
            try self.validate(self.meetingHostId, name: "meetingHostId", parent: name, max: 64)
            try self.validate(self.meetingHostId, name: "meetingHostId", parent: name, min: 2)
            try self.notificationsConfiguration?.validate(name: "\(name).notificationsConfiguration")
            try self.validate(self.primaryMeetingId, name: "primaryMeetingId", parent: name, max: 64)
            try self.validate(self.primaryMeetingId, name: "primaryMeetingId", parent: name, min: 2)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.tenantIds?.forEach {
                try validate($0, name: "tenantIds[]", parent: name, max: 256)
                try validate($0, name: "tenantIds[]", parent: name, min: 2)
                try validate($0, name: "tenantIds[]", parent: name, pattern: "^(?!.*?(.)\\1{3})[-_!@#$a-zA-Z0-9]*$")
            }
            try self.validate(self.tenantIds, name: "tenantIds", parent: name, max: 5)
            try self.validate(self.tenantIds, name: "tenantIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attendees = "Attendees"
            case clientRequestToken = "ClientRequestToken"
            case externalMeetingId = "ExternalMeetingId"
            case mediaRegion = "MediaRegion"
            case meetingFeatures = "MeetingFeatures"
            case meetingHostId = "MeetingHostId"
            case notificationsConfiguration = "NotificationsConfiguration"
            case primaryMeetingId = "PrimaryMeetingId"
            case tags = "Tags"
            case tenantIds = "TenantIds"
        }
    }

    public struct CreateMeetingWithAttendeesResponse: AWSDecodableShape {
        /// The attendee information, including attendees' IDs and join tokens.
        public let attendees: [Attendee]?
        /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
        public let errors: [CreateAttendeeError]?
        /// The meeting information, including the meeting ID and  MediaPlacement.
        public let meeting: Meeting?

        public init(attendees: [Attendee]? = nil, errors: [CreateAttendeeError]? = nil, meeting: Meeting? = nil) {
            self.attendees = attendees
            self.errors = errors
            self.meeting = meeting
        }

        private enum CodingKeys: String, CodingKey {
            case attendees = "Attendees"
            case errors = "Errors"
            case meeting = "Meeting"
        }
    }

    public struct DeleteAttendeeRequest: AWSEncodableShape {
        /// The Amazon Chime SDK attendee ID.
        public let attendeeId: String
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String

        public init(attendeeId: String, meetingId: String) {
            self.attendeeId = attendeeId
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attendeeId, key: "AttendeeId")
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attendeeId, name: "attendeeId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMeetingRequest: AWSEncodableShape {
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String

        public init(meetingId: String) {
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct EngineTranscribeMedicalSettings: AWSEncodableShape {
        /// Set this field to PHI to identify personal health information in the transcription output.
        public let contentIdentificationType: TranscribeMedicalContentIdentificationType?
        /// The language code specified for the Amazon Transcribe Medical engine.
        public let languageCode: TranscribeMedicalLanguageCode
        /// The Amazon Web Services Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public let region: TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        public let specialty: TranscribeMedicalSpecialty
        /// The type of transcription.
        public let type: TranscribeMedicalType
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public let vocabularyName: String?

        public init(contentIdentificationType: TranscribeMedicalContentIdentificationType? = nil, languageCode: TranscribeMedicalLanguageCode, region: TranscribeMedicalRegion? = nil, specialty: TranscribeMedicalSpecialty, type: TranscribeMedicalType, vocabularyName: String? = nil) {
            self.contentIdentificationType = contentIdentificationType
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }

        public func validate(name: String) throws {
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case contentIdentificationType = "ContentIdentificationType"
            case languageCode = "LanguageCode"
            case region = "Region"
            case specialty = "Specialty"
            case type = "Type"
            case vocabularyName = "VocabularyName"
        }
    }

    public struct EngineTranscribeSettings: AWSEncodableShape {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified.  You can’t set ContentIdentificationType and ContentRedactionType.
        public let contentIdentificationType: TranscribeContentIdentificationType?
        /// Content redaction is performed at the segment level. If you don't include PiiEntityTypes, all PII is redacted.  You can’t set ContentRedactionType and ContentIdentificationType.
        public let contentRedactionType: TranscribeContentRedactionType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.
        public let enablePartialResultsStabilization: Bool?
        /// Enables automatic language identification for your transcription. If you include IdentifyLanguage, you can optionally use LanguageOptions to include a list of language codes that you think may be present in your audio stream.  Including language options can improve transcription accuracy. You can also use PreferredLanguage to include a preferred language. Doing so can help Amazon Transcribe identify the language faster. You must include either LanguageCode or IdentifyLanguage. Language identification can't be combined with custom language models or redaction.
        public let identifyLanguage: Bool?
        /// Specify the language code that represents the language spoken. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification.
        public let languageCode: TranscribeLanguageCode?
        /// Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with  a language mismatch. If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.
        public let languageModelName: String?
        /// Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages  are present, do not include this parameter. Including language options can improve the accuracy of language identification. If you include LanguageOptions, you must also include IdentifyLanguage.  You can only include one language dialect per language. For example, you cannot include en-US and en-AU.
        public let languageOptions: String?
        /// Specify the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.
        public let partialResultsStability: TranscribePartialResultsStability?
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRY CREDIT_DEBIT_NUMBER, EMAIL,NAME, PHONE,  PIN,  SSN, or ALL. Note that if you include PiiEntityTypes, you must also include ContentIdentificationType or ContentRedactionType. If you include ContentRedactionType or ContentIdentificationType, but do not include PiiEntityTypes, all PII is redacted or identified.
        public let piiEntityTypes: String?
        /// Specify a preferred language from the subset of languages codes you specified in LanguageOptions. You can only use this parameter if you include IdentifyLanguage and LanguageOptions.
        public let preferredLanguage: TranscribeLanguageCode?
        /// The Amazon Web Services Region in which to use Amazon Transcribe. If you don't specify a Region, then the MediaRegion of the meeting is used.   However, if Amazon Transcribe is not available in the MediaRegion, then a TranscriptFailed event is sent. Use auto to use Amazon Transcribe in a Region near the meeting’s MediaRegion.  For more information, refer to  Choosing a transcription Region in the  Amazon Chime SDK Developer Guide.
        public let region: TranscribeRegion?
        /// Specify how you want your vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public let vocabularyFilterMethod: TranscribeVocabularyFilterMethod?
        /// Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.  If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more vocabulary filters with your transcription, use the VocabularyFilterNames parameter instead.
        public let vocabularyFilterName: String?
        /// Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you're not including IdentifyLanguage and want to use a custom vocabulary filter with your transcription, use the VocabularyFilterName  parameter instead.
        public let vocabularyFilterNames: String?
        /// Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more custom vocabularies with your transcription, use the VocabularyNames  parameter instead.
        public let vocabularyName: String?
        /// Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you don't include IdentifyLanguage and want to use a custom vocabulary with your transcription, use the VocabularyName parameter instead.
        public let vocabularyNames: String?

        public init(contentIdentificationType: TranscribeContentIdentificationType? = nil, contentRedactionType: TranscribeContentRedactionType? = nil, enablePartialResultsStabilization: Bool? = nil, identifyLanguage: Bool? = nil, languageCode: TranscribeLanguageCode? = nil, languageModelName: String? = nil, languageOptions: String? = nil, partialResultsStability: TranscribePartialResultsStability? = nil, piiEntityTypes: String? = nil, preferredLanguage: TranscribeLanguageCode? = nil, region: TranscribeRegion? = nil, vocabularyFilterMethod: TranscribeVocabularyFilterMethod? = nil, vocabularyFilterName: String? = nil, vocabularyFilterNames: String? = nil, vocabularyName: String? = nil, vocabularyNames: String? = nil) {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }

        public func validate(name: String) throws {
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, max: 200)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, min: 1)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.languageOptions, name: "languageOptions", parent: name, max: 200)
            try self.validate(self.languageOptions, name: "languageOptions", parent: name, min: 1)
            try self.validate(self.languageOptions, name: "languageOptions", parent: name, pattern: "^[a-zA-Z-,]+$")
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, max: 300)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, min: 1)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, pattern: "^[A-Z_, ]+$")
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, max: 4096)
            try self.validate(self.vocabularyFilterNames, name: "vocabularyFilterNames", parent: name, max: 3000)
            try self.validate(self.vocabularyFilterNames, name: "vocabularyFilterNames", parent: name, min: 1)
            try self.validate(self.vocabularyFilterNames, name: "vocabularyFilterNames", parent: name, pattern: "^[a-zA-Z0-9,-._]+$")
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, max: 4096)
            try self.validate(self.vocabularyNames, name: "vocabularyNames", parent: name, max: 3000)
            try self.validate(self.vocabularyNames, name: "vocabularyNames", parent: name, min: 1)
            try self.validate(self.vocabularyNames, name: "vocabularyNames", parent: name, pattern: "^[a-zA-Z0-9,-._]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentIdentificationType = "ContentIdentificationType"
            case contentRedactionType = "ContentRedactionType"
            case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
            case identifyLanguage = "IdentifyLanguage"
            case languageCode = "LanguageCode"
            case languageModelName = "LanguageModelName"
            case languageOptions = "LanguageOptions"
            case partialResultsStability = "PartialResultsStability"
            case piiEntityTypes = "PiiEntityTypes"
            case preferredLanguage = "PreferredLanguage"
            case region = "Region"
            case vocabularyFilterMethod = "VocabularyFilterMethod"
            case vocabularyFilterName = "VocabularyFilterName"
            case vocabularyFilterNames = "VocabularyFilterNames"
            case vocabularyName = "VocabularyName"
            case vocabularyNames = "VocabularyNames"
        }
    }

    public struct GetAttendeeRequest: AWSEncodableShape {
        /// The Amazon Chime SDK attendee ID.
        public let attendeeId: String
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String

        public init(attendeeId: String, meetingId: String) {
            self.attendeeId = attendeeId
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attendeeId, key: "AttendeeId")
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attendeeId, name: "attendeeId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAttendeeResponse: AWSDecodableShape {
        /// The Amazon Chime SDK attendee information.
        public let attendee: Attendee?

        public init(attendee: Attendee? = nil) {
            self.attendee = attendee
        }

        private enum CodingKeys: String, CodingKey {
            case attendee = "Attendee"
        }
    }

    public struct GetMeetingRequest: AWSEncodableShape {
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String

        public init(meetingId: String) {
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMeetingResponse: AWSDecodableShape {
        /// The Amazon Chime SDK meeting information.
        public let meeting: Meeting?

        public init(meeting: Meeting? = nil) {
            self.meeting = meeting
        }

        private enum CodingKeys: String, CodingKey {
            case meeting = "Meeting"
        }
    }

    public struct ListAttendeesRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, meetingId: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.meetingId = meetingId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.meetingId, key: "MeetingId")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAttendeesResponse: AWSDecodableShape {
        /// The Amazon Chime SDK attendee information.
        public let attendees: [Attendee]?
        /// The token to use to retrieve the next page of results.
        public let nextToken: String?

        public init(attendees: [Attendee]? = nil, nextToken: String? = nil) {
            self.attendees = attendees
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case attendees = "Attendees"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags requested for the specified resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MediaPlacement: AWSDecodableShape {
        /// The audio fallback URL.
        public let audioFallbackUrl: String?
        /// The audio host URL.
        public let audioHostUrl: String?
        /// The event ingestion URL.
        public let eventIngestionUrl: String?
        /// The screen data URL.   This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public let screenDataUrl: String?
        /// The screen sharing URL.   This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public let screenSharingUrl: String?
        /// The screen viewing URL.   This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public let screenViewingUrl: String?
        /// The signaling URL.
        public let signalingUrl: String?
        /// The turn control URL.   This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public let turnControlUrl: String?

        public init(audioFallbackUrl: String? = nil, audioHostUrl: String? = nil, eventIngestionUrl: String? = nil, screenDataUrl: String? = nil, screenSharingUrl: String? = nil, screenViewingUrl: String? = nil, signalingUrl: String? = nil, turnControlUrl: String? = nil) {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }

        private enum CodingKeys: String, CodingKey {
            case audioFallbackUrl = "AudioFallbackUrl"
            case audioHostUrl = "AudioHostUrl"
            case eventIngestionUrl = "EventIngestionUrl"
            case screenDataUrl = "ScreenDataUrl"
            case screenSharingUrl = "ScreenSharingUrl"
            case screenViewingUrl = "ScreenViewingUrl"
            case signalingUrl = "SignalingUrl"
            case turnControlUrl = "TurnControlUrl"
        }
    }

    public struct Meeting: AWSDecodableShape {
        /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]*  Values that begin with aws: are reserved. You can't configure a value that uses this prefix.  Case insensitive.
        public let externalMeetingId: String?
        /// The media placement for the meeting.
        public let mediaPlacement: MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1,  ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1,  eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in Amazon Web Services GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
        public let mediaRegion: String?
        /// The ARN of the meeting.
        public let meetingArn: String?
        /// The features available to a meeting, such as echo reduction.
        public let meetingFeatures: MeetingFeaturesConfiguration?
        /// Reserved.
        public let meetingHostId: String?
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String?
        /// When specified, replicates the media from the primary meeting to this meeting.
        public let primaryMeetingId: String?
        /// Array of strings.
        public let tenantIds: [String]?

        public init(externalMeetingId: String? = nil, mediaPlacement: MediaPlacement? = nil, mediaRegion: String? = nil, meetingArn: String? = nil, meetingFeatures: MeetingFeaturesConfiguration? = nil, meetingHostId: String? = nil, meetingId: String? = nil, primaryMeetingId: String? = nil, tenantIds: [String]? = nil) {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingArn = meetingArn
            self.meetingFeatures = meetingFeatures
            self.meetingHostId = meetingHostId
            self.meetingId = meetingId
            self.primaryMeetingId = primaryMeetingId
            self.tenantIds = tenantIds
        }

        private enum CodingKeys: String, CodingKey {
            case externalMeetingId = "ExternalMeetingId"
            case mediaPlacement = "MediaPlacement"
            case mediaRegion = "MediaRegion"
            case meetingArn = "MeetingArn"
            case meetingFeatures = "MeetingFeatures"
            case meetingHostId = "MeetingHostId"
            case meetingId = "MeetingId"
            case primaryMeetingId = "PrimaryMeetingId"
            case tenantIds = "TenantIds"
        }
    }

    public struct MeetingFeaturesConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings for the attendee features available to a meeting.
        public let attendee: AttendeeFeatures?
        /// The configuration settings for the audio features available to a meeting.
        public let audio: AudioFeatures?
        /// The configuration settings for the content features available to a meeting.
        public let content: ContentFeatures?
        /// The configuration settings for the video features available to a meeting.
        public let video: VideoFeatures?

        public init(attendee: AttendeeFeatures? = nil, audio: AudioFeatures? = nil, content: ContentFeatures? = nil, video: VideoFeatures? = nil) {
            self.attendee = attendee
            self.audio = audio
            self.content = content
            self.video = video
        }

        public func validate(name: String) throws {
            try self.attendee?.validate(name: "\(name).attendee")
        }

        private enum CodingKeys: String, CodingKey {
            case attendee = "Attendee"
            case audio = "Audio"
            case content = "Content"
            case video = "Video"
        }
    }

    public struct NotificationsConfiguration: AWSEncodableShape {
        /// The ARN of the Amazon Web Services Lambda function in the notifications configuration.
        public let lambdaFunctionArn: String?
        /// The ARN of the SNS topic.
        public let snsTopicArn: String?
        /// The ARN of the SQS queue.
        public let sqsQueueArn: String?

        public init(lambdaFunctionArn: String? = nil, snsTopicArn: String? = nil, sqsQueueArn: String? = nil) {
            self.lambdaFunctionArn = lambdaFunctionArn
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, max: 1024)
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, min: 1)
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 1024)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, min: 1)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.validate(self.sqsQueueArn, name: "sqsQueueArn", parent: name, max: 1024)
            try self.validate(self.sqsQueueArn, name: "sqsQueueArn", parent: name, min: 1)
            try self.validate(self.sqsQueueArn, name: "sqsQueueArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctionArn = "LambdaFunctionArn"
            case snsTopicArn = "SnsTopicArn"
            case sqsQueueArn = "SqsQueueArn"
        }
    }

    public struct StartMeetingTranscriptionRequest: AWSEncodableShape {
        /// The unique ID of the meeting being transcribed.
        public let meetingId: String
        /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or  EngineTranscribeMedicalSettings.
        public let transcriptionConfiguration: TranscriptionConfiguration

        public init(meetingId: String, transcriptionConfiguration: TranscriptionConfiguration) {
            self.meetingId = meetingId
            self.transcriptionConfiguration = transcriptionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meetingId, key: "MeetingId")
            try container.encode(self.transcriptionConfiguration, forKey: .transcriptionConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            try self.transcriptionConfiguration.validate(name: "\(name).transcriptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case transcriptionConfiguration = "TranscriptionConfiguration"
        }
    }

    public struct StopMeetingTranscriptionRequest: AWSEncodableShape {
        /// The unique ID of the meeting for which you stop transcription.
        public let meetingId: String

        public init(meetingId: String) {
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag's key.
        public let key: String
        /// The tag's value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// Lists the requested tags.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TranscriptionConfiguration: AWSEncodableShape {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public let engineTranscribeMedicalSettings: EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public let engineTranscribeSettings: EngineTranscribeSettings?

        public init(engineTranscribeMedicalSettings: EngineTranscribeMedicalSettings? = nil, engineTranscribeSettings: EngineTranscribeSettings? = nil) {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }

        public func validate(name: String) throws {
            try self.engineTranscribeMedicalSettings?.validate(name: "\(name).engineTranscribeMedicalSettings")
            try self.engineTranscribeSettings?.validate(name: "\(name).engineTranscribeSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case engineTranscribeMedicalSettings = "EngineTranscribeMedicalSettings"
            case engineTranscribeSettings = "EngineTranscribeSettings"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource that you're removing tags from.
        public let resourceARN: String
        /// The tag keys being removed from the resources.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAttendeeCapabilitiesRequest: AWSEncodableShape {
        /// The ID of the attendee associated with the update request.
        public let attendeeId: String
        /// The capabilities that you want to update.
        public let capabilities: AttendeeCapabilities
        /// The ID of the meeting associated with the update request.
        public let meetingId: String

        public init(attendeeId: String, capabilities: AttendeeCapabilities, meetingId: String) {
            self.attendeeId = attendeeId
            self.capabilities = capabilities
            self.meetingId = meetingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attendeeId, key: "AttendeeId")
            try container.encode(self.capabilities, forKey: .capabilities)
            request.encodePath(self.meetingId, key: "MeetingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attendeeId, name: "attendeeId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            try self.validate(self.meetingId, name: "meetingId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
        }
    }

    public struct UpdateAttendeeCapabilitiesResponse: AWSDecodableShape {
        /// The updated attendee data.
        public let attendee: Attendee?

        public init(attendee: Attendee? = nil) {
            self.attendee = attendee
        }

        private enum CodingKeys: String, CodingKey {
            case attendee = "Attendee"
        }
    }

    public struct VideoFeatures: AWSEncodableShape & AWSDecodableShape {
        /// The maximum video resolution for the meeting. Applies to all attendees.  Defaults to HD. To use FHD, you must also provide a MeetingFeatures:Attendee:MaxCount value and override the default size  limit of 250 attendees.
        public let maxResolution: VideoResolution?

        public init(maxResolution: VideoResolution? = nil) {
            self.maxResolution = maxResolution
        }

        private enum CodingKeys: String, CodingKey {
            case maxResolution = "MaxResolution"
        }
    }
}

// MARK: - Errors

/// Error enum for ChimeSDKMeetings
public struct ChimeSDKMeetingsErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceFailureException = "ServiceFailureException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case unauthorizedException = "UnauthorizedException"
        case unprocessableEntityException = "UnprocessableEntityException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ChimeSDKMeetings
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The input parameters don't match the service's restrictions.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// Multiple instances of the same request have been made simultaneously.
    public static var conflictException: Self { .init(.conflictException) }
    /// The client is permanently forbidden from making the request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// The request exceeds the resource limit.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// One or more of the resources in the request does not exist in the system.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The resource that you want to tag couldn't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service encountered an unexpected error.
    public static var serviceFailureException: Self { .init(.serviceFailureException) }
    /// The service is currently unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The number of customer requests exceeds the request rate limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Too many tags were added to the specified resource.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The user isn't authorized to request a resource.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The request was well-formed but was unable to be followed due to semantic errors.
    public static var unprocessableEntityException: Self { .init(.unprocessableEntityException) }
}

extension ChimeSDKMeetingsErrorType: Equatable {
    public static func == (lhs: ChimeSDKMeetingsErrorType, rhs: ChimeSDKMeetingsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ChimeSDKMeetingsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
