//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension IoTTwinMaker {
    // MARK: Enums

    public enum ComponentUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalFailure = "INTERNAL_FAILURE"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum InterpolationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case linear = "LINEAR"
        public var description: String { return self.rawValue }
    }

    public enum OrderByTime: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum ParentEntityUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum PropertyUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum Scope: String, CustomStringConvertible, Codable, _SotoSendable {
        case entity = "ENTITY"
        case workspace = "WORKSPACE"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case error = "ERROR"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, _SotoSendable {
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case list = "LIST"
        case long = "LONG"
        case map = "MAP"
        case relationship = "RELATIONSHIP"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ListComponentTypesFilter: AWSEncodableShape, _SotoSendable {
        /// The component type that the component types in the list extend.
        case extendsFrom(String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isAbstract(Bool)
        /// The namespace to which the component types in the list belong.
        case namespace(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .extendsFrom(let value):
                try container.encode(value, forKey: .extendsFrom)
            case .isAbstract(let value):
                try container.encode(value, forKey: .isAbstract)
            case .namespace(let value):
                try container.encode(value, forKey: .namespace)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .extendsFrom(let value):
                try self.validate(value, name: "extendsFrom", parent: name, max: 256)
                try self.validate(value, name: "extendsFrom", parent: name, min: 1)
                try self.validate(value, name: "extendsFrom", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            case .namespace(let value):
                try self.validate(value, name: "namespace", parent: name, max: 256)
                try self.validate(value, name: "namespace", parent: name, min: 1)
                try self.validate(value, name: "namespace", parent: name, pattern: ".*")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case extendsFrom
            case isAbstract
            case namespace
        }
    }

    public enum ListEntitiesFilter: AWSEncodableShape, _SotoSendable {
        /// The ID of the component type in the entities in the list.
        case componentTypeId(String)
        /// The external-Id property of a component. The external-Id property is the primary key of an external storage system.
        case externalId(String)
        /// The parent of the entities in the list.
        case parentEntityId(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .componentTypeId(let value):
                try container.encode(value, forKey: .componentTypeId)
            case .externalId(let value):
                try container.encode(value, forKey: .externalId)
            case .parentEntityId(let value):
                try container.encode(value, forKey: .parentEntityId)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .componentTypeId(let value):
                try self.validate(value, name: "componentTypeId", parent: name, max: 256)
                try self.validate(value, name: "componentTypeId", parent: name, min: 1)
                try self.validate(value, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            case .externalId(let value):
                try self.validate(value, name: "externalId", parent: name, max: 256)
                try self.validate(value, name: "externalId", parent: name, min: 1)
                try self.validate(value, name: "externalId", parent: name, pattern: ".*")
            case .parentEntityId(let value):
                try self.validate(value, name: "parentEntityId", parent: name, max: 128)
                try self.validate(value, name: "parentEntityId", parent: name, min: 1)
                try self.validate(value, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId
            case externalId
            case parentEntityId
        }
    }

    // MARK: Shapes

    public struct BatchPutPropertyError: AWSDecodableShape {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        public let entry: PropertyValueEntry
        /// The error code.
        public let errorCode: String
        /// The error message.
        public let errorMessage: String

        public init(entry: PropertyValueEntry, errorCode: String, errorMessage: String) {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entry
            case errorCode
            case errorMessage
        }
    }

    public struct BatchPutPropertyErrorEntry: AWSDecodableShape {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        public let errors: [BatchPutPropertyError]

        public init(errors: [BatchPutPropertyError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchPutPropertyValuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// An object that maps strings to the property value entries to set. Each string  in the mapping must be unique to this object.
        public let entries: [PropertyValueEntry]
        /// The ID of the workspace that contains the properties to set.
        public let workspaceId: String

        public init(entries: [PropertyValueEntry], workspaceId: String) {
            self.entries = entries
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 10)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries
        }
    }

    public struct BatchPutPropertyValuesResponse: AWSDecodableShape {
        /// Entries that caused errors in the batch put operation.
        public let errorEntries: [BatchPutPropertyErrorEntry]

        public init(errorEntries: [BatchPutPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
        }
    }

    public struct ComponentRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The description of the component request.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type. Each string  in the mapping must be unique to this object.
        public let properties: [String: PropertyRequest]?

        public init(componentTypeId: String? = nil, description: String? = nil, properties: [String: PropertyRequest]? = nil) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, min: 1)
                try validate($0.key, name: "properties.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).properties[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId
            case description
            case properties
        }
    }

    public struct ComponentResponse: AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The name of the property definition set in the request.
        public let definedIn: String?
        /// The description of the component type.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type. Each string  in the mapping must be unique to this object.
        public let properties: [String: PropertyResponse]?
        /// The status of the component type.
        public let status: Status?

        public init(componentName: String? = nil, componentTypeId: String? = nil, definedIn: String? = nil, description: String? = nil, properties: [String: PropertyResponse]? = nil, status: Status? = nil) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case componentTypeId
            case definedIn
            case description
            case properties
            case status
        }
    }

    public struct ComponentTypeSummary: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The date and time when the component type was created.
        public let creationDateTime: Date
        /// The description of the component type.
        public let description: String?
        /// The current status of the component type.
        public let status: Status?
        /// The date and time when the component type was last updated.
        public let updateDateTime: Date

        public init(arn: String, componentTypeId: String, creationDateTime: Date, description: String? = nil, status: Status? = nil, updateDateTime: Date) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case componentTypeId
            case creationDateTime
            case description
            case status
            case updateDateTime
        }
    }

    public struct ComponentUpdateRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The description of the component type.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type update. Each string  in the mapping must be unique to this object.
        public let propertyUpdates: [String: PropertyRequest]?
        /// The update type of the component update request.
        public let updateType: ComponentUpdateType?

        public init(componentTypeId: String? = nil, description: String? = nil, propertyUpdates: [String: PropertyRequest]? = nil, updateType: ComponentUpdateType? = nil) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.propertyUpdates?.forEach {
                try validate($0.key, name: "propertyUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyUpdates[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId
            case description
            case propertyUpdates
            case updateType
        }
    }

    public struct CreateComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type.
        public let componentTypeId: String
        /// The description of the component type.
        public let description: String?
        /// Specifies the parent component type to extend.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
        public let functions: [String: FunctionRequest]?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionRequest]?
        /// Metadata that you can use to manage the component type.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionRequest]? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionRequest]? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.extendsFrom?.forEach {
                try validate($0, name: "extendsFrom[]", parent: name, max: 256)
                try validate($0, name: "extendsFrom[]", parent: name, min: 1)
                try validate($0, name: "extendsFrom[]", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            }
            try self.functions?.forEach {
                try validate($0.key, name: "functions.key", parent: name, max: 256)
                try validate($0.key, name: "functions.key", parent: name, min: 1)
                try validate($0.key, name: "functions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).functions[\"\($0.key)\"]")
            }
            try self.propertyDefinitions?.forEach {
                try validate($0.key, name: "propertyDefinitions.key", parent: name, max: 256)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, min: 1)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyDefinitions[\"\($0.key)\"]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case extendsFrom
            case functions
            case isSingleton
            case propertyDefinitions
            case tags
        }
    }

    public struct CreateComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The current state of the component type.
        public let state: State

        public init(arn: String, creationDateTime: Date, state: State) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case state
        }
    }

    public struct CreateEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// An object that maps strings to the components in the entity. Each string  in the mapping must be unique to this object.
        public let components: [String: ComponentRequest]?
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String?
        /// The name of the entity.
        public let entityName: String
        /// The ID of the entity's parent entity.
        public let parentEntityId: String?
        /// Metadata that you can use to manage the entity.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the entity.
        public let workspaceId: String

        public init(components: [String: ComponentRequest]? = nil, description: String? = nil, entityId: String? = nil, entityName: String, parentEntityId: String? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.components = components
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.parentEntityId = parentEntityId
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.components?.forEach {
                try validate($0.key, name: "components.key", parent: name, max: 256)
                try validate($0.key, name: "components.key", parent: name, min: 1)
                try validate($0.key, name: "components.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).components[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, min: 1)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^[a-zA-Z_0-9-.][a-zA-Z_0-9-. ]*[a-zA-Z0-9]+$")
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, max: 128)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, min: 1)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case components
            case description
            case entityId
            case entityName
            case parentEntityId
            case tags
        }
    }

    public struct CreateEntityResponse: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The ID of the entity.
        public let entityId: String
        /// The current state of the entity.
        public let state: State

        public init(arn: String, creationDateTime: Date, entityId: String, state: State) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.entityId = entityId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case entityId
            case state
        }
    }

    public struct CreateSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of capabilities that the scene uses to render itself.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The description for this scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// Metadata that you can use to manage the scene.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(capabilities: [String]? = nil, contentLocation: String, description: String? = nil, sceneId: String, tags: [String: String]? = nil, workspaceId: String) {
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.description = description
            self.sceneId = sceneId
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 256)
                try validate($0, name: "capabilities[]", parent: name, pattern: ".*")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, max: 256)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, pattern: "^[sS]3://[A-Za-z0-9._/-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities
            case contentLocation
            case description
            case sceneId
            case tags
        }
    }

    public struct CreateSceneResponse: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date

        public init(arn: String, creationDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
        }
    }

    public struct CreateWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String
        /// Metadata that you can use to manage the workspace
        public let tags: [String: String]?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(description: String? = nil, role: String, s3Location: String, tags: [String: String]? = nil, workspaceId: String) {
            self.description = description
            self.role = role
            self.s3Location = s3Location
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.s3Location, name: "s3Location", parent: name, max: 1024)
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "(^arn:((aws)|(aws-cn)|(aws-us-gov)):s3:::)([a-zA-Z0-9_-]+$)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case role
            case s3Location
            case tags
        }
    }

    public struct CreateWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date

        public init(arn: String, creationDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
        }
    }

    public struct DataConnector: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
        public let isNative: Bool?
        /// The Lambda function associated with this data connector.
        public let lambda: LambdaFunction?

        public init(isNative: Bool? = nil, lambda: LambdaFunction? = nil) {
            self.isNative = isNative
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda?.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case isNative
            case lambda
        }
    }

    public final class DataType: AWSEncodableShape & AWSDecodableShape {
        /// The allowed values for this data type.
        public let allowedValues: [DataValue]?
        /// The nested type in the data type.
        public let nestedType: DataType?
        /// A relationship that associates a component with another component.
        public let relationship: Relationship?
        /// The underlying type of the data type.
        public let type: `Type`
        /// The unit of measure used in this data type.
        public let unitOfMeasure: String?

        public init(allowedValues: [DataValue]? = nil, nestedType: DataType? = nil, relationship: Relationship? = nil, type: `Type`, unitOfMeasure: String? = nil) {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }

        public func validate(name: String) throws {
            try self.allowedValues?.forEach {
                try $0.validate(name: "\(name).allowedValues[]")
            }
            try self.validate(self.allowedValues, name: "allowedValues", parent: name, max: 50)
            try self.nestedType?.validate(name: "\(name).nestedType")
            try self.relationship?.validate(name: "\(name).relationship")
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, max: 256)
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, min: 1)
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues
            case nestedType
            case relationship
            case type
            case unitOfMeasure
        }
    }

    public final class DataValue: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value.
        public let booleanValue: Bool?
        /// A double value.
        public let doubleValue: Double?
        /// An expression that produces the value.
        public let expression: String?
        /// An integer value.
        public let integerValue: Int?
        /// A list of multiple values.
        public let listValue: [DataValue]?
        /// A long value.
        public let longValue: Int64?
        /// An object that maps strings to multiple DataValue objects.
        public let mapValue: [String: DataValue]?
        /// A value that relates a component to another component.
        public let relationshipValue: RelationshipValue?
        /// A string value.
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, expression: String? = nil, integerValue: Int? = nil, listValue: [DataValue]? = nil, longValue: Int64? = nil, mapValue: [String: DataValue]? = nil, relationshipValue: RelationshipValue? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 316)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^(^\\$\\{Parameters\\.[a-zA-z]+([a-zA-z_0-9]*)}$)$")
            try self.listValue?.forEach {
                try $0.validate(name: "\(name).listValue[]")
            }
            try self.validate(self.listValue, name: "listValue", parent: name, max: 50)
            try self.mapValue?.forEach {
                try validate($0.key, name: "mapValue.key", parent: name, max: 256)
                try validate($0.key, name: "mapValue.key", parent: name, min: 1)
                try validate($0.key, name: "mapValue.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).mapValue[\"\($0.key)\"]")
            }
            try self.validate(self.mapValue, name: "mapValue", parent: name, max: 50)
            try self.relationshipValue?.validate(name: "\(name).relationshipValue")
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 256)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue
            case doubleValue
            case expression
            case integerValue
            case listValue
            case longValue
            case mapValue
            case relationshipValue
            case stringValue
        }
    }

    public struct DeleteComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type to delete.
        public let componentTypeId: String
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentTypeResponse: AWSDecodableShape {
        /// The current state of the component type to be deleted.
        public let state: State

        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct DeleteEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "entityId", location: .uri("entityId")),
            AWSMemberEncoding(label: "isRecursive", location: .querystring("isRecursive")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the entity to delete.
        public let entityId: String
        /// A Boolean value that specifies whether the operation deletes child entities.
        public let isRecursive: Bool?
        /// The ID of the workspace that contains the entity to delete.
        public let workspaceId: String

        public init(entityId: String, isRecursive: Bool? = nil, workspaceId: String) {
            self.entityId = entityId
            self.isRecursive = isRecursive
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEntityResponse: AWSDecodableShape {
        /// The current state of the deleted entity.
        public let state: State

        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct DeleteSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sceneId", location: .uri("sceneId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the scene to delete.
        public let sceneId: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(sceneId: String, workspaceId: String) {
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSceneResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace to delete.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkspaceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EntityPropertyReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// The ID of the entity.
        public let entityId: String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public let externalIdProperty: [String: String]?
        /// The name of the property.
        public let propertyName: String

        public init(componentName: String? = nil, entityId: String? = nil, externalIdProperty: [String: String]? = nil, propertyName: String) {
            self.componentName = componentName
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.externalIdProperty?.forEach {
                try validate($0.key, name: "externalIdProperty.key", parent: name, max: 256)
                try validate($0.key, name: "externalIdProperty.key", parent: name, min: 1)
                try validate($0.key, name: "externalIdProperty.key", parent: name, pattern: ".*")
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case entityId
            case externalIdProperty
            case propertyName
        }
    }

    public struct EntitySummary: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String
        /// A Boolean value that specifies whether the entity has child entities or not.
        public let hasChildEntities: Bool?
        /// The ID of the parent entity.
        public let parentEntityId: String?
        /// The current status of the entity.
        public let status: Status
        /// The last date and time when the entity was updated.
        public let updateDateTime: Date

        public init(arn: String, creationDateTime: Date, description: String? = nil, entityId: String, entityName: String, hasChildEntities: Bool? = nil, parentEntityId: String? = nil, status: Status, updateDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case entityId
            case entityName
            case hasChildEntities
            case parentEntityId
            case status
            case updateDateTime
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode?
        /// The error message.
        public let message: String?

        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct FunctionRequest: AWSEncodableShape {
        /// The data connector.
        public let implementedBy: DataConnector?
        /// The required properties of the function.
        public let requiredProperties: [String]?
        /// The scope of the function.
        public let scope: Scope?

        public init(implementedBy: DataConnector? = nil, requiredProperties: [String]? = nil, scope: Scope? = nil) {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.implementedBy?.validate(name: "\(name).implementedBy")
            try self.requiredProperties?.forEach {
                try validate($0, name: "requiredProperties[]", parent: name, max: 256)
                try validate($0, name: "requiredProperties[]", parent: name, min: 1)
                try validate($0, name: "requiredProperties[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case implementedBy
            case requiredProperties
            case scope
        }
    }

    public struct FunctionResponse: AWSDecodableShape {
        /// The data connector.
        public let implementedBy: DataConnector?
        /// Indicates whether this function is inherited.
        public let isInherited: Bool?
        /// The required properties of the function.
        public let requiredProperties: [String]?
        /// The scope of the function.
        public let scope: Scope?

        public init(implementedBy: DataConnector? = nil, isInherited: Bool? = nil, requiredProperties: [String]? = nil, scope: Scope? = nil) {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case implementedBy
            case isInherited
            case requiredProperties
            case scope
        }
    }

    public struct GetComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type.
        public let componentTypeId: String
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The date and time when the component type was created.
        public let creationDateTime: Date
        /// The description of the component type.
        public let description: String?
        /// The name of the parent component type that this component type extends.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string  in the mapping must be unique to this object.
        public let functions: [String: FunctionResponse]?
        /// A Boolean value that specifies whether the component type is abstract.
        public let isAbstract: Bool?
        /// A Boolean value that specifies whether the component type has a schema initializer and that the  schema initializer has run.
        public let isSchemaInitialized: Bool?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionResponse]?
        /// The current status of the component type.
        public let status: Status?
        /// The date and time when the component was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(arn: String, componentTypeId: String, creationDateTime: Date, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionResponse]? = nil, isAbstract: Bool? = nil, isSchemaInitialized: Bool? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionResponse]? = nil, status: Status? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.creationDateTime = creationDateTime
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isAbstract = isAbstract
            self.isSchemaInitialized = isSchemaInitialized
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.status = status
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case componentTypeId
            case creationDateTime
            case description
            case extendsFrom
            case functions
            case isAbstract
            case isSchemaInitialized
            case isSingleton
            case propertyDefinitions
            case status
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "entityId", location: .uri("entityId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the entity.
        public let entityId: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(entityId: String, workspaceId: String) {
            self.entityId = entityId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEntityResponse: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// An object that maps strings to the components in the entity. Each string  in the mapping must be unique to this object.
        public let components: [String: ComponentResponse]?
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String
        /// A Boolean value that specifies whether the entity has associated child entities.
        public let hasChildEntities: Bool
        /// The ID of the parent entity for this entity.
        public let parentEntityId: String
        /// The current status of the entity.
        public let status: Status
        /// The date and time when the entity was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, components: [String: ComponentResponse]? = nil, creationDateTime: Date, description: String? = nil, entityId: String, entityName: String, hasChildEntities: Bool, parentEntityId: String, status: Status, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.components = components
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case components
            case creationDateTime
            case description
            case entityId
            case entityName
            case hasChildEntities
            case parentEntityId
            case status
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetPropertyValueHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The name of the component.
        public let componentName: String?
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The date and time of the latest property value to return.
        public let endDateTime: Date?
        /// The ISO8601 DateTime of the latest property value to return. For more information about the ISO8601 DateTime format, see the data type PropertyValue.
        public let endTime: String?
        /// The ID of the entity.
        public let entityId: String?
        /// An object that specifies the interpolation type and the interval over which to interpolate data.
        public let interpolation: InterpolationParameters?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The time direction to use in the result order.
        public let orderByTime: OrderByTime?
        /// A list of objects that filter the property value history request.
        public let propertyFilters: [PropertyFilter]?
        /// A list of properties whose value histories the request retrieves.
        public let selectedProperties: [String]
        /// The date and time of the earliest property value to return.
        public let startDateTime: Date?
        /// The ISO8601 DateTime of the earliest property value to return. For more information about the ISO8601 DateTime format, see the data type PropertyValue.
        public let startTime: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentName: String? = nil, componentTypeId: String? = nil, endTime: String? = nil, entityId: String? = nil, interpolation: InterpolationParameters? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderByTime: OrderByTime? = nil, propertyFilters: [PropertyFilter]? = nil, selectedProperties: [String], startTime: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.endDateTime = nil
            self.endTime = endTime
            self.entityId = entityId
            self.interpolation = interpolation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderByTime = orderByTime
            self.propertyFilters = propertyFilters
            self.selectedProperties = selectedProperties
            self.startDateTime = nil
            self.startTime = startTime
            self.workspaceId = workspaceId
        }

        @available(*, deprecated, message: "Members endDateTime, startDateTime have been deprecated")
        public init(componentName: String? = nil, componentTypeId: String? = nil, endDateTime: Date? = nil, endTime: String? = nil, entityId: String? = nil, interpolation: InterpolationParameters? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderByTime: OrderByTime? = nil, propertyFilters: [PropertyFilter]? = nil, selectedProperties: [String], startDateTime: Date? = nil, startTime: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.endDateTime = endDateTime
            self.endTime = endTime
            self.entityId = entityId
            self.interpolation = interpolation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderByTime = orderByTime
            self.propertyFilters = propertyFilters
            self.selectedProperties = selectedProperties
            self.startDateTime = startDateTime
            self.startTime = startTime
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.endTime, name: "endTime", parent: name, max: 35)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 20)
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.propertyFilters?.forEach {
                try $0.validate(name: "\(name).propertyFilters[]")
            }
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, max: 10)
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, min: 1)
            try self.selectedProperties.forEach {
                try validate($0, name: "selectedProperties[]", parent: name, max: 256)
                try validate($0, name: "selectedProperties[]", parent: name, min: 1)
                try validate($0, name: "selectedProperties[]", parent: name, pattern: ".*")
            }
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, max: 10)
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, min: 1)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 35)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 20)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case componentTypeId
            case endDateTime
            case endTime
            case entityId
            case interpolation
            case maxResults
            case nextToken
            case orderByTime
            case propertyFilters
            case selectedProperties
            case startDateTime
            case startTime
        }
    }

    public struct GetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyValues: [PropertyValueHistory]

        public init(nextToken: String? = nil, propertyValues: [PropertyValueHistory]) {
            self.nextToken = nextToken
            self.propertyValues = propertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case propertyValues
        }
    }

    public struct GetPropertyValueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The name of the component whose property values the operation returns.
        public let componentName: String?
        /// The ID of the component type whose property values the operation returns.
        public let componentTypeId: String?
        /// The ID of the entity whose property values the operation returns.
        public let entityId: String?
        /// The properties whose values the operation returns.
        public let selectedProperties: [String]
        /// The ID of the workspace whose values the operation returns.
        public let workspaceId: String

        public init(componentName: String? = nil, componentTypeId: String? = nil, entityId: String? = nil, selectedProperties: [String], workspaceId: String) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.entityId = entityId
            self.selectedProperties = selectedProperties
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.selectedProperties.forEach {
                try validate($0, name: "selectedProperties[]", parent: name, max: 256)
                try validate($0, name: "selectedProperties[]", parent: name, min: 1)
                try validate($0, name: "selectedProperties[]", parent: name, pattern: ".*")
            }
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, max: 10)
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case componentTypeId
            case entityId
            case selectedProperties
        }
    }

    public struct GetPropertyValueResponse: AWSDecodableShape {
        /// An object that maps strings to the properties and latest property values in the response. Each string  in the mapping must be unique to this object.
        public let propertyValues: [String: PropertyLatestValue]

        public init(propertyValues: [String: PropertyLatestValue]) {
            self.propertyValues = propertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValues
        }
    }

    public struct GetSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sceneId", location: .uri("sceneId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the scene.
        public let sceneId: String
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(sceneId: String, workspaceId: String) {
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSceneResponse: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// A list of capabilities that the scene uses to render.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date
        /// The description of the scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(arn: String, capabilities: [String]? = nil, contentLocation: String, creationDateTime: Date, description: String? = nil, sceneId: String, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case capabilities
            case contentLocation
            case creationDateTime
            case description
            case sceneId
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 2048)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$|^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date
        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String
        /// The date and time when the workspace was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, description: String? = nil, role: String, s3Location: String, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.role = role
            self.s3Location = s3Location
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case role
            case s3Location
            case updateDateTime
            case workspaceId
        }
    }

    public struct InterpolationParameters: AWSEncodableShape {
        /// The interpolation type.
        public let interpolationType: InterpolationType?
        /// The interpolation time interval in seconds.
        public let intervalInSeconds: Int64?

        public init(interpolationType: InterpolationType? = nil, intervalInSeconds: Int64? = nil) {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case interpolationType
            case intervalInSeconds
        }
    }

    public struct LambdaFunction: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):lambda:[a-z0-9-]+:[0-9]{12}:function:[\\/a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct ListComponentTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of objects that filter the request.
        public let filters: [ListComponentTypesFilter]?
        /// The maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(filters: [ListComponentTypesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListComponentTypesResponse: AWSDecodableShape {
        /// A list of objects that contain information about the component types.
        public let componentTypeSummaries: [ComponentTypeSummary]
        /// Specifies the maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentTypeSummaries: [ComponentTypeSummary], maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.componentTypeSummaries = componentTypeSummaries
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeSummaries
            case maxResults
            case nextToken
            case workspaceId
        }
    }

    public struct ListEntitiesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of objects that filter the request.  Only one object is accepted as a valid input.
        public let filters: [ListEntitiesFilter]?
        /// The maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(filters: [ListEntitiesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListEntitiesResponse: AWSDecodableShape {
        /// A list of objects that contain information about the entities.
        public let entitySummaries: [EntitySummary]?
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(entitySummaries: [EntitySummary]? = nil, nextToken: String? = nil) {
            self.entitySummaries = entitySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entitySummaries
            case nextToken
        }
    }

    public struct ListScenesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Specifies the maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace that contains the scenes.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListScenesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// A list of objects that contain information about the scenes.
        public let sceneSummaries: [SceneSummary]?

        public init(nextToken: String? = nil, sceneSummaries: [SceneSummary]? = nil) {
            self.nextToken = nextToken
            self.sceneSummaries = sceneSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sceneSummaries
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ARN of the resource.
        public let resourceARN: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case resourceARN
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Metadata that you can use to manage a resource.
        public let tags: [String: String]?

        public init(nextToken: String? = nil, tags: [String: String]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tags
        }
    }

    public struct ListWorkspacesRequest: AWSEncodableShape {
        /// The maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListWorkspacesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// A list of objects that contain information about the workspaces.
        public let workspaceSummaries: [WorkspaceSummary]?

        public init(nextToken: String? = nil, workspaceSummaries: [WorkspaceSummary]? = nil) {
            self.nextToken = nextToken
            self.workspaceSummaries = workspaceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case workspaceSummaries
        }
    }

    public struct ParentEntityUpdateRequest: AWSEncodableShape {
        /// The ID of the parent entity.
        public let parentEntityId: String?
        /// The type of the update.
        public let updateType: ParentEntityUpdateType

        public init(parentEntityId: String? = nil, updateType: ParentEntityUpdateType) {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, max: 128)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, min: 1)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parentEntityId
            case updateType
        }
    }

    public struct PropertyDefinitionRequest: AWSEncodableShape {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public let configuration: [String: String]?
        /// An object that contains information about the data type.
        public let dataType: DataType?
        /// An object that contains the default value.
        public let defaultValue: DataValue?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public let isExternalId: Bool?
        /// A Boolean value that specifies whether the property is required.
        public let isRequiredInEntity: Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public let isStoredExternally: Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public let isTimeSeries: Bool?

        public init(configuration: [String: String]? = nil, dataType: DataType? = nil, defaultValue: DataValue? = nil, isExternalId: Bool? = nil, isRequiredInEntity: Bool? = nil, isStoredExternally: Bool? = nil, isTimeSeries: Bool? = nil) {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }

        public func validate(name: String) throws {
            try self.configuration?.forEach {
                try validate($0.key, name: "configuration.key", parent: name, max: 256)
                try validate($0.key, name: "configuration.key", parent: name, min: 1)
                try validate($0.key, name: "configuration.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try validate($0.value, name: "configuration[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.dataType?.validate(name: "\(name).dataType")
            try self.defaultValue?.validate(name: "\(name).defaultValue")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case dataType
            case defaultValue
            case isExternalId
            case isRequiredInEntity
            case isStoredExternally
            case isTimeSeries
        }
    }

    public struct PropertyDefinitionResponse: AWSDecodableShape {
        /// A mapping that specifies configuration information about the property.
        public let configuration: [String: String]?
        /// An object that contains information about the data type.
        public let dataType: DataType
        /// An object that contains the default value.
        public let defaultValue: DataValue?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public let isExternalId: Bool
        /// A Boolean value that specifies whether the property definition can be updated.
        public let isFinal: Bool
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        public let isImported: Bool
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        public let isInherited: Bool
        /// A Boolean value that specifies whether the property is required in an entity.
        public let isRequiredInEntity: Bool
        /// A Boolean value that specifies whether the property is stored externally.
        public let isStoredExternally: Bool
        /// A Boolean value that specifies whether the property consists of time series data.
        public let isTimeSeries: Bool

        public init(configuration: [String: String]? = nil, dataType: DataType, defaultValue: DataValue? = nil, isExternalId: Bool, isFinal: Bool, isImported: Bool, isInherited: Bool, isRequiredInEntity: Bool, isStoredExternally: Bool, isTimeSeries: Bool) {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case dataType
            case defaultValue
            case isExternalId
            case isFinal
            case isImported
            case isInherited
            case isRequiredInEntity
            case isStoredExternally
            case isTimeSeries
        }
    }

    public struct PropertyFilter: AWSEncodableShape {
        /// The operator associated with this property filter.
        public let `operator`: String?
        /// The property name associated with this property filter.
        public let propertyName: String?
        /// The value associated with this property filter.
        public let value: DataValue?

        public init(operator: String? = nil, propertyName: String? = nil, value: DataValue? = nil) {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.`operator`, name: "`operator`", parent: name, max: 256)
            try self.validate(self.`operator`, name: "`operator`", parent: name, min: 1)
            try self.validate(self.`operator`, name: "`operator`", parent: name, pattern: ".*")
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: ".*")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case `operator`
            case propertyName
            case value
        }
    }

    public struct PropertyLatestValue: AWSDecodableShape {
        /// An object that specifies information about a property.&gt;
        public let propertyReference: EntityPropertyReference
        /// The value of the property.
        public let propertyValue: DataValue?

        public init(propertyReference: EntityPropertyReference, propertyValue: DataValue? = nil) {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyReference
            case propertyValue
        }
    }

    public struct PropertyRequest: AWSEncodableShape {
        /// An object that specifies information about a property.
        public let definition: PropertyDefinitionRequest?
        /// The update type of the update property request.
        public let updateType: PropertyUpdateType?
        /// The value of the property.
        public let value: DataValue?

        public init(definition: PropertyDefinitionRequest? = nil, updateType: PropertyUpdateType? = nil, value: DataValue? = nil) {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }

        public func validate(name: String) throws {
            try self.definition?.validate(name: "\(name).definition")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case definition
            case updateType
            case value
        }
    }

    public struct PropertyResponse: AWSDecodableShape {
        /// An object that specifies information about a property.
        public let definition: PropertyDefinitionResponse?
        /// The value of the property.
        public let value: DataValue?

        public init(definition: PropertyDefinitionResponse? = nil, value: DataValue? = nil) {
            self.definition = definition
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case definition
            case value
        }
    }

    public struct PropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// ISO8601 DateTime of a value for a time series property. The time for when the property value was recorded in ISO 8601 format: YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm].     [YYYY]: year    [MM]: month    [DD]: day    [hh]: hour    [mm]: minute    [ss]: seconds    [.SSSSSSSSS]: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.    Z: default timezone UTC    ± HH:mm: time zone offset in Hours and Minutes.    Required sub-fields: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]
        public let time: String?
        /// The timestamp of a value for a time series property.
        public let timestamp: Date?
        /// An object that specifies a value for a time series property.
        public let value: DataValue

        public init(time: String? = nil, value: DataValue) {
            self.time = time
            self.timestamp = nil
            self.value = value
        }

        @available(*, deprecated, message: "Members timestamp have been deprecated")
        public init(time: String? = nil, timestamp: Date? = nil, value: DataValue) {
            self.time = time
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.time, name: "time", parent: name, max: 35)
            try self.validate(self.time, name: "time", parent: name, min: 20)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case time
            case timestamp
            case value
        }
    }

    public struct PropertyValueEntry: AWSEncodableShape & AWSDecodableShape {
        /// An object that contains information about the entity that has the property.
        public let entityPropertyReference: EntityPropertyReference
        /// A list of objects that specify time series property values.
        public let propertyValues: [PropertyValue]?

        public init(entityPropertyReference: EntityPropertyReference, propertyValues: [PropertyValue]? = nil) {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.entityPropertyReference.validate(name: "\(name).entityPropertyReference")
            try self.propertyValues?.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
            try self.validate(self.propertyValues, name: "propertyValues", parent: name, max: 10)
            try self.validate(self.propertyValues, name: "propertyValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityPropertyReference
            case propertyValues
        }
    }

    public struct PropertyValueHistory: AWSDecodableShape {
        /// An object that uniquely identifies an entity property.
        public let entityPropertyReference: EntityPropertyReference
        /// A list of objects that contain information about the values in the history of a time series property.
        public let values: [PropertyValue]?

        public init(entityPropertyReference: EntityPropertyReference, values: [PropertyValue]? = nil) {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case entityPropertyReference
            case values
        }
    }

    public struct Relationship: AWSEncodableShape & AWSDecodableShape {
        /// The type of the relationship.
        public let relationshipType: String?
        /// The ID of the target component type associated with this relationship.
        public let targetComponentTypeId: String?

        public init(relationshipType: String? = nil, targetComponentTypeId: String? = nil) {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, max: 256)
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, min: 1)
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, pattern: ".*")
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, max: 256)
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, min: 1)
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipType
            case targetComponentTypeId
        }
    }

    public struct RelationshipValue: AWSEncodableShape & AWSDecodableShape {
        /// The name of the target component associated with the relationship value.
        public let targetComponentName: String?
        /// The ID of the target entity associated with this relationship value.
        public let targetEntityId: String?

        public init(targetComponentName: String? = nil, targetEntityId: String? = nil) {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }

        public func validate(name: String) throws {
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, max: 256)
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, min: 1)
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, max: 128)
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, min: 1)
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetComponentName
            case targetEntityId
        }
    }

    public struct SceneSummary: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date
        /// The scene description.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date

        public init(arn: String, contentLocation: String, creationDateTime: Date, description: String? = nil, sceneId: String, updateDateTime: Date) {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case contentLocation
            case creationDateTime
            case description
            case sceneId
            case updateDateTime
        }
    }

    public struct Status: AWSDecodableShape {
        /// The error message.
        public let error: ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public let state: State?

        public init(error: ErrorDetails? = nil, state: State? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// Metadata to add to this resource.
        public let tags: [String: String]

        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .querystring("resourceARN")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource.
        public let resourceARN: String
        /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type.
        public let componentTypeId: String
        /// The description of the component type.
        public let description: String?
        /// Specifies the component type that this component type extends.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string  in the mapping must be unique to this object.
        public let functions: [String: FunctionRequest]?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionRequest]?
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionRequest]? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionRequest]? = nil, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.extendsFrom?.forEach {
                try validate($0, name: "extendsFrom[]", parent: name, max: 256)
                try validate($0, name: "extendsFrom[]", parent: name, min: 1)
                try validate($0, name: "extendsFrom[]", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            }
            try self.functions?.forEach {
                try validate($0.key, name: "functions.key", parent: name, max: 256)
                try validate($0.key, name: "functions.key", parent: name, min: 1)
                try validate($0.key, name: "functions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).functions[\"\($0.key)\"]")
            }
            try self.propertyDefinitions?.forEach {
                try validate($0.key, name: "propertyDefinitions.key", parent: name, max: 256)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, min: 1)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyDefinitions[\"\($0.key)\"]")
            }
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case extendsFrom
            case functions
            case isSingleton
            case propertyDefinitions
        }
    }

    public struct UpdateComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The current state of the component type.
        public let state: State
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(arn: String, componentTypeId: String, state: State, workspaceId: String) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.state = state
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case componentTypeId
            case state
            case workspaceId
        }
    }

    public struct UpdateEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "entityId", location: .uri("entityId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// An object that maps strings to the component updates in the request. Each string  in the mapping must be unique to this object.
        public let componentUpdates: [String: ComponentUpdateRequest]?
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String?
        /// An object that describes the update request for a parent entity.
        public let parentEntityUpdate: ParentEntityUpdateRequest?
        /// The ID of the workspace that contains the entity.
        public let workspaceId: String

        public init(componentUpdates: [String: ComponentUpdateRequest]? = nil, description: String? = nil, entityId: String, entityName: String? = nil, parentEntityUpdate: ParentEntityUpdateRequest? = nil, workspaceId: String) {
            self.componentUpdates = componentUpdates
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.parentEntityUpdate = parentEntityUpdate
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.componentUpdates?.forEach {
                try validate($0.key, name: "componentUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "componentUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "componentUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).componentUpdates[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, min: 1)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^[a-zA-Z_0-9-.][a-zA-Z_0-9-. ]*[a-zA-Z0-9]+$")
            try self.parentEntityUpdate?.validate(name: "\(name).parentEntityUpdate")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentUpdates
            case description
            case entityName
            case parentEntityUpdate
        }
    }

    public struct UpdateEntityResponse: AWSDecodableShape {
        /// The current state of the entity update.
        public let state: State
        /// The date and time when the entity was last updated.
        public let updateDateTime: Date

        public init(state: State, updateDateTime: Date) {
            self.state = state
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case state
            case updateDateTime
        }
    }

    public struct UpdateSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sceneId", location: .uri("sceneId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of capabilities that the scene uses to render.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String?
        /// The description of this scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(capabilities: [String]? = nil, contentLocation: String? = nil, description: String? = nil, sceneId: String, workspaceId: String) {
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.description = description
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 256)
                try validate($0, name: "capabilities[]", parent: name, pattern: ".*")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, max: 256)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, pattern: "^[sS]3://[A-Za-z0-9._/-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities
            case contentLocation
            case description
        }
    }

    public struct UpdateSceneResponse: AWSDecodableShape {
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date

        public init(updateDateTime: Date) {
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case updateDateTime
        }
    }

    public struct UpdateWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(description: String? = nil, role: String? = nil, workspaceId: String) {
            self.description = description
            self.role = role
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case role
        }
    }

    public struct UpdateWorkspaceResponse: AWSDecodableShape {
        /// The date and time of the current update.
        public let updateDateTime: Date

        public init(updateDateTime: Date) {
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case updateDateTime
        }
    }

    public struct WorkspaceSummary: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date
        /// The description of the workspace.
        public let description: String?
        /// The date and time when the workspace was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, description: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case updateDateTime
            case workspaceId
        }
    }
}
