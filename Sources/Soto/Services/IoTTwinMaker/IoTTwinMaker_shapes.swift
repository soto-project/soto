//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTTwinMaker {
    // MARK: Enums

    public enum ColumnType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edge = "EDGE"
        case node = "NODE"
        case value = "VALUE"
        public var description: String { return self.rawValue }
    }

    public enum ComponentUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iotsitewise = "iotsitewise"
        case iottwinmaker = "iottwinmaker"
        case s3 = "s3"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compositeComponentFailure = "COMPOSITE_COMPONENT_FAILURE"
        case internalFailure = "INTERNAL_FAILURE"
        case processingError = "PROCESSING_ERROR"
        case syncCreatingError = "SYNC_CREATING_ERROR"
        case syncDeletingError = "SYNC_DELETING_ERROR"
        case syncInitializingError = "SYNC_INITIALIZING_ERROR"
        case syncProcessingError = "SYNC_PROCESSING_ERROR"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum GroupType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tabular = "TABULAR"
        public var description: String { return self.rawValue }
    }

    public enum InterpolationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linear = "LINEAR"
        public var description: String { return self.rawValue }
    }

    public enum MetadataTransferJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case error = "ERROR"
        case pending = "PENDING"
        case running = "RUNNING"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum OrderByTime: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum ParentEntityUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum PricingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case standard = "STANDARD"
        case tieredBundle = "TIERED_BUNDLE"
        public var description: String { return self.rawValue }
    }

    public enum PricingTier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tier1 = "TIER_1"
        case tier2 = "TIER_2"
        case tier3 = "TIER_3"
        case tier4 = "TIER_4"
        public var description: String { return self.rawValue }
    }

    public enum PropertyGroupUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum PropertyUpdateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum SceneErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case matterportError = "MATTERPORT_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum Scope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case entity = "ENTITY"
        case workspace = "WORKSPACE"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iotsitewise = "iotsitewise"
        case iottwinmaker = "iottwinmaker"
        case s3 = "s3"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case error = "ERROR"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum SyncJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case error = "ERROR"
        case initializing = "INITIALIZING"
        public var description: String { return self.rawValue }
    }

    public enum SyncResourceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case error = "ERROR"
        case initializing = "INITIALIZING"
        case inSync = "IN_SYNC"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum SyncResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case componentType = "COMPONENT_TYPE"
        case entity = "ENTITY"
        public var description: String { return self.rawValue }
    }

    public enum UpdateReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case entityCountUpdate = "ENTITY_COUNT_UPDATE"
        case overwritten = "OVERWRITTEN"
        case pricingModeUpdate = "PRICING_MODE_UPDATE"
        case pricingTierUpdate = "PRICING_TIER_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case list = "LIST"
        case long = "LONG"
        case map = "MAP"
        case relationship = "RELATIONSHIP"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum IotSiteWiseSourceConfigurationFilter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Filter by asset.
        case filterByAsset(FilterByAsset)
        /// Filter by asset model.
        case filterByAssetModel(FilterByAssetModel)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .filterByAsset:
                let value = try container.decode(FilterByAsset.self, forKey: .filterByAsset)
                self = .filterByAsset(value)
            case .filterByAssetModel:
                let value = try container.decode(FilterByAssetModel.self, forKey: .filterByAssetModel)
                self = .filterByAssetModel(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .filterByAsset(let value):
                try container.encode(value, forKey: .filterByAsset)
            case .filterByAssetModel(let value):
                try container.encode(value, forKey: .filterByAssetModel)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .filterByAsset(let value):
                try value.validate(name: "\(name).filterByAsset")
            case .filterByAssetModel(let value):
                try value.validate(name: "\(name).filterByAssetModel")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filterByAsset = "filterByAsset"
            case filterByAssetModel = "filterByAssetModel"
        }
    }

    public enum IotTwinMakerSourceConfigurationFilter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Filter by component type.
        case filterByComponentType(FilterByComponentType)
        /// Filter by entity.
        case filterByEntity(FilterByEntity)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .filterByComponentType:
                let value = try container.decode(FilterByComponentType.self, forKey: .filterByComponentType)
                self = .filterByComponentType(value)
            case .filterByEntity:
                let value = try container.decode(FilterByEntity.self, forKey: .filterByEntity)
                self = .filterByEntity(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .filterByComponentType(let value):
                try container.encode(value, forKey: .filterByComponentType)
            case .filterByEntity(let value):
                try container.encode(value, forKey: .filterByEntity)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .filterByComponentType(let value):
                try value.validate(name: "\(name).filterByComponentType")
            case .filterByEntity(let value):
                try value.validate(name: "\(name).filterByEntity")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filterByComponentType = "filterByComponentType"
            case filterByEntity = "filterByEntity"
        }
    }

    public enum ListComponentTypesFilter: AWSEncodableShape, Sendable {
        /// The component type that the component types in the list extend.
        case extendsFrom(String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isAbstract(Bool)
        /// The namespace to which the component types in the list belong.
        case namespace(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .extendsFrom(let value):
                try container.encode(value, forKey: .extendsFrom)
            case .isAbstract(let value):
                try container.encode(value, forKey: .isAbstract)
            case .namespace(let value):
                try container.encode(value, forKey: .namespace)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .extendsFrom(let value):
                try self.validate(value, name: "extendsFrom", parent: name, max: 256)
                try self.validate(value, name: "extendsFrom", parent: name, min: 1)
                try self.validate(value, name: "extendsFrom", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            case .namespace(let value):
                try self.validate(value, name: "namespace", parent: name, max: 256)
                try self.validate(value, name: "namespace", parent: name, min: 1)
                try self.validate(value, name: "namespace", parent: name, pattern: ".*")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case extendsFrom = "extendsFrom"
            case isAbstract = "isAbstract"
            case namespace = "namespace"
        }
    }

    public enum ListEntitiesFilter: AWSEncodableShape, Sendable {
        /// The ID of the component type in the entities in the list.
        case componentTypeId(String)
        /// The external-Id property of a component. The external-Id property is the primary key of an external storage system.
        case externalId(String)
        /// The parent of the entities in the list.
        case parentEntityId(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .componentTypeId(let value):
                try container.encode(value, forKey: .componentTypeId)
            case .externalId(let value):
                try container.encode(value, forKey: .externalId)
            case .parentEntityId(let value):
                try container.encode(value, forKey: .parentEntityId)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .componentTypeId(let value):
                try self.validate(value, name: "componentTypeId", parent: name, max: 256)
                try self.validate(value, name: "componentTypeId", parent: name, min: 1)
                try self.validate(value, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            case .externalId(let value):
                try self.validate(value, name: "externalId", parent: name, max: 256)
                try self.validate(value, name: "externalId", parent: name, min: 1)
                try self.validate(value, name: "externalId", parent: name, pattern: ".*")
            case .parentEntityId(let value):
                try self.validate(value, name: "parentEntityId", parent: name, max: 128)
                try self.validate(value, name: "parentEntityId", parent: name, min: 1)
                try self.validate(value, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId = "componentTypeId"
            case externalId = "externalId"
            case parentEntityId = "parentEntityId"
        }
    }

    public enum ListMetadataTransferJobsFilter: AWSEncodableShape, Sendable {
        /// The filter state.
        case state(MetadataTransferJobState)
        /// The workspace Id.
        case workspaceId(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .state(let value):
                try container.encode(value, forKey: .state)
            case .workspaceId(let value):
                try container.encode(value, forKey: .workspaceId)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .workspaceId(let value):
                try self.validate(value, name: "workspaceId", parent: name, max: 128)
                try self.validate(value, name: "workspaceId", parent: name, min: 1)
                try self.validate(value, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case workspaceId = "workspaceId"
        }
    }

    public enum SyncResourceFilter: AWSEncodableShape, Sendable {
        /// The external ID.
        case externalId(String)
        /// The sync resource filter resource ID.
        case resourceId(String)
        /// The sync resource filter resource type
        case resourceType(SyncResourceType)
        /// The sync resource filter's state.
        case state(SyncResourceState)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .externalId(let value):
                try container.encode(value, forKey: .externalId)
            case .resourceId(let value):
                try container.encode(value, forKey: .resourceId)
            case .resourceType(let value):
                try container.encode(value, forKey: .resourceType)
            case .state(let value):
                try container.encode(value, forKey: .state)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .externalId(let value):
                try self.validate(value, name: "externalId", parent: name, max: 128)
                try self.validate(value, name: "externalId", parent: name, min: 1)
                try self.validate(value, name: "externalId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            case .resourceId(let value):
                try self.validate(value, name: "resourceId", parent: name, max: 128)
                try self.validate(value, name: "resourceId", parent: name, min: 1)
                try self.validate(value, name: "resourceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "externalId"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case state = "state"
        }
    }

    // MARK: Shapes

    public struct BatchPutPropertyError: AWSDecodableShape {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        public let entry: PropertyValueEntry
        /// The error code.
        public let errorCode: String
        /// The error message.
        public let errorMessage: String

        public init(entry: PropertyValueEntry, errorCode: String, errorMessage: String) {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entry = "entry"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchPutPropertyErrorEntry: AWSDecodableShape {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        public let errors: [BatchPutPropertyError]

        public init(errors: [BatchPutPropertyError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchPutPropertyValuesRequest: AWSEncodableShape {
        /// An object that maps strings to the property value entries to set. Each string in the mapping must be unique to this object.
        public let entries: [PropertyValueEntry]
        /// The ID of the workspace that contains the properties to set.
        public let workspaceId: String

        public init(entries: [PropertyValueEntry], workspaceId: String) {
            self.entries = entries
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.entries, forKey: .entries)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 10)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
        }
    }

    public struct BatchPutPropertyValuesResponse: AWSDecodableShape {
        /// Entries that caused errors in the batch put operation.
        public let errorEntries: [BatchPutPropertyErrorEntry]

        public init(errorEntries: [BatchPutPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct BundleInformation: AWSDecodableShape {
        /// The bundle names.
        public let bundleNames: [String]
        /// The pricing tier.
        public let pricingTier: PricingTier?

        public init(bundleNames: [String], pricingTier: PricingTier? = nil) {
            self.bundleNames = bundleNames
            self.pricingTier = pricingTier
        }

        private enum CodingKeys: String, CodingKey {
            case bundleNames = "bundleNames"
            case pricingTier = "pricingTier"
        }
    }

    public struct CancelMetadataTransferJobRequest: AWSEncodableShape {
        /// The metadata transfer job Id.
        public let metadataTransferJobId: String

        public init(metadataTransferJobId: String) {
            self.metadataTransferJobId = metadataTransferJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.metadataTransferJobId, key: "metadataTransferJobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, max: 128)
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, min: 1)
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelMetadataTransferJobResponse: AWSDecodableShape {
        /// The metadata transfer job ARN.
        public let arn: String
        /// The metadata transfer job Id.
        public let metadataTransferJobId: String
        /// The metadata transfer job's progress.
        public let progress: MetadataTransferJobProgress?
        /// The metadata transfer job's status.
        public let status: MetadataTransferJobStatus
        /// Used to update the DateTime property.
        public let updateDateTime: Date

        public init(arn: String, metadataTransferJobId: String, progress: MetadataTransferJobProgress? = nil, status: MetadataTransferJobStatus, updateDateTime: Date) {
            self.arn = arn
            self.metadataTransferJobId = metadataTransferJobId
            self.progress = progress
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case metadataTransferJobId = "metadataTransferJobId"
            case progress = "progress"
            case status = "status"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct ColumnDescription: AWSDecodableShape {
        /// The name of the column description.
        public let name: String?
        /// The type of the column description.
        public let type: ColumnType?

        public init(name: String? = nil, type: ColumnType? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ComponentPropertyGroupRequest: AWSEncodableShape {
        /// The group type.
        public let groupType: GroupType?
        /// The property names.
        public let propertyNames: [String]?
        /// The update type.
        public let updateType: PropertyGroupUpdateType?

        public init(groupType: GroupType? = nil, propertyNames: [String]? = nil, updateType: PropertyGroupUpdateType? = nil) {
            self.groupType = groupType
            self.propertyNames = propertyNames
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.propertyNames?.forEach {
                try validate($0, name: "propertyNames[]", parent: name, max: 256)
                try validate($0, name: "propertyNames[]", parent: name, min: 1)
                try validate($0, name: "propertyNames[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupType = "groupType"
            case propertyNames = "propertyNames"
            case updateType = "updateType"
        }
    }

    public struct ComponentPropertyGroupResponse: AWSDecodableShape {
        /// The group type.
        public let groupType: GroupType
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        public let isInherited: Bool
        /// The names of properties
        public let propertyNames: [String]

        public init(groupType: GroupType, isInherited: Bool, propertyNames: [String]) {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }

        private enum CodingKeys: String, CodingKey {
            case groupType = "groupType"
            case isInherited = "isInherited"
            case propertyNames = "propertyNames"
        }
    }

    public struct ComponentRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The description of the component request.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public let properties: [String: PropertyRequest]?
        /// The property groups.
        public let propertyGroups: [String: ComponentPropertyGroupRequest]?

        public init(componentTypeId: String? = nil, description: String? = nil, properties: [String: PropertyRequest]? = nil, propertyGroups: [String: ComponentPropertyGroupRequest]? = nil) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, min: 1)
                try validate($0.key, name: "properties.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).properties[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId = "componentTypeId"
            case description = "description"
            case properties = "properties"
            case propertyGroups = "propertyGroups"
        }
    }

    public struct ComponentResponse: AWSDecodableShape {
        /// This flag notes whether all compositeComponents are returned in the API  response.
        public let areAllCompositeComponentsReturned: Bool?
        /// This flag notes whether all properties of the component are returned in the API response.  The maximum number of properties returned is 800.
        public let areAllPropertiesReturned: Bool?
        /// The name of the component.
        public let componentName: String?
        /// The ID of the component type.
        public let componentTypeId: String?
        /// This lists objects that contain information about the compositeComponents.
        public let compositeComponents: [String: ComponentSummary]?
        /// The name of the property definition set in the request.
        public let definedIn: String?
        /// The description of the component type.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public let properties: [String: PropertyResponse]?
        /// The property groups.
        public let propertyGroups: [String: ComponentPropertyGroupResponse]?
        /// The status of the component type.
        public let status: Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public let syncSource: String?

        public init(areAllCompositeComponentsReturned: Bool? = nil, areAllPropertiesReturned: Bool? = nil, componentName: String? = nil, componentTypeId: String? = nil, compositeComponents: [String: ComponentSummary]? = nil, definedIn: String? = nil, description: String? = nil, properties: [String: PropertyResponse]? = nil, propertyGroups: [String: ComponentPropertyGroupResponse]? = nil, status: Status? = nil, syncSource: String? = nil) {
            self.areAllCompositeComponentsReturned = areAllCompositeComponentsReturned
            self.areAllPropertiesReturned = areAllPropertiesReturned
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.compositeComponents = compositeComponents
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }

        private enum CodingKeys: String, CodingKey {
            case areAllCompositeComponentsReturned = "areAllCompositeComponentsReturned"
            case areAllPropertiesReturned = "areAllPropertiesReturned"
            case componentName = "componentName"
            case componentTypeId = "componentTypeId"
            case compositeComponents = "compositeComponents"
            case definedIn = "definedIn"
            case description = "description"
            case properties = "properties"
            case propertyGroups = "propertyGroups"
            case status = "status"
            case syncSource = "syncSource"
        }
    }

    public struct ComponentSummary: AWSDecodableShape {
        /// The name of the component.
        public let componentName: String
        /// This string specifies the path to the composite component, starting from the top-level component.
        public let componentPath: String?
        /// The ID of the component type.
        public let componentTypeId: String
        /// The name of the property definition set in the request.
        public let definedIn: String?
        /// The description of the component request.
        public let description: String?
        /// The property groups.
        public let propertyGroups: [String: ComponentPropertyGroupResponse]?
        /// The status of the component type.
        public let status: Status
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public let syncSource: String?

        public init(componentName: String, componentPath: String? = nil, componentTypeId: String, definedIn: String? = nil, description: String? = nil, propertyGroups: [String: ComponentPropertyGroupResponse]? = nil, status: Status, syncSource: String? = nil) {
            self.componentName = componentName
            self.componentPath = componentPath
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case componentPath = "componentPath"
            case componentTypeId = "componentTypeId"
            case definedIn = "definedIn"
            case description = "description"
            case propertyGroups = "propertyGroups"
            case status = "status"
            case syncSource = "syncSource"
        }
    }

    public struct ComponentTypeSummary: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The component type name.
        public let componentTypeName: String?
        /// The date and time when the component type was created.
        public let creationDateTime: Date
        /// The description of the component type.
        public let description: String?
        /// The current status of the component type.
        public let status: Status?
        /// The date and time when the component type was last updated.
        public let updateDateTime: Date

        public init(arn: String, componentTypeId: String, componentTypeName: String? = nil, creationDateTime: Date, description: String? = nil, status: Status? = nil, updateDateTime: Date) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case componentTypeId = "componentTypeId"
            case componentTypeName = "componentTypeName"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case status = "status"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct ComponentUpdateRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The description of the component type.
        public let description: String?
        /// The property group updates.
        public let propertyGroupUpdates: [String: ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public let propertyUpdates: [String: PropertyRequest]?
        /// The update type of the component update request.
        public let updateType: ComponentUpdateType?

        public init(componentTypeId: String? = nil, description: String? = nil, propertyGroupUpdates: [String: ComponentPropertyGroupRequest]? = nil, propertyUpdates: [String: PropertyRequest]? = nil, updateType: ComponentUpdateType? = nil) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.propertyGroupUpdates?.forEach {
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroupUpdates[\"\($0.key)\"]")
            }
            try self.propertyUpdates?.forEach {
                try validate($0.key, name: "propertyUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyUpdates[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId = "componentTypeId"
            case description = "description"
            case propertyGroupUpdates = "propertyGroupUpdates"
            case propertyUpdates = "propertyUpdates"
            case updateType = "updateType"
        }
    }

    public struct CompositeComponentRequest: AWSEncodableShape {
        /// The description of the component type.
        public let description: String?
        /// This is an object that maps strings to the properties to set in the component type. Each string in  the mapping must be unique to this object.
        public let properties: [String: PropertyRequest]?
        /// The property groups.
        public let propertyGroups: [String: ComponentPropertyGroupRequest]?

        public init(description: String? = nil, properties: [String: PropertyRequest]? = nil, propertyGroups: [String: ComponentPropertyGroupRequest]? = nil) {
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, min: 1)
                try validate($0.key, name: "properties.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).properties[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case properties = "properties"
            case propertyGroups = "propertyGroups"
        }
    }

    public struct CompositeComponentTypeRequest: AWSEncodableShape {
        /// This is the componentTypeId that the compositeComponentType refers to.
        public let componentTypeId: String?

        public init(componentTypeId: String? = nil) {
            self.componentTypeId = componentTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId = "componentTypeId"
        }
    }

    public struct CompositeComponentTypeResponse: AWSDecodableShape {
        /// This is the componentTypeId that this compositeComponentType refers to.
        public let componentTypeId: String?
        /// This boolean indicates whether this compositeComponentType is inherited from its parent.
        public let isInherited: Bool?

        public init(componentTypeId: String? = nil, isInherited: Bool? = nil) {
            self.componentTypeId = componentTypeId
            self.isInherited = isInherited
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId = "componentTypeId"
            case isInherited = "isInherited"
        }
    }

    public struct CompositeComponentUpdateRequest: AWSEncodableShape {
        /// The description of the component type.
        public let description: String?
        /// The property group updates.
        public let propertyGroupUpdates: [String: ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public let propertyUpdates: [String: PropertyRequest]?
        /// The update type of the component update request.
        public let updateType: ComponentUpdateType?

        public init(description: String? = nil, propertyGroupUpdates: [String: ComponentPropertyGroupRequest]? = nil, propertyUpdates: [String: PropertyRequest]? = nil, updateType: ComponentUpdateType? = nil) {
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.propertyGroupUpdates?.forEach {
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroupUpdates[\"\($0.key)\"]")
            }
            try self.propertyUpdates?.forEach {
                try validate($0.key, name: "propertyUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyUpdates[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case propertyGroupUpdates = "propertyGroupUpdates"
            case propertyUpdates = "propertyUpdates"
            case updateType = "updateType"
        }
    }

    public struct CreateComponentTypeRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String
        /// A friendly name for the component type.
        public let componentTypeName: String?
        /// This is an object that maps strings to compositeComponentTypes of the componentType.  CompositeComponentType is referenced by componentTypeId.
        public let compositeComponentTypes: [String: CompositeComponentTypeRequest]?
        /// The description of the component type.
        public let description: String?
        /// Specifies the parent component type to extend.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
        public let functions: [String: FunctionRequest]?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionRequest]?
        public let propertyGroups: [String: PropertyGroupRequest]?
        /// Metadata that you can use to manage the component type.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, componentTypeName: String? = nil, compositeComponentTypes: [String: CompositeComponentTypeRequest]? = nil, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionRequest]? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionRequest]? = nil, propertyGroups: [String: PropertyGroupRequest]? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.compositeComponentTypes = compositeComponentTypes
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.propertyGroups = propertyGroups
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.componentTypeId, key: "componentTypeId")
            try container.encodeIfPresent(self.componentTypeName, forKey: .componentTypeName)
            try container.encodeIfPresent(self.compositeComponentTypes, forKey: .compositeComponentTypes)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.extendsFrom, forKey: .extendsFrom)
            try container.encodeIfPresent(self.functions, forKey: .functions)
            try container.encodeIfPresent(self.isSingleton, forKey: .isSingleton)
            try container.encodeIfPresent(self.propertyDefinitions, forKey: .propertyDefinitions)
            try container.encodeIfPresent(self.propertyGroups, forKey: .propertyGroups)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, max: 256)
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]*")
            try self.compositeComponentTypes?.forEach {
                try validate($0.key, name: "compositeComponentTypes.key", parent: name, max: 256)
                try validate($0.key, name: "compositeComponentTypes.key", parent: name, min: 1)
                try validate($0.key, name: "compositeComponentTypes.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).compositeComponentTypes[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.extendsFrom?.forEach {
                try validate($0, name: "extendsFrom[]", parent: name, max: 256)
                try validate($0, name: "extendsFrom[]", parent: name, min: 1)
                try validate($0, name: "extendsFrom[]", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            }
            try self.functions?.forEach {
                try validate($0.key, name: "functions.key", parent: name, max: 256)
                try validate($0.key, name: "functions.key", parent: name, min: 1)
                try validate($0.key, name: "functions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).functions[\"\($0.key)\"]")
            }
            try self.propertyDefinitions?.forEach {
                try validate($0.key, name: "propertyDefinitions.key", parent: name, max: 256)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, min: 1)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyDefinitions[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeName = "componentTypeName"
            case compositeComponentTypes = "compositeComponentTypes"
            case description = "description"
            case extendsFrom = "extendsFrom"
            case functions = "functions"
            case isSingleton = "isSingleton"
            case propertyDefinitions = "propertyDefinitions"
            case propertyGroups = "propertyGroups"
            case tags = "tags"
        }
    }

    public struct CreateComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The current state of the component type.
        public let state: State

        public init(arn: String, creationDateTime: Date, state: State) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case state = "state"
        }
    }

    public struct CreateEntityRequest: AWSEncodableShape {
        /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
        public let components: [String: ComponentRequest]?
        /// This is an object that maps strings to compositeComponent updates in the request.  Each key of the map represents the componentPath of the compositeComponent.
        public let compositeComponents: [String: CompositeComponentRequest]?
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String?
        /// The name of the entity.
        public let entityName: String
        /// The ID of the entity's parent entity.
        public let parentEntityId: String?
        /// Metadata that you can use to manage the entity.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the entity.
        public let workspaceId: String

        public init(components: [String: ComponentRequest]? = nil, compositeComponents: [String: CompositeComponentRequest]? = nil, description: String? = nil, entityId: String? = nil, entityName: String, parentEntityId: String? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.components = components
            self.compositeComponents = compositeComponents
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.parentEntityId = parentEntityId
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.components, forKey: .components)
            try container.encodeIfPresent(self.compositeComponents, forKey: .compositeComponents)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.entityId, forKey: .entityId)
            try container.encode(self.entityName, forKey: .entityName)
            try container.encodeIfPresent(self.parentEntityId, forKey: .parentEntityId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.components?.forEach {
                try validate($0.key, name: "components.key", parent: name, max: 256)
                try validate($0.key, name: "components.key", parent: name, min: 1)
                try validate($0.key, name: "components.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).components[\"\($0.key)\"]")
            }
            try self.compositeComponents?.forEach {
                try validate($0.key, name: "compositeComponents.key", parent: name, max: 2048)
                try validate($0.key, name: "compositeComponents.key", parent: name, min: 1)
                try validate($0.key, name: "compositeComponents.key", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
                try $0.value.validate(name: "\(name).compositeComponents[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, min: 1)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, max: 128)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, min: 1)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case components = "components"
            case compositeComponents = "compositeComponents"
            case description = "description"
            case entityId = "entityId"
            case entityName = "entityName"
            case parentEntityId = "parentEntityId"
            case tags = "tags"
        }
    }

    public struct CreateEntityResponse: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The ID of the entity.
        public let entityId: String
        /// The current state of the entity.
        public let state: State

        public init(arn: String, creationDateTime: Date, entityId: String, state: State) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.entityId = entityId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case entityId = "entityId"
            case state = "state"
        }
    }

    public struct CreateMetadataTransferJobRequest: AWSEncodableShape {
        /// The metadata transfer job description.
        public let description: String?
        /// The metadata transfer job destination.
        public let destination: DestinationConfiguration
        /// The metadata transfer job Id.
        public let metadataTransferJobId: String?
        /// The metadata transfer job sources.
        public let sources: [SourceConfiguration]

        public init(description: String? = nil, destination: DestinationConfiguration, metadataTransferJobId: String? = nil, sources: [SourceConfiguration]) {
            self.description = description
            self.destination = destination
            self.metadataTransferJobId = metadataTransferJobId
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, max: 128)
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, min: 1)
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case destination = "destination"
            case metadataTransferJobId = "metadataTransferJobId"
            case sources = "sources"
        }
    }

    public struct CreateMetadataTransferJobResponse: AWSDecodableShape {
        /// The metadata transfer job ARN.
        public let arn: String
        /// The The metadata transfer job creation DateTime property.
        public let creationDateTime: Date
        /// The metadata transfer job Id.
        public let metadataTransferJobId: String
        /// The metadata transfer job response status.
        public let status: MetadataTransferJobStatus

        public init(arn: String, creationDateTime: Date, metadataTransferJobId: String, status: MetadataTransferJobStatus) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.metadataTransferJobId = metadataTransferJobId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case metadataTransferJobId = "metadataTransferJobId"
            case status = "status"
        }
    }

    public struct CreateSceneRequest: AWSEncodableShape {
        /// A list of capabilities that the scene uses to render itself.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The description for this scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The request metadata.
        public let sceneMetadata: [String: String]?
        /// Metadata that you can use to manage the scene.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(capabilities: [String]? = nil, contentLocation: String, description: String? = nil, sceneId: String, sceneMetadata: [String: String]? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.description = description
            self.sceneId = sceneId
            self.sceneMetadata = sceneMetadata
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encode(self.contentLocation, forKey: .contentLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.sceneId, forKey: .sceneId)
            try container.encodeIfPresent(self.sceneMetadata, forKey: .sceneMetadata)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 256)
                try validate($0, name: "capabilities[]", parent: name, pattern: ".*")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, max: 256)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, pattern: "^[sS]3://[A-Za-z0-9._/-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.sceneMetadata?.forEach {
                try validate($0.key, name: "sceneMetadata.key", parent: name, max: 256)
                try validate($0.key, name: "sceneMetadata.key", parent: name, min: 1)
                try validate($0.key, name: "sceneMetadata.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try validate($0.value, name: "sceneMetadata[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "sceneMetadata[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.sceneMetadata, name: "sceneMetadata", parent: name, max: 50)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case contentLocation = "contentLocation"
            case description = "description"
            case sceneId = "sceneId"
            case sceneMetadata = "sceneMetadata"
            case tags = "tags"
        }
    }

    public struct CreateSceneResponse: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date

        public init(arn: String, creationDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
        }
    }

    public struct CreateSyncJobRequest: AWSEncodableShape {
        /// The SyncJob IAM role. This IAM role is used by the SyncJob to read from the syncSource, and create, update, or delete the corresponding resources.
        public let syncRole: String
        /// The sync source.  Currently the only supported syncSoource is SITEWISE .
        public let syncSource: String
        /// The SyncJob tags.
        public let tags: [String: String]?
        /// The workspace ID.
        public let workspaceId: String

        public init(syncRole: String, syncSource: String, tags: [String: String]? = nil, workspaceId: String) {
            self.syncRole = syncRole
            self.syncSource = syncSource
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.syncRole, forKey: .syncRole)
            request.encodePath(self.syncSource, key: "syncSource")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.syncRole, name: "syncRole", parent: name, max: 2048)
            try self.validate(self.syncRole, name: "syncRole", parent: name, min: 20)
            try self.validate(self.syncRole, name: "syncRole", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case syncRole = "syncRole"
            case tags = "tags"
        }
    }

    public struct CreateSyncJobResponse: AWSDecodableShape {
        /// The SyncJob ARN.
        public let arn: String
        /// The date and time for the SyncJob creation.
        public let creationDateTime: Date
        /// The SyncJob response state.
        public let state: SyncJobState

        public init(arn: String, creationDateTime: Date, state: SyncJobState) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case state = "state"
        }
    }

    public struct CreateWorkspaceRequest: AWSEncodableShape {
        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String?
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String?
        /// Metadata that you can use to manage the workspace
        public let tags: [String: String]?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(description: String? = nil, role: String? = nil, s3Location: String? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.description = description
            self.role = role
            self.s3Location = s3Location
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.role, forKey: .role)
            try container.encodeIfPresent(self.s3Location, forKey: .s3Location)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.s3Location, name: "s3Location", parent: name, max: 1024)
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "(^arn:((aws)|(aws-cn)|(aws-us-gov)):s3:::)([a-zA-Z0-9_-]+$)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case role = "role"
            case s3Location = "s3Location"
            case tags = "tags"
        }
    }

    public struct CreateWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date

        public init(arn: String, creationDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
        }
    }

    public struct DataConnector: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
        public let isNative: Bool?
        /// The Lambda function associated with this data connector.
        public let lambda: LambdaFunction?

        public init(isNative: Bool? = nil, lambda: LambdaFunction? = nil) {
            self.isNative = isNative
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda?.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case isNative = "isNative"
            case lambda = "lambda"
        }
    }

    public final class DataType: AWSEncodableShape & AWSDecodableShape {
        /// The allowed values for this data type.
        public let allowedValues: [DataValue]?
        /// The nested type in the data type.
        public let nestedType: DataType?
        /// A relationship that associates a component with another component.
        public let relationship: Relationship?
        /// The underlying type of the data type.
        public let type: `Type`
        /// The unit of measure used in this data type.
        public let unitOfMeasure: String?

        public init(allowedValues: [DataValue]? = nil, nestedType: DataType? = nil, relationship: Relationship? = nil, type: `Type`, unitOfMeasure: String? = nil) {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }

        public func validate(name: String) throws {
            try self.allowedValues?.forEach {
                try $0.validate(name: "\(name).allowedValues[]")
            }
            try self.validate(self.allowedValues, name: "allowedValues", parent: name, max: 50)
            try self.nestedType?.validate(name: "\(name).nestedType")
            try self.relationship?.validate(name: "\(name).relationship")
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, max: 256)
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, min: 1)
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case nestedType = "nestedType"
            case relationship = "relationship"
            case type = "type"
            case unitOfMeasure = "unitOfMeasure"
        }
    }

    public struct DataValue: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value.
        public let booleanValue: Bool?
        /// A double value.
        public let doubleValue: Double?
        /// An expression that produces the value.
        public let expression: String?
        /// An integer value.
        public let integerValue: Int?
        /// A list of multiple values.
        public let listValue: [DataValue]?
        /// A long value.
        public let longValue: Int64?
        /// An object that maps strings to multiple DataValue objects.
        public let mapValue: [String: DataValue]?
        /// A value that relates a component to another component.
        public let relationshipValue: RelationshipValue?
        /// A string value.
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, expression: String? = nil, integerValue: Int? = nil, listValue: [DataValue]? = nil, longValue: Int64? = nil, mapValue: [String: DataValue]? = nil, relationshipValue: RelationshipValue? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 316)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^(^\\$\\{Parameters\\.[a-zA-z]+([a-zA-z_0-9]*)}$)$")
            try self.listValue?.forEach {
                try $0.validate(name: "\(name).listValue[]")
            }
            try self.validate(self.listValue, name: "listValue", parent: name, max: 50)
            try self.mapValue?.forEach {
                try validate($0.key, name: "mapValue.key", parent: name, max: 256)
                try validate($0.key, name: "mapValue.key", parent: name, min: 1)
                try validate($0.key, name: "mapValue.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).mapValue[\"\($0.key)\"]")
            }
            try self.validate(self.mapValue, name: "mapValue", parent: name, max: 50)
            try self.relationshipValue?.validate(name: "\(name).relationshipValue")
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 256)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case expression = "expression"
            case integerValue = "integerValue"
            case listValue = "listValue"
            case longValue = "longValue"
            case mapValue = "mapValue"
            case relationshipValue = "relationshipValue"
            case stringValue = "stringValue"
        }
    }

    public struct DeleteComponentTypeRequest: AWSEncodableShape {
        /// The ID of the component type to delete.
        public let componentTypeId: String
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.componentTypeId, key: "componentTypeId")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentTypeResponse: AWSDecodableShape {
        /// The current state of the component type to be deleted.
        public let state: State

        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DeleteEntityRequest: AWSEncodableShape {
        /// The ID of the entity to delete.
        public let entityId: String
        /// A Boolean value that specifies whether the operation deletes child entities.
        public let isRecursive: Bool?
        /// The ID of the workspace that contains the entity to delete.
        public let workspaceId: String

        public init(entityId: String, isRecursive: Bool? = nil, workspaceId: String) {
            self.entityId = entityId
            self.isRecursive = isRecursive
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.entityId, key: "entityId")
            request.encodeQuery(self.isRecursive, key: "isRecursive")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEntityResponse: AWSDecodableShape {
        /// The current state of the deleted entity.
        public let state: State

        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DeleteSceneRequest: AWSEncodableShape {
        /// The ID of the scene to delete.
        public let sceneId: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(sceneId: String, workspaceId: String) {
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sceneId, key: "sceneId")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSceneResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSyncJobRequest: AWSEncodableShape {
        /// The sync source.  Currently the only supported syncSource is SITEWISE .
        public let syncSource: String
        /// The workspace ID.
        public let workspaceId: String

        public init(syncSource: String, workspaceId: String) {
            self.syncSource = syncSource
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.syncSource, key: "syncSource")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSyncJobResponse: AWSDecodableShape {
        /// The SyncJob response state.
        public let state: SyncJobState

        public init(state: SyncJobState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
        }
    }

    public struct DeleteWorkspaceRequest: AWSEncodableShape {
        /// The ID of the workspace to delete.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkspaceResponse: AWSDecodableShape {
        /// The string that specifies the delete result for the workspace.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The metadata transfer job Amazon Web Services IoT TwinMaker configuration.
        public let iotTwinMakerConfiguration: IotTwinMakerDestinationConfiguration?
        /// The metadata transfer job S3 configuration. [need to add S3 entity]
        public let s3Configuration: S3DestinationConfiguration?
        /// The destination type.
        public let type: DestinationType

        public init(iotTwinMakerConfiguration: IotTwinMakerDestinationConfiguration? = nil, s3Configuration: S3DestinationConfiguration? = nil, type: DestinationType) {
            self.iotTwinMakerConfiguration = iotTwinMakerConfiguration
            self.s3Configuration = s3Configuration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.iotTwinMakerConfiguration?.validate(name: "\(name).iotTwinMakerConfiguration")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case iotTwinMakerConfiguration = "iotTwinMakerConfiguration"
            case s3Configuration = "s3Configuration"
            case type = "type"
        }
    }

    public struct EntityPropertyReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public let componentPath: String?
        /// The ID of the entity.
        public let entityId: String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public let externalIdProperty: [String: String]?
        /// The name of the property.
        public let propertyName: String

        public init(componentName: String? = nil, componentPath: String? = nil, entityId: String? = nil, externalIdProperty: [String: String]? = nil, propertyName: String) {
            self.componentName = componentName
            self.componentPath = componentPath
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentPath, name: "componentPath", parent: name, max: 2048)
            try self.validate(self.componentPath, name: "componentPath", parent: name, min: 1)
            try self.validate(self.componentPath, name: "componentPath", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.externalIdProperty?.forEach {
                try validate($0.key, name: "externalIdProperty.key", parent: name, max: 256)
                try validate($0.key, name: "externalIdProperty.key", parent: name, min: 1)
                try validate($0.key, name: "externalIdProperty.key", parent: name, pattern: ".*")
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case componentPath = "componentPath"
            case entityId = "entityId"
            case externalIdProperty = "externalIdProperty"
            case propertyName = "propertyName"
        }
    }

    public struct EntitySummary: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String
        /// An eventual Boolean value that specifies whether the entity has child entities or not.
        public let hasChildEntities: Bool?
        /// The ID of the parent entity.
        public let parentEntityId: String?
        /// The current status of the entity.
        public let status: Status
        /// The last date and time when the entity was updated.
        public let updateDateTime: Date

        public init(arn: String, creationDateTime: Date, description: String? = nil, entityId: String, entityName: String, hasChildEntities: Bool? = nil, parentEntityId: String? = nil, status: Status, updateDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case entityId = "entityId"
            case entityName = "entityName"
            case hasChildEntities = "hasChildEntities"
            case parentEntityId = "parentEntityId"
            case status = "status"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode?
        /// The error message.
        public let message: String?

        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ExecuteQueryRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 50.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The query statement.
        public let queryStatement: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, queryStatement: String, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryStatement = queryStatement
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, max: 1000)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, pattern: "^[\\s\\S]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case queryStatement = "queryStatement"
            case workspaceId = "workspaceId"
        }
    }

    public struct ExecuteQueryResponse: AWSDecodableShape {
        /// A list of ColumnDescription objects.
        public let columnDescriptions: [ColumnDescription]?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Represents a single row in the query results.
        public let rows: [Row]?

        public init(columnDescriptions: [ColumnDescription]? = nil, nextToken: String? = nil, rows: [Row]? = nil) {
            self.columnDescriptions = columnDescriptions
            self.nextToken = nextToken
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case columnDescriptions = "columnDescriptions"
            case nextToken = "nextToken"
            case rows = "rows"
        }
    }

    public struct FilterByAsset: AWSEncodableShape & AWSDecodableShape {
        /// The external-Id property of an asset.
        public let assetExternalId: String?
        /// Filter by asset Id.
        public let assetId: String?
        /// Boolean to include the asset model.
        public let includeAssetModel: Bool?
        /// Includes sub-assets.[need description hekp for this]
        public let includeOffspring: Bool?

        public init(assetExternalId: String? = nil, assetId: String? = nil, includeAssetModel: Bool? = nil, includeOffspring: Bool? = nil) {
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.includeAssetModel = includeAssetModel
            self.includeOffspring = includeOffspring
        }

        public func validate(name: String) throws {
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, max: 128)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, min: 2)
            try self.validate(self.assetExternalId, name: "assetExternalId", parent: name, pattern: "[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+")
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetExternalId = "assetExternalId"
            case assetId = "assetId"
            case includeAssetModel = "includeAssetModel"
            case includeOffspring = "includeOffspring"
        }
    }

    public struct FilterByAssetModel: AWSEncodableShape & AWSDecodableShape {
        /// The external-Id property of an asset model.
        public let assetModelExternalId: String?
        /// The asset model Id.
        public let assetModelId: String?
        /// Bolean to include assets.
        public let includeAssets: Bool?
        /// Include asset offspring. [need desc.]
        public let includeOffspring: Bool?

        public init(assetModelExternalId: String? = nil, assetModelId: String? = nil, includeAssets: Bool? = nil, includeOffspring: Bool? = nil) {
            self.assetModelExternalId = assetModelExternalId
            self.assetModelId = assetModelId
            self.includeAssets = includeAssets
            self.includeOffspring = includeOffspring
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, max: 128)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, min: 2)
            try self.validate(self.assetModelExternalId, name: "assetModelExternalId", parent: name, pattern: "[a-zA-Z0-9_][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9_]+")
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelExternalId = "assetModelExternalId"
            case assetModelId = "assetModelId"
            case includeAssets = "includeAssets"
            case includeOffspring = "includeOffspring"
        }
    }

    public struct FilterByComponentType: AWSEncodableShape & AWSDecodableShape {
        /// The component type Id.
        public let componentTypeId: String

        public init(componentTypeId: String) {
            self.componentTypeId = componentTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId = "componentTypeId"
        }
    }

    public struct FilterByEntity: AWSEncodableShape & AWSDecodableShape {
        /// The entity Id.
        public let entityId: String

        public init(entityId: String) {
            self.entityId = entityId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "entityId"
        }
    }

    public struct FunctionRequest: AWSEncodableShape {
        /// The data connector.
        public let implementedBy: DataConnector?
        /// The required properties of the function.
        public let requiredProperties: [String]?
        /// The scope of the function.
        public let scope: Scope?

        public init(implementedBy: DataConnector? = nil, requiredProperties: [String]? = nil, scope: Scope? = nil) {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.implementedBy?.validate(name: "\(name).implementedBy")
            try self.requiredProperties?.forEach {
                try validate($0, name: "requiredProperties[]", parent: name, max: 256)
                try validate($0, name: "requiredProperties[]", parent: name, min: 1)
                try validate($0, name: "requiredProperties[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case implementedBy = "implementedBy"
            case requiredProperties = "requiredProperties"
            case scope = "scope"
        }
    }

    public struct FunctionResponse: AWSDecodableShape {
        /// The data connector.
        public let implementedBy: DataConnector?
        /// Indicates whether this function is inherited.
        public let isInherited: Bool?
        /// The required properties of the function.
        public let requiredProperties: [String]?
        /// The scope of the function.
        public let scope: Scope?

        public init(implementedBy: DataConnector? = nil, isInherited: Bool? = nil, requiredProperties: [String]? = nil, scope: Scope? = nil) {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case implementedBy = "implementedBy"
            case isInherited = "isInherited"
            case requiredProperties = "requiredProperties"
            case scope = "scope"
        }
    }

    public struct GetComponentTypeRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.componentTypeId, key: "componentTypeId")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The component type name.
        public let componentTypeName: String?
        /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
        public let compositeComponentTypes: [String: CompositeComponentTypeResponse]?
        /// The date and time when the component type was created.
        public let creationDateTime: Date
        /// The description of the component type.
        public let description: String?
        /// The name of the parent component type that this component type extends.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
        public let functions: [String: FunctionResponse]?
        /// A Boolean value that specifies whether the component type is abstract.
        public let isAbstract: Bool?
        /// A Boolean value that specifies whether the component type has a schema initializer and that the schema initializer has run.
        public let isSchemaInitialized: Bool?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionResponse]?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let propertyGroups: [String: PropertyGroupResponse]?
        /// The current status of the component type.
        public let status: Status?
        /// The syncSource of the SyncJob, if this entity was created by a SyncJob.
        public let syncSource: String?
        /// The date and time when the component was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(arn: String, componentTypeId: String, componentTypeName: String? = nil, compositeComponentTypes: [String: CompositeComponentTypeResponse]? = nil, creationDateTime: Date, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionResponse]? = nil, isAbstract: Bool? = nil, isSchemaInitialized: Bool? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionResponse]? = nil, propertyGroups: [String: PropertyGroupResponse]? = nil, status: Status? = nil, syncSource: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.compositeComponentTypes = compositeComponentTypes
            self.creationDateTime = creationDateTime
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isAbstract = isAbstract
            self.isSchemaInitialized = isSchemaInitialized
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case componentTypeId = "componentTypeId"
            case componentTypeName = "componentTypeName"
            case compositeComponentTypes = "compositeComponentTypes"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case extendsFrom = "extendsFrom"
            case functions = "functions"
            case isAbstract = "isAbstract"
            case isSchemaInitialized = "isSchemaInitialized"
            case isSingleton = "isSingleton"
            case propertyDefinitions = "propertyDefinitions"
            case propertyGroups = "propertyGroups"
            case status = "status"
            case syncSource = "syncSource"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }

    public struct GetEntityRequest: AWSEncodableShape {
        /// The ID of the entity.
        public let entityId: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(entityId: String, workspaceId: String) {
            self.entityId = entityId
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.entityId, key: "entityId")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEntityResponse: AWSDecodableShape {
        /// This flag notes whether all components are returned in the API response. The maximum number of components returned is 30.
        public let areAllComponentsReturned: Bool?
        /// The ARN of the entity.
        public let arn: String
        /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
        public let components: [String: ComponentResponse]?
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String
        /// A Boolean value that specifies whether the entity has associated child entities.
        public let hasChildEntities: Bool
        /// The ID of the parent entity for this entity.
        public let parentEntityId: String
        /// The current status of the entity.
        public let status: Status
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public let syncSource: String?
        /// The date and time when the entity was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(areAllComponentsReturned: Bool? = nil, arn: String, components: [String: ComponentResponse]? = nil, creationDateTime: Date, description: String? = nil, entityId: String, entityName: String, hasChildEntities: Bool, parentEntityId: String, status: Status, syncSource: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.areAllComponentsReturned = areAllComponentsReturned
            self.arn = arn
            self.components = components
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case areAllComponentsReturned = "areAllComponentsReturned"
            case arn = "arn"
            case components = "components"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case entityId = "entityId"
            case entityName = "entityName"
            case hasChildEntities = "hasChildEntities"
            case parentEntityId = "parentEntityId"
            case status = "status"
            case syncSource = "syncSource"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }

    public struct GetMetadataTransferJobRequest: AWSEncodableShape {
        /// The metadata transfer job Id.
        public let metadataTransferJobId: String

        public init(metadataTransferJobId: String) {
            self.metadataTransferJobId = metadataTransferJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.metadataTransferJobId, key: "metadataTransferJobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, max: 128)
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, min: 1)
            try self.validate(self.metadataTransferJobId, name: "metadataTransferJobId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetadataTransferJobResponse: AWSDecodableShape {
        /// The metadata transfer job ARN.
        public let arn: String
        /// The metadata transfer job's creation DateTime property.
        public let creationDateTime: Date
        /// The metadata transfer job description.
        public let description: String?
        /// The metadata transfer job's destination.
        public let destination: DestinationConfiguration
        /// The metadata transfer job Id.
        public let metadataTransferJobId: String
        /// The metadata transfer job's role.
        public let metadataTransferJobRole: String
        /// The metadata transfer job's progress.
        public let progress: MetadataTransferJobProgress?
        /// The metadata transfer job's report URL.
        public let reportUrl: String?
        /// The metadata transfer job's sources.
        public let sources: [SourceConfiguration]
        /// The metadata transfer job's status.
        public let status: MetadataTransferJobStatus
        /// The metadata transfer job's update DateTime property.
        public let updateDateTime: Date

        public init(arn: String, creationDateTime: Date, description: String? = nil, destination: DestinationConfiguration, metadataTransferJobId: String, metadataTransferJobRole: String, progress: MetadataTransferJobProgress? = nil, reportUrl: String? = nil, sources: [SourceConfiguration], status: MetadataTransferJobStatus, updateDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.destination = destination
            self.metadataTransferJobId = metadataTransferJobId
            self.metadataTransferJobRole = metadataTransferJobRole
            self.progress = progress
            self.reportUrl = reportUrl
            self.sources = sources
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case destination = "destination"
            case metadataTransferJobId = "metadataTransferJobId"
            case metadataTransferJobRole = "metadataTransferJobRole"
            case progress = "progress"
            case reportUrl = "reportUrl"
            case sources = "sources"
            case status = "status"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct GetPricingPlanRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPricingPlanResponse: AWSDecodableShape {
        /// The chosen pricing plan for the current billing cycle.
        public let currentPricingPlan: PricingPlan
        /// The pending pricing plan.
        public let pendingPricingPlan: PricingPlan?

        public init(currentPricingPlan: PricingPlan, pendingPricingPlan: PricingPlan? = nil) {
            self.currentPricingPlan = currentPricingPlan
            self.pendingPricingPlan = pendingPricingPlan
        }

        private enum CodingKeys: String, CodingKey {
            case currentPricingPlan = "currentPricingPlan"
            case pendingPricingPlan = "pendingPricingPlan"
        }
    }

    public struct GetPropertyValueHistoryRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public let componentPath: String?
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The date and time of the latest property value to return.
        public let endDateTime: Date?
        /// The ISO8601 DateTime of the latest property value to return. For more information about the ISO8601 DateTime format, see the data type PropertyValue.
        public let endTime: String?
        /// The ID of the entity.
        public let entityId: String?
        /// An object that specifies the interpolation type and the interval over which to interpolate data.
        public let interpolation: InterpolationParameters?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The time direction to use in the result order.
        public let orderByTime: OrderByTime?
        /// A list of objects that filter the property value history request.
        public let propertyFilters: [PropertyFilter]?
        /// A list of properties whose value histories the request retrieves.
        public let selectedProperties: [String]
        /// The date and time of the earliest property value to return.
        public let startDateTime: Date?
        /// The ISO8601 DateTime of the earliest property value to return. For more information about the ISO8601 DateTime format, see the data type PropertyValue.
        public let startTime: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentName: String? = nil, componentPath: String? = nil, componentTypeId: String? = nil, endTime: String? = nil, entityId: String? = nil, interpolation: InterpolationParameters? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderByTime: OrderByTime? = nil, propertyFilters: [PropertyFilter]? = nil, selectedProperties: [String], startTime: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentPath = componentPath
            self.componentTypeId = componentTypeId
            self.endDateTime = nil
            self.endTime = endTime
            self.entityId = entityId
            self.interpolation = interpolation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderByTime = orderByTime
            self.propertyFilters = propertyFilters
            self.selectedProperties = selectedProperties
            self.startDateTime = nil
            self.startTime = startTime
            self.workspaceId = workspaceId
        }

        @available(*, deprecated, message: "Members endDateTime, startDateTime have been deprecated")
        public init(componentName: String? = nil, componentPath: String? = nil, componentTypeId: String? = nil, endDateTime: Date? = nil, endTime: String? = nil, entityId: String? = nil, interpolation: InterpolationParameters? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderByTime: OrderByTime? = nil, propertyFilters: [PropertyFilter]? = nil, selectedProperties: [String], startDateTime: Date? = nil, startTime: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentPath = componentPath
            self.componentTypeId = componentTypeId
            self.endDateTime = endDateTime
            self.endTime = endTime
            self.entityId = entityId
            self.interpolation = interpolation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderByTime = orderByTime
            self.propertyFilters = propertyFilters
            self.selectedProperties = selectedProperties
            self.startDateTime = startDateTime
            self.startTime = startTime
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.componentName, forKey: .componentName)
            try container.encodeIfPresent(self.componentPath, forKey: .componentPath)
            try container.encodeIfPresent(self.componentTypeId, forKey: .componentTypeId)
            try container.encodeIfPresent(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.endTime, forKey: .endTime)
            try container.encodeIfPresent(self.entityId, forKey: .entityId)
            try container.encodeIfPresent(self.interpolation, forKey: .interpolation)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.orderByTime, forKey: .orderByTime)
            try container.encodeIfPresent(self.propertyFilters, forKey: .propertyFilters)
            try container.encode(self.selectedProperties, forKey: .selectedProperties)
            try container.encodeIfPresent(self.startDateTime, forKey: .startDateTime)
            try container.encodeIfPresent(self.startTime, forKey: .startTime)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentPath, name: "componentPath", parent: name, max: 2048)
            try self.validate(self.componentPath, name: "componentPath", parent: name, min: 1)
            try self.validate(self.componentPath, name: "componentPath", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.endTime, name: "endTime", parent: name, max: 35)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 20)
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.propertyFilters?.forEach {
                try $0.validate(name: "\(name).propertyFilters[]")
            }
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, max: 10)
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, min: 1)
            try self.selectedProperties.forEach {
                try validate($0, name: "selectedProperties[]", parent: name, max: 256)
                try validate($0, name: "selectedProperties[]", parent: name, min: 1)
                try validate($0, name: "selectedProperties[]", parent: name, pattern: ".*")
            }
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, max: 10)
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, min: 1)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 35)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 20)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case componentPath = "componentPath"
            case componentTypeId = "componentTypeId"
            case endDateTime = "endDateTime"
            case endTime = "endTime"
            case entityId = "entityId"
            case interpolation = "interpolation"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case orderByTime = "orderByTime"
            case propertyFilters = "propertyFilters"
            case selectedProperties = "selectedProperties"
            case startDateTime = "startDateTime"
            case startTime = "startTime"
        }
    }

    public struct GetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
        public let propertyValues: [PropertyValueHistory]

        public init(nextToken: String? = nil, propertyValues: [PropertyValueHistory]) {
            self.nextToken = nextToken
            self.propertyValues = propertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case propertyValues = "propertyValues"
        }
    }

    public struct GetPropertyValueRequest: AWSEncodableShape {
        /// The name of the component whose property values the operation returns.
        public let componentName: String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public let componentPath: String?
        /// The ID of the component type whose property values the operation returns.
        public let componentTypeId: String?
        /// The ID of the entity whose property values the operation returns.
        public let entityId: String?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The property group name.
        public let propertyGroupName: String?
        /// The properties whose values the operation returns.
        public let selectedProperties: [String]
        /// The tabular conditions.
        public let tabularConditions: TabularConditions?
        /// The ID of the workspace whose values the operation returns.
        public let workspaceId: String

        public init(componentName: String? = nil, componentPath: String? = nil, componentTypeId: String? = nil, entityId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyGroupName: String? = nil, selectedProperties: [String], tabularConditions: TabularConditions? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentPath = componentPath
            self.componentTypeId = componentTypeId
            self.entityId = entityId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyGroupName = propertyGroupName
            self.selectedProperties = selectedProperties
            self.tabularConditions = tabularConditions
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.componentName, forKey: .componentName)
            try container.encodeIfPresent(self.componentPath, forKey: .componentPath)
            try container.encodeIfPresent(self.componentTypeId, forKey: .componentTypeId)
            try container.encodeIfPresent(self.entityId, forKey: .entityId)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.propertyGroupName, forKey: .propertyGroupName)
            try container.encode(self.selectedProperties, forKey: .selectedProperties)
            try container.encodeIfPresent(self.tabularConditions, forKey: .tabularConditions)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentPath, name: "componentPath", parent: name, max: 2048)
            try self.validate(self.componentPath, name: "componentPath", parent: name, min: 1)
            try self.validate(self.componentPath, name: "componentPath", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.propertyGroupName, name: "propertyGroupName", parent: name, max: 256)
            try self.validate(self.propertyGroupName, name: "propertyGroupName", parent: name, min: 1)
            try self.validate(self.propertyGroupName, name: "propertyGroupName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.selectedProperties.forEach {
                try validate($0, name: "selectedProperties[]", parent: name, max: 256)
                try validate($0, name: "selectedProperties[]", parent: name, min: 1)
                try validate($0, name: "selectedProperties[]", parent: name, pattern: ".*")
            }
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, max: 10)
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, min: 1)
            try self.tabularConditions?.validate(name: "\(name).tabularConditions")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case componentPath = "componentPath"
            case componentTypeId = "componentTypeId"
            case entityId = "entityId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case propertyGroupName = "propertyGroupName"
            case selectedProperties = "selectedProperties"
            case tabularConditions = "tabularConditions"
        }
    }

    public struct GetPropertyValueResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// An object that maps strings to the properties and latest property values in the response. Each string in the mapping must be unique to this object.
        public let propertyValues: [String: PropertyLatestValue]?
        /// A table of property values.
        public let tabularPropertyValues: [[[String: DataValue]]]?

        public init(nextToken: String? = nil, propertyValues: [String: PropertyLatestValue]? = nil, tabularPropertyValues: [[[String: DataValue]]]? = nil) {
            self.nextToken = nextToken
            self.propertyValues = propertyValues
            self.tabularPropertyValues = tabularPropertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case propertyValues = "propertyValues"
            case tabularPropertyValues = "tabularPropertyValues"
        }
    }

    public struct GetSceneRequest: AWSEncodableShape {
        /// The ID of the scene.
        public let sceneId: String
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(sceneId: String, workspaceId: String) {
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sceneId, key: "sceneId")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSceneResponse: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// A list of capabilities that the scene uses to render.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date
        /// The description of the scene.
        public let description: String?
        /// The SceneResponse error.
        public let error: SceneError?
        /// The generated scene metadata.
        public let generatedSceneMetadata: [String: String]?
        /// The ID of the scene.
        public let sceneId: String
        /// The response metadata.
        public let sceneMetadata: [String: String]?
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(arn: String, capabilities: [String]? = nil, contentLocation: String, creationDateTime: Date, description: String? = nil, error: SceneError? = nil, generatedSceneMetadata: [String: String]? = nil, sceneId: String, sceneMetadata: [String: String]? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.error = error
            self.generatedSceneMetadata = generatedSceneMetadata
            self.sceneId = sceneId
            self.sceneMetadata = sceneMetadata
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case capabilities = "capabilities"
            case contentLocation = "contentLocation"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case error = "error"
            case generatedSceneMetadata = "generatedSceneMetadata"
            case sceneId = "sceneId"
            case sceneMetadata = "sceneMetadata"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }

    public struct GetSyncJobRequest: AWSEncodableShape {
        /// The sync source.  Currently the only supported syncSource is SITEWISE .
        public let syncSource: String
        /// The workspace ID.
        public let workspaceId: String?

        public init(syncSource: String, workspaceId: String? = nil) {
            self.syncSource = syncSource
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.syncSource, key: "syncSource")
            request.encodeQuery(self.workspaceId, key: "workspace")
        }

        public func validate(name: String) throws {
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSyncJobResponse: AWSDecodableShape {
        /// The sync job ARN.
        public let arn: String
        /// The creation date and time.
        public let creationDateTime: Date
        /// The SyncJob response status.
        public let status: SyncJobStatus
        /// The sync IAM role.
        public let syncRole: String
        /// The sync soucre.  Currently the only supported syncSource is SITEWISE .
        public let syncSource: String
        /// The update date and time.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, status: SyncJobStatus, syncRole: String, syncSource: String, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncRole = syncRole
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case status = "status"
            case syncRole = "syncRole"
            case syncSource = "syncSource"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }

    public struct GetWorkspaceRequest: AWSEncodableShape {
        /// The ID of the workspace.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 2048)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$|^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date
        /// The description of the workspace.
        public let description: String?
        /// A list of services that are linked to the workspace.
        public let linkedServices: [String]?
        /// The ARN of the execution role associated with the workspace.
        public let role: String?
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String?
        /// The date and time when the workspace was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, description: String? = nil, linkedServices: [String]? = nil, role: String? = nil, s3Location: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.linkedServices = linkedServices
            self.role = role
            self.s3Location = s3Location
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case linkedServices = "linkedServices"
            case role = "role"
            case s3Location = "s3Location"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }

    public struct InterpolationParameters: AWSEncodableShape {
        /// The interpolation type.
        public let interpolationType: InterpolationType?
        /// The interpolation time interval in seconds.
        public let intervalInSeconds: Int64?

        public init(interpolationType: InterpolationType? = nil, intervalInSeconds: Int64? = nil) {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case interpolationType = "interpolationType"
            case intervalInSeconds = "intervalInSeconds"
        }
    }

    public struct IotSiteWiseSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The AWS IoT SiteWise soucre configuration filters.
        public let filters: [IotSiteWiseSourceConfigurationFilter]?

        public init(filters: [IotSiteWiseSourceConfigurationFilter]? = nil) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct IotTwinMakerDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The IoT TwinMaker workspace.
        public let workspace: String

        public init(workspace: String) {
            self.workspace = workspace
        }

        public func validate(name: String) throws {
            try self.validate(self.workspace, name: "workspace", parent: name, max: 2048)
            try self.validate(self.workspace, name: "workspace", parent: name, min: 20)
            try self.validate(self.workspace, name: "workspace", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workspace = "workspace"
        }
    }

    public struct IotTwinMakerSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The metadata transfer job AWS IoT TwinMaker source configuration filters.
        public let filters: [IotTwinMakerSourceConfigurationFilter]?
        /// The IoT TwinMaker workspace.
        public let workspace: String

        public init(filters: [IotTwinMakerSourceConfigurationFilter]? = nil, workspace: String) {
            self.filters = filters
            self.workspace = workspace
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.workspace, name: "workspace", parent: name, max: 2048)
            try self.validate(self.workspace, name: "workspace", parent: name, min: 20)
            try self.validate(self.workspace, name: "workspace", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case workspace = "workspace"
        }
    }

    public struct LambdaFunction: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):lambda:[a-z0-9-]+:[0-9]{12}:function:[\\/a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListComponentTypesRequest: AWSEncodableShape {
        /// A list of objects that filter the request.
        public let filters: [ListComponentTypesFilter]?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(filters: [ListComponentTypesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentTypesResponse: AWSDecodableShape {
        /// A list of objects that contain information about the component types.
        public let componentTypeSummaries: [ComponentTypeSummary]
        /// Specifies the maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentTypeSummaries: [ComponentTypeSummary], maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.componentTypeSummaries = componentTypeSummaries
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeSummaries = "componentTypeSummaries"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case workspaceId = "workspaceId"
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {
        /// This string specifies the path to the composite component, starting from the top-level component.
        public let componentPath: String?
        /// The ID for the entity whose metadata (component/properties) is returned by the operation.
        public let entityId: String
        /// The maximum number of results returned at one time. The default is 25.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The workspace ID.
        public let workspaceId: String

        public init(componentPath: String? = nil, entityId: String, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.componentPath = componentPath
            self.entityId = entityId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.componentPath, forKey: .componentPath)
            request.encodePath(self.entityId, key: "entityId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentPath, name: "componentPath", parent: name, max: 2048)
            try self.validate(self.componentPath, name: "componentPath", parent: name, min: 1)
            try self.validate(self.componentPath, name: "componentPath", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentPath = "componentPath"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentsResponse: AWSDecodableShape {
        /// A list of objects that contain information about the components.
        public let componentSummaries: [ComponentSummary]
        /// The string that specifies the next page of component results.
        public let nextToken: String?

        public init(componentSummaries: [ComponentSummary], nextToken: String? = nil) {
            self.componentSummaries = componentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case componentSummaries = "componentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListEntitiesRequest: AWSEncodableShape {
        /// A list of objects that filter the request.  Only one object is accepted as a valid input.
        public let filters: [ListEntitiesFilter]?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(filters: [ListEntitiesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEntitiesResponse: AWSDecodableShape {
        /// A list of objects that contain information about the entities.
        public let entitySummaries: [EntitySummary]?
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(entitySummaries: [EntitySummary]? = nil, nextToken: String? = nil) {
            self.entitySummaries = entitySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entitySummaries = "entitySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMetadataTransferJobsRequest: AWSEncodableShape {
        /// The metadata transfer job's destination type.
        public let destinationType: DestinationType
        /// An object that filters metadata transfer jobs.
        public let filters: [ListMetadataTransferJobsFilter]?
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The metadata transfer job's source type.
        public let sourceType: SourceType

        public init(destinationType: DestinationType, filters: [ListMetadataTransferJobsFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sourceType: SourceType) {
            self.destinationType = destinationType
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationType = "destinationType"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sourceType = "sourceType"
        }
    }

    public struct ListMetadataTransferJobsResponse: AWSDecodableShape {
        /// The metadata transfer job summaries.
        public let metadataTransferJobSummaries: [MetadataTransferJobSummary]
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(metadataTransferJobSummaries: [MetadataTransferJobSummary], nextToken: String? = nil) {
            self.metadataTransferJobSummaries = metadataTransferJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metadataTransferJobSummaries = "metadataTransferJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPropertiesRequest: AWSEncodableShape {
        /// The name of the component whose properties are returned by the operation.
        public let componentName: String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public let componentPath: String?
        /// The ID for the entity whose metadata (component/properties) is returned by the operation.
        public let entityId: String
        /// The maximum number of results returned at one time. The default is 25.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The workspace ID.
        public let workspaceId: String

        public init(componentName: String? = nil, componentPath: String? = nil, entityId: String, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentPath = componentPath
            self.entityId = entityId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.componentName, forKey: .componentName)
            try container.encodeIfPresent(self.componentPath, forKey: .componentPath)
            try container.encode(self.entityId, forKey: .entityId)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentPath, name: "componentPath", parent: name, max: 2048)
            try self.validate(self.componentPath, name: "componentPath", parent: name, min: 1)
            try self.validate(self.componentPath, name: "componentPath", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case componentPath = "componentPath"
            case entityId = "entityId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListPropertiesResponse: AWSDecodableShape {
        /// The string that specifies the next page of property results.
        public let nextToken: String?
        /// A list of objects that contain information about the properties.
        public let propertySummaries: [PropertySummary]

        public init(nextToken: String? = nil, propertySummaries: [PropertySummary]) {
            self.nextToken = nextToken
            self.propertySummaries = propertySummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case propertySummaries = "propertySummaries"
        }
    }

    public struct ListScenesRequest: AWSEncodableShape {
        /// Specifies the maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace that contains the scenes.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListScenesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// A list of objects that contain information about the scenes.
        public let sceneSummaries: [SceneSummary]?

        public init(nextToken: String? = nil, sceneSummaries: [SceneSummary]? = nil) {
            self.nextToken = nextToken
            self.sceneSummaries = sceneSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sceneSummaries = "sceneSummaries"
        }
    }

    public struct ListSyncJobsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSyncJobsResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The listed SyncJob summaries.
        public let syncJobSummaries: [SyncJobSummary]?

        public init(nextToken: String? = nil, syncJobSummaries: [SyncJobSummary]? = nil) {
            self.nextToken = nextToken
            self.syncJobSummaries = syncJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case syncJobSummaries = "syncJobSummaries"
        }
    }

    public struct ListSyncResourcesRequest: AWSEncodableShape {
        /// A list of objects that filter the request. The following filter combinations are supported:   Filter with state   Filter with ResourceType and ResourceId   Filter with ResourceType and ExternalId
        public let filters: [SyncResourceFilter]?
        /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The sync source.  Currently the only supported syncSource is SITEWISE .
        public let syncSource: String
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String

        public init(filters: [SyncResourceFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, syncSource: String, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.syncSource = syncSource
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.syncSource, key: "syncSource")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSyncResourcesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The sync resources.
        public let syncResources: [SyncResourceSummary]?

        public init(nextToken: String? = nil, syncResources: [SyncResourceSummary]? = nil) {
            self.nextToken = nextToken
            self.syncResources = syncResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case syncResources = "syncResources"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ARN of the resource.
        public let resourceARN: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceARN = "resourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Metadata that you can use to manage a resource.
        public let tags: [String: String]?

        public init(nextToken: String? = nil, tags: [String: String]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct ListWorkspacesRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkspacesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// A list of objects that contain information about the workspaces.
        public let workspaceSummaries: [WorkspaceSummary]?

        public init(nextToken: String? = nil, workspaceSummaries: [WorkspaceSummary]? = nil) {
            self.nextToken = nextToken
            self.workspaceSummaries = workspaceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workspaceSummaries = "workspaceSummaries"
        }
    }

    public struct MetadataTransferJobProgress: AWSDecodableShape {
        /// The failed count.
        public let failedCount: Int?
        /// The skipped count.
        public let skippedCount: Int?
        /// The succeeded count.
        public let succeededCount: Int?
        /// The total count. [of what]
        public let totalCount: Int?

        public init(failedCount: Int? = nil, skippedCount: Int? = nil, succeededCount: Int? = nil, totalCount: Int? = nil) {
            self.failedCount = failedCount
            self.skippedCount = skippedCount
            self.succeededCount = succeededCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "failedCount"
            case skippedCount = "skippedCount"
            case succeededCount = "succeededCount"
            case totalCount = "totalCount"
        }
    }

    public struct MetadataTransferJobStatus: AWSDecodableShape {
        /// The metadata transfer job error.
        public let error: ErrorDetails?
        /// The queued position.
        public let queuedPosition: Int?
        /// The metadata transfer job state.
        public let state: MetadataTransferJobState?

        public init(error: ErrorDetails? = nil, queuedPosition: Int? = nil, state: MetadataTransferJobState? = nil) {
            self.error = error
            self.queuedPosition = queuedPosition
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case queuedPosition = "queuedPosition"
            case state = "state"
        }
    }

    public struct MetadataTransferJobSummary: AWSDecodableShape {
        /// The metadata transfer job summary ARN.
        public let arn: String
        /// The metadata transfer job summary creation DateTime object.
        public let creationDateTime: Date
        /// The metadata transfer job summary Id.
        public let metadataTransferJobId: String
        /// The metadata transfer job summary progess.
        public let progress: MetadataTransferJobProgress?
        /// The metadata transfer job summary status.
        public let status: MetadataTransferJobStatus
        /// The metadata transfer job summary update DateTime object
        public let updateDateTime: Date

        public init(arn: String, creationDateTime: Date, metadataTransferJobId: String, progress: MetadataTransferJobProgress? = nil, status: MetadataTransferJobStatus, updateDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.metadataTransferJobId = metadataTransferJobId
            self.progress = progress
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case metadataTransferJobId = "metadataTransferJobId"
            case progress = "progress"
            case status = "status"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct OrderBy: AWSEncodableShape {
        /// The set order that filters results.
        public let order: Order?
        /// The property name.
        public let propertyName: String

        public init(order: Order? = nil, propertyName: String) {
            self.order = order
            self.propertyName = propertyName
        }

        public func validate(name: String) throws {
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case order = "order"
            case propertyName = "propertyName"
        }
    }

    public struct ParentEntityUpdateRequest: AWSEncodableShape {
        /// The ID of the parent entity.
        public let parentEntityId: String?
        /// The type of the update.
        public let updateType: ParentEntityUpdateType

        public init(parentEntityId: String? = nil, updateType: ParentEntityUpdateType) {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, max: 128)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, min: 1)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parentEntityId = "parentEntityId"
            case updateType = "updateType"
        }
    }

    public struct PricingPlan: AWSDecodableShape {
        /// The billable entity count.
        public let billableEntityCount: Int64?
        /// The pricing plan's bundle information.
        public let bundleInformation: BundleInformation?
        /// The effective date and time of the pricing plan.
        public let effectiveDateTime: Date
        /// The pricing mode.
        public let pricingMode: PricingMode
        /// The set date and time for updating a pricing plan.
        public let updateDateTime: Date
        /// The update reason for changing a pricing plan.
        public let updateReason: UpdateReason

        public init(billableEntityCount: Int64? = nil, bundleInformation: BundleInformation? = nil, effectiveDateTime: Date, pricingMode: PricingMode, updateDateTime: Date, updateReason: UpdateReason) {
            self.billableEntityCount = billableEntityCount
            self.bundleInformation = bundleInformation
            self.effectiveDateTime = effectiveDateTime
            self.pricingMode = pricingMode
            self.updateDateTime = updateDateTime
            self.updateReason = updateReason
        }

        private enum CodingKeys: String, CodingKey {
            case billableEntityCount = "billableEntityCount"
            case bundleInformation = "bundleInformation"
            case effectiveDateTime = "effectiveDateTime"
            case pricingMode = "pricingMode"
            case updateDateTime = "updateDateTime"
            case updateReason = "updateReason"
        }
    }

    public struct PropertyDefinitionRequest: AWSEncodableShape {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public let configuration: [String: String]?
        /// An object that contains information about the data type.
        public let dataType: DataType?
        /// An object that contains the default value.
        public let defaultValue: DataValue?
        /// A friendly name for the property.
        public let displayName: String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public let isExternalId: Bool?
        /// A Boolean value that specifies whether the property is required.
        public let isRequiredInEntity: Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public let isStoredExternally: Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public let isTimeSeries: Bool?

        public init(configuration: [String: String]? = nil, dataType: DataType? = nil, defaultValue: DataValue? = nil, displayName: String? = nil, isExternalId: Bool? = nil, isRequiredInEntity: Bool? = nil, isStoredExternally: Bool? = nil, isTimeSeries: Bool? = nil) {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }

        public func validate(name: String) throws {
            try self.configuration?.forEach {
                try validate($0.key, name: "configuration.key", parent: name, max: 256)
                try validate($0.key, name: "configuration.key", parent: name, min: 1)
                try validate($0.key, name: "configuration.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try validate($0.value, name: "configuration[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.dataType?.validate(name: "\(name).dataType")
            try self.defaultValue?.validate(name: "\(name).defaultValue")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]*")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case displayName = "displayName"
            case isExternalId = "isExternalId"
            case isRequiredInEntity = "isRequiredInEntity"
            case isStoredExternally = "isStoredExternally"
            case isTimeSeries = "isTimeSeries"
        }
    }

    public struct PropertyDefinitionResponse: AWSDecodableShape {
        /// A mapping that specifies configuration information about the property.
        public let configuration: [String: String]?
        /// An object that contains information about the data type.
        public let dataType: DataType
        /// An object that contains the default value.
        public let defaultValue: DataValue?
        /// A friendly name for the property.
        public let displayName: String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public let isExternalId: Bool
        /// A Boolean value that specifies whether the property definition can be updated.
        public let isFinal: Bool
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        public let isImported: Bool
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        public let isInherited: Bool
        /// A Boolean value that specifies whether the property is required in an entity.
        public let isRequiredInEntity: Bool
        /// A Boolean value that specifies whether the property is stored externally.
        public let isStoredExternally: Bool
        /// A Boolean value that specifies whether the property consists of time series data.
        public let isTimeSeries: Bool

        public init(configuration: [String: String]? = nil, dataType: DataType, defaultValue: DataValue? = nil, displayName: String? = nil, isExternalId: Bool, isFinal: Bool, isImported: Bool, isInherited: Bool, isRequiredInEntity: Bool, isStoredExternally: Bool, isTimeSeries: Bool) {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case displayName = "displayName"
            case isExternalId = "isExternalId"
            case isFinal = "isFinal"
            case isImported = "isImported"
            case isInherited = "isInherited"
            case isRequiredInEntity = "isRequiredInEntity"
            case isStoredExternally = "isStoredExternally"
            case isTimeSeries = "isTimeSeries"
        }
    }

    public struct PropertyFilter: AWSEncodableShape {
        /// The operator associated with this property filter.
        public let `operator`: String?
        /// The property name associated with this property filter.
        public let propertyName: String?
        /// The value associated with this property filter.
        public let value: DataValue?

        public init(operator: String? = nil, propertyName: String? = nil, value: DataValue? = nil) {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.`operator`, name: "`operator`", parent: name, max: 256)
            try self.validate(self.`operator`, name: "`operator`", parent: name, min: 1)
            try self.validate(self.`operator`, name: "`operator`", parent: name, pattern: ".*")
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: ".*")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "operator"
            case propertyName = "propertyName"
            case value = "value"
        }
    }

    public struct PropertyGroupRequest: AWSEncodableShape {
        /// The group type.
        public let groupType: GroupType?
        /// The names of properties.
        public let propertyNames: [String]?

        public init(groupType: GroupType? = nil, propertyNames: [String]? = nil) {
            self.groupType = groupType
            self.propertyNames = propertyNames
        }

        public func validate(name: String) throws {
            try self.propertyNames?.forEach {
                try validate($0, name: "propertyNames[]", parent: name, max: 256)
                try validate($0, name: "propertyNames[]", parent: name, min: 1)
                try validate($0, name: "propertyNames[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupType = "groupType"
            case propertyNames = "propertyNames"
        }
    }

    public struct PropertyGroupResponse: AWSDecodableShape {
        /// The group types.
        public let groupType: GroupType
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        public let isInherited: Bool
        /// The names of properties.
        public let propertyNames: [String]

        public init(groupType: GroupType, isInherited: Bool, propertyNames: [String]) {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }

        private enum CodingKeys: String, CodingKey {
            case groupType = "groupType"
            case isInherited = "isInherited"
            case propertyNames = "propertyNames"
        }
    }

    public struct PropertyLatestValue: AWSDecodableShape {
        /// An object that specifies information about a property.
        public let propertyReference: EntityPropertyReference
        /// The value of the property.
        public let propertyValue: DataValue?

        public init(propertyReference: EntityPropertyReference, propertyValue: DataValue? = nil) {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyReference = "propertyReference"
            case propertyValue = "propertyValue"
        }
    }

    public struct PropertyRequest: AWSEncodableShape {
        /// An object that specifies information about a property.
        public let definition: PropertyDefinitionRequest?
        /// The update type of the update property request.
        public let updateType: PropertyUpdateType?
        /// The value of the property.
        public let value: DataValue?

        public init(definition: PropertyDefinitionRequest? = nil, updateType: PropertyUpdateType? = nil, value: DataValue? = nil) {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }

        public func validate(name: String) throws {
            try self.definition?.validate(name: "\(name).definition")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case updateType = "updateType"
            case value = "value"
        }
    }

    public struct PropertyResponse: AWSDecodableShape {
        /// This flag notes whether all values of a list or map type property are returned in the API response. The maximum number of values per property returned is 50.
        public let areAllPropertyValuesReturned: Bool?
        /// An object that specifies information about a property.
        public let definition: PropertyDefinitionResponse?
        /// The value of the property.
        public let value: DataValue?

        public init(areAllPropertyValuesReturned: Bool? = nil, definition: PropertyDefinitionResponse? = nil, value: DataValue? = nil) {
            self.areAllPropertyValuesReturned = areAllPropertyValuesReturned
            self.definition = definition
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case areAllPropertyValuesReturned = "areAllPropertyValuesReturned"
            case definition = "definition"
            case value = "value"
        }
    }

    public struct PropertySummary: AWSDecodableShape {
        /// This flag notes whether all values of a list or map type property are returned in the API  response. The maximum number of values per property returned is 50.
        public let areAllPropertyValuesReturned: Bool?
        /// This is the schema for the property.
        public let definition: PropertyDefinitionResponse?
        /// This is the name of the property.
        public let propertyName: String
        /// This is the value for the property.
        public let value: DataValue?

        public init(areAllPropertyValuesReturned: Bool? = nil, definition: PropertyDefinitionResponse? = nil, propertyName: String, value: DataValue? = nil) {
            self.areAllPropertyValuesReturned = areAllPropertyValuesReturned
            self.definition = definition
            self.propertyName = propertyName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case areAllPropertyValuesReturned = "areAllPropertyValuesReturned"
            case definition = "definition"
            case propertyName = "propertyName"
            case value = "value"
        }
    }

    public struct PropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// ISO8601 DateTime of a value for a time series property. The time for when the property value was recorded in ISO 8601 format: YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm].    [YYYY]: year    [MM]: month    [DD]: day    [hh]: hour    [mm]: minute    [ss]: seconds    [.SSSSSSSSS]: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.    Z: default timezone UTC    ± HH:mm: time zone offset in Hours and Minutes.    Required sub-fields: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]
        public let time: String?
        /// The timestamp of a value for a time series property.
        public let timestamp: Date?
        /// An object that specifies a value for a time series property.
        public let value: DataValue

        public init(time: String? = nil, value: DataValue) {
            self.time = time
            self.timestamp = nil
            self.value = value
        }

        @available(*, deprecated, message: "Members timestamp have been deprecated")
        public init(time: String? = nil, timestamp: Date? = nil, value: DataValue) {
            self.time = time
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.time, name: "time", parent: name, max: 35)
            try self.validate(self.time, name: "time", parent: name, min: 20)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case time = "time"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct PropertyValueEntry: AWSEncodableShape & AWSDecodableShape {
        /// An object that contains information about the entity that has the property.
        public let entityPropertyReference: EntityPropertyReference
        /// A list of objects that specify time series property values.
        public let propertyValues: [PropertyValue]?

        public init(entityPropertyReference: EntityPropertyReference, propertyValues: [PropertyValue]? = nil) {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.entityPropertyReference.validate(name: "\(name).entityPropertyReference")
            try self.propertyValues?.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
            try self.validate(self.propertyValues, name: "propertyValues", parent: name, max: 10)
            try self.validate(self.propertyValues, name: "propertyValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityPropertyReference = "entityPropertyReference"
            case propertyValues = "propertyValues"
        }
    }

    public struct PropertyValueHistory: AWSDecodableShape {
        /// An object that uniquely identifies an entity property.
        public let entityPropertyReference: EntityPropertyReference
        /// A list of objects that contain information about the values in the history of a time series property.
        public let values: [PropertyValue]?

        public init(entityPropertyReference: EntityPropertyReference, values: [PropertyValue]? = nil) {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case entityPropertyReference = "entityPropertyReference"
            case values = "values"
        }
    }

    public struct Relationship: AWSEncodableShape & AWSDecodableShape {
        /// The type of the relationship.
        public let relationshipType: String?
        /// The ID of the target component type associated with this relationship.
        public let targetComponentTypeId: String?

        public init(relationshipType: String? = nil, targetComponentTypeId: String? = nil) {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, max: 256)
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, min: 1)
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, pattern: ".*")
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, max: 256)
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, min: 1)
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipType = "relationshipType"
            case targetComponentTypeId = "targetComponentTypeId"
        }
    }

    public struct RelationshipValue: AWSEncodableShape & AWSDecodableShape {
        /// The name of the target component associated with the relationship value.
        public let targetComponentName: String?
        /// The ID of the target entity associated with this relationship value.
        public let targetEntityId: String?

        public init(targetComponentName: String? = nil, targetEntityId: String? = nil) {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }

        public func validate(name: String) throws {
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, max: 256)
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, min: 1)
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, max: 128)
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, min: 1)
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetComponentName = "targetComponentName"
            case targetEntityId = "targetEntityId"
        }
    }

    public struct Row: AWSDecodableShape {
        /// The data in a row of query results.
        public let rowData: [String]?

        public init(rowData: [String]? = nil) {
            self.rowData = rowData
        }

        private enum CodingKeys: String, CodingKey {
            case rowData = "rowData"
        }
    }

    public struct S3DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 destination configuration location.
        public let location: String

        public init(location: String) {
            self.location = location
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, pattern: "(^arn:((aws)|(aws-cn)|(aws-us-gov)):s3:::)([/a-zA-Z0-9_-]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct S3SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 destination source configuration location.
        public let location: String

        public init(location: String) {
            self.location = location
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, pattern: "(^arn:((aws)|(aws-cn)|(aws-us-gov)):s3:::)([a-zA-Z0-9_-]+)\\/([/.a-zA-Z0-9_-]+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct SceneError: AWSDecodableShape {
        /// The SceneError code.
        public let code: SceneErrorCode?
        /// The SceneError message.
        public let message: String?

        public init(code: SceneErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct SceneSummary: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date
        /// The scene description.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date

        public init(arn: String, contentLocation: String, creationDateTime: Date, description: String? = nil, sceneId: String, updateDateTime: Date) {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case contentLocation = "contentLocation"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case sceneId = "sceneId"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The source configuration IoT SiteWise configuration.
        public let iotSiteWiseConfiguration: IotSiteWiseSourceConfiguration?
        /// The source configuration IoT TwinMaker configuration.
        public let iotTwinMakerConfiguration: IotTwinMakerSourceConfiguration?
        /// The source configuration S3 configuration.
        public let s3Configuration: S3SourceConfiguration?
        /// The source configuration type.
        public let type: SourceType

        public init(iotSiteWiseConfiguration: IotSiteWiseSourceConfiguration? = nil, iotTwinMakerConfiguration: IotTwinMakerSourceConfiguration? = nil, s3Configuration: S3SourceConfiguration? = nil, type: SourceType) {
            self.iotSiteWiseConfiguration = iotSiteWiseConfiguration
            self.iotTwinMakerConfiguration = iotTwinMakerConfiguration
            self.s3Configuration = s3Configuration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.iotSiteWiseConfiguration?.validate(name: "\(name).iotSiteWiseConfiguration")
            try self.iotTwinMakerConfiguration?.validate(name: "\(name).iotTwinMakerConfiguration")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case iotSiteWiseConfiguration = "iotSiteWiseConfiguration"
            case iotTwinMakerConfiguration = "iotTwinMakerConfiguration"
            case s3Configuration = "s3Configuration"
            case type = "type"
        }
    }

    public struct Status: AWSDecodableShape {
        /// The error message.
        public let error: ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public let state: State?

        public init(error: ErrorDetails? = nil, state: State? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct SyncJobStatus: AWSDecodableShape {
        /// The SyncJob error.
        public let error: ErrorDetails?
        /// The SyncJob status state.
        public let state: SyncJobState?

        public init(error: ErrorDetails? = nil, state: SyncJobState? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct SyncJobSummary: AWSDecodableShape {
        /// The SyncJob summary ARN.
        public let arn: String?
        /// The creation date and time.
        public let creationDateTime: Date?
        /// The SyncJob summaries status.
        public let status: SyncJobStatus?
        /// The sync source.
        public let syncSource: String?
        /// The update date and time.
        public let updateDateTime: Date?
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String?

        public init(arn: String? = nil, creationDateTime: Date? = nil, status: SyncJobStatus? = nil, syncSource: String? = nil, updateDateTime: Date? = nil, workspaceId: String? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case status = "status"
            case syncSource = "syncSource"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }

    public struct SyncResourceStatus: AWSDecodableShape {
        /// The status error.
        public let error: ErrorDetails?
        /// The sync resource status state.
        public let state: SyncResourceState?

        public init(error: ErrorDetails? = nil, state: SyncResourceState? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct SyncResourceSummary: AWSDecodableShape {
        /// The external ID.
        public let externalId: String?
        /// The resource ID.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: SyncResourceType?
        /// The sync resource summary status.
        public let status: SyncResourceStatus?
        /// The update date and time.
        public let updateDateTime: Date?

        public init(externalId: String? = nil, resourceId: String? = nil, resourceType: SyncResourceType? = nil, status: SyncResourceStatus? = nil, updateDateTime: Date? = nil) {
            self.externalId = externalId
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "externalId"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case status = "status"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct TabularConditions: AWSEncodableShape {
        /// Filter criteria that orders the output. It can be sorted in ascending or descending order.
        public let orderBy: [OrderBy]?
        /// You can filter the request using various logical operators and a key-value format. For example:  {"key": "serverType", "value": "webServer"}
        public let propertyFilters: [PropertyFilter]?

        public init(orderBy: [OrderBy]? = nil, propertyFilters: [PropertyFilter]? = nil) {
            self.orderBy = orderBy
            self.propertyFilters = propertyFilters
        }

        public func validate(name: String) throws {
            try self.orderBy?.forEach {
                try $0.validate(name: "\(name).orderBy[]")
            }
            try self.validate(self.orderBy, name: "orderBy", parent: name, max: 10)
            try self.validate(self.orderBy, name: "orderBy", parent: name, min: 1)
            try self.propertyFilters?.forEach {
                try $0.validate(name: "\(name).propertyFilters[]")
            }
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, max: 10)
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case orderBy = "orderBy"
            case propertyFilters = "propertyFilters"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// Metadata to add to this resource.
        public let tags: [String: String]

        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceARN")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateComponentTypeRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String
        /// The component type name.
        public let componentTypeName: String?
        /// This is an object that maps strings to compositeComponentTypes of the componentType.  CompositeComponentType is referenced by componentTypeId.
        public let compositeComponentTypes: [String: CompositeComponentTypeRequest]?
        /// The description of the component type.
        public let description: String?
        /// Specifies the component type that this component type extends.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
        public let functions: [String: FunctionRequest]?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionRequest]?
        /// The property groups.
        public let propertyGroups: [String: PropertyGroupRequest]?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentTypeId: String, componentTypeName: String? = nil, compositeComponentTypes: [String: CompositeComponentTypeRequest]? = nil, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionRequest]? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionRequest]? = nil, propertyGroups: [String: PropertyGroupRequest]? = nil, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.compositeComponentTypes = compositeComponentTypes
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.propertyGroups = propertyGroups
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.componentTypeId, key: "componentTypeId")
            try container.encodeIfPresent(self.componentTypeName, forKey: .componentTypeName)
            try container.encodeIfPresent(self.compositeComponentTypes, forKey: .compositeComponentTypes)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.extendsFrom, forKey: .extendsFrom)
            try container.encodeIfPresent(self.functions, forKey: .functions)
            try container.encodeIfPresent(self.isSingleton, forKey: .isSingleton)
            try container.encodeIfPresent(self.propertyDefinitions, forKey: .propertyDefinitions)
            try container.encodeIfPresent(self.propertyGroups, forKey: .propertyGroups)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, max: 256)
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]*")
            try self.compositeComponentTypes?.forEach {
                try validate($0.key, name: "compositeComponentTypes.key", parent: name, max: 256)
                try validate($0.key, name: "compositeComponentTypes.key", parent: name, min: 1)
                try validate($0.key, name: "compositeComponentTypes.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).compositeComponentTypes[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.extendsFrom?.forEach {
                try validate($0, name: "extendsFrom[]", parent: name, max: 256)
                try validate($0, name: "extendsFrom[]", parent: name, min: 1)
                try validate($0, name: "extendsFrom[]", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            }
            try self.functions?.forEach {
                try validate($0.key, name: "functions.key", parent: name, max: 256)
                try validate($0.key, name: "functions.key", parent: name, min: 1)
                try validate($0.key, name: "functions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).functions[\"\($0.key)\"]")
            }
            try self.propertyDefinitions?.forEach {
                try validate($0.key, name: "propertyDefinitions.key", parent: name, max: 256)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, min: 1)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyDefinitions[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeName = "componentTypeName"
            case compositeComponentTypes = "compositeComponentTypes"
            case description = "description"
            case extendsFrom = "extendsFrom"
            case functions = "functions"
            case isSingleton = "isSingleton"
            case propertyDefinitions = "propertyDefinitions"
            case propertyGroups = "propertyGroups"
        }
    }

    public struct UpdateComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The current state of the component type.
        public let state: State
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(arn: String, componentTypeId: String, state: State, workspaceId: String) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.state = state
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case componentTypeId = "componentTypeId"
            case state = "state"
            case workspaceId = "workspaceId"
        }
    }

    public struct UpdateEntityRequest: AWSEncodableShape {
        /// An object that maps strings to the component updates in the request. Each string in the mapping must be unique to this object.
        public let componentUpdates: [String: ComponentUpdateRequest]?
        /// This is an object that maps strings to compositeComponent updates in the request. Each key  of the map represents the componentPath of the compositeComponent.
        public let compositeComponentUpdates: [String: CompositeComponentUpdateRequest]?
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String?
        /// An object that describes the update request for a parent entity.
        public let parentEntityUpdate: ParentEntityUpdateRequest?
        /// The ID of the workspace that contains the entity.
        public let workspaceId: String

        public init(componentUpdates: [String: ComponentUpdateRequest]? = nil, compositeComponentUpdates: [String: CompositeComponentUpdateRequest]? = nil, description: String? = nil, entityId: String, entityName: String? = nil, parentEntityUpdate: ParentEntityUpdateRequest? = nil, workspaceId: String) {
            self.componentUpdates = componentUpdates
            self.compositeComponentUpdates = compositeComponentUpdates
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.parentEntityUpdate = parentEntityUpdate
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.componentUpdates, forKey: .componentUpdates)
            try container.encodeIfPresent(self.compositeComponentUpdates, forKey: .compositeComponentUpdates)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.entityId, key: "entityId")
            try container.encodeIfPresent(self.entityName, forKey: .entityName)
            try container.encodeIfPresent(self.parentEntityUpdate, forKey: .parentEntityUpdate)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.componentUpdates?.forEach {
                try validate($0.key, name: "componentUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "componentUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "componentUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).componentUpdates[\"\($0.key)\"]")
            }
            try self.compositeComponentUpdates?.forEach {
                try validate($0.key, name: "compositeComponentUpdates.key", parent: name, max: 2048)
                try validate($0.key, name: "compositeComponentUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "compositeComponentUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9/]+$")
                try $0.value.validate(name: "\(name).compositeComponentUpdates[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, min: 1)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.parentEntityUpdate?.validate(name: "\(name).parentEntityUpdate")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentUpdates = "componentUpdates"
            case compositeComponentUpdates = "compositeComponentUpdates"
            case description = "description"
            case entityName = "entityName"
            case parentEntityUpdate = "parentEntityUpdate"
        }
    }

    public struct UpdateEntityResponse: AWSDecodableShape {
        /// The current state of the entity update.
        public let state: State
        /// The date and time when the entity was last updated.
        public let updateDateTime: Date

        public init(state: State, updateDateTime: Date) {
            self.state = state
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case updateDateTime = "updateDateTime"
        }
    }

    public struct UpdatePricingPlanRequest: AWSEncodableShape {
        /// The bundle names.
        public let bundleNames: [String]?
        /// The pricing mode.
        public let pricingMode: PricingMode

        public init(bundleNames: [String]? = nil, pricingMode: PricingMode) {
            self.bundleNames = bundleNames
            self.pricingMode = pricingMode
        }

        public func validate(name: String) throws {
            try self.bundleNames?.forEach {
                try validate($0, name: "bundleNames[]", parent: name, max: 256)
                try validate($0, name: "bundleNames[]", parent: name, min: 1)
                try validate($0, name: "bundleNames[]", parent: name, pattern: ".*")
            }
            try self.validate(self.bundleNames, name: "bundleNames", parent: name, max: 10)
            try self.validate(self.bundleNames, name: "bundleNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bundleNames = "bundleNames"
            case pricingMode = "pricingMode"
        }
    }

    public struct UpdatePricingPlanResponse: AWSDecodableShape {
        /// Update the current pricing plan.
        public let currentPricingPlan: PricingPlan
        /// Update the pending pricing plan.
        public let pendingPricingPlan: PricingPlan?

        public init(currentPricingPlan: PricingPlan, pendingPricingPlan: PricingPlan? = nil) {
            self.currentPricingPlan = currentPricingPlan
            self.pendingPricingPlan = pendingPricingPlan
        }

        private enum CodingKeys: String, CodingKey {
            case currentPricingPlan = "currentPricingPlan"
            case pendingPricingPlan = "pendingPricingPlan"
        }
    }

    public struct UpdateSceneRequest: AWSEncodableShape {
        /// A list of capabilities that the scene uses to render.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String?
        /// The description of this scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The scene metadata.
        public let sceneMetadata: [String: String]?
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(capabilities: [String]? = nil, contentLocation: String? = nil, description: String? = nil, sceneId: String, sceneMetadata: [String: String]? = nil, workspaceId: String) {
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.description = description
            self.sceneId = sceneId
            self.sceneMetadata = sceneMetadata
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encodeIfPresent(self.contentLocation, forKey: .contentLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.sceneId, key: "sceneId")
            try container.encodeIfPresent(self.sceneMetadata, forKey: .sceneMetadata)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 256)
                try validate($0, name: "capabilities[]", parent: name, pattern: ".*")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, max: 256)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, pattern: "^[sS]3://[A-Za-z0-9._/-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.sceneMetadata?.forEach {
                try validate($0.key, name: "sceneMetadata.key", parent: name, max: 256)
                try validate($0.key, name: "sceneMetadata.key", parent: name, min: 1)
                try validate($0.key, name: "sceneMetadata.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try validate($0.value, name: "sceneMetadata[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "sceneMetadata[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.sceneMetadata, name: "sceneMetadata", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case contentLocation = "contentLocation"
            case description = "description"
            case sceneMetadata = "sceneMetadata"
        }
    }

    public struct UpdateSceneResponse: AWSDecodableShape {
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date

        public init(updateDateTime: Date) {
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case updateDateTime = "updateDateTime"
        }
    }

    public struct UpdateWorkspaceRequest: AWSEncodableShape {
        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String?
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(description: String? = nil, role: String? = nil, s3Location: String? = nil, workspaceId: String) {
            self.description = description
            self.role = role
            self.s3Location = s3Location
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.role, forKey: .role)
            try container.encodeIfPresent(self.s3Location, forKey: .s3Location)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.s3Location, name: "s3Location", parent: name, max: 1024)
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "(^arn:((aws)|(aws-cn)|(aws-us-gov)):s3:::)([a-zA-Z0-9_-]+$)")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case role = "role"
            case s3Location = "s3Location"
        }
    }

    public struct UpdateWorkspaceResponse: AWSDecodableShape {
        /// The date and time of the current update.
        public let updateDateTime: Date

        public init(updateDateTime: Date) {
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case updateDateTime = "updateDateTime"
        }
    }

    public struct WorkspaceSummary: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date
        /// The description of the workspace.
        public let description: String?
        /// A list of services that are linked to the workspace.
        public let linkedServices: [String]?
        /// The date and time when the workspace was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, description: String? = nil, linkedServices: [String]? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.linkedServices = linkedServices
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case linkedServices = "linkedServices"
            case updateDateTime = "updateDateTime"
            case workspaceId = "workspaceId"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTTwinMaker
public struct IoTTwinMakerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case connectorFailureException = "ConnectorFailureException"
        case connectorTimeoutException = "ConnectorTimeoutException"
        case internalServerException = "InternalServerException"
        case queryTimeoutException = "QueryTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTTwinMaker
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A conflict occurred.
    public static var conflictException: Self { .init(.conflictException) }
    /// The connector failed.
    public static var connectorFailureException: Self { .init(.connectorFailureException) }
    /// The connector timed out.
    public static var connectorTimeoutException: Self { .init(.connectorTimeoutException) }
    /// An unexpected error has occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The query timeout exception.
    public static var queryTimeoutException: Self { .init(.queryTimeoutException) }
    /// The resource wasn't found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The rate exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The number of tags exceeds the limit.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// Failed
    public static var validationException: Self { .init(.validationException) }
}

extension IoTTwinMakerErrorType: Equatable {
    public static func == (lhs: IoTTwinMakerErrorType, rhs: IoTTwinMakerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTTwinMakerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
