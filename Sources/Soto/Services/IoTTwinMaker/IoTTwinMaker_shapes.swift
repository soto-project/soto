//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension IoTTwinMaker {
    // MARK: Enums

    public enum ColumnType: String, CustomStringConvertible, Codable, _SotoSendable {
        case edge = "EDGE"
        case node = "NODE"
        case value = "VALUE"
        public var description: String { return self.rawValue }
    }

    public enum ComponentUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalFailure = "INTERNAL_FAILURE"
        case syncCreatingError = "SYNC_CREATING_ERROR"
        case syncInitializingError = "SYNC_INITIALIZING_ERROR"
        case syncProcessingError = "SYNC_PROCESSING_ERROR"
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum GroupType: String, CustomStringConvertible, Codable, _SotoSendable {
        case tabular = "TABULAR"
        public var description: String { return self.rawValue }
    }

    public enum InterpolationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case linear = "LINEAR"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum OrderByTime: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum ParentEntityUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum PricingMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case basic = "BASIC"
        case standard = "STANDARD"
        case tieredBundle = "TIERED_BUNDLE"
        public var description: String { return self.rawValue }
    }

    public enum PricingTier: String, CustomStringConvertible, Codable, _SotoSendable {
        case tier1 = "TIER_1"
        case tier2 = "TIER_2"
        case tier3 = "TIER_3"
        case tier4 = "TIER_4"
        public var description: String { return self.rawValue }
    }

    public enum PropertyGroupUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum PropertyUpdateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum Scope: String, CustomStringConvertible, Codable, _SotoSendable {
        case entity = "ENTITY"
        case workspace = "WORKSPACE"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case error = "ERROR"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum SyncJobState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case error = "ERROR"
        case initializing = "INITIALIZING"
        public var description: String { return self.rawValue }
    }

    public enum SyncResourceState: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleted = "DELETED"
        case error = "ERROR"
        case initializing = "INITIALIZING"
        case inSync = "IN_SYNC"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum SyncResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case componentType = "COMPONENT_TYPE"
        case entity = "ENTITY"
        public var description: String { return self.rawValue }
    }

    public enum UpdateReason: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "DEFAULT"
        case entityCountUpdate = "ENTITY_COUNT_UPDATE"
        case overwritten = "OVERWRITTEN"
        case pricingModeUpdate = "PRICING_MODE_UPDATE"
        case pricingTierUpdate = "PRICING_TIER_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, _SotoSendable {
        case boolean = "BOOLEAN"
        case double = "DOUBLE"
        case integer = "INTEGER"
        case list = "LIST"
        case long = "LONG"
        case map = "MAP"
        case relationship = "RELATIONSHIP"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ListComponentTypesFilter: AWSEncodableShape, _SotoSendable {
        /// The component type that the component types in the list extend.
        case extendsFrom(String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isAbstract(Bool)
        /// The namespace to which the component types in the list belong.
        case namespace(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .extendsFrom(let value):
                try container.encode(value, forKey: .extendsFrom)
            case .isAbstract(let value):
                try container.encode(value, forKey: .isAbstract)
            case .namespace(let value):
                try container.encode(value, forKey: .namespace)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .extendsFrom(let value):
                try self.validate(value, name: "extendsFrom", parent: name, max: 256)
                try self.validate(value, name: "extendsFrom", parent: name, min: 1)
                try self.validate(value, name: "extendsFrom", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            case .namespace(let value):
                try self.validate(value, name: "namespace", parent: name, max: 256)
                try self.validate(value, name: "namespace", parent: name, min: 1)
                try self.validate(value, name: "namespace", parent: name, pattern: ".*")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case extendsFrom
            case isAbstract
            case namespace
        }
    }

    public enum ListEntitiesFilter: AWSEncodableShape, _SotoSendable {
        /// The ID of the component type in the entities in the list.
        case componentTypeId(String)
        /// The external-Id property of a component. The external-Id property is the primary key of an external storage system.
        case externalId(String)
        /// The parent of the entities in the list.
        case parentEntityId(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .componentTypeId(let value):
                try container.encode(value, forKey: .componentTypeId)
            case .externalId(let value):
                try container.encode(value, forKey: .externalId)
            case .parentEntityId(let value):
                try container.encode(value, forKey: .parentEntityId)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .componentTypeId(let value):
                try self.validate(value, name: "componentTypeId", parent: name, max: 256)
                try self.validate(value, name: "componentTypeId", parent: name, min: 1)
                try self.validate(value, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            case .externalId(let value):
                try self.validate(value, name: "externalId", parent: name, max: 256)
                try self.validate(value, name: "externalId", parent: name, min: 1)
                try self.validate(value, name: "externalId", parent: name, pattern: ".*")
            case .parentEntityId(let value):
                try self.validate(value, name: "parentEntityId", parent: name, max: 128)
                try self.validate(value, name: "parentEntityId", parent: name, min: 1)
                try self.validate(value, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId
            case externalId
            case parentEntityId
        }
    }

    public enum SyncResourceFilter: AWSEncodableShape, _SotoSendable {
        /// The external Id.
        case externalId(String)
        /// The sync resource filter resource Id.
        case resourceId(String)
        /// The sync resource filter resoucre type
        case resourceType(SyncResourceType)
        /// The sync resource filter's state.
        case state(SyncResourceState)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .externalId(let value):
                try container.encode(value, forKey: .externalId)
            case .resourceId(let value):
                try container.encode(value, forKey: .resourceId)
            case .resourceType(let value):
                try container.encode(value, forKey: .resourceType)
            case .state(let value):
                try container.encode(value, forKey: .state)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .externalId(let value):
                try self.validate(value, name: "externalId", parent: name, max: 128)
                try self.validate(value, name: "externalId", parent: name, min: 1)
                try self.validate(value, name: "externalId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            case .resourceId(let value):
                try self.validate(value, name: "resourceId", parent: name, max: 128)
                try self.validate(value, name: "resourceId", parent: name, min: 1)
                try self.validate(value, name: "resourceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case externalId
            case resourceId
            case resourceType
            case state
        }
    }

    // MARK: Shapes

    public struct BatchPutPropertyError: AWSDecodableShape {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        public let entry: PropertyValueEntry
        /// The error code.
        public let errorCode: String
        /// The error message.
        public let errorMessage: String

        public init(entry: PropertyValueEntry, errorCode: String, errorMessage: String) {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case entry
            case errorCode
            case errorMessage
        }
    }

    public struct BatchPutPropertyErrorEntry: AWSDecodableShape {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        public let errors: [BatchPutPropertyError]

        public init(errors: [BatchPutPropertyError]) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct BatchPutPropertyValuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// An object that maps strings to the property value entries to set. Each string  in the mapping must be unique to this object.
        public let entries: [PropertyValueEntry]
        /// The ID of the workspace that contains the properties to set.
        public let workspaceId: String

        public init(entries: [PropertyValueEntry], workspaceId: String) {
            self.entries = entries
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 10)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case entries
        }
    }

    public struct BatchPutPropertyValuesResponse: AWSDecodableShape {
        /// Entries that caused errors in the batch put operation.
        public let errorEntries: [BatchPutPropertyErrorEntry]

        public init(errorEntries: [BatchPutPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries
        }
    }

    public struct BundleInformation: AWSDecodableShape {
        /// The bundle names.
        public let bundleNames: [String]
        /// The pricing tier.
        public let pricingTier: PricingTier?

        public init(bundleNames: [String], pricingTier: PricingTier? = nil) {
            self.bundleNames = bundleNames
            self.pricingTier = pricingTier
        }

        private enum CodingKeys: String, CodingKey {
            case bundleNames
            case pricingTier
        }
    }

    public struct ColumnDescription: AWSDecodableShape {
        /// The name of the column description.
        public let name: String?
        /// The type of the column description.
        public let type: ColumnType?

        public init(name: String? = nil, type: ColumnType? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case type
        }
    }

    public struct ComponentPropertyGroupRequest: AWSEncodableShape {
        /// The group type.
        public let groupType: GroupType?
        /// The property names.
        public let propertyNames: [String]?
        /// The update type.
        public let updateType: PropertyGroupUpdateType?

        public init(groupType: GroupType? = nil, propertyNames: [String]? = nil, updateType: PropertyGroupUpdateType? = nil) {
            self.groupType = groupType
            self.propertyNames = propertyNames
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.propertyNames?.forEach {
                try validate($0, name: "propertyNames[]", parent: name, max: 256)
                try validate($0, name: "propertyNames[]", parent: name, min: 1)
                try validate($0, name: "propertyNames[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupType
            case propertyNames
            case updateType
        }
    }

    public struct ComponentPropertyGroupResponse: AWSDecodableShape {
        /// The group type.
        public let groupType: GroupType
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        public let isInherited: Bool
        /// The names of properties
        public let propertyNames: [String]

        public init(groupType: GroupType, isInherited: Bool, propertyNames: [String]) {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }

        private enum CodingKeys: String, CodingKey {
            case groupType
            case isInherited
            case propertyNames
        }
    }

    public struct ComponentRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The description of the component request.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type. Each string  in the mapping must be unique to this object.
        public let properties: [String: PropertyRequest]?
        /// The property groups.
        public let propertyGroups: [String: ComponentPropertyGroupRequest]?

        public init(componentTypeId: String? = nil, description: String? = nil, properties: [String: PropertyRequest]? = nil, propertyGroups: [String: ComponentPropertyGroupRequest]? = nil) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.properties?.forEach {
                try validate($0.key, name: "properties.key", parent: name, max: 256)
                try validate($0.key, name: "properties.key", parent: name, min: 1)
                try validate($0.key, name: "properties.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).properties[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId
            case description
            case properties
            case propertyGroups
        }
    }

    public struct ComponentResponse: AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The name of the property definition set in the request.
        public let definedIn: String?
        /// The description of the component type.
        public let description: String?
        /// An object that maps strings to the properties to set in the component type. Each string  in the mapping must be unique to this object.
        public let properties: [String: PropertyResponse]?
        /// The property groups.
        public let propertyGroups: [String: ComponentPropertyGroupResponse]?
        /// The status of the component type.
        public let status: Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public let syncSource: String?

        public init(componentName: String? = nil, componentTypeId: String? = nil, definedIn: String? = nil, description: String? = nil, properties: [String: PropertyResponse]? = nil, propertyGroups: [String: ComponentPropertyGroupResponse]? = nil, status: Status? = nil, syncSource: String? = nil) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case componentTypeId
            case definedIn
            case description
            case properties
            case propertyGroups
            case status
            case syncSource
        }
    }

    public struct ComponentTypeSummary: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The component type name.
        public let componentTypeName: String?
        /// The date and time when the component type was created.
        public let creationDateTime: Date
        /// The description of the component type.
        public let description: String?
        /// The current status of the component type.
        public let status: Status?
        /// The date and time when the component type was last updated.
        public let updateDateTime: Date

        public init(arn: String, componentTypeId: String, componentTypeName: String? = nil, creationDateTime: Date, description: String? = nil, status: Status? = nil, updateDateTime: Date) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case componentTypeId
            case componentTypeName
            case creationDateTime
            case description
            case status
            case updateDateTime
        }
    }

    public struct ComponentUpdateRequest: AWSEncodableShape {
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The description of the component type.
        public let description: String?
        /// The property group updates.
        public let propertyGroupUpdates: [String: ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string  in the mapping must be unique to this object.
        public let propertyUpdates: [String: PropertyRequest]?
        /// The update type of the component update request.
        public let updateType: ComponentUpdateType?

        public init(componentTypeId: String? = nil, description: String? = nil, propertyGroupUpdates: [String: ComponentPropertyGroupRequest]? = nil, propertyUpdates: [String: PropertyRequest]? = nil, updateType: ComponentUpdateType? = nil) {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.propertyGroupUpdates?.forEach {
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroupUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroupUpdates[\"\($0.key)\"]")
            }
            try self.propertyUpdates?.forEach {
                try validate($0.key, name: "propertyUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "propertyUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "propertyUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyUpdates[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeId
            case description
            case propertyGroupUpdates
            case propertyUpdates
            case updateType
        }
    }

    public struct CreateComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type.
        public let componentTypeId: String
        /// A friendly name for the component type.
        public let componentTypeName: String?
        /// The description of the component type.
        public let description: String?
        /// Specifies the parent component type to extend.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
        public let functions: [String: FunctionRequest]?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionRequest]?
        public let propertyGroups: [String: PropertyGroupRequest]?
        /// Metadata that you can use to manage the component type.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, componentTypeName: String? = nil, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionRequest]? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionRequest]? = nil, propertyGroups: [String: PropertyGroupRequest]? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.propertyGroups = propertyGroups
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, max: 256)
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]*")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.extendsFrom?.forEach {
                try validate($0, name: "extendsFrom[]", parent: name, max: 256)
                try validate($0, name: "extendsFrom[]", parent: name, min: 1)
                try validate($0, name: "extendsFrom[]", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            }
            try self.functions?.forEach {
                try validate($0.key, name: "functions.key", parent: name, max: 256)
                try validate($0.key, name: "functions.key", parent: name, min: 1)
                try validate($0.key, name: "functions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).functions[\"\($0.key)\"]")
            }
            try self.propertyDefinitions?.forEach {
                try validate($0.key, name: "propertyDefinitions.key", parent: name, max: 256)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, min: 1)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyDefinitions[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeName
            case description
            case extendsFrom
            case functions
            case isSingleton
            case propertyDefinitions
            case propertyGroups
            case tags
        }
    }

    public struct CreateComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The current state of the component type.
        public let state: State

        public init(arn: String, creationDateTime: Date, state: State) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case state
        }
    }

    public struct CreateEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// An object that maps strings to the components in the entity. Each string  in the mapping must be unique to this object.
        public let components: [String: ComponentRequest]?
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String?
        /// The name of the entity.
        public let entityName: String
        /// The ID of the entity's parent entity.
        public let parentEntityId: String?
        /// Metadata that you can use to manage the entity.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the entity.
        public let workspaceId: String

        public init(components: [String: ComponentRequest]? = nil, description: String? = nil, entityId: String? = nil, entityName: String, parentEntityId: String? = nil, tags: [String: String]? = nil, workspaceId: String) {
            self.components = components
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.parentEntityId = parentEntityId
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.components?.forEach {
                try validate($0.key, name: "components.key", parent: name, max: 256)
                try validate($0.key, name: "components.key", parent: name, min: 1)
                try validate($0.key, name: "components.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).components[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, min: 1)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, max: 128)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, min: 1)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case components
            case description
            case entityId
            case entityName
            case parentEntityId
            case tags
        }
    }

    public struct CreateEntityResponse: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The ID of the entity.
        public let entityId: String
        /// The current state of the entity.
        public let state: State

        public init(arn: String, creationDateTime: Date, entityId: String, state: State) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.entityId = entityId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case entityId
            case state
        }
    }

    public struct CreateSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of capabilities that the scene uses to render itself.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The description for this scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// Metadata that you can use to manage the scene.
        public let tags: [String: String]?
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(capabilities: [String]? = nil, contentLocation: String, description: String? = nil, sceneId: String, tags: [String: String]? = nil, workspaceId: String) {
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.description = description
            self.sceneId = sceneId
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 256)
                try validate($0, name: "capabilities[]", parent: name, pattern: ".*")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, max: 256)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, pattern: "^[sS]3://[A-Za-z0-9._/-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities
            case contentLocation
            case description
            case sceneId
            case tags
        }
    }

    public struct CreateSceneResponse: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date

        public init(arn: String, creationDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
        }
    }

    public struct CreateSyncJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "syncSource", location: .uri("syncSource")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The SyncJob IAM role. This IAM role is used by the sync job to read from the syncSource, and create,  update or delete the corresponding resources.
        public let syncRole: String
        /// The sync source.  Currently the only supported syncSoucre is SITEWISE .
        public let syncSource: String
        /// The SyncJob tags.
        public let tags: [String: String]?
        /// The workspace Id.
        public let workspaceId: String

        public init(syncRole: String, syncSource: String, tags: [String: String]? = nil, workspaceId: String) {
            self.syncRole = syncRole
            self.syncSource = syncSource
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.syncRole, name: "syncRole", parent: name, max: 2048)
            try self.validate(self.syncRole, name: "syncRole", parent: name, min: 20)
            try self.validate(self.syncRole, name: "syncRole", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case syncRole
            case tags
        }
    }

    public struct CreateSyncJobResponse: AWSDecodableShape {
        /// The SyncJob ARN.
        public let arn: String
        /// The date and time for the SyncJob creation.
        public let creationDateTime: Date
        /// The SyncJob response state.
        public let state: SyncJobState

        public init(arn: String, creationDateTime: Date, state: SyncJobState) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case state
        }
    }

    public struct CreateWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String
        /// Metadata that you can use to manage the workspace
        public let tags: [String: String]?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(description: String? = nil, role: String, s3Location: String, tags: [String: String]? = nil, workspaceId: String) {
            self.description = description
            self.role = role
            self.s3Location = s3Location
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.s3Location, name: "s3Location", parent: name, max: 1024)
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "(^arn:((aws)|(aws-cn)|(aws-us-gov)):s3:::)([a-zA-Z0-9_-]+$)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case role
            case s3Location
            case tags
        }
    }

    public struct CreateWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date

        public init(arn: String, creationDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
        }
    }

    public struct DataConnector: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
        public let isNative: Bool?
        /// The Lambda function associated with this data connector.
        public let lambda: LambdaFunction?

        public init(isNative: Bool? = nil, lambda: LambdaFunction? = nil) {
            self.isNative = isNative
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda?.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case isNative
            case lambda
        }
    }

    public final class DataType: AWSEncodableShape & AWSDecodableShape {
        /// The allowed values for this data type.
        public let allowedValues: [DataValue]?
        /// The nested type in the data type.
        public let nestedType: DataType?
        /// A relationship that associates a component with another component.
        public let relationship: Relationship?
        /// The underlying type of the data type.
        public let type: `Type`
        /// The unit of measure used in this data type.
        public let unitOfMeasure: String?

        public init(allowedValues: [DataValue]? = nil, nestedType: DataType? = nil, relationship: Relationship? = nil, type: `Type`, unitOfMeasure: String? = nil) {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }

        public func validate(name: String) throws {
            try self.allowedValues?.forEach {
                try $0.validate(name: "\(name).allowedValues[]")
            }
            try self.validate(self.allowedValues, name: "allowedValues", parent: name, max: 50)
            try self.nestedType?.validate(name: "\(name).nestedType")
            try self.relationship?.validate(name: "\(name).relationship")
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, max: 256)
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, min: 1)
            try self.validate(self.unitOfMeasure, name: "unitOfMeasure", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues
            case nestedType
            case relationship
            case type
            case unitOfMeasure
        }
    }

    public struct DataValue: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value.
        public let booleanValue: Bool?
        /// A double value.
        public let doubleValue: Double?
        /// An expression that produces the value.
        public let expression: String?
        /// An integer value.
        public let integerValue: Int?
        /// A list of multiple values.
        public let listValue: [DataValue]?
        /// A long value.
        public let longValue: Int64?
        /// An object that maps strings to multiple DataValue objects.
        public let mapValue: [String: DataValue]?
        /// A value that relates a component to another component.
        public let relationshipValue: RelationshipValue?
        /// A string value.
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, expression: String? = nil, integerValue: Int? = nil, listValue: [DataValue]? = nil, longValue: Int64? = nil, mapValue: [String: DataValue]? = nil, relationshipValue: RelationshipValue? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 316)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^(^\\$\\{Parameters\\.[a-zA-z]+([a-zA-z_0-9]*)}$)$")
            try self.listValue?.forEach {
                try $0.validate(name: "\(name).listValue[]")
            }
            try self.validate(self.listValue, name: "listValue", parent: name, max: 50)
            try self.mapValue?.forEach {
                try validate($0.key, name: "mapValue.key", parent: name, max: 256)
                try validate($0.key, name: "mapValue.key", parent: name, min: 1)
                try validate($0.key, name: "mapValue.key", parent: name, pattern: ".*")
                try $0.value.validate(name: "\(name).mapValue[\"\($0.key)\"]")
            }
            try self.validate(self.mapValue, name: "mapValue", parent: name, max: 50)
            try self.relationshipValue?.validate(name: "\(name).relationshipValue")
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 256)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue
            case doubleValue
            case expression
            case integerValue
            case listValue
            case longValue
            case mapValue
            case relationshipValue
            case stringValue
        }
    }

    public struct DeleteComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type to delete.
        public let componentTypeId: String
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentTypeResponse: AWSDecodableShape {
        /// The current state of the component type to be deleted.
        public let state: State

        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct DeleteEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "entityId", location: .uri("entityId")),
            AWSMemberEncoding(label: "isRecursive", location: .querystring("isRecursive")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the entity to delete.
        public let entityId: String
        /// A Boolean value that specifies whether the operation deletes child entities.
        public let isRecursive: Bool?
        /// The ID of the workspace that contains the entity to delete.
        public let workspaceId: String

        public init(entityId: String, isRecursive: Bool? = nil, workspaceId: String) {
            self.entityId = entityId
            self.isRecursive = isRecursive
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEntityResponse: AWSDecodableShape {
        /// The current state of the deleted entity.
        public let state: State

        public init(state: State) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct DeleteSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sceneId", location: .uri("sceneId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the scene to delete.
        public let sceneId: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(sceneId: String, workspaceId: String) {
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSceneResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSyncJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "syncSource", location: .uri("syncSource")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The sync source.  Currently the only supported syncSoucre is SITEWISE .
        public let syncSource: String
        /// The workspace Id.
        public let workspaceId: String

        public init(syncSource: String, workspaceId: String) {
            self.syncSource = syncSource
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSyncJobResponse: AWSDecodableShape {
        /// The SyncJob response state.
        public let state: SyncJobState

        public init(state: SyncJobState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state
        }
    }

    public struct DeleteWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace to delete.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkspaceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EntityPropertyReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// The ID of the entity.
        public let entityId: String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public let externalIdProperty: [String: String]?
        /// The name of the property.
        public let propertyName: String

        public init(componentName: String? = nil, entityId: String? = nil, externalIdProperty: [String: String]? = nil, propertyName: String) {
            self.componentName = componentName
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.externalIdProperty?.forEach {
                try validate($0.key, name: "externalIdProperty.key", parent: name, max: 256)
                try validate($0.key, name: "externalIdProperty.key", parent: name, min: 1)
                try validate($0.key, name: "externalIdProperty.key", parent: name, pattern: ".*")
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "externalIdProperty[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case entityId
            case externalIdProperty
            case propertyName
        }
    }

    public struct EntitySummary: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String
        /// A Boolean value that specifies whether the entity has child entities or not.
        public let hasChildEntities: Bool?
        /// The ID of the parent entity.
        public let parentEntityId: String?
        /// The current status of the entity.
        public let status: Status
        /// The last date and time when the entity was updated.
        public let updateDateTime: Date

        public init(arn: String, creationDateTime: Date, description: String? = nil, entityId: String, entityName: String, hasChildEntities: Bool? = nil, parentEntityId: String? = nil, status: Status, updateDateTime: Date) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case entityId
            case entityName
            case hasChildEntities
            case parentEntityId
            case status
            case updateDateTime
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code.
        public let code: ErrorCode?
        /// The error message.
        public let message: String?

        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct ExecuteQueryRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 25.  Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The query statement.
        public let queryStatement: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, queryStatement: String, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryStatement = queryStatement
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, max: 1000)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, min: 1)
            try self.validate(self.queryStatement, name: "queryStatement", parent: name, pattern: "^[\\s\\S]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case queryStatement
            case workspaceId
        }
    }

    public struct ExecuteQueryResponse: AWSDecodableShape {
        /// A list of ColumnDescription objects.
        public let columnDescriptions: [ColumnDescription]?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Represents a single row in the query results.
        public let rows: [Row]?

        public init(columnDescriptions: [ColumnDescription]? = nil, nextToken: String? = nil, rows: [Row]? = nil) {
            self.columnDescriptions = columnDescriptions
            self.nextToken = nextToken
            self.rows = rows
        }

        private enum CodingKeys: String, CodingKey {
            case columnDescriptions
            case nextToken
            case rows
        }
    }

    public struct FunctionRequest: AWSEncodableShape {
        /// The data connector.
        public let implementedBy: DataConnector?
        /// The required properties of the function.
        public let requiredProperties: [String]?
        /// The scope of the function.
        public let scope: Scope?

        public init(implementedBy: DataConnector? = nil, requiredProperties: [String]? = nil, scope: Scope? = nil) {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.implementedBy?.validate(name: "\(name).implementedBy")
            try self.requiredProperties?.forEach {
                try validate($0, name: "requiredProperties[]", parent: name, max: 256)
                try validate($0, name: "requiredProperties[]", parent: name, min: 1)
                try validate($0, name: "requiredProperties[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case implementedBy
            case requiredProperties
            case scope
        }
    }

    public struct FunctionResponse: AWSDecodableShape {
        /// The data connector.
        public let implementedBy: DataConnector?
        /// Indicates whether this function is inherited.
        public let isInherited: Bool?
        /// The required properties of the function.
        public let requiredProperties: [String]?
        /// The scope of the function.
        public let scope: Scope?

        public init(implementedBy: DataConnector? = nil, isInherited: Bool? = nil, requiredProperties: [String]? = nil, scope: Scope? = nil) {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case implementedBy
            case isInherited
            case requiredProperties
            case scope
        }
    }

    public struct GetComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type.
        public let componentTypeId: String
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(componentTypeId: String, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The component type name.
        public let componentTypeName: String?
        /// The date and time when the component type was created.
        public let creationDateTime: Date
        /// The description of the component type.
        public let description: String?
        /// The name of the parent component type that this component type extends.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string  in the mapping must be unique to this object.
        public let functions: [String: FunctionResponse]?
        /// A Boolean value that specifies whether the component type is abstract.
        public let isAbstract: Bool?
        /// A Boolean value that specifies whether the component type has a schema initializer and that the  schema initializer has run.
        public let isSchemaInitialized: Bool?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionResponse]?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let propertyGroups: [String: PropertyGroupResponse]?
        /// The current status of the component type.
        public let status: Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public let syncSource: String?
        /// The date and time when the component was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(arn: String, componentTypeId: String, componentTypeName: String? = nil, creationDateTime: Date, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionResponse]? = nil, isAbstract: Bool? = nil, isSchemaInitialized: Bool? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionResponse]? = nil, propertyGroups: [String: PropertyGroupResponse]? = nil, status: Status? = nil, syncSource: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.creationDateTime = creationDateTime
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isAbstract = isAbstract
            self.isSchemaInitialized = isSchemaInitialized
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case componentTypeId
            case componentTypeName
            case creationDateTime
            case description
            case extendsFrom
            case functions
            case isAbstract
            case isSchemaInitialized
            case isSingleton
            case propertyDefinitions
            case propertyGroups
            case status
            case syncSource
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "entityId", location: .uri("entityId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the entity.
        public let entityId: String
        /// The ID of the workspace.
        public let workspaceId: String

        public init(entityId: String, workspaceId: String) {
            self.entityId = entityId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEntityResponse: AWSDecodableShape {
        /// The ARN of the entity.
        public let arn: String
        /// An object that maps strings to the components in the entity. Each string  in the mapping must be unique to this object.
        public let components: [String: ComponentResponse]?
        /// The date and time when the entity was created.
        public let creationDateTime: Date
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String
        /// A Boolean value that specifies whether the entity has associated child entities.
        public let hasChildEntities: Bool
        /// The ID of the parent entity for this entity.
        public let parentEntityId: String
        /// The current status of the entity.
        public let status: Status
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public let syncSource: String?
        /// The date and time when the entity was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, components: [String: ComponentResponse]? = nil, creationDateTime: Date, description: String? = nil, entityId: String, entityName: String, hasChildEntities: Bool, parentEntityId: String, status: Status, syncSource: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.components = components
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case components
            case creationDateTime
            case description
            case entityId
            case entityName
            case hasChildEntities
            case parentEntityId
            case status
            case syncSource
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetPricingPlanRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPricingPlanResponse: AWSDecodableShape {
        /// The chosen pricing plan for the current billing cycle.
        public let currentPricingPlan: PricingPlan
        /// The pending pricing plan.
        public let pendingPricingPlan: PricingPlan?

        public init(currentPricingPlan: PricingPlan, pendingPricingPlan: PricingPlan? = nil) {
            self.currentPricingPlan = currentPricingPlan
            self.pendingPricingPlan = pendingPricingPlan
        }

        private enum CodingKeys: String, CodingKey {
            case currentPricingPlan
            case pendingPricingPlan
        }
    }

    public struct GetPropertyValueHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The name of the component.
        public let componentName: String?
        /// The ID of the component type.
        public let componentTypeId: String?
        /// The date and time of the latest property value to return.
        public let endDateTime: Date?
        /// The ISO8601 DateTime of the latest property value to return. For more information about the ISO8601 DateTime format, see the data type PropertyValue.
        public let endTime: String?
        /// The ID of the entity.
        public let entityId: String?
        /// An object that specifies the interpolation type and the interval over which to interpolate data.
        public let interpolation: InterpolationParameters?
        /// The maximum number of results to return at one time. The default is 25.  Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The time direction to use in the result order.
        public let orderByTime: OrderByTime?
        /// A list of objects that filter the property value history request.
        public let propertyFilters: [PropertyFilter]?
        /// A list of properties whose value histories the request retrieves.
        public let selectedProperties: [String]
        /// The date and time of the earliest property value to return.
        public let startDateTime: Date?
        /// The ISO8601 DateTime of the earliest property value to return. For more information about the ISO8601 DateTime format, see the data type PropertyValue.
        public let startTime: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentName: String? = nil, componentTypeId: String? = nil, endTime: String? = nil, entityId: String? = nil, interpolation: InterpolationParameters? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderByTime: OrderByTime? = nil, propertyFilters: [PropertyFilter]? = nil, selectedProperties: [String], startTime: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.endDateTime = nil
            self.endTime = endTime
            self.entityId = entityId
            self.interpolation = interpolation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderByTime = orderByTime
            self.propertyFilters = propertyFilters
            self.selectedProperties = selectedProperties
            self.startDateTime = nil
            self.startTime = startTime
            self.workspaceId = workspaceId
        }

        @available(*, deprecated, message: "Members endDateTime, startDateTime have been deprecated")
        public init(componentName: String? = nil, componentTypeId: String? = nil, endDateTime: Date? = nil, endTime: String? = nil, entityId: String? = nil, interpolation: InterpolationParameters? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderByTime: OrderByTime? = nil, propertyFilters: [PropertyFilter]? = nil, selectedProperties: [String], startDateTime: Date? = nil, startTime: String? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.endDateTime = endDateTime
            self.endTime = endTime
            self.entityId = entityId
            self.interpolation = interpolation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderByTime = orderByTime
            self.propertyFilters = propertyFilters
            self.selectedProperties = selectedProperties
            self.startDateTime = startDateTime
            self.startTime = startTime
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.endTime, name: "endTime", parent: name, max: 35)
            try self.validate(self.endTime, name: "endTime", parent: name, min: 20)
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.propertyFilters?.forEach {
                try $0.validate(name: "\(name).propertyFilters[]")
            }
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, max: 10)
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, min: 1)
            try self.selectedProperties.forEach {
                try validate($0, name: "selectedProperties[]", parent: name, max: 256)
                try validate($0, name: "selectedProperties[]", parent: name, min: 1)
                try validate($0, name: "selectedProperties[]", parent: name, pattern: ".*")
            }
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, max: 10)
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, min: 1)
            try self.validate(self.startTime, name: "startTime", parent: name, max: 35)
            try self.validate(self.startTime, name: "startTime", parent: name, min: 20)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case componentTypeId
            case endDateTime
            case endTime
            case entityId
            case interpolation
            case maxResults
            case nextToken
            case orderByTime
            case propertyFilters
            case selectedProperties
            case startDateTime
            case startTime
        }
    }

    public struct GetPropertyValueHistoryResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyValues: [PropertyValueHistory]

        public init(nextToken: String? = nil, propertyValues: [PropertyValueHistory]) {
            self.nextToken = nextToken
            self.propertyValues = propertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case propertyValues
        }
    }

    public struct GetPropertyValueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The name of the component whose property values the operation returns.
        public let componentName: String?
        /// The ID of the component type whose property values the operation returns.
        public let componentTypeId: String?
        /// The ID of the entity whose property values the operation returns.
        public let entityId: String?
        /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The property group name.
        public let propertyGroupName: String?
        /// The properties whose values the operation returns.
        public let selectedProperties: [String]
        /// The tabular conditions.
        public let tabularConditions: TabularConditions?
        /// The ID of the workspace whose values the operation returns.
        public let workspaceId: String

        public init(componentName: String? = nil, componentTypeId: String? = nil, entityId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyGroupName: String? = nil, selectedProperties: [String], tabularConditions: TabularConditions? = nil, workspaceId: String) {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.entityId = entityId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyGroupName = propertyGroupName
            self.selectedProperties = selectedProperties
            self.tabularConditions = tabularConditions
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 256)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.propertyGroupName, name: "propertyGroupName", parent: name, max: 256)
            try self.validate(self.propertyGroupName, name: "propertyGroupName", parent: name, min: 1)
            try self.validate(self.propertyGroupName, name: "propertyGroupName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.selectedProperties.forEach {
                try validate($0, name: "selectedProperties[]", parent: name, max: 256)
                try validate($0, name: "selectedProperties[]", parent: name, min: 1)
                try validate($0, name: "selectedProperties[]", parent: name, pattern: ".*")
            }
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, max: 10)
            try self.validate(self.selectedProperties, name: "selectedProperties", parent: name, min: 1)
            try self.tabularConditions?.validate(name: "\(name).tabularConditions")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName
            case componentTypeId
            case entityId
            case maxResults
            case nextToken
            case propertyGroupName
            case selectedProperties
            case tabularConditions
        }
    }

    public struct GetPropertyValueResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// An object that maps strings to the properties and latest property values in the response. Each string  in the mapping must be unique to this object.
        public let propertyValues: [String: PropertyLatestValue]?
        /// A table of property values.
        public let tabularPropertyValues: [[[String: DataValue]]]?

        public init(nextToken: String? = nil, propertyValues: [String: PropertyLatestValue]? = nil, tabularPropertyValues: [[[String: DataValue]]]? = nil) {
            self.nextToken = nextToken
            self.propertyValues = propertyValues
            self.tabularPropertyValues = tabularPropertyValues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case propertyValues
            case tabularPropertyValues
        }
    }

    public struct GetSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sceneId", location: .uri("sceneId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the scene.
        public let sceneId: String
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(sceneId: String, workspaceId: String) {
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSceneResponse: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// A list of capabilities that the scene uses to render.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date
        /// The description of the scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(arn: String, capabilities: [String]? = nil, contentLocation: String, creationDateTime: Date, description: String? = nil, sceneId: String, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case capabilities
            case contentLocation
            case creationDateTime
            case description
            case sceneId
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetSyncJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "syncSource", location: .uri("syncSource")),
            AWSMemberEncoding(label: "workspaceId", location: .querystring("workspace"))
        ]

        /// The sync soucre.  Currently the only supported syncSoucre is SITEWISE .
        public let syncSource: String
        /// The workspace Id.
        public let workspaceId: String?

        public init(syncSource: String, workspaceId: String? = nil) {
            self.syncSource = syncSource
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSyncJobResponse: AWSDecodableShape {
        /// The sync job ARN.
        public let arn: String
        /// The creation date and time.
        public let creationDateTime: Date
        /// The SyncJob response status.
        public let status: SyncJobStatus
        /// The sync IAM role.
        public let syncRole: String
        /// The sync soucre.  Currently the only supported syncSoucre is SITEWISE .
        public let syncSource: String
        /// The update date and time.
        public let updateDateTime: Date
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, status: SyncJobStatus, syncRole: String, syncSource: String, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncRole = syncRole
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case status
            case syncRole
            case syncSource
            case updateDateTime
            case workspaceId
        }
    }

    public struct GetWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 2048)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$|^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date
        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String
        /// The ARN of the S3 bucket where resources associated with the workspace are stored.
        public let s3Location: String
        /// The date and time when the workspace was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, description: String? = nil, role: String, s3Location: String, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.role = role
            self.s3Location = s3Location
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case role
            case s3Location
            case updateDateTime
            case workspaceId
        }
    }

    public struct InterpolationParameters: AWSEncodableShape {
        /// The interpolation type.
        public let interpolationType: InterpolationType?
        /// The interpolation time interval in seconds.
        public let intervalInSeconds: Int64?

        public init(interpolationType: InterpolationType? = nil, intervalInSeconds: Int64? = nil) {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case interpolationType
            case intervalInSeconds
        }
    }

    public struct LambdaFunction: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):lambda:[a-z0-9-]+:[0-9]{12}:function:[\\/a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct ListComponentTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of objects that filter the request.
        public let filters: [ListComponentTypesFilter]?
        /// The maximum number of results to return at one time. The default is 25.  Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(filters: [ListComponentTypesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListComponentTypesResponse: AWSDecodableShape {
        /// A list of objects that contain information about the component types.
        public let componentTypeSummaries: [ComponentTypeSummary]
        /// Specifies the maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentTypeSummaries: [ComponentTypeSummary], maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.componentTypeSummaries = componentTypeSummaries
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeSummaries
            case maxResults
            case nextToken
            case workspaceId
        }
    }

    public struct ListEntitiesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of objects that filter the request.  Only one object is accepted as a valid input.
        public let filters: [ListEntitiesFilter]?
        /// The maximum number of results to return at one time. The default is 25.  Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(filters: [ListEntitiesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListEntitiesResponse: AWSDecodableShape {
        /// A list of objects that contain information about the entities.
        public let entitySummaries: [EntitySummary]?
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(entitySummaries: [EntitySummary]? = nil, nextToken: String? = nil) {
            self.entitySummaries = entitySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entitySummaries
            case nextToken
        }
    }

    public struct ListScenesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Specifies the maximum number of results to display.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace that contains the scenes.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListScenesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// A list of objects that contain information about the scenes.
        public let sceneSummaries: [SceneSummary]?

        public init(nextToken: String? = nil, sceneSummaries: [SceneSummary]? = nil) {
            self.nextToken = nextToken
            self.sceneSummaries = sceneSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sceneSummaries
        }
    }

    public struct ListSyncJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The maximum number of results to return at one time. The default is 50.  Valid Range: Minimum value of 0. Maximum value of 200.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListSyncJobsResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The listed SyncJob summaries.
        public let syncJobSummaries: [SyncJobSummary]?

        public init(nextToken: String? = nil, syncJobSummaries: [SyncJobSummary]? = nil) {
            self.nextToken = nextToken
            self.syncJobSummaries = syncJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case syncJobSummaries
        }
    }

    public struct ListSyncResourcesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "syncSource", location: .uri("syncSource")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of objects that filter the request.
        public let filters: [SyncResourceFilter]?
        /// The maximum number of results to return at one time. The default is 50.  Valid Range: Minimum value of 0. Maximum value of 200.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The sync soucre.  Currently the only supported syncSoucre is SITEWISE .
        public let syncSource: String
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String

        public init(filters: [SyncResourceFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, syncSource: String, workspaceId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.syncSource = syncSource
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.syncSource, name: "syncSource", parent: name, pattern: "^[a-zA-Z_0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListSyncResourcesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The sync resources.
        public let syncResources: [SyncResourceSummary]?

        public init(nextToken: String? = nil, syncResources: [SyncResourceSummary]? = nil) {
            self.nextToken = nextToken
            self.syncResources = syncResources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case syncResources
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 25.  Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// The ARN of the resource.
        public let resourceARN: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceARN: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case resourceARN
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// Metadata that you can use to manage a resource.
        public let tags: [String: String]?

        public init(nextToken: String? = nil, tags: [String: String]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tags
        }
    }

    public struct ListWorkspacesRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time. The default is 25.  Valid Range: Minimum value of 1. Maximum value of 250.
        public let maxResults: Int?
        /// The string that specifies the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 17880)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListWorkspacesResponse: AWSDecodableShape {
        /// The string that specifies the next page of results.
        public let nextToken: String?
        /// A list of objects that contain information about the workspaces.
        public let workspaceSummaries: [WorkspaceSummary]?

        public init(nextToken: String? = nil, workspaceSummaries: [WorkspaceSummary]? = nil) {
            self.nextToken = nextToken
            self.workspaceSummaries = workspaceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case workspaceSummaries
        }
    }

    public struct OrderBy: AWSEncodableShape {
        /// The set order that filters results.
        public let order: Order?
        /// The property name.
        public let propertyName: String

        public init(order: Order? = nil, propertyName: String) {
            self.order = order
            self.propertyName = propertyName
        }

        public func validate(name: String) throws {
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case order
            case propertyName
        }
    }

    public struct ParentEntityUpdateRequest: AWSEncodableShape {
        /// The ID of the parent entity.
        public let parentEntityId: String?
        /// The type of the update.
        public let updateType: ParentEntityUpdateType

        public init(parentEntityId: String? = nil, updateType: ParentEntityUpdateType) {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }

        public func validate(name: String) throws {
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, max: 128)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, min: 1)
            try self.validate(self.parentEntityId, name: "parentEntityId", parent: name, pattern: "^\\$ROOT|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parentEntityId
            case updateType
        }
    }

    public struct PricingPlan: AWSDecodableShape {
        /// The billable entity count.
        public let billableEntityCount: Int64?
        /// The pricing plan's bundle information.
        public let bundleInformation: BundleInformation?
        /// The effective date and time of the pricing plan.
        public let effectiveDateTime: Date
        /// The pricing mode.
        public let pricingMode: PricingMode
        /// The set date and time for updating a pricing plan.
        public let updateDateTime: Date
        /// The update reason, for changing a pricing plan.
        public let updateReason: UpdateReason

        public init(billableEntityCount: Int64? = nil, bundleInformation: BundleInformation? = nil, effectiveDateTime: Date, pricingMode: PricingMode, updateDateTime: Date, updateReason: UpdateReason) {
            self.billableEntityCount = billableEntityCount
            self.bundleInformation = bundleInformation
            self.effectiveDateTime = effectiveDateTime
            self.pricingMode = pricingMode
            self.updateDateTime = updateDateTime
            self.updateReason = updateReason
        }

        private enum CodingKeys: String, CodingKey {
            case billableEntityCount
            case bundleInformation
            case effectiveDateTime
            case pricingMode
            case updateDateTime
            case updateReason
        }
    }

    public struct PropertyDefinitionRequest: AWSEncodableShape {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public let configuration: [String: String]?
        /// An object that contains information about the data type.
        public let dataType: DataType?
        /// An object that contains the default value.
        public let defaultValue: DataValue?
        /// A friendly name for the property.
        public let displayName: String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public let isExternalId: Bool?
        /// A Boolean value that specifies whether the property is required.
        public let isRequiredInEntity: Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public let isStoredExternally: Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public let isTimeSeries: Bool?

        public init(configuration: [String: String]? = nil, dataType: DataType? = nil, defaultValue: DataValue? = nil, displayName: String? = nil, isExternalId: Bool? = nil, isRequiredInEntity: Bool? = nil, isStoredExternally: Bool? = nil, isTimeSeries: Bool? = nil) {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }

        public func validate(name: String) throws {
            try self.configuration?.forEach {
                try validate($0.key, name: "configuration.key", parent: name, max: 256)
                try validate($0.key, name: "configuration.key", parent: name, min: 1)
                try validate($0.key, name: "configuration.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try validate($0.value, name: "configuration[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.dataType?.validate(name: "\(name).dataType")
            try self.defaultValue?.validate(name: "\(name).defaultValue")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]*")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case dataType
            case defaultValue
            case displayName
            case isExternalId
            case isRequiredInEntity
            case isStoredExternally
            case isTimeSeries
        }
    }

    public struct PropertyDefinitionResponse: AWSDecodableShape {
        /// A mapping that specifies configuration information about the property.
        public let configuration: [String: String]?
        /// An object that contains information about the data type.
        public let dataType: DataType
        /// An object that contains the default value.
        public let defaultValue: DataValue?
        /// A friendly name for the property.
        public let displayName: String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public let isExternalId: Bool
        /// A Boolean value that specifies whether the property definition can be updated.
        public let isFinal: Bool
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        public let isImported: Bool
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        public let isInherited: Bool
        /// A Boolean value that specifies whether the property is required in an entity.
        public let isRequiredInEntity: Bool
        /// A Boolean value that specifies whether the property is stored externally.
        public let isStoredExternally: Bool
        /// A Boolean value that specifies whether the property consists of time series data.
        public let isTimeSeries: Bool

        public init(configuration: [String: String]? = nil, dataType: DataType, defaultValue: DataValue? = nil, displayName: String? = nil, isExternalId: Bool, isFinal: Bool, isImported: Bool, isInherited: Bool, isRequiredInEntity: Bool, isStoredExternally: Bool, isTimeSeries: Bool) {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case dataType
            case defaultValue
            case displayName
            case isExternalId
            case isFinal
            case isImported
            case isInherited
            case isRequiredInEntity
            case isStoredExternally
            case isTimeSeries
        }
    }

    public struct PropertyFilter: AWSEncodableShape {
        /// The operator associated with this property filter.
        public let `operator`: String?
        /// The property name associated with this property filter.
        public let propertyName: String?
        /// The value associated with this property filter.
        public let value: DataValue?

        public init(operator: String? = nil, propertyName: String? = nil, value: DataValue? = nil) {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.`operator`, name: "`operator`", parent: name, max: 256)
            try self.validate(self.`operator`, name: "`operator`", parent: name, min: 1)
            try self.validate(self.`operator`, name: "`operator`", parent: name, pattern: ".*")
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
            try self.validate(self.propertyName, name: "propertyName", parent: name, min: 1)
            try self.validate(self.propertyName, name: "propertyName", parent: name, pattern: ".*")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case `operator`
            case propertyName
            case value
        }
    }

    public struct PropertyGroupRequest: AWSEncodableShape {
        /// The group type.
        public let groupType: GroupType?
        /// The names of properties.
        public let propertyNames: [String]?

        public init(groupType: GroupType? = nil, propertyNames: [String]? = nil) {
            self.groupType = groupType
            self.propertyNames = propertyNames
        }

        public func validate(name: String) throws {
            try self.propertyNames?.forEach {
                try validate($0, name: "propertyNames[]", parent: name, max: 256)
                try validate($0, name: "propertyNames[]", parent: name, min: 1)
                try validate($0, name: "propertyNames[]", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupType
            case propertyNames
        }
    }

    public struct PropertyGroupResponse: AWSDecodableShape {
        /// The group types.
        public let groupType: GroupType
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        public let isInherited: Bool
        /// The names of properties.
        public let propertyNames: [String]

        public init(groupType: GroupType, isInherited: Bool, propertyNames: [String]) {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }

        private enum CodingKeys: String, CodingKey {
            case groupType
            case isInherited
            case propertyNames
        }
    }

    public struct PropertyLatestValue: AWSDecodableShape {
        /// An object that specifies information about a property.&gt;
        public let propertyReference: EntityPropertyReference
        /// The value of the property.
        public let propertyValue: DataValue?

        public init(propertyReference: EntityPropertyReference, propertyValue: DataValue? = nil) {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyReference
            case propertyValue
        }
    }

    public struct PropertyRequest: AWSEncodableShape {
        /// An object that specifies information about a property.
        public let definition: PropertyDefinitionRequest?
        /// The update type of the update property request.
        public let updateType: PropertyUpdateType?
        /// The value of the property.
        public let value: DataValue?

        public init(definition: PropertyDefinitionRequest? = nil, updateType: PropertyUpdateType? = nil, value: DataValue? = nil) {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }

        public func validate(name: String) throws {
            try self.definition?.validate(name: "\(name).definition")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case definition
            case updateType
            case value
        }
    }

    public struct PropertyResponse: AWSDecodableShape {
        /// An object that specifies information about a property.
        public let definition: PropertyDefinitionResponse?
        /// The value of the property.
        public let value: DataValue?

        public init(definition: PropertyDefinitionResponse? = nil, value: DataValue? = nil) {
            self.definition = definition
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case definition
            case value
        }
    }

    public struct PropertyValue: AWSEncodableShape & AWSDecodableShape {
        /// ISO8601 DateTime of a value for a time series property. The time for when the property value was recorded in ISO 8601 format: YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm].     [YYYY]: year    [MM]: month    [DD]: day    [hh]: hour    [mm]: minute    [ss]: seconds    [.SSSSSSSSS]: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.    Z: default timezone UTC    ± HH:mm: time zone offset in Hours and Minutes.    Required sub-fields: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]
        public let time: String?
        /// The timestamp of a value for a time series property.
        public let timestamp: Date?
        /// An object that specifies a value for a time series property.
        public let value: DataValue

        public init(time: String? = nil, value: DataValue) {
            self.time = time
            self.timestamp = nil
            self.value = value
        }

        @available(*, deprecated, message: "Members timestamp have been deprecated")
        public init(time: String? = nil, timestamp: Date? = nil, value: DataValue) {
            self.time = time
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.time, name: "time", parent: name, max: 35)
            try self.validate(self.time, name: "time", parent: name, min: 20)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case time
            case timestamp
            case value
        }
    }

    public struct PropertyValueEntry: AWSEncodableShape & AWSDecodableShape {
        /// An object that contains information about the entity that has the property.
        public let entityPropertyReference: EntityPropertyReference
        /// A list of objects that specify time series property values.
        public let propertyValues: [PropertyValue]?

        public init(entityPropertyReference: EntityPropertyReference, propertyValues: [PropertyValue]? = nil) {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.entityPropertyReference.validate(name: "\(name).entityPropertyReference")
            try self.propertyValues?.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
            try self.validate(self.propertyValues, name: "propertyValues", parent: name, max: 10)
            try self.validate(self.propertyValues, name: "propertyValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityPropertyReference
            case propertyValues
        }
    }

    public struct PropertyValueHistory: AWSDecodableShape {
        /// An object that uniquely identifies an entity property.
        public let entityPropertyReference: EntityPropertyReference
        /// A list of objects that contain information about the values in the history of a time series property.
        public let values: [PropertyValue]?

        public init(entityPropertyReference: EntityPropertyReference, values: [PropertyValue]? = nil) {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case entityPropertyReference
            case values
        }
    }

    public struct Relationship: AWSEncodableShape & AWSDecodableShape {
        /// The type of the relationship.
        public let relationshipType: String?
        /// The ID of the target component type associated with this relationship.
        public let targetComponentTypeId: String?

        public init(relationshipType: String? = nil, targetComponentTypeId: String? = nil) {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, max: 256)
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, min: 1)
            try self.validate(self.relationshipType, name: "relationshipType", parent: name, pattern: ".*")
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, max: 256)
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, min: 1)
            try self.validate(self.targetComponentTypeId, name: "targetComponentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case relationshipType
            case targetComponentTypeId
        }
    }

    public struct RelationshipValue: AWSEncodableShape & AWSDecodableShape {
        /// The name of the target component associated with the relationship value.
        public let targetComponentName: String?
        /// The ID of the target entity associated with this relationship value.
        public let targetEntityId: String?

        public init(targetComponentName: String? = nil, targetEntityId: String? = nil) {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }

        public func validate(name: String) throws {
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, max: 256)
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, min: 1)
            try self.validate(self.targetComponentName, name: "targetComponentName", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, max: 128)
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, min: 1)
            try self.validate(self.targetEntityId, name: "targetEntityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetComponentName
            case targetEntityId
        }
    }

    public struct Row: AWSDecodableShape {
        /// The data in a row of query results.
        public let rowData: [String]?

        public init(rowData: [String]? = nil) {
            self.rowData = rowData
        }

        private enum CodingKeys: String, CodingKey {
            case rowData
        }
    }

    public struct SceneSummary: AWSDecodableShape {
        /// The ARN of the scene.
        public let arn: String
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String
        /// The date and time when the scene was created.
        public let creationDateTime: Date
        /// The scene description.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date

        public init(arn: String, contentLocation: String, creationDateTime: Date, description: String? = nil, sceneId: String, updateDateTime: Date) {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case contentLocation
            case creationDateTime
            case description
            case sceneId
            case updateDateTime
        }
    }

    public struct Status: AWSDecodableShape {
        /// The error message.
        public let error: ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public let state: State?

        public init(error: ErrorDetails? = nil, state: State? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct SyncJobStatus: AWSDecodableShape {
        /// The SyncJob error.
        public let error: ErrorDetails?
        /// The SyncJob status state.
        public let state: SyncJobState?

        public init(error: ErrorDetails? = nil, state: SyncJobState? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct SyncJobSummary: AWSDecodableShape {
        /// The SyncJob summary ARN.
        public let arn: String?
        /// The creation date and time.
        public let creationDateTime: Date?
        /// The SyncJob summaries status.
        public let status: SyncJobStatus?
        /// The sync source.
        public let syncSource: String?
        /// The update date and time.
        public let updateDateTime: Date?
        /// The ID of the workspace that contains the sync job.
        public let workspaceId: String?

        public init(arn: String? = nil, creationDateTime: Date? = nil, status: SyncJobStatus? = nil, syncSource: String? = nil, updateDateTime: Date? = nil, workspaceId: String? = nil) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case status
            case syncSource
            case updateDateTime
            case workspaceId
        }
    }

    public struct SyncResourceStatus: AWSDecodableShape {
        /// The status error.
        public let error: ErrorDetails?
        /// The sync resource status state.
        public let state: SyncResourceState?

        public init(error: ErrorDetails? = nil, state: SyncResourceState? = nil) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error
            case state
        }
    }

    public struct SyncResourceSummary: AWSDecodableShape {
        /// The external Id.
        public let externalId: String?
        /// The resource Id.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: SyncResourceType?
        /// The sync resource summary status.
        public let status: SyncResourceStatus?
        /// The update date and time.
        public let updateDateTime: Date?

        public init(externalId: String? = nil, resourceId: String? = nil, resourceType: SyncResourceType? = nil, status: SyncResourceStatus? = nil, updateDateTime: Date? = nil) {
            self.externalId = externalId
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case externalId
            case resourceId
            case resourceType
            case status
            case updateDateTime
        }
    }

    public struct TabularConditions: AWSEncodableShape {
        /// Filter criteria that orders the output. It can be sorted in ascending or descending order.
        public let orderBy: [OrderBy]?
        /// You can filter the request using various logical operators and a key-value format. For example:     {"key": "serverType", "value": "webServer"}
        public let propertyFilters: [PropertyFilter]?

        public init(orderBy: [OrderBy]? = nil, propertyFilters: [PropertyFilter]? = nil) {
            self.orderBy = orderBy
            self.propertyFilters = propertyFilters
        }

        public func validate(name: String) throws {
            try self.orderBy?.forEach {
                try $0.validate(name: "\(name).orderBy[]")
            }
            try self.validate(self.orderBy, name: "orderBy", parent: name, max: 10)
            try self.validate(self.orderBy, name: "orderBy", parent: name, min: 1)
            try self.propertyFilters?.forEach {
                try $0.validate(name: "\(name).propertyFilters[]")
            }
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, max: 10)
            try self.validate(self.propertyFilters, name: "propertyFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case orderBy
            case propertyFilters
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// Metadata to add to this resource.
        public let tags: [String: String]

        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .querystring("resourceARN")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource.
        public let resourceARN: String
        /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 2048)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iottwinmaker:[a-z0-9-]+:[0-9]{12}:[\\/a-zA-Z0-9_\\-\\.:]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateComponentTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentTypeId", location: .uri("componentTypeId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the component type.
        public let componentTypeId: String
        /// The component type name.
        public let componentTypeName: String?
        /// The description of the component type.
        public let description: String?
        /// Specifies the component type that this component type extends.
        public let extendsFrom: [String]?
        /// An object that maps strings to the functions in the component type. Each string  in the mapping must be unique to this object.
        public let functions: [String: FunctionRequest]?
        /// A Boolean value that specifies whether an entity can have more than one component of this type.
        public let isSingleton: Bool?
        /// An object that maps strings to the property definitions in the component type. Each string  in the mapping must be unique to this object.
        public let propertyDefinitions: [String: PropertyDefinitionRequest]?
        /// The property groups
        public let propertyGroups: [String: PropertyGroupRequest]?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(componentTypeId: String, componentTypeName: String? = nil, description: String? = nil, extendsFrom: [String]? = nil, functions: [String: FunctionRequest]? = nil, isSingleton: Bool? = nil, propertyDefinitions: [String: PropertyDefinitionRequest]? = nil, propertyGroups: [String: PropertyGroupRequest]? = nil, workspaceId: String) {
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.description = description
            self.extendsFrom = extendsFrom
            self.functions = functions
            self.isSingleton = isSingleton
            self.propertyDefinitions = propertyDefinitions
            self.propertyGroups = propertyGroups
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, max: 256)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, min: 1)
            try self.validate(self.componentTypeId, name: "componentTypeId", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, max: 256)
            try self.validate(self.componentTypeName, name: "componentTypeName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]*")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.extendsFrom?.forEach {
                try validate($0, name: "extendsFrom[]", parent: name, max: 256)
                try validate($0, name: "extendsFrom[]", parent: name, min: 1)
                try validate($0, name: "extendsFrom[]", parent: name, pattern: "^[a-zA-Z_\\.\\-0-9:]+$")
            }
            try self.functions?.forEach {
                try validate($0.key, name: "functions.key", parent: name, max: 256)
                try validate($0.key, name: "functions.key", parent: name, min: 1)
                try validate($0.key, name: "functions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).functions[\"\($0.key)\"]")
            }
            try self.propertyDefinitions?.forEach {
                try validate($0.key, name: "propertyDefinitions.key", parent: name, max: 256)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, min: 1)
                try validate($0.key, name: "propertyDefinitions.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyDefinitions[\"\($0.key)\"]")
            }
            try self.propertyGroups?.forEach {
                try validate($0.key, name: "propertyGroups.key", parent: name, max: 256)
                try validate($0.key, name: "propertyGroups.key", parent: name, min: 1)
                try validate($0.key, name: "propertyGroups.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).propertyGroups[\"\($0.key)\"]")
            }
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentTypeName
            case description
            case extendsFrom
            case functions
            case isSingleton
            case propertyDefinitions
            case propertyGroups
        }
    }

    public struct UpdateComponentTypeResponse: AWSDecodableShape {
        /// The ARN of the component type.
        public let arn: String
        /// The ID of the component type.
        public let componentTypeId: String
        /// The current state of the component type.
        public let state: State
        /// The ID of the workspace that contains the component type.
        public let workspaceId: String

        public init(arn: String, componentTypeId: String, state: State, workspaceId: String) {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.state = state
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case componentTypeId
            case state
            case workspaceId
        }
    }

    public struct UpdateEntityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "entityId", location: .uri("entityId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// An object that maps strings to the component updates in the request. Each string  in the mapping must be unique to this object.
        public let componentUpdates: [String: ComponentUpdateRequest]?
        /// The description of the entity.
        public let description: String?
        /// The ID of the entity.
        public let entityId: String
        /// The name of the entity.
        public let entityName: String?
        /// An object that describes the update request for a parent entity.
        public let parentEntityUpdate: ParentEntityUpdateRequest?
        /// The ID of the workspace that contains the entity.
        public let workspaceId: String

        public init(componentUpdates: [String: ComponentUpdateRequest]? = nil, description: String? = nil, entityId: String, entityName: String? = nil, parentEntityUpdate: ParentEntityUpdateRequest? = nil, workspaceId: String) {
            self.componentUpdates = componentUpdates
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.parentEntityUpdate = parentEntityUpdate
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.componentUpdates?.forEach {
                try validate($0.key, name: "componentUpdates.key", parent: name, max: 256)
                try validate($0.key, name: "componentUpdates.key", parent: name, min: 1)
                try validate($0.key, name: "componentUpdates.key", parent: name, pattern: "^[a-zA-Z_\\-0-9]+$")
                try $0.value.validate(name: "\(name).componentUpdates[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.entityId, name: "entityId", parent: name, max: 128)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 1)
            try self.validate(self.entityId, name: "entityId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|^[a-zA-Z0-9][a-zA-Z_\\-0-9.:]*[a-zA-Z0-9]+$")
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, min: 1)
            try self.validate(self.entityName, name: "entityName", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.parentEntityUpdate?.validate(name: "\(name).parentEntityUpdate")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentUpdates
            case description
            case entityName
            case parentEntityUpdate
        }
    }

    public struct UpdateEntityResponse: AWSDecodableShape {
        /// The current state of the entity update.
        public let state: State
        /// The date and time when the entity was last updated.
        public let updateDateTime: Date

        public init(state: State, updateDateTime: Date) {
            self.state = state
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case state
            case updateDateTime
        }
    }

    public struct UpdatePricingPlanRequest: AWSEncodableShape {
        /// The bundle names.
        public let bundleNames: [String]?
        /// The pricing mode.
        public let pricingMode: PricingMode

        public init(bundleNames: [String]? = nil, pricingMode: PricingMode) {
            self.bundleNames = bundleNames
            self.pricingMode = pricingMode
        }

        public func validate(name: String) throws {
            try self.bundleNames?.forEach {
                try validate($0, name: "bundleNames[]", parent: name, max: 256)
                try validate($0, name: "bundleNames[]", parent: name, min: 1)
                try validate($0, name: "bundleNames[]", parent: name, pattern: ".*")
            }
            try self.validate(self.bundleNames, name: "bundleNames", parent: name, max: 10)
            try self.validate(self.bundleNames, name: "bundleNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bundleNames
            case pricingMode
        }
    }

    public struct UpdatePricingPlanResponse: AWSDecodableShape {
        /// Update the current pricing plan.
        public let currentPricingPlan: PricingPlan
        /// Update the pending pricing plan.
        public let pendingPricingPlan: PricingPlan?

        public init(currentPricingPlan: PricingPlan, pendingPricingPlan: PricingPlan? = nil) {
            self.currentPricingPlan = currentPricingPlan
            self.pendingPricingPlan = pendingPricingPlan
        }

        private enum CodingKeys: String, CodingKey {
            case currentPricingPlan
            case pendingPricingPlan
        }
    }

    public struct UpdateSceneRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sceneId", location: .uri("sceneId")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// A list of capabilities that the scene uses to render.
        public let capabilities: [String]?
        /// The relative path that specifies the location of the content definition file.
        public let contentLocation: String?
        /// The description of this scene.
        public let description: String?
        /// The ID of the scene.
        public let sceneId: String
        /// The ID of the workspace that contains the scene.
        public let workspaceId: String

        public init(capabilities: [String]? = nil, contentLocation: String? = nil, description: String? = nil, sceneId: String, workspaceId: String) {
            self.capabilities = capabilities
            self.contentLocation = contentLocation
            self.description = description
            self.sceneId = sceneId
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 256)
                try validate($0, name: "capabilities[]", parent: name, pattern: ".*")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, max: 256)
            try self.validate(self.contentLocation, name: "contentLocation", parent: name, pattern: "^[sS]3://[A-Za-z0-9._/-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.sceneId, name: "sceneId", parent: name, max: 128)
            try self.validate(self.sceneId, name: "sceneId", parent: name, min: 1)
            try self.validate(self.sceneId, name: "sceneId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities
            case contentLocation
            case description
        }
    }

    public struct UpdateSceneResponse: AWSDecodableShape {
        /// The date and time when the scene was last updated.
        public let updateDateTime: Date

        public init(updateDateTime: Date) {
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case updateDateTime
        }
    }

    public struct UpdateWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The description of the workspace.
        public let description: String?
        /// The ARN of the execution role associated with the workspace.
        public let role: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(description: String? = nil, role: String? = nil, workspaceId: String) {
            self.description = description
            self.role = role
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:((aws)|(aws-cn)|(aws-us-gov)):iam::[0-9]{12}:role/")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 128)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "^[a-zA-Z_0-9][a-zA-Z_\\-0-9]*[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case role
        }
    }

    public struct UpdateWorkspaceResponse: AWSDecodableShape {
        /// The date and time of the current update.
        public let updateDateTime: Date

        public init(updateDateTime: Date) {
            self.updateDateTime = updateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case updateDateTime
        }
    }

    public struct WorkspaceSummary: AWSDecodableShape {
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time when the workspace was created.
        public let creationDateTime: Date
        /// The description of the workspace.
        public let description: String?
        /// The date and time when the workspace was last updated.
        public let updateDateTime: Date
        /// The ID of the workspace.
        public let workspaceId: String

        public init(arn: String, creationDateTime: Date, description: String? = nil, updateDateTime: Date, workspaceId: String) {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationDateTime
            case description
            case updateDateTime
            case workspaceId
        }
    }
}

// MARK: - Errors

/// Error enum for IoTTwinMaker
public struct IoTTwinMakerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case connectorFailureException = "ConnectorFailureException"
        case connectorTimeoutException = "ConnectorTimeoutException"
        case internalServerException = "InternalServerException"
        case queryTimeoutException = "QueryTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTTwinMaker
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A conflict occurred.
    public static var conflictException: Self { .init(.conflictException) }
    /// The connector failed.
    public static var connectorFailureException: Self { .init(.connectorFailureException) }
    /// The connector timed out.
    public static var connectorTimeoutException: Self { .init(.connectorTimeoutException) }
    /// An unexpected error has occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The query timeout exception.
    public static var queryTimeoutException: Self { .init(.queryTimeoutException) }
    /// The resource wasn&#39;t found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The rate exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The number of tags exceeds the limit.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// Failed
    public static var validationException: Self { .init(.validationException) }
}

extension IoTTwinMakerErrorType: Equatable {
    public static func == (lhs: IoTTwinMakerErrorType, rhs: IoTTwinMakerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTTwinMakerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
