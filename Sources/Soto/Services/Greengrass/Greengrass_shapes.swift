//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Greengrass {
    // MARK: Enums

    public enum BulkDeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case initializing = "Initializing"
        case running = "Running"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationSyncStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inSync = "InSync"
        case outOfSync = "OutOfSync"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case forceResetDeployment = "ForceResetDeployment"
        case newDeployment = "NewDeployment"
        case redeployment = "Redeployment"
        case resetDeployment = "ResetDeployment"
        public var description: String { return self.rawValue }
    }

    public enum EncodingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binary = "binary"
        case json = "json"
        public var description: String { return self.rawValue }
    }

    public enum FunctionIsolationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case greengrassContainer = "GreengrassContainer"
        case noContainer = "NoContainer"
        public var description: String { return self.rawValue }
    }

    public enum LoggerComponent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case greengrassSystem = "GreengrassSystem"
        case lambda = "Lambda"
        public var description: String { return self.rawValue }
    }

    public enum LoggerLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case error = "ERROR"
        case fatal = "FATAL"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum LoggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsCloudWatch = "AWSCloudWatch"
        case fileSystem = "FileSystem"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ro = "ro"
        case rw = "rw"
        public var description: String { return self.rawValue }
    }

    public enum SoftwareToUpdate: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case core = "core"
        case otaAgent = "ota_agent"
        public var description: String { return self.rawValue }
    }

    public enum Telemetry: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "Off"
        case on = "On"
        public var description: String { return self.rawValue }
    }

    public enum UpdateAgentLogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case error = "ERROR"
        case fatal = "FATAL"
        case info = "INFO"
        case none = "NONE"
        case trace = "TRACE"
        case verbose = "VERBOSE"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum UpdateTargetsArchitecture: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aarch64 = "aarch64"
        case armv6l = "armv6l"
        case armv7l = "armv7l"
        case x8664 = "x86_64"
        public var description: String { return self.rawValue }
    }

    public enum UpdateTargetsOperatingSystem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonLinux = "amazon_linux"
        case openwrt = "openwrt"
        case raspbian = "raspbian"
        case ubuntu = "ubuntu"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateRoleToGroupRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
        public let roleArn: String?

        @inlinable
        public init(groupId: String, roleArn: String? = nil) {
            self.groupId = groupId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
        }
    }

    public struct AssociateRoleToGroupResponse: AWSDecodableShape {
        /// The time, in milliseconds since the epoch, when the role ARN was associated with the group.
        public let associatedAt: String?

        @inlinable
        public init(associatedAt: String? = nil) {
            self.associatedAt = associatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAt = "AssociatedAt"
        }
    }

    public struct AssociateServiceRoleToAccountRequest: AWSEncodableShape {
        /// The ARN of the service role you wish to associate with your account.
        public let roleArn: String?

        @inlinable
        public init(roleArn: String? = nil) {
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
        }
    }

    public struct AssociateServiceRoleToAccountResponse: AWSDecodableShape {
        /// The time when the service role was associated with the account.
        public let associatedAt: String?

        @inlinable
        public init(associatedAt: String? = nil) {
            self.associatedAt = associatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAt = "AssociatedAt"
        }
    }

    public struct BadRequestException: AWSErrorShape {
        /// Details about the error.
        public let errorDetails: [ErrorDetail]?
        /// A message containing information about the error.
        public let message: String?

        @inlinable
        public init(errorDetails: [ErrorDetail]? = nil, message: String? = nil) {
            self.errorDetails = errorDetails
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetails = "ErrorDetails"
            case message = "Message"
        }
    }

    public struct BulkDeployment: AWSDecodableShape {
        /// The ARN of the bulk deployment.
        public let bulkDeploymentArn: String?
        /// The ID of the bulk deployment.
        public let bulkDeploymentId: String?
        /// The time, in ISO format, when the deployment was created.
        public let createdAt: String?

        @inlinable
        public init(bulkDeploymentArn: String? = nil, bulkDeploymentId: String? = nil, createdAt: String? = nil) {
            self.bulkDeploymentArn = bulkDeploymentArn
            self.bulkDeploymentId = bulkDeploymentId
            self.createdAt = createdAt
        }

        private enum CodingKeys: String, CodingKey {
            case bulkDeploymentArn = "BulkDeploymentArn"
            case bulkDeploymentId = "BulkDeploymentId"
            case createdAt = "CreatedAt"
        }
    }

    public struct BulkDeploymentMetrics: AWSDecodableShape {
        /// The total number of records that returned a non-retryable error. For example, this can occur if a group record from the input file uses an invalid format or specifies a nonexistent group version, or if the execution role doesn't grant permission to deploy a group or group version.
        public let invalidInputRecords: Int?
        /// The total number of group records from the input file that have been processed so far, or attempted.
        public let recordsProcessed: Int?
        /// The total number of deployment attempts that returned a retryable error. For example, a retry is triggered if the attempt to deploy a group returns a throttling error. ''StartBulkDeployment'' retries a group deployment up to five times.
        public let retryAttempts: Int?

        @inlinable
        public init(invalidInputRecords: Int? = nil, recordsProcessed: Int? = nil, retryAttempts: Int? = nil) {
            self.invalidInputRecords = invalidInputRecords
            self.recordsProcessed = recordsProcessed
            self.retryAttempts = retryAttempts
        }

        private enum CodingKeys: String, CodingKey {
            case invalidInputRecords = "InvalidInputRecords"
            case recordsProcessed = "RecordsProcessed"
            case retryAttempts = "RetryAttempts"
        }
    }

    public struct BulkDeploymentResult: AWSDecodableShape {
        /// The time, in ISO format, when the deployment was created.
        public let createdAt: String?
        /// The ARN of the group deployment.
        public let deploymentArn: String?
        /// The ID of the group deployment.
        public let deploymentId: String?
        /// The current status of the group deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
        public let deploymentStatus: String?
        /// The type of the deployment.
        public let deploymentType: DeploymentType?
        /// Details about the error.
        public let errorDetails: [ErrorDetail]?
        /// The error message for a failed deployment
        public let errorMessage: String?
        /// The ARN of the Greengrass group.
        public let groupArn: String?

        @inlinable
        public init(createdAt: String? = nil, deploymentArn: String? = nil, deploymentId: String? = nil, deploymentStatus: String? = nil, deploymentType: DeploymentType? = nil, errorDetails: [ErrorDetail]? = nil, errorMessage: String? = nil, groupArn: String? = nil) {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.groupArn = groupArn
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deploymentArn = "DeploymentArn"
            case deploymentId = "DeploymentId"
            case deploymentStatus = "DeploymentStatus"
            case deploymentType = "DeploymentType"
            case errorDetails = "ErrorDetails"
            case errorMessage = "ErrorMessage"
            case groupArn = "GroupArn"
        }
    }

    public struct ConnectivityInfo: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint for the Greengrass core. Can be an IP address or DNS.
        public let hostAddress: String?
        /// The ID of the connectivity information.
        public let id: String?
        /// Metadata for this endpoint.
        public let metadata: String?
        /// The port of the Greengrass core. Usually 8883.
        public let portNumber: Int?

        @inlinable
        public init(hostAddress: String? = nil, id: String? = nil, metadata: String? = nil, portNumber: Int? = nil) {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }

        private enum CodingKeys: String, CodingKey {
            case hostAddress = "HostAddress"
            case id = "Id"
            case metadata = "Metadata"
            case portNumber = "PortNumber"
        }
    }

    public struct Connector: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the connector.
        public let connectorArn: String?
        /// A descriptive or arbitrary ID for the connector. This value must be unique within the connector definition version. Max length is 128 characters with pattern [a-zA-Z0-9:_-]+.
        public let id: String?
        /// The parameters or configuration that the connector uses.
        public let parameters: [String: String]?

        @inlinable
        public init(connectorArn: String? = nil, id: String? = nil, parameters: [String: String]? = nil) {
            self.connectorArn = connectorArn
            self.id = id
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case connectorArn = "ConnectorArn"
            case id = "Id"
            case parameters = "Parameters"
        }
    }

    public struct ConnectorDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        public let connectors: [Connector]?

        @inlinable
        public init(connectors: [Connector]? = nil) {
            self.connectors = connectors
        }

        private enum CodingKeys: String, CodingKey {
            case connectors = "Connectors"
        }
    }

    public struct Core: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the certificate associated with the core.
        public let certificateArn: String?
        /// A descriptive or arbitrary ID for the core. This value must be unique within the core definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        public let id: String?
        /// If true, the core's local shadow is automatically synced with the cloud.
        public let syncShadow: Bool?
        /// The ARN of the thing which is the core.
        public let thingArn: String?

        @inlinable
        public init(certificateArn: String? = nil, id: String? = nil, syncShadow: Bool? = nil, thingArn: String? = nil) {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case id = "Id"
            case syncShadow = "SyncShadow"
            case thingArn = "ThingArn"
        }
    }

    public struct CoreDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// A list of cores in the core definition version.
        public let cores: [Core]?

        @inlinable
        public init(cores: [Core]? = nil) {
            self.cores = cores
        }

        private enum CodingKeys: String, CodingKey {
            case cores = "Cores"
        }
    }

    public struct CreateConnectorDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the connector definition.
        public let initialVersion: ConnectorDefinitionVersion?
        /// The name of the connector definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: ConnectorDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateConnectorDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateConnectorDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the connector definition.
        public let connectorDefinitionId: String
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        public let connectors: [Connector]?

        @inlinable
        public init(amznClientToken: String? = nil, connectorDefinitionId: String, connectors: [Connector]? = nil) {
            self.amznClientToken = amznClientToken
            self.connectorDefinitionId = connectorDefinitionId
            self.connectors = connectors
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.connectorDefinitionId, key: "ConnectorDefinitionId")
            try container.encodeIfPresent(self.connectors, forKey: .connectors)
        }

        private enum CodingKeys: String, CodingKey {
            case connectors = "Connectors"
        }
    }

    public struct CreateConnectorDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateCoreDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the core definition.
        public let initialVersion: CoreDefinitionVersion?
        /// The name of the core definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: CoreDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateCoreDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateCoreDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the core definition.
        public let coreDefinitionId: String
        /// A list of cores in the core definition version.
        public let cores: [Core]?

        @inlinable
        public init(amznClientToken: String? = nil, coreDefinitionId: String, cores: [Core]? = nil) {
            self.amznClientToken = amznClientToken
            self.coreDefinitionId = coreDefinitionId
            self.cores = cores
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.coreDefinitionId, key: "CoreDefinitionId")
            try container.encodeIfPresent(self.cores, forKey: .cores)
        }

        private enum CodingKeys: String, CodingKey {
            case cores = "Cores"
        }
    }

    public struct CreateCoreDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateDeploymentRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the deployment if you wish to redeploy a previous deployment.
        public let deploymentId: String?
        /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
        public let deploymentType: DeploymentType?
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The ID of the group version to be deployed.
        public let groupVersionId: String?

        @inlinable
        public init(amznClientToken: String? = nil, deploymentId: String? = nil, deploymentType: DeploymentType? = nil, groupId: String, groupVersionId: String? = nil) {
            self.amznClientToken = amznClientToken
            self.deploymentId = deploymentId
            self.deploymentType = deploymentType
            self.groupId = groupId
            self.groupVersionId = groupVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.deploymentId, forKey: .deploymentId)
            try container.encodeIfPresent(self.deploymentType, forKey: .deploymentType)
            request.encodePath(self.groupId, key: "GroupId")
            try container.encodeIfPresent(self.groupVersionId, forKey: .groupVersionId)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "DeploymentId"
            case deploymentType = "DeploymentType"
            case groupVersionId = "GroupVersionId"
        }
    }

    public struct CreateDeploymentResponse: AWSDecodableShape {
        /// The ARN of the deployment.
        public let deploymentArn: String?
        /// The ID of the deployment.
        public let deploymentId: String?

        @inlinable
        public init(deploymentArn: String? = nil, deploymentId: String? = nil) {
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentArn = "DeploymentArn"
            case deploymentId = "DeploymentId"
        }
    }

    public struct CreateDeviceDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the device definition.
        public let initialVersion: DeviceDefinitionVersion?
        /// The name of the device definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: DeviceDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateDeviceDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateDeviceDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the device definition.
        public let deviceDefinitionId: String
        /// A list of devices in the definition version.
        public let devices: [Device]?

        @inlinable
        public init(amznClientToken: String? = nil, deviceDefinitionId: String, devices: [Device]? = nil) {
            self.amznClientToken = amznClientToken
            self.deviceDefinitionId = deviceDefinitionId
            self.devices = devices
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.deviceDefinitionId, key: "DeviceDefinitionId")
            try container.encodeIfPresent(self.devices, forKey: .devices)
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "Devices"
        }
    }

    public struct CreateDeviceDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateFunctionDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the function definition.
        public let initialVersion: FunctionDefinitionVersion?
        /// The name of the function definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: FunctionDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateFunctionDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateFunctionDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        public let defaultConfig: FunctionDefaultConfig?
        /// The ID of the Lambda function definition.
        public let functionDefinitionId: String
        /// A list of Lambda functions in this function definition version.
        public let functions: [Function]?

        @inlinable
        public init(amznClientToken: String? = nil, defaultConfig: FunctionDefaultConfig? = nil, functionDefinitionId: String, functions: [Function]? = nil) {
            self.amznClientToken = amznClientToken
            self.defaultConfig = defaultConfig
            self.functionDefinitionId = functionDefinitionId
            self.functions = functions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.defaultConfig, forKey: .defaultConfig)
            request.encodePath(self.functionDefinitionId, key: "FunctionDefinitionId")
            try container.encodeIfPresent(self.functions, forKey: .functions)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultConfig = "DefaultConfig"
            case functions = "Functions"
        }
    }

    public struct CreateFunctionDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateGroupCertificateAuthorityRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(amznClientToken: String? = nil, groupId: String) {
            self.amznClientToken = amznClientToken
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateGroupCertificateAuthorityResponse: AWSDecodableShape {
        /// The ARN of the group certificate authority.
        public let groupCertificateAuthorityArn: String?

        @inlinable
        public init(groupCertificateAuthorityArn: String? = nil) {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        }

        private enum CodingKeys: String, CodingKey {
            case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        }
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the group.
        public let initialVersion: GroupVersion?
        /// The name of the group.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: GroupVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateGroupResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateGroupVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ARN of the connector definition version for this group.
        public let connectorDefinitionVersionArn: String?
        /// The ARN of the core definition version for this group.
        public let coreDefinitionVersionArn: String?
        /// The ARN of the device definition version for this group.
        public let deviceDefinitionVersionArn: String?
        /// The ARN of the function definition version for this group.
        public let functionDefinitionVersionArn: String?
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The ARN of the logger definition version for this group.
        public let loggerDefinitionVersionArn: String?
        /// The ARN of the resource definition version for this group.
        public let resourceDefinitionVersionArn: String?
        /// The ARN of the subscription definition version for this group.
        public let subscriptionDefinitionVersionArn: String?

        @inlinable
        public init(amznClientToken: String? = nil, connectorDefinitionVersionArn: String? = nil, coreDefinitionVersionArn: String? = nil, deviceDefinitionVersionArn: String? = nil, functionDefinitionVersionArn: String? = nil, groupId: String, loggerDefinitionVersionArn: String? = nil, resourceDefinitionVersionArn: String? = nil, subscriptionDefinitionVersionArn: String? = nil) {
            self.amznClientToken = amznClientToken
            self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
            self.coreDefinitionVersionArn = coreDefinitionVersionArn
            self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
            self.functionDefinitionVersionArn = functionDefinitionVersionArn
            self.groupId = groupId
            self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
            self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
            self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
            try container.encodeIfPresent(self.coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
            try container.encodeIfPresent(self.deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
            try container.encodeIfPresent(self.functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
            request.encodePath(self.groupId, key: "GroupId")
            try container.encodeIfPresent(self.loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
            try container.encodeIfPresent(self.resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
            try container.encodeIfPresent(self.subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
            case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
            case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
            case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
            case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
            case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
            case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
        }
    }

    public struct CreateGroupVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateLoggerDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the logger definition.
        public let initialVersion: LoggerDefinitionVersion?
        /// The name of the logger definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: LoggerDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateLoggerDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateLoggerDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the logger definition.
        public let loggerDefinitionId: String
        /// A list of loggers.
        public let loggers: [Logger]?

        @inlinable
        public init(amznClientToken: String? = nil, loggerDefinitionId: String, loggers: [Logger]? = nil) {
            self.amznClientToken = amznClientToken
            self.loggerDefinitionId = loggerDefinitionId
            self.loggers = loggers
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.loggerDefinitionId, key: "LoggerDefinitionId")
            try container.encodeIfPresent(self.loggers, forKey: .loggers)
        }

        private enum CodingKeys: String, CodingKey {
            case loggers = "Loggers"
        }
    }

    public struct CreateLoggerDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateResourceDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the resource definition.
        public let initialVersion: ResourceDefinitionVersion?
        /// The name of the resource definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: ResourceDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateResourceDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateResourceDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the resource definition.
        public let resourceDefinitionId: String
        /// A list of resources.
        public let resources: [Resource]?

        @inlinable
        public init(amznClientToken: String? = nil, resourceDefinitionId: String, resources: [Resource]? = nil) {
            self.amznClientToken = amznClientToken
            self.resourceDefinitionId = resourceDefinitionId
            self.resources = resources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.resourceDefinitionId, key: "ResourceDefinitionId")
            try container.encodeIfPresent(self.resources, forKey: .resources)
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "Resources"
        }
    }

    public struct CreateResourceDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct CreateSoftwareUpdateJobRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        public let s3UrlSignerRole: String?
        public let softwareToUpdate: SoftwareToUpdate?
        public let updateAgentLogLevel: UpdateAgentLogLevel?
        public let updateTargets: [String]?
        public let updateTargetsArchitecture: UpdateTargetsArchitecture?
        public let updateTargetsOperatingSystem: UpdateTargetsOperatingSystem?

        @inlinable
        public init(amznClientToken: String? = nil, s3UrlSignerRole: String? = nil, softwareToUpdate: SoftwareToUpdate? = nil, updateAgentLogLevel: UpdateAgentLogLevel? = nil, updateTargets: [String]? = nil, updateTargetsArchitecture: UpdateTargetsArchitecture? = nil, updateTargetsOperatingSystem: UpdateTargetsOperatingSystem? = nil) {
            self.amznClientToken = amznClientToken
            self.s3UrlSignerRole = s3UrlSignerRole
            self.softwareToUpdate = softwareToUpdate
            self.updateAgentLogLevel = updateAgentLogLevel
            self.updateTargets = updateTargets
            self.updateTargetsArchitecture = updateTargetsArchitecture
            self.updateTargetsOperatingSystem = updateTargetsOperatingSystem
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.s3UrlSignerRole, forKey: .s3UrlSignerRole)
            try container.encodeIfPresent(self.softwareToUpdate, forKey: .softwareToUpdate)
            try container.encodeIfPresent(self.updateAgentLogLevel, forKey: .updateAgentLogLevel)
            try container.encodeIfPresent(self.updateTargets, forKey: .updateTargets)
            try container.encodeIfPresent(self.updateTargetsArchitecture, forKey: .updateTargetsArchitecture)
            try container.encodeIfPresent(self.updateTargetsOperatingSystem, forKey: .updateTargetsOperatingSystem)
        }

        private enum CodingKeys: String, CodingKey {
            case s3UrlSignerRole = "S3UrlSignerRole"
            case softwareToUpdate = "SoftwareToUpdate"
            case updateAgentLogLevel = "UpdateAgentLogLevel"
            case updateTargets = "UpdateTargets"
            case updateTargetsArchitecture = "UpdateTargetsArchitecture"
            case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
        }
    }

    public struct CreateSoftwareUpdateJobResponse: AWSDecodableShape {
        /// The IoT Job ARN corresponding to this update.
        public let iotJobArn: String?
        /// The IoT Job Id corresponding to this update.
        public let iotJobId: String?
        /// The software version installed on the device or devices after the update.
        public let platformSoftwareVersion: String?

        @inlinable
        public init(iotJobArn: String? = nil, iotJobId: String? = nil, platformSoftwareVersion: String? = nil) {
            self.iotJobArn = iotJobArn
            self.iotJobId = iotJobId
            self.platformSoftwareVersion = platformSoftwareVersion
        }

        private enum CodingKeys: String, CodingKey {
            case iotJobArn = "IotJobArn"
            case iotJobId = "IotJobId"
            case platformSoftwareVersion = "PlatformSoftwareVersion"
        }
    }

    public struct CreateSubscriptionDefinitionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// Information about the initial version of the subscription definition.
        public let initialVersion: SubscriptionDefinitionVersion?
        /// The name of the subscription definition.
        public let name: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, initialVersion: SubscriptionDefinitionVersion? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.initialVersion = initialVersion
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.initialVersion, forKey: .initialVersion)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case initialVersion = "InitialVersion"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct CreateSubscriptionDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct CreateSubscriptionDefinitionVersionRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ID of the subscription definition.
        public let subscriptionDefinitionId: String
        /// A list of subscriptions.
        public let subscriptions: [Subscription]?

        @inlinable
        public init(amznClientToken: String? = nil, subscriptionDefinitionId: String, subscriptions: [Subscription]? = nil) {
            self.amznClientToken = amznClientToken
            self.subscriptionDefinitionId = subscriptionDefinitionId
            self.subscriptions = subscriptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.subscriptionDefinitionId, key: "SubscriptionDefinitionId")
            try container.encodeIfPresent(self.subscriptions, forKey: .subscriptions)
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptions = "Subscriptions"
        }
    }

    public struct CreateSubscriptionDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct DefinitionInformation: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct DeleteConnectorDefinitionRequest: AWSEncodableShape {
        /// The ID of the connector definition.
        public let connectorDefinitionId: String

        @inlinable
        public init(connectorDefinitionId: String) {
            self.connectorDefinitionId = connectorDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorDefinitionId, key: "ConnectorDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectorDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCoreDefinitionRequest: AWSEncodableShape {
        /// The ID of the core definition.
        public let coreDefinitionId: String

        @inlinable
        public init(coreDefinitionId: String) {
            self.coreDefinitionId = coreDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreDefinitionId, key: "CoreDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCoreDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDeviceDefinitionRequest: AWSEncodableShape {
        /// The ID of the device definition.
        public let deviceDefinitionId: String

        @inlinable
        public init(deviceDefinitionId: String) {
            self.deviceDefinitionId = deviceDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceDefinitionId, key: "DeviceDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeviceDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFunctionDefinitionRequest: AWSEncodableShape {
        /// The ID of the Lambda function definition.
        public let functionDefinitionId: String

        @inlinable
        public init(functionDefinitionId: String) {
            self.functionDefinitionId = functionDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionDefinitionId, key: "FunctionDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLoggerDefinitionRequest: AWSEncodableShape {
        /// The ID of the logger definition.
        public let loggerDefinitionId: String

        @inlinable
        public init(loggerDefinitionId: String) {
            self.loggerDefinitionId = loggerDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.loggerDefinitionId, key: "LoggerDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLoggerDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourceDefinitionRequest: AWSEncodableShape {
        /// The ID of the resource definition.
        public let resourceDefinitionId: String

        @inlinable
        public init(resourceDefinitionId: String) {
            self.resourceDefinitionId = resourceDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceDefinitionId, key: "ResourceDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourceDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSubscriptionDefinitionRequest: AWSEncodableShape {
        /// The ID of the subscription definition.
        public let subscriptionDefinitionId: String

        @inlinable
        public init(subscriptionDefinitionId: String) {
            self.subscriptionDefinitionId = subscriptionDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.subscriptionDefinitionId, key: "SubscriptionDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSubscriptionDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Deployment: AWSDecodableShape {
        /// The time, in milliseconds since the epoch, when the deployment was created.
        public let createdAt: String?
        /// The ARN of the deployment.
        public let deploymentArn: String?
        /// The ID of the deployment.
        public let deploymentId: String?
        /// The type of the deployment.
        public let deploymentType: DeploymentType?
        /// The ARN of the group for this deployment.
        public let groupArn: String?

        @inlinable
        public init(createdAt: String? = nil, deploymentArn: String? = nil, deploymentId: String? = nil, deploymentType: DeploymentType? = nil, groupArn: String? = nil) {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentType = deploymentType
            self.groupArn = groupArn
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deploymentArn = "DeploymentArn"
            case deploymentId = "DeploymentId"
            case deploymentType = "DeploymentType"
            case groupArn = "GroupArn"
        }
    }

    public struct Device: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the certificate associated with the device.
        public let certificateArn: String?
        /// A descriptive or arbitrary ID for the device. This value must be unique within the device definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        public let id: String?
        /// If true, the device's local shadow will be automatically synced with the cloud.
        public let syncShadow: Bool?
        /// The thing ARN of the device.
        public let thingArn: String?

        @inlinable
        public init(certificateArn: String? = nil, id: String? = nil, syncShadow: Bool? = nil, thingArn: String? = nil) {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case id = "Id"
            case syncShadow = "SyncShadow"
            case thingArn = "ThingArn"
        }
    }

    public struct DeviceDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// A list of devices in the definition version.
        public let devices: [Device]?

        @inlinable
        public init(devices: [Device]? = nil) {
            self.devices = devices
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "Devices"
        }
    }

    public struct DisassociateRoleFromGroupRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateRoleFromGroupResponse: AWSDecodableShape {
        /// The time, in milliseconds since the epoch, when the role was disassociated from the group.
        public let disassociatedAt: String?

        @inlinable
        public init(disassociatedAt: String? = nil) {
            self.disassociatedAt = disassociatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case disassociatedAt = "DisassociatedAt"
        }
    }

    public struct DisassociateServiceRoleFromAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateServiceRoleFromAccountResponse: AWSDecodableShape {
        /// The time when the service role was disassociated from the account.
        public let disassociatedAt: String?

        @inlinable
        public init(disassociatedAt: String? = nil) {
            self.disassociatedAt = disassociatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case disassociatedAt = "DisassociatedAt"
        }
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// A detailed error code.
        public let detailedErrorCode: String?
        /// A detailed error message.
        public let detailedErrorMessage: String?

        @inlinable
        public init(detailedErrorCode: String? = nil, detailedErrorMessage: String? = nil) {
            self.detailedErrorCode = detailedErrorCode
            self.detailedErrorMessage = detailedErrorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case detailedErrorCode = "DetailedErrorCode"
            case detailedErrorMessage = "DetailedErrorMessage"
        }
    }

    public struct Function: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function.
        public let functionArn: String?
        /// The configuration of the Lambda function.
        public let functionConfiguration: FunctionConfiguration?
        /// A descriptive or arbitrary ID for the function. This value must be unique within the function definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        public let id: String?

        @inlinable
        public init(functionArn: String? = nil, functionConfiguration: FunctionConfiguration? = nil, id: String? = nil) {
            self.functionArn = functionArn
            self.functionConfiguration = functionConfiguration
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
            case functionConfiguration = "FunctionConfiguration"
            case id = "Id"
        }
    }

    public struct FunctionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The expected encoding type of the input payload for the function. The default is ''json''.
        public let encodingType: EncodingType?
        /// The environment configuration of the function.
        public let environment: FunctionConfigurationEnvironment?
        /// The execution arguments.
        public let execArgs: String?
        /// The name of the function executable.
        public let executable: String?
        /// The Lambda runtime supported by Greengrass which is to be used instead of the one specified in the Lambda function.
        public let functionRuntimeOverride: String?
        /// The memory size, in KB, which the function requires. This setting is not applicable and should be cleared when you run the Lambda function without containerization.
        public let memorySize: Int?
        /// True if the function is pinned. Pinned means the function is long-lived and starts when the core starts.
        public let pinned: Bool?
        /// The allowed function execution time, after which Lambda should terminate the function. This timeout still applies to pinned Lambda functions for each request.
        public let timeout: Int?

        @inlinable
        public init(encodingType: EncodingType? = nil, environment: FunctionConfigurationEnvironment? = nil, execArgs: String? = nil, executable: String? = nil, functionRuntimeOverride: String? = nil, memorySize: Int? = nil, pinned: Bool? = nil, timeout: Int? = nil) {
            self.encodingType = encodingType
            self.environment = environment
            self.execArgs = execArgs
            self.executable = executable
            self.functionRuntimeOverride = functionRuntimeOverride
            self.memorySize = memorySize
            self.pinned = pinned
            self.timeout = timeout
        }

        private enum CodingKeys: String, CodingKey {
            case encodingType = "EncodingType"
            case environment = "Environment"
            case execArgs = "ExecArgs"
            case executable = "Executable"
            case functionRuntimeOverride = "FunctionRuntimeOverride"
            case memorySize = "MemorySize"
            case pinned = "Pinned"
            case timeout = "Timeout"
        }
    }

    public struct FunctionConfigurationEnvironment: AWSEncodableShape & AWSDecodableShape {
        /// If true, the Lambda function is allowed to access the host's /sys folder. Use this when the Lambda function needs to read device information from /sys. This setting applies only when you run the Lambda function in a Greengrass container.
        public let accessSysfs: Bool?
        /// Configuration related to executing the Lambda function
        public let execution: FunctionExecutionConfig?
        /// A list of the resources, with their permissions, to which the Lambda function will be granted access. A Lambda function can have at most 10 resources. ResourceAccessPolicies apply only when you run the Lambda function in a Greengrass container.
        public let resourceAccessPolicies: [ResourceAccessPolicy]?
        /// Environment variables for the Lambda function's configuration.
        public let variables: [String: String]?

        @inlinable
        public init(accessSysfs: Bool? = nil, execution: FunctionExecutionConfig? = nil, resourceAccessPolicies: [ResourceAccessPolicy]? = nil, variables: [String: String]? = nil) {
            self.accessSysfs = accessSysfs
            self.execution = execution
            self.resourceAccessPolicies = resourceAccessPolicies
            self.variables = variables
        }

        private enum CodingKeys: String, CodingKey {
            case accessSysfs = "AccessSysfs"
            case execution = "Execution"
            case resourceAccessPolicies = "ResourceAccessPolicies"
            case variables = "Variables"
        }
    }

    public struct FunctionDefaultConfig: AWSEncodableShape & AWSDecodableShape {
        public let execution: FunctionDefaultExecutionConfig?

        @inlinable
        public init(execution: FunctionDefaultExecutionConfig? = nil) {
            self.execution = execution
        }

        private enum CodingKeys: String, CodingKey {
            case execution = "Execution"
        }
    }

    public struct FunctionDefaultExecutionConfig: AWSEncodableShape & AWSDecodableShape {
        public let isolationMode: FunctionIsolationMode?
        public let runAs: FunctionRunAsConfig?

        @inlinable
        public init(isolationMode: FunctionIsolationMode? = nil, runAs: FunctionRunAsConfig? = nil) {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }

        private enum CodingKeys: String, CodingKey {
            case isolationMode = "IsolationMode"
            case runAs = "RunAs"
        }
    }

    public struct FunctionDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        public let defaultConfig: FunctionDefaultConfig?
        /// A list of Lambda functions in this function definition version.
        public let functions: [Function]?

        @inlinable
        public init(defaultConfig: FunctionDefaultConfig? = nil, functions: [Function]? = nil) {
            self.defaultConfig = defaultConfig
            self.functions = functions
        }

        private enum CodingKeys: String, CodingKey {
            case defaultConfig = "DefaultConfig"
            case functions = "Functions"
        }
    }

    public struct FunctionExecutionConfig: AWSEncodableShape & AWSDecodableShape {
        public let isolationMode: FunctionIsolationMode?
        public let runAs: FunctionRunAsConfig?

        @inlinable
        public init(isolationMode: FunctionIsolationMode? = nil, runAs: FunctionRunAsConfig? = nil) {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }

        private enum CodingKeys: String, CodingKey {
            case isolationMode = "IsolationMode"
            case runAs = "RunAs"
        }
    }

    public struct FunctionRunAsConfig: AWSEncodableShape & AWSDecodableShape {
        /// The group ID whose permissions are used to run a Lambda function.
        public let gid: Int?
        /// The user ID whose permissions are used to run a Lambda function.
        public let uid: Int?

        @inlinable
        public init(gid: Int? = nil, uid: Int? = nil) {
            self.gid = gid
            self.uid = uid
        }

        private enum CodingKeys: String, CodingKey {
            case gid = "Gid"
            case uid = "Uid"
        }
    }

    public struct GetAssociatedRoleRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssociatedRoleResponse: AWSDecodableShape {
        /// The time when the role was associated with the group.
        public let associatedAt: String?
        /// The ARN of the role that is associated with the group.
        public let roleArn: String?

        @inlinable
        public init(associatedAt: String? = nil, roleArn: String? = nil) {
            self.associatedAt = associatedAt
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAt = "AssociatedAt"
            case roleArn = "RoleArn"
        }
    }

    public struct GetBulkDeploymentStatusRequest: AWSEncodableShape {
        /// The ID of the bulk deployment.
        public let bulkDeploymentId: String

        @inlinable
        public init(bulkDeploymentId: String) {
            self.bulkDeploymentId = bulkDeploymentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.bulkDeploymentId, key: "BulkDeploymentId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBulkDeploymentStatusResponse: AWSDecodableShape {
        /// Relevant metrics on input records processed during bulk deployment.
        public let bulkDeploymentMetrics: BulkDeploymentMetrics?
        /// The status of the bulk deployment.
        public let bulkDeploymentStatus: BulkDeploymentStatus?
        /// The time, in ISO format, when the deployment was created.
        public let createdAt: String?
        /// Error details
        public let errorDetails: [ErrorDetail]?
        /// Error message
        public let errorMessage: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(bulkDeploymentMetrics: BulkDeploymentMetrics? = nil, bulkDeploymentStatus: BulkDeploymentStatus? = nil, createdAt: String? = nil, errorDetails: [ErrorDetail]? = nil, errorMessage: String? = nil, tags: [String: String]? = nil) {
            self.bulkDeploymentMetrics = bulkDeploymentMetrics
            self.bulkDeploymentStatus = bulkDeploymentStatus
            self.createdAt = createdAt
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case bulkDeploymentMetrics = "BulkDeploymentMetrics"
            case bulkDeploymentStatus = "BulkDeploymentStatus"
            case createdAt = "CreatedAt"
            case errorDetails = "ErrorDetails"
            case errorMessage = "ErrorMessage"
            case tags = "tags"
        }
    }

    public struct GetConnectivityInfoRequest: AWSEncodableShape {
        /// The thing name.
        public let thingName: String

        @inlinable
        public init(thingName: String) {
            self.thingName = thingName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.thingName, key: "ThingName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectivityInfoResponse: AWSDecodableShape {
        /// Connectivity info list.
        public let connectivityInfo: [ConnectivityInfo]?
        /// A message about the connectivity info request.
        public let message: String?

        @inlinable
        public init(connectivityInfo: [ConnectivityInfo]? = nil, message: String? = nil) {
            self.connectivityInfo = connectivityInfo
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case connectivityInfo = "ConnectivityInfo"
            case message = "message"
        }
    }

    public struct GetConnectorDefinitionRequest: AWSEncodableShape {
        /// The ID of the connector definition.
        public let connectorDefinitionId: String

        @inlinable
        public init(connectorDefinitionId: String) {
            self.connectorDefinitionId = connectorDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorDefinitionId, key: "ConnectorDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectorDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetConnectorDefinitionVersionRequest: AWSEncodableShape {
        /// The ID of the connector definition.
        public let connectorDefinitionId: String
        /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let connectorDefinitionVersionId: String
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(connectorDefinitionId: String, connectorDefinitionVersionId: String, nextToken: String? = nil) {
            self.connectorDefinitionId = connectorDefinitionId
            self.connectorDefinitionVersionId = connectorDefinitionVersionId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorDefinitionId, key: "ConnectorDefinitionId")
            request.encodePath(self.connectorDefinitionVersionId, key: "ConnectorDefinitionVersionId")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectorDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the connector definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the connector definition version was created.
        public let creationTimestamp: String?
        /// Information about the connector definition version.
        public let definition: ConnectorDefinitionVersion?
        /// The ID of the connector definition version.
        public let id: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The version of the connector definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: ConnectorDefinitionVersion? = nil, id: String? = nil, nextToken: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.nextToken = nextToken
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case nextToken = "NextToken"
            case version = "Version"
        }
    }

    public struct GetCoreDefinitionRequest: AWSEncodableShape {
        /// The ID of the core definition.
        public let coreDefinitionId: String

        @inlinable
        public init(coreDefinitionId: String) {
            self.coreDefinitionId = coreDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreDefinitionId, key: "CoreDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetCoreDefinitionVersionRequest: AWSEncodableShape {
        /// The ID of the core definition.
        public let coreDefinitionId: String
        /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let coreDefinitionVersionId: String

        @inlinable
        public init(coreDefinitionId: String, coreDefinitionVersionId: String) {
            self.coreDefinitionId = coreDefinitionId
            self.coreDefinitionVersionId = coreDefinitionVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreDefinitionId, key: "CoreDefinitionId")
            request.encodePath(self.coreDefinitionVersionId, key: "CoreDefinitionVersionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the core definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the core definition version was created.
        public let creationTimestamp: String?
        /// Information about the core definition version.
        public let definition: CoreDefinitionVersion?
        /// The ID of the core definition version.
        public let id: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The version of the core definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: CoreDefinitionVersion? = nil, id: String? = nil, nextToken: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.nextToken = nextToken
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case nextToken = "NextToken"
            case version = "Version"
        }
    }

    public struct GetDeploymentStatusRequest: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(deploymentId: String, groupId: String) {
            self.deploymentId = deploymentId
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deploymentId, key: "DeploymentId")
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentStatusResponse: AWSDecodableShape {
        /// The status of the deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
        public let deploymentStatus: String?
        /// The type of the deployment.
        public let deploymentType: DeploymentType?
        /// Error details
        public let errorDetails: [ErrorDetail]?
        /// Error message
        public let errorMessage: String?
        /// The time, in milliseconds since the epoch, when the deployment status was updated.
        public let updatedAt: String?

        @inlinable
        public init(deploymentStatus: String? = nil, deploymentType: DeploymentType? = nil, errorDetails: [ErrorDetail]? = nil, errorMessage: String? = nil, updatedAt: String? = nil) {
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentStatus = "DeploymentStatus"
            case deploymentType = "DeploymentType"
            case errorDetails = "ErrorDetails"
            case errorMessage = "ErrorMessage"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetDeviceDefinitionRequest: AWSEncodableShape {
        /// The ID of the device definition.
        public let deviceDefinitionId: String

        @inlinable
        public init(deviceDefinitionId: String) {
            self.deviceDefinitionId = deviceDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceDefinitionId, key: "DeviceDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetDeviceDefinitionVersionRequest: AWSEncodableShape {
        /// The ID of the device definition.
        public let deviceDefinitionId: String
        /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let deviceDefinitionVersionId: String
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(deviceDefinitionId: String, deviceDefinitionVersionId: String, nextToken: String? = nil) {
            self.deviceDefinitionId = deviceDefinitionId
            self.deviceDefinitionVersionId = deviceDefinitionVersionId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceDefinitionId, key: "DeviceDefinitionId")
            request.encodePath(self.deviceDefinitionVersionId, key: "DeviceDefinitionVersionId")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the device definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the device definition version was created.
        public let creationTimestamp: String?
        /// Information about the device definition version.
        public let definition: DeviceDefinitionVersion?
        /// The ID of the device definition version.
        public let id: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The version of the device definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: DeviceDefinitionVersion? = nil, id: String? = nil, nextToken: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.nextToken = nextToken
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case nextToken = "NextToken"
            case version = "Version"
        }
    }

    public struct GetFunctionDefinitionRequest: AWSEncodableShape {
        /// The ID of the Lambda function definition.
        public let functionDefinitionId: String

        @inlinable
        public init(functionDefinitionId: String) {
            self.functionDefinitionId = functionDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionDefinitionId, key: "FunctionDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetFunctionDefinitionVersionRequest: AWSEncodableShape {
        /// The ID of the Lambda function definition.
        public let functionDefinitionId: String
        /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let functionDefinitionVersionId: String
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(functionDefinitionId: String, functionDefinitionVersionId: String, nextToken: String? = nil) {
            self.functionDefinitionId = functionDefinitionId
            self.functionDefinitionVersionId = functionDefinitionVersionId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionDefinitionId, key: "FunctionDefinitionId")
            request.encodePath(self.functionDefinitionVersionId, key: "FunctionDefinitionVersionId")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the function definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the function definition version was created.
        public let creationTimestamp: String?
        /// Information on the definition.
        public let definition: FunctionDefinitionVersion?
        /// The ID of the function definition version.
        public let id: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The version of the function definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: FunctionDefinitionVersion? = nil, id: String? = nil, nextToken: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.nextToken = nextToken
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case nextToken = "NextToken"
            case version = "Version"
        }
    }

    public struct GetGroupCertificateAuthorityRequest: AWSEncodableShape {
        /// The ID of the certificate authority.
        public let certificateAuthorityId: String
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(certificateAuthorityId: String, groupId: String) {
            self.certificateAuthorityId = certificateAuthorityId
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.certificateAuthorityId, key: "CertificateAuthorityId")
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupCertificateAuthorityResponse: AWSDecodableShape {
        /// The ARN of the certificate authority for the group.
        public let groupCertificateAuthorityArn: String?
        /// The ID of the certificate authority for the group.
        public let groupCertificateAuthorityId: String?
        /// The PEM encoded certificate for the group.
        public let pemEncodedCertificate: String?

        @inlinable
        public init(groupCertificateAuthorityArn: String? = nil, groupCertificateAuthorityId: String? = nil, pemEncodedCertificate: String? = nil) {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = groupCertificateAuthorityId
            self.pemEncodedCertificate = pemEncodedCertificate
        }

        private enum CodingKeys: String, CodingKey {
            case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
            case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
            case pemEncodedCertificate = "PemEncodedCertificate"
        }
    }

    public struct GetGroupCertificateConfigurationRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupCertificateConfigurationResponse: AWSDecodableShape {
        /// The amount of time remaining before the certificate authority expires, in milliseconds.
        public let certificateAuthorityExpiryInMilliseconds: String?
        /// The amount of time remaining before the certificate expires, in milliseconds.
        public let certificateExpiryInMilliseconds: String?
        /// The ID of the group certificate configuration.
        public let groupId: String?

        @inlinable
        public init(certificateAuthorityExpiryInMilliseconds: String? = nil, certificateExpiryInMilliseconds: String? = nil, groupId: String? = nil) {
            self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
            case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
            case groupId = "GroupId"
        }
    }

    public struct GetGroupRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetGroupVersionRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
        public let groupVersionId: String

        @inlinable
        public init(groupId: String, groupVersionId: String) {
            self.groupId = groupId
            self.groupVersionId = groupVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
            request.encodePath(self.groupVersionId, key: "GroupVersionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupVersionResponse: AWSDecodableShape {
        /// The ARN of the group version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the group version was created.
        public let creationTimestamp: String?
        /// Information about the group version definition.
        public let definition: GroupVersion?
        /// The ID of the group that the version is associated with.
        public let id: String?
        /// The ID of the group version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: GroupVersion? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct GetLoggerDefinitionRequest: AWSEncodableShape {
        /// The ID of the logger definition.
        public let loggerDefinitionId: String

        @inlinable
        public init(loggerDefinitionId: String) {
            self.loggerDefinitionId = loggerDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.loggerDefinitionId, key: "LoggerDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLoggerDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetLoggerDefinitionVersionRequest: AWSEncodableShape {
        /// The ID of the logger definition.
        public let loggerDefinitionId: String
        /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let loggerDefinitionVersionId: String
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(loggerDefinitionId: String, loggerDefinitionVersionId: String, nextToken: String? = nil) {
            self.loggerDefinitionId = loggerDefinitionId
            self.loggerDefinitionVersionId = loggerDefinitionVersionId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.loggerDefinitionId, key: "LoggerDefinitionId")
            request.encodePath(self.loggerDefinitionVersionId, key: "LoggerDefinitionVersionId")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLoggerDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the logger definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the logger definition version was created.
        public let creationTimestamp: String?
        /// Information about the logger definition version.
        public let definition: LoggerDefinitionVersion?
        /// The ID of the logger definition version.
        public let id: String?
        /// The version of the logger definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: LoggerDefinitionVersion? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct GetResourceDefinitionRequest: AWSEncodableShape {
        /// The ID of the resource definition.
        public let resourceDefinitionId: String

        @inlinable
        public init(resourceDefinitionId: String) {
            self.resourceDefinitionId = resourceDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceDefinitionId, key: "ResourceDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetResourceDefinitionVersionRequest: AWSEncodableShape {
        /// The ID of the resource definition.
        public let resourceDefinitionId: String
        /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let resourceDefinitionVersionId: String

        @inlinable
        public init(resourceDefinitionId: String, resourceDefinitionVersionId: String) {
            self.resourceDefinitionId = resourceDefinitionId
            self.resourceDefinitionVersionId = resourceDefinitionVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceDefinitionId, key: "ResourceDefinitionId")
            request.encodePath(self.resourceDefinitionVersionId, key: "ResourceDefinitionVersionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceDefinitionVersionResponse: AWSDecodableShape {
        /// Arn of the resource definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the resource definition version was created.
        public let creationTimestamp: String?
        /// Information about the definition.
        public let definition: ResourceDefinitionVersion?
        /// The ID of the resource definition version.
        public let id: String?
        /// The version of the resource definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: ResourceDefinitionVersion? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case version = "Version"
        }
    }

    public struct GetServiceRoleForAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetServiceRoleForAccountResponse: AWSDecodableShape {
        /// The time when the service role was associated with the account.
        public let associatedAt: String?
        /// The ARN of the role which is associated with the account.
        public let roleArn: String?

        @inlinable
        public init(associatedAt: String? = nil, roleArn: String? = nil) {
            self.associatedAt = associatedAt
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedAt = "AssociatedAt"
            case roleArn = "RoleArn"
        }
    }

    public struct GetSubscriptionDefinitionRequest: AWSEncodableShape {
        /// The ID of the subscription definition.
        public let subscriptionDefinitionId: String

        @inlinable
        public init(subscriptionDefinitionId: String) {
            self.subscriptionDefinitionId = subscriptionDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.subscriptionDefinitionId, key: "SubscriptionDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionDefinitionResponse: AWSDecodableShape {
        /// The ARN of the definition.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public let creationTimestamp: String?
        /// The ID of the definition.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the definition.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the definition.
        public let latestVersionArn: String?
        /// The name of the definition.
        public let name: String?
        /// Tag(s) attached to the resource arn.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
            case tags = "tags"
        }
    }

    public struct GetSubscriptionDefinitionVersionRequest: AWSEncodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The ID of the subscription definition.
        public let subscriptionDefinitionId: String
        /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
        public let subscriptionDefinitionVersionId: String

        @inlinable
        public init(nextToken: String? = nil, subscriptionDefinitionId: String, subscriptionDefinitionVersionId: String) {
            self.nextToken = nextToken
            self.subscriptionDefinitionId = subscriptionDefinitionId
            self.subscriptionDefinitionVersionId = subscriptionDefinitionVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.subscriptionDefinitionId, key: "SubscriptionDefinitionId")
            request.encodePath(self.subscriptionDefinitionVersionId, key: "SubscriptionDefinitionVersionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionDefinitionVersionResponse: AWSDecodableShape {
        /// The ARN of the subscription definition version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the subscription definition version was created.
        public let creationTimestamp: String?
        /// Information about the subscription definition version.
        public let definition: SubscriptionDefinitionVersion?
        /// The ID of the subscription definition version.
        public let id: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The version of the subscription definition version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, definition: SubscriptionDefinitionVersion? = nil, id: String? = nil, nextToken: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.definition = definition
            self.id = id
            self.nextToken = nextToken
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case definition = "Definition"
            case id = "Id"
            case nextToken = "NextToken"
            case version = "Version"
        }
    }

    public struct GetThingRuntimeConfigurationRequest: AWSEncodableShape {
        /// The thing name.
        public let thingName: String

        @inlinable
        public init(thingName: String) {
            self.thingName = thingName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.thingName, key: "ThingName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetThingRuntimeConfigurationResponse: AWSDecodableShape {
        /// Runtime configuration for a thing.
        public let runtimeConfiguration: RuntimeConfiguration?

        @inlinable
        public init(runtimeConfiguration: RuntimeConfiguration? = nil) {
            self.runtimeConfiguration = runtimeConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeConfiguration = "RuntimeConfiguration"
        }
    }

    public struct GroupCertificateAuthorityProperties: AWSDecodableShape {
        /// The ARN of the certificate authority for the group.
        public let groupCertificateAuthorityArn: String?
        /// The ID of the certificate authority for the group.
        public let groupCertificateAuthorityId: String?

        @inlinable
        public init(groupCertificateAuthorityArn: String? = nil, groupCertificateAuthorityId: String? = nil) {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = groupCertificateAuthorityId
        }

        private enum CodingKeys: String, CodingKey {
            case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
            case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
        }
    }

    public struct GroupInformation: AWSDecodableShape {
        /// The ARN of the group.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the group was created.
        public let creationTimestamp: String?
        /// The ID of the group.
        public let id: String?
        /// The time, in milliseconds since the epoch, when the group was last updated.
        public let lastUpdatedTimestamp: String?
        /// The ID of the latest version associated with the group.
        public let latestVersion: String?
        /// The ARN of the latest version associated with the group.
        public let latestVersionArn: String?
        /// The name of the group.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, lastUpdatedTimestamp: String? = nil, latestVersion: String? = nil, latestVersionArn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case latestVersion = "LatestVersion"
            case latestVersionArn = "LatestVersionArn"
            case name = "Name"
        }
    }

    public struct GroupOwnerSetting: AWSEncodableShape & AWSDecodableShape {
        /// If true, AWS IoT Greengrass automatically adds the specified Linux OS group owner of the resource to the Lambda process privileges. Thus the Lambda process will have the file access permissions of the added Linux group.
        public let autoAddGroupOwner: Bool?
        /// The name of the Linux OS group whose privileges will be added to the Lambda process. This field is optional.
        public let groupOwner: String?

        @inlinable
        public init(autoAddGroupOwner: Bool? = nil, groupOwner: String? = nil) {
            self.autoAddGroupOwner = autoAddGroupOwner
            self.groupOwner = groupOwner
        }

        private enum CodingKeys: String, CodingKey {
            case autoAddGroupOwner = "AutoAddGroupOwner"
            case groupOwner = "GroupOwner"
        }
    }

    public struct GroupVersion: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the connector definition version for this group.
        public let connectorDefinitionVersionArn: String?
        /// The ARN of the core definition version for this group.
        public let coreDefinitionVersionArn: String?
        /// The ARN of the device definition version for this group.
        public let deviceDefinitionVersionArn: String?
        /// The ARN of the function definition version for this group.
        public let functionDefinitionVersionArn: String?
        /// The ARN of the logger definition version for this group.
        public let loggerDefinitionVersionArn: String?
        /// The ARN of the resource definition version for this group.
        public let resourceDefinitionVersionArn: String?
        /// The ARN of the subscription definition version for this group.
        public let subscriptionDefinitionVersionArn: String?

        @inlinable
        public init(connectorDefinitionVersionArn: String? = nil, coreDefinitionVersionArn: String? = nil, deviceDefinitionVersionArn: String? = nil, functionDefinitionVersionArn: String? = nil, loggerDefinitionVersionArn: String? = nil, resourceDefinitionVersionArn: String? = nil, subscriptionDefinitionVersionArn: String? = nil) {
            self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
            self.coreDefinitionVersionArn = coreDefinitionVersionArn
            self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
            self.functionDefinitionVersionArn = functionDefinitionVersionArn
            self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
            self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
            self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
            case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
            case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
            case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
            case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
            case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
            case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
        }
    }

    public struct InternalServerErrorException: AWSErrorShape {
        /// Details about the error.
        public let errorDetails: [ErrorDetail]?
        /// A message containing information about the error.
        public let message: String?

        @inlinable
        public init(errorDetails: [ErrorDetail]? = nil, message: String? = nil) {
            self.errorDetails = errorDetails
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetails = "ErrorDetails"
            case message = "Message"
        }
    }

    public struct ListBulkDeploymentDetailedReportsRequest: AWSEncodableShape {
        /// The ID of the bulk deployment.
        public let bulkDeploymentId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(bulkDeploymentId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.bulkDeploymentId = bulkDeploymentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.bulkDeploymentId, key: "BulkDeploymentId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBulkDeploymentDetailedReportsResponse: AWSDecodableShape {
        /// A list of the individual group deployments in the bulk deployment operation.
        public let deployments: [BulkDeploymentResult]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(deployments: [BulkDeploymentResult]? = nil, nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments = "Deployments"
            case nextToken = "NextToken"
        }
    }

    public struct ListBulkDeploymentsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBulkDeploymentsResponse: AWSDecodableShape {
        /// A list of bulk deployments.
        public let bulkDeployments: [BulkDeployment]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(bulkDeployments: [BulkDeployment]? = nil, nextToken: String? = nil) {
            self.bulkDeployments = bulkDeployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case bulkDeployments = "BulkDeployments"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectorDefinitionVersionsRequest: AWSEncodableShape {
        /// The ID of the connector definition.
        public let connectorDefinitionId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(connectorDefinitionId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.connectorDefinitionId = connectorDefinitionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorDefinitionId, key: "ConnectorDefinitionId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectorDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListConnectorDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectorDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListCoreDefinitionVersionsRequest: AWSEncodableShape {
        /// The ID of the core definition.
        public let coreDefinitionId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(coreDefinitionId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.coreDefinitionId = coreDefinitionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreDefinitionId, key: "CoreDefinitionId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCoreDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListCoreDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCoreDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeploymentsRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(groupId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.groupId = groupId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeploymentsResponse: AWSDecodableShape {
        /// A list of deployments for the requested groups.
        public let deployments: [Deployment]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(deployments: [Deployment]? = nil, nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments = "Deployments"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeviceDefinitionVersionsRequest: AWSEncodableShape {
        /// The ID of the device definition.
        public let deviceDefinitionId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(deviceDefinitionId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.deviceDefinitionId = deviceDefinitionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceDefinitionId, key: "DeviceDefinitionId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeviceDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListDeviceDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeviceDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListFunctionDefinitionVersionsRequest: AWSEncodableShape {
        /// The ID of the Lambda function definition.
        public let functionDefinitionId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(functionDefinitionId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.functionDefinitionId = functionDefinitionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionDefinitionId, key: "FunctionDefinitionId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListFunctionDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListGroupCertificateAuthoritiesRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupCertificateAuthoritiesResponse: AWSDecodableShape {
        /// A list of certificate authorities associated with the group.
        public let groupCertificateAuthorities: [GroupCertificateAuthorityProperties]?

        @inlinable
        public init(groupCertificateAuthorities: [GroupCertificateAuthorityProperties]? = nil) {
            self.groupCertificateAuthorities = groupCertificateAuthorities
        }

        private enum CodingKeys: String, CodingKey {
            case groupCertificateAuthorities = "GroupCertificateAuthorities"
        }
    }

    public struct ListGroupVersionsRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(groupId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.groupId = groupId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        /// Information about a group.
        public let groups: [GroupInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(groups: [GroupInformation]? = nil, nextToken: String? = nil) {
            self.groups = groups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case nextToken = "NextToken"
        }
    }

    public struct ListLoggerDefinitionVersionsRequest: AWSEncodableShape {
        /// The ID of the logger definition.
        public let loggerDefinitionId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(loggerDefinitionId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.loggerDefinitionId = loggerDefinitionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.loggerDefinitionId, key: "LoggerDefinitionId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLoggerDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListLoggerDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLoggerDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListResourceDefinitionVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The ID of the resource definition.
        public let resourceDefinitionId: String

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil, resourceDefinitionId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceDefinitionId = resourceDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.resourceDefinitionId, key: "ResourceDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourceDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListResourceDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourceDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListSubscriptionDefinitionVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// The ID of the subscription definition.
        public let subscriptionDefinitionId: String

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil, subscriptionDefinitionId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.subscriptionDefinitionId = subscriptionDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.subscriptionDefinitionId, key: "SubscriptionDefinitionId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionDefinitionVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?
        /// Information about a version.
        public let versions: [VersionInformation]?

        @inlinable
        public init(nextToken: String? = nil, versions: [VersionInformation]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListSubscriptionDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned per request.
        public let maxResults: String?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionDefinitionsResponse: AWSDecodableShape {
        /// Information about a definition.
        public let definitions: [DefinitionInformation]?
        /// The token for the next set of results, or ''null'' if there are no additional results.
        public let nextToken: String?

        @inlinable
        public init(definitions: [DefinitionInformation]? = nil, nextToken: String? = nil) {
            self.definitions = definitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case definitions = "Definitions"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LocalDeviceResourceData: AWSEncodableShape & AWSDecodableShape {
        /// Group/owner related settings for local resources.
        public let groupOwnerSetting: GroupOwnerSetting?
        /// The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ''/dev''.
        public let sourcePath: String?

        @inlinable
        public init(groupOwnerSetting: GroupOwnerSetting? = nil, sourcePath: String? = nil) {
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }

        private enum CodingKeys: String, CodingKey {
            case groupOwnerSetting = "GroupOwnerSetting"
            case sourcePath = "SourcePath"
        }
    }

    public struct LocalVolumeResourceData: AWSEncodableShape & AWSDecodableShape {
        /// The absolute local path of the resource inside the Lambda environment.
        public let destinationPath: String?
        /// Allows you to configure additional group privileges for the Lambda process. This field is optional.
        public let groupOwnerSetting: GroupOwnerSetting?
        /// The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ''/sys''.
        public let sourcePath: String?

        @inlinable
        public init(destinationPath: String? = nil, groupOwnerSetting: GroupOwnerSetting? = nil, sourcePath: String? = nil) {
            self.destinationPath = destinationPath
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPath = "DestinationPath"
            case groupOwnerSetting = "GroupOwnerSetting"
            case sourcePath = "SourcePath"
        }
    }

    public struct Logger: AWSEncodableShape & AWSDecodableShape {
        /// The component that will be subject to logging.
        public let component: LoggerComponent?
        /// A descriptive or arbitrary ID for the logger. This value must be unique within the logger definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        public let id: String?
        /// The level of the logs.
        public let level: LoggerLevel?
        /// The amount of file space, in KB, to use if the local file system is used for logging purposes.
        public let space: Int?
        /// The type of log output which will be used.
        public let type: LoggerType?

        @inlinable
        public init(component: LoggerComponent? = nil, id: String? = nil, level: LoggerLevel? = nil, space: Int? = nil, type: LoggerType? = nil) {
            self.component = component
            self.id = id
            self.level = level
            self.space = space
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case component = "Component"
            case id = "Id"
            case level = "Level"
            case space = "Space"
            case type = "Type"
        }
    }

    public struct LoggerDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// A list of loggers.
        public let loggers: [Logger]?

        @inlinable
        public init(loggers: [Logger]? = nil) {
            self.loggers = loggers
        }

        private enum CodingKeys: String, CodingKey {
            case loggers = "Loggers"
        }
    }

    public struct ResetDeploymentsRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// If true, performs a best-effort only core reset.
        public let force: Bool?
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(amznClientToken: String? = nil, force: Bool? = nil, groupId: String) {
            self.amznClientToken = amznClientToken
            self.force = force
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.force, forKey: .force)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: String, CodingKey {
            case force = "Force"
        }
    }

    public struct ResetDeploymentsResponse: AWSDecodableShape {
        /// The ARN of the deployment.
        public let deploymentArn: String?
        /// The ID of the deployment.
        public let deploymentId: String?

        @inlinable
        public init(deploymentArn: String? = nil, deploymentId: String? = nil) {
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentArn = "DeploymentArn"
            case deploymentId = "DeploymentId"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// The resource ID, used to refer to a resource in the Lambda function configuration. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        public let id: String?
        /// The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Max length 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        public let name: String?
        /// A container of data for all resource types.
        public let resourceDataContainer: ResourceDataContainer?

        @inlinable
        public init(id: String? = nil, name: String? = nil, resourceDataContainer: ResourceDataContainer? = nil) {
            self.id = id
            self.name = name
            self.resourceDataContainer = resourceDataContainer
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
            case resourceDataContainer = "ResourceDataContainer"
        }
    }

    public struct ResourceAccessPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The permissions that the Lambda function has to the resource. Can be one of ''rw'' (read/write) or ''ro'' (read-only).
        public let permission: Permission?
        /// The ID of the resource. (This ID is assigned to the resource when you create the resource definiton.)
        public let resourceId: String?

        @inlinable
        public init(permission: Permission? = nil, resourceId: String? = nil) {
            self.permission = permission
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case permission = "Permission"
            case resourceId = "ResourceId"
        }
    }

    public struct ResourceDataContainer: AWSEncodableShape & AWSDecodableShape {
        /// Attributes that define the local device resource.
        public let localDeviceResourceData: LocalDeviceResourceData?
        /// Attributes that define the local volume resource.
        public let localVolumeResourceData: LocalVolumeResourceData?
        /// Attributes that define an Amazon S3 machine learning resource.
        public let s3MachineLearningModelResourceData: S3MachineLearningModelResourceData?
        /// Attributes that define an Amazon SageMaker machine learning resource.
        public let sageMakerMachineLearningModelResourceData: SageMakerMachineLearningModelResourceData?
        /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager.
        public let secretsManagerSecretResourceData: SecretsManagerSecretResourceData?

        @inlinable
        public init(localDeviceResourceData: LocalDeviceResourceData? = nil, localVolumeResourceData: LocalVolumeResourceData? = nil, s3MachineLearningModelResourceData: S3MachineLearningModelResourceData? = nil, sageMakerMachineLearningModelResourceData: SageMakerMachineLearningModelResourceData? = nil, secretsManagerSecretResourceData: SecretsManagerSecretResourceData? = nil) {
            self.localDeviceResourceData = localDeviceResourceData
            self.localVolumeResourceData = localVolumeResourceData
            self.s3MachineLearningModelResourceData = s3MachineLearningModelResourceData
            self.sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData
            self.secretsManagerSecretResourceData = secretsManagerSecretResourceData
        }

        private enum CodingKeys: String, CodingKey {
            case localDeviceResourceData = "LocalDeviceResourceData"
            case localVolumeResourceData = "LocalVolumeResourceData"
            case s3MachineLearningModelResourceData = "S3MachineLearningModelResourceData"
            case sageMakerMachineLearningModelResourceData = "SageMakerMachineLearningModelResourceData"
            case secretsManagerSecretResourceData = "SecretsManagerSecretResourceData"
        }
    }

    public struct ResourceDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// A list of resources.
        public let resources: [Resource]?

        @inlinable
        public init(resources: [Resource]? = nil) {
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "Resources"
        }
    }

    public struct ResourceDownloadOwnerSetting: AWSEncodableShape & AWSDecodableShape {
        /// The group owner of the resource. This is the name of an existing Linux OS group on the system or a GID. The group's permissions are added to the Lambda process.
        public let groupOwner: String?
        /// The permissions that the group owner has to the resource. Valid values are ''rw'' (read/write) or ''ro'' (read-only).
        public let groupPermission: Permission?

        @inlinable
        public init(groupOwner: String? = nil, groupPermission: Permission? = nil) {
            self.groupOwner = groupOwner
            self.groupPermission = groupPermission
        }

        private enum CodingKeys: String, CodingKey {
            case groupOwner = "GroupOwner"
            case groupPermission = "GroupPermission"
        }
    }

    public struct RuntimeConfiguration: AWSDecodableShape {
        /// Configuration for telemetry service.
        public let telemetryConfiguration: TelemetryConfiguration?

        @inlinable
        public init(telemetryConfiguration: TelemetryConfiguration? = nil) {
            self.telemetryConfiguration = telemetryConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case telemetryConfiguration = "TelemetryConfiguration"
        }
    }

    public struct S3MachineLearningModelResourceData: AWSEncodableShape & AWSDecodableShape {
        /// The absolute local path of the resource inside the Lambda environment.
        public let destinationPath: String?
        public let ownerSetting: ResourceDownloadOwnerSetting?
        /// The URI of the source model in an S3 bucket. The model package must be in tar.gz or .zip format.
        public let s3Uri: String?

        @inlinable
        public init(destinationPath: String? = nil, ownerSetting: ResourceDownloadOwnerSetting? = nil, s3Uri: String? = nil) {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPath = "DestinationPath"
            case ownerSetting = "OwnerSetting"
            case s3Uri = "S3Uri"
        }
    }

    public struct SageMakerMachineLearningModelResourceData: AWSEncodableShape & AWSDecodableShape {
        /// The absolute local path of the resource inside the Lambda environment.
        public let destinationPath: String?
        public let ownerSetting: ResourceDownloadOwnerSetting?
        /// The ARN of the Amazon SageMaker training job that represents the source model.
        public let sageMakerJobArn: String?

        @inlinable
        public init(destinationPath: String? = nil, ownerSetting: ResourceDownloadOwnerSetting? = nil, sageMakerJobArn: String? = nil) {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.sageMakerJobArn = sageMakerJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPath = "DestinationPath"
            case ownerSetting = "OwnerSetting"
            case sageMakerJobArn = "SageMakerJobArn"
        }
    }

    public struct SecretsManagerSecretResourceData: AWSEncodableShape & AWSDecodableShape {
        /// Optional. The staging labels whose values you want to make available on the core, in addition to ''AWSCURRENT''.
        public let additionalStagingLabelsToDownload: [String]?
        /// The ARN of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ''AWSCURRENT'' staging label) is included by default.
        public let arn: String?

        @inlinable
        public init(additionalStagingLabelsToDownload: [String]? = nil, arn: String? = nil) {
            self.additionalStagingLabelsToDownload = additionalStagingLabelsToDownload
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalStagingLabelsToDownload = "AdditionalStagingLabelsToDownload"
            case arn = "ARN"
        }
    }

    public struct StartBulkDeploymentRequest: AWSEncodableShape {
        /// A client token used to correlate requests and responses.
        public let amznClientToken: String?
        /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
        public let executionRoleArn: String?
        /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
        public let inputFileUri: String?
        /// Tag(s) to add to the new resource.
        public let tags: [String: String]?

        @inlinable
        public init(amznClientToken: String? = nil, executionRoleArn: String? = nil, inputFileUri: String? = nil, tags: [String: String]? = nil) {
            self.amznClientToken = amznClientToken
            self.executionRoleArn = executionRoleArn
            self.inputFileUri = inputFileUri
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.amznClientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.executionRoleArn, forKey: .executionRoleArn)
            try container.encodeIfPresent(self.inputFileUri, forKey: .inputFileUri)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case executionRoleArn = "ExecutionRoleArn"
            case inputFileUri = "InputFileUri"
            case tags = "tags"
        }
    }

    public struct StartBulkDeploymentResponse: AWSDecodableShape {
        /// The ARN of the bulk deployment.
        public let bulkDeploymentArn: String?
        /// The ID of the bulk deployment.
        public let bulkDeploymentId: String?

        @inlinable
        public init(bulkDeploymentArn: String? = nil, bulkDeploymentId: String? = nil) {
            self.bulkDeploymentArn = bulkDeploymentArn
            self.bulkDeploymentId = bulkDeploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case bulkDeploymentArn = "BulkDeploymentArn"
            case bulkDeploymentId = "BulkDeploymentId"
        }
    }

    public struct StopBulkDeploymentRequest: AWSEncodableShape {
        /// The ID of the bulk deployment.
        public let bulkDeploymentId: String

        @inlinable
        public init(bulkDeploymentId: String) {
            self.bulkDeploymentId = bulkDeploymentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.bulkDeploymentId, key: "BulkDeploymentId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopBulkDeploymentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Subscription: AWSEncodableShape & AWSDecodableShape {
        /// A descriptive or arbitrary ID for the subscription. This value must be unique within the subscription definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        public let id: String?
        /// The source of the subscription. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        public let source: String?
        /// The MQTT topic used to route the message.
        public let subject: String?
        /// Where the message is sent to. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        public let target: String?

        @inlinable
        public init(id: String? = nil, source: String? = nil, subject: String? = nil, target: String? = nil) {
            self.id = id
            self.source = source
            self.subject = subject
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case source = "Source"
            case subject = "Subject"
            case target = "Target"
        }
    }

    public struct SubscriptionDefinitionVersion: AWSEncodableShape & AWSDecodableShape {
        /// A list of subscriptions.
        public let subscriptions: [Subscription]?

        @inlinable
        public init(subscriptions: [Subscription]? = nil) {
            self.subscriptions = subscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptions = "Subscriptions"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TelemetryConfiguration: AWSDecodableShape {
        /// Synchronization status of the device reported configuration with the desired configuration.
        public let configurationSyncStatus: ConfigurationSyncStatus?
        /// Configure telemetry to be on or off.
        public let telemetry: Telemetry?

        @inlinable
        public init(configurationSyncStatus: ConfigurationSyncStatus? = nil, telemetry: Telemetry? = nil) {
            self.configurationSyncStatus = configurationSyncStatus
            self.telemetry = telemetry
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSyncStatus = "ConfigurationSyncStatus"
            case telemetry = "Telemetry"
        }
    }

    public struct TelemetryConfigurationUpdate: AWSEncodableShape {
        /// Configure telemetry to be on or off.
        public let telemetry: Telemetry?

        @inlinable
        public init(telemetry: Telemetry? = nil) {
            self.telemetry = telemetry
        }

        private enum CodingKeys: String, CodingKey {
            case telemetry = "Telemetry"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of tag keys to delete
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateConnectivityInfoRequest: AWSEncodableShape {
        /// A list of connectivity info.
        public let connectivityInfo: [ConnectivityInfo]?
        /// The thing name.
        public let thingName: String

        @inlinable
        public init(connectivityInfo: [ConnectivityInfo]? = nil, thingName: String) {
            self.connectivityInfo = connectivityInfo
            self.thingName = thingName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectivityInfo, forKey: .connectivityInfo)
            request.encodePath(self.thingName, key: "ThingName")
        }

        private enum CodingKeys: String, CodingKey {
            case connectivityInfo = "ConnectivityInfo"
        }
    }

    public struct UpdateConnectivityInfoResponse: AWSDecodableShape {
        /// A message about the connectivity info update request.
        public let message: String?
        /// The new version of the connectivity info.
        public let version: String?

        @inlinable
        public init(message: String? = nil, version: String? = nil) {
            self.message = message
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case version = "Version"
        }
    }

    public struct UpdateConnectorDefinitionRequest: AWSEncodableShape {
        /// The ID of the connector definition.
        public let connectorDefinitionId: String
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(connectorDefinitionId: String, name: String? = nil) {
            self.connectorDefinitionId = connectorDefinitionId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectorDefinitionId, key: "ConnectorDefinitionId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateConnectorDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCoreDefinitionRequest: AWSEncodableShape {
        /// The ID of the core definition.
        public let coreDefinitionId: String
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(coreDefinitionId: String, name: String? = nil) {
            self.coreDefinitionId = coreDefinitionId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreDefinitionId, key: "CoreDefinitionId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateCoreDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeviceDefinitionRequest: AWSEncodableShape {
        /// The ID of the device definition.
        public let deviceDefinitionId: String
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(deviceDefinitionId: String, name: String? = nil) {
            self.deviceDefinitionId = deviceDefinitionId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceDefinitionId, key: "DeviceDefinitionId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateDeviceDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFunctionDefinitionRequest: AWSEncodableShape {
        /// The ID of the Lambda function definition.
        public let functionDefinitionId: String
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(functionDefinitionId: String, name: String? = nil) {
            self.functionDefinitionId = functionDefinitionId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.functionDefinitionId, key: "FunctionDefinitionId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateFunctionDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGroupCertificateConfigurationRequest: AWSEncodableShape {
        /// The amount of time remaining before the certificate expires, in milliseconds.
        public let certificateExpiryInMilliseconds: String?
        /// The ID of the Greengrass group.
        public let groupId: String

        @inlinable
        public init(certificateExpiryInMilliseconds: String? = nil, groupId: String) {
            self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
            self.groupId = groupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.certificateExpiryInMilliseconds, forKey: .certificateExpiryInMilliseconds)
            request.encodePath(self.groupId, key: "GroupId")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        }
    }

    public struct UpdateGroupCertificateConfigurationResponse: AWSDecodableShape {
        /// The amount of time remaining before the certificate authority expires, in milliseconds.
        public let certificateAuthorityExpiryInMilliseconds: String?
        /// The amount of time remaining before the certificate expires, in milliseconds.
        public let certificateExpiryInMilliseconds: String?
        /// The ID of the group certificate configuration.
        public let groupId: String?

        @inlinable
        public init(certificateAuthorityExpiryInMilliseconds: String? = nil, certificateExpiryInMilliseconds: String? = nil, groupId: String? = nil) {
            self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
            case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
            case groupId = "GroupId"
        }
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        /// The ID of the Greengrass group.
        public let groupId: String
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(groupId: String, name: String? = nil) {
            self.groupId = groupId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.groupId, key: "GroupId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLoggerDefinitionRequest: AWSEncodableShape {
        /// The ID of the logger definition.
        public let loggerDefinitionId: String
        /// The name of the definition.
        public let name: String?

        @inlinable
        public init(loggerDefinitionId: String, name: String? = nil) {
            self.loggerDefinitionId = loggerDefinitionId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.loggerDefinitionId, key: "LoggerDefinitionId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateLoggerDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResourceDefinitionRequest: AWSEncodableShape {
        /// The name of the definition.
        public let name: String?
        /// The ID of the resource definition.
        public let resourceDefinitionId: String

        @inlinable
        public init(name: String? = nil, resourceDefinitionId: String) {
            self.name = name
            self.resourceDefinitionId = resourceDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.resourceDefinitionId, key: "ResourceDefinitionId")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateResourceDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSubscriptionDefinitionRequest: AWSEncodableShape {
        /// The name of the definition.
        public let name: String?
        /// The ID of the subscription definition.
        public let subscriptionDefinitionId: String

        @inlinable
        public init(name: String? = nil, subscriptionDefinitionId: String) {
            self.name = name
            self.subscriptionDefinitionId = subscriptionDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.subscriptionDefinitionId, key: "SubscriptionDefinitionId")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateSubscriptionDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateThingRuntimeConfigurationRequest: AWSEncodableShape {
        /// Configuration for telemetry service.
        public let telemetryConfiguration: TelemetryConfigurationUpdate?
        /// The thing name.
        public let thingName: String

        @inlinable
        public init(telemetryConfiguration: TelemetryConfigurationUpdate? = nil, thingName: String) {
            self.telemetryConfiguration = telemetryConfiguration
            self.thingName = thingName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.telemetryConfiguration, forKey: .telemetryConfiguration)
            request.encodePath(self.thingName, key: "ThingName")
        }

        private enum CodingKeys: String, CodingKey {
            case telemetryConfiguration = "TelemetryConfiguration"
        }
    }

    public struct UpdateThingRuntimeConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct VersionInformation: AWSDecodableShape {
        /// The ARN of the version.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public let creationTimestamp: String?
        /// The ID of the parent definition that the version is associated with.
        public let id: String?
        /// The ID of the version.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTimestamp: String? = nil, id: String? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTimestamp = "CreationTimestamp"
            case id = "Id"
            case version = "Version"
        }
    }
}

// MARK: - Errors

/// Error enum for Greengrass
public struct GreengrassErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case internalServerErrorException = "InternalServerErrorException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Greengrass
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// General error information.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// General error information.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
}

extension GreengrassErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "BadRequestException": Greengrass.BadRequestException.self,
        "InternalServerErrorException": Greengrass.InternalServerErrorException.self
    ]
}

extension GreengrassErrorType: Equatable {
    public static func == (lhs: GreengrassErrorType, rhs: GreengrassErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GreengrassErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
