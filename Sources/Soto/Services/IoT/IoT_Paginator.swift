//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension IoT {
    ///   Returns a Device Defender's ML Detect Security Profile training model's status.  Requires permission to access the GetBehaviorModelTrainingSummaries action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getBehaviorModelTrainingSummariesPaginator<Result>(
        _ input: GetBehaviorModelTrainingSummariesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetBehaviorModelTrainingSummariesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getBehaviorModelTrainingSummaries,
            inputKey: \GetBehaviorModelTrainingSummariesRequest.nextToken,
            outputKey: \GetBehaviorModelTrainingSummariesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getBehaviorModelTrainingSummariesPaginator(
        _ input: GetBehaviorModelTrainingSummariesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetBehaviorModelTrainingSummariesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getBehaviorModelTrainingSummaries,
            inputKey: \GetBehaviorModelTrainingSummariesRequest.nextToken,
            outputKey: \GetBehaviorModelTrainingSummariesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the active violations for a given Device Defender security profile. Requires permission to access the ListActiveViolations action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listActiveViolationsPaginator<Result>(
        _ input: ListActiveViolationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListActiveViolationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listActiveViolations,
            inputKey: \ListActiveViolationsRequest.nextToken,
            outputKey: \ListActiveViolationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listActiveViolationsPaginator(
        _ input: ListActiveViolationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListActiveViolationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listActiveViolations,
            inputKey: \ListActiveViolationsRequest.nextToken,
            outputKey: \ListActiveViolationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the policies attached to the specified thing group. Requires permission to access the ListAttachedPolicies action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAttachedPoliciesPaginator<Result>(
        _ input: ListAttachedPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAttachedPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAttachedPolicies,
            inputKey: \ListAttachedPoliciesRequest.marker,
            outputKey: \ListAttachedPoliciesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAttachedPoliciesPaginator(
        _ input: ListAttachedPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAttachedPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAttachedPolicies,
            inputKey: \ListAttachedPoliciesRequest.marker,
            outputKey: \ListAttachedPoliciesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 90 days.)  Requires permission to access the ListAuditFindings action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAuditFindingsPaginator<Result>(
        _ input: ListAuditFindingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAuditFindingsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAuditFindings,
            inputKey: \ListAuditFindingsRequest.nextToken,
            outputKey: \ListAuditFindingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAuditFindingsPaginator(
        _ input: ListAuditFindingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAuditFindingsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAuditFindings,
            inputKey: \ListAuditFindingsRequest.nextToken,
            outputKey: \ListAuditFindingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets the status of audit mitigation action tasks that were executed. Requires permission to access the ListAuditMitigationActionsExecutions action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAuditMitigationActionsExecutionsPaginator<Result>(
        _ input: ListAuditMitigationActionsExecutionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAuditMitigationActionsExecutionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAuditMitigationActionsExecutions,
            inputKey: \ListAuditMitigationActionsExecutionsRequest.nextToken,
            outputKey: \ListAuditMitigationActionsExecutionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAuditMitigationActionsExecutionsPaginator(
        _ input: ListAuditMitigationActionsExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAuditMitigationActionsExecutionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAuditMitigationActionsExecutions,
            inputKey: \ListAuditMitigationActionsExecutionsRequest.nextToken,
            outputKey: \ListAuditMitigationActionsExecutionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets a list of audit mitigation action tasks that match the specified filters. Requires permission to access the ListAuditMitigationActionsTasks action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAuditMitigationActionsTasksPaginator<Result>(
        _ input: ListAuditMitigationActionsTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAuditMitigationActionsTasksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAuditMitigationActionsTasks,
            inputKey: \ListAuditMitigationActionsTasksRequest.nextToken,
            outputKey: \ListAuditMitigationActionsTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAuditMitigationActionsTasksPaginator(
        _ input: ListAuditMitigationActionsTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAuditMitigationActionsTasksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAuditMitigationActionsTasks,
            inputKey: \ListAuditMitigationActionsTasksRequest.nextToken,
            outputKey: \ListAuditMitigationActionsTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Lists your Device Defender audit listings.  Requires permission to access the ListAuditSuppressions action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAuditSuppressionsPaginator<Result>(
        _ input: ListAuditSuppressionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAuditSuppressionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAuditSuppressions,
            inputKey: \ListAuditSuppressionsRequest.nextToken,
            outputKey: \ListAuditSuppressionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAuditSuppressionsPaginator(
        _ input: ListAuditSuppressionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAuditSuppressionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAuditSuppressions,
            inputKey: \ListAuditSuppressionsRequest.nextToken,
            outputKey: \ListAuditSuppressionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the Device Defender audits that have been performed during a given time period. Requires permission to access the ListAuditTasks action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAuditTasksPaginator<Result>(
        _ input: ListAuditTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAuditTasksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAuditTasks,
            inputKey: \ListAuditTasksRequest.nextToken,
            outputKey: \ListAuditTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAuditTasksPaginator(
        _ input: ListAuditTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAuditTasksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAuditTasks,
            inputKey: \ListAuditTasksRequest.nextToken,
            outputKey: \ListAuditTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the authorizers registered in your account. Requires permission to access the ListAuthorizers action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAuthorizersPaginator<Result>(
        _ input: ListAuthorizersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAuthorizersResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAuthorizers,
            inputKey: \ListAuthorizersRequest.marker,
            outputKey: \ListAuthorizersResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAuthorizersPaginator(
        _ input: ListAuthorizersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAuthorizersResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAuthorizers,
            inputKey: \ListAuthorizersRequest.marker,
            outputKey: \ListAuthorizersResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the billing groups you have created.
    ///  		       Requires permission to access the ListBillingGroups action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listBillingGroupsPaginator<Result>(
        _ input: ListBillingGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListBillingGroupsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listBillingGroups,
            inputKey: \ListBillingGroupsRequest.nextToken,
            outputKey: \ListBillingGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listBillingGroupsPaginator(
        _ input: ListBillingGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListBillingGroupsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listBillingGroups,
            inputKey: \ListBillingGroupsRequest.nextToken,
            outputKey: \ListBillingGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the CA certificates registered for your Amazon Web Services account. The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results. Requires permission to access the ListCACertificates action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCACertificatesPaginator<Result>(
        _ input: ListCACertificatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCACertificatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listCACertificates,
            inputKey: \ListCACertificatesRequest.marker,
            outputKey: \ListCACertificatesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCACertificatesPaginator(
        _ input: ListCACertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCACertificatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listCACertificates,
            inputKey: \ListCACertificatesRequest.marker,
            outputKey: \ListCACertificatesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the certificates registered in your Amazon Web Services account. The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results. Requires permission to access the ListCertificates action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCertificatesPaginator<Result>(
        _ input: ListCertificatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCertificatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listCertificates,
            inputKey: \ListCertificatesRequest.marker,
            outputKey: \ListCertificatesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCertificatesPaginator(
        _ input: ListCertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCertificatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listCertificates,
            inputKey: \ListCertificatesRequest.marker,
            outputKey: \ListCertificatesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List the device certificates signed by the specified CA certificate. Requires permission to access the ListCertificatesByCA action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCertificatesByCAPaginator<Result>(
        _ input: ListCertificatesByCARequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCertificatesByCAResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listCertificatesByCA,
            inputKey: \ListCertificatesByCARequest.marker,
            outputKey: \ListCertificatesByCAResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCertificatesByCAPaginator(
        _ input: ListCertificatesByCARequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCertificatesByCAResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listCertificatesByCA,
            inputKey: \ListCertificatesByCARequest.marker,
            outputKey: \ListCertificatesByCAResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Lists your Device Defender detect custom metrics.  Requires permission to access the ListCustomMetrics action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listCustomMetricsPaginator<Result>(
        _ input: ListCustomMetricsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListCustomMetricsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listCustomMetrics,
            inputKey: \ListCustomMetricsRequest.nextToken,
            outputKey: \ListCustomMetricsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listCustomMetricsPaginator(
        _ input: ListCustomMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListCustomMetricsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listCustomMetrics,
            inputKey: \ListCustomMetricsRequest.nextToken,
            outputKey: \ListCustomMetricsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   Lists mitigation actions executions for a Device Defender ML Detect Security Profile.  Requires permission to access the ListDetectMitigationActionsExecutions action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDetectMitigationActionsExecutionsPaginator<Result>(
        _ input: ListDetectMitigationActionsExecutionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDetectMitigationActionsExecutionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDetectMitigationActionsExecutions,
            inputKey: \ListDetectMitigationActionsExecutionsRequest.nextToken,
            outputKey: \ListDetectMitigationActionsExecutionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDetectMitigationActionsExecutionsPaginator(
        _ input: ListDetectMitigationActionsExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDetectMitigationActionsExecutionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDetectMitigationActionsExecutions,
            inputKey: \ListDetectMitigationActionsExecutionsRequest.nextToken,
            outputKey: \ListDetectMitigationActionsExecutionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///   List of Device Defender ML Detect mitigation actions tasks.  Requires permission to access the ListDetectMitigationActionsTasks action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDetectMitigationActionsTasksPaginator<Result>(
        _ input: ListDetectMitigationActionsTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDetectMitigationActionsTasksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDetectMitigationActionsTasks,
            inputKey: \ListDetectMitigationActionsTasksRequest.nextToken,
            outputKey: \ListDetectMitigationActionsTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDetectMitigationActionsTasksPaginator(
        _ input: ListDetectMitigationActionsTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDetectMitigationActionsTasksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDetectMitigationActionsTasks,
            inputKey: \ListDetectMitigationActionsTasksRequest.nextToken,
            outputKey: \ListDetectMitigationActionsTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List the set of dimensions that are defined for your Amazon Web Services accounts. Requires permission to access the ListDimensions action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDimensionsPaginator<Result>(
        _ input: ListDimensionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDimensionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDimensions,
            inputKey: \ListDimensionsRequest.nextToken,
            outputKey: \ListDimensionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDimensionsPaginator(
        _ input: ListDimensionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDimensionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDimensions,
            inputKey: \ListDimensionsRequest.nextToken,
            outputKey: \ListDimensionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name. Requires permission to access the ListDomainConfigurations action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listDomainConfigurationsPaginator<Result>(
        _ input: ListDomainConfigurationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListDomainConfigurationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listDomainConfigurations,
            inputKey: \ListDomainConfigurationsRequest.marker,
            outputKey: \ListDomainConfigurationsResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listDomainConfigurationsPaginator(
        _ input: ListDomainConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListDomainConfigurationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listDomainConfigurations,
            inputKey: \ListDomainConfigurationsRequest.marker,
            outputKey: \ListDomainConfigurationsResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all your fleet metrics.  Requires permission to access the ListFleetMetrics action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listFleetMetricsPaginator<Result>(
        _ input: ListFleetMetricsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListFleetMetricsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listFleetMetrics,
            inputKey: \ListFleetMetricsRequest.nextToken,
            outputKey: \ListFleetMetricsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listFleetMetricsPaginator(
        _ input: ListFleetMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListFleetMetricsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listFleetMetrics,
            inputKey: \ListFleetMetricsRequest.nextToken,
            outputKey: \ListFleetMetricsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the search indices. Requires permission to access the ListIndices action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listIndicesPaginator<Result>(
        _ input: ListIndicesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListIndicesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listIndicesPaginator(
        _ input: ListIndicesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListIndicesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the job executions for a job. Requires permission to access the ListJobExecutionsForJob action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listJobExecutionsForJobPaginator<Result>(
        _ input: ListJobExecutionsForJobRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListJobExecutionsForJobResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listJobExecutionsForJob,
            inputKey: \ListJobExecutionsForJobRequest.nextToken,
            outputKey: \ListJobExecutionsForJobResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listJobExecutionsForJobPaginator(
        _ input: ListJobExecutionsForJobRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListJobExecutionsForJobResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listJobExecutionsForJob,
            inputKey: \ListJobExecutionsForJobRequest.nextToken,
            outputKey: \ListJobExecutionsForJobResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the job executions for the specified thing. Requires permission to access the ListJobExecutionsForThing action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listJobExecutionsForThingPaginator<Result>(
        _ input: ListJobExecutionsForThingRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListJobExecutionsForThingResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listJobExecutionsForThing,
            inputKey: \ListJobExecutionsForThingRequest.nextToken,
            outputKey: \ListJobExecutionsForThingResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listJobExecutionsForThingPaginator(
        _ input: ListJobExecutionsForThingRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListJobExecutionsForThingResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listJobExecutionsForThing,
            inputKey: \ListJobExecutionsForThingRequest.nextToken,
            outputKey: \ListJobExecutionsForThingResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of job templates. Requires permission to access the ListJobTemplates action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listJobTemplatesPaginator<Result>(
        _ input: ListJobTemplatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListJobTemplatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listJobTemplates,
            inputKey: \ListJobTemplatesRequest.nextToken,
            outputKey: \ListJobTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listJobTemplatesPaginator(
        _ input: ListJobTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListJobTemplatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listJobTemplates,
            inputKey: \ListJobTemplatesRequest.nextToken,
            outputKey: \ListJobTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists jobs. Requires permission to access the ListJobs action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listJobsPaginator<Result>(
        _ input: ListJobsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListJobsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listJobsPaginator(
        _ input: ListJobsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListJobsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets a list of all mitigation actions that match the specified filter criteria. Requires permission to access the ListMitigationActions action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMitigationActionsPaginator<Result>(
        _ input: ListMitigationActionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMitigationActionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listMitigationActions,
            inputKey: \ListMitigationActionsRequest.nextToken,
            outputKey: \ListMitigationActionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMitigationActionsPaginator(
        _ input: ListMitigationActionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMitigationActionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listMitigationActions,
            inputKey: \ListMitigationActionsRequest.nextToken,
            outputKey: \ListMitigationActionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists OTA updates. Requires permission to access the ListOTAUpdates action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOTAUpdatesPaginator<Result>(
        _ input: ListOTAUpdatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOTAUpdatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOTAUpdates,
            inputKey: \ListOTAUpdatesRequest.nextToken,
            outputKey: \ListOTAUpdatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOTAUpdatesPaginator(
        _ input: ListOTAUpdatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOTAUpdatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOTAUpdates,
            inputKey: \ListOTAUpdatesRequest.nextToken,
            outputKey: \ListOTAUpdatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists certificates that are being transferred but not yet accepted. Requires permission to access the ListOutgoingCertificates action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOutgoingCertificatesPaginator<Result>(
        _ input: ListOutgoingCertificatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOutgoingCertificatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOutgoingCertificates,
            inputKey: \ListOutgoingCertificatesRequest.marker,
            outputKey: \ListOutgoingCertificatesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOutgoingCertificatesPaginator(
        _ input: ListOutgoingCertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOutgoingCertificatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOutgoingCertificates,
            inputKey: \ListOutgoingCertificatesRequest.marker,
            outputKey: \ListOutgoingCertificatesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists your policies. Requires permission to access the ListPolicies action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPoliciesPaginator<Result>(
        _ input: ListPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPolicies,
            inputKey: \ListPoliciesRequest.marker,
            outputKey: \ListPoliciesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPoliciesPaginator(
        _ input: ListPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPolicies,
            inputKey: \ListPoliciesRequest.marker,
            outputKey: \ListPoliciesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the principals associated with the specified policy.  Note: This action is deprecated. Please use ListTargetsForPolicy instead. Requires permission to access the ListPolicyPrincipals action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPolicyPrincipalsPaginator<Result>(
        _ input: ListPolicyPrincipalsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPolicyPrincipalsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPolicyPrincipals,
            inputKey: \ListPolicyPrincipalsRequest.marker,
            outputKey: \ListPolicyPrincipalsResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPolicyPrincipalsPaginator(
        _ input: ListPolicyPrincipalsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPolicyPrincipalsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPolicyPrincipals,
            inputKey: \ListPolicyPrincipalsRequest.marker,
            outputKey: \ListPolicyPrincipalsResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in AmazonCognito Identity format.  Note: This action is deprecated. Please use ListAttachedPolicies instead. Requires permission to access the ListPrincipalPolicies action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPrincipalPoliciesPaginator<Result>(
        _ input: ListPrincipalPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPrincipalPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPrincipalPolicies,
            inputKey: \ListPrincipalPoliciesRequest.marker,
            outputKey: \ListPrincipalPoliciesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPrincipalPoliciesPaginator(
        _ input: ListPrincipalPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPrincipalPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPrincipalPolicies,
            inputKey: \ListPrincipalPoliciesRequest.marker,
            outputKey: \ListPrincipalPoliciesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the things associated with the specified principal. A principal can be X.509
    ///  			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    ///  			identities.
    ///  		       Requires permission to access the ListPrincipalThings action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPrincipalThingsPaginator<Result>(
        _ input: ListPrincipalThingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPrincipalThingsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPrincipalThings,
            inputKey: \ListPrincipalThingsRequest.nextToken,
            outputKey: \ListPrincipalThingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPrincipalThingsPaginator(
        _ input: ListPrincipalThingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPrincipalThingsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPrincipalThings,
            inputKey: \ListPrincipalThingsRequest.nextToken,
            outputKey: \ListPrincipalThingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  A list of fleet provisioning template versions. Requires permission to access the ListProvisioningTemplateVersions action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProvisioningTemplateVersionsPaginator<Result>(
        _ input: ListProvisioningTemplateVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProvisioningTemplateVersionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listProvisioningTemplateVersions,
            inputKey: \ListProvisioningTemplateVersionsRequest.nextToken,
            outputKey: \ListProvisioningTemplateVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProvisioningTemplateVersionsPaginator(
        _ input: ListProvisioningTemplateVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProvisioningTemplateVersionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listProvisioningTemplateVersions,
            inputKey: \ListProvisioningTemplateVersionsRequest.nextToken,
            outputKey: \ListProvisioningTemplateVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the fleet provisioning templates in your Amazon Web Services account. Requires permission to access the ListProvisioningTemplates action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProvisioningTemplatesPaginator<Result>(
        _ input: ListProvisioningTemplatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProvisioningTemplatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listProvisioningTemplates,
            inputKey: \ListProvisioningTemplatesRequest.nextToken,
            outputKey: \ListProvisioningTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProvisioningTemplatesPaginator(
        _ input: ListProvisioningTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProvisioningTemplatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listProvisioningTemplates,
            inputKey: \ListProvisioningTemplatesRequest.nextToken,
            outputKey: \ListProvisioningTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the role aliases registered in your account. Requires permission to access the ListRoleAliases action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listRoleAliasesPaginator<Result>(
        _ input: ListRoleAliasesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListRoleAliasesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listRoleAliases,
            inputKey: \ListRoleAliasesRequest.marker,
            outputKey: \ListRoleAliasesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listRoleAliasesPaginator(
        _ input: ListRoleAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListRoleAliasesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listRoleAliases,
            inputKey: \ListRoleAliasesRequest.marker,
            outputKey: \ListRoleAliasesResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all of your scheduled audits. Requires permission to access the ListScheduledAudits action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listScheduledAuditsPaginator<Result>(
        _ input: ListScheduledAuditsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListScheduledAuditsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listScheduledAudits,
            inputKey: \ListScheduledAuditsRequest.nextToken,
            outputKey: \ListScheduledAuditsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listScheduledAuditsPaginator(
        _ input: ListScheduledAuditsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListScheduledAuditsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listScheduledAudits,
            inputKey: \ListScheduledAuditsRequest.nextToken,
            outputKey: \ListScheduledAuditsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the Device Defender security profiles you've created. You can filter security profiles by dimension or custom metric. Requires permission to access the ListSecurityProfiles action.   dimensionName and metricName cannot be used in the same request.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSecurityProfilesPaginator<Result>(
        _ input: ListSecurityProfilesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSecurityProfilesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listSecurityProfiles,
            inputKey: \ListSecurityProfilesRequest.nextToken,
            outputKey: \ListSecurityProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSecurityProfilesPaginator(
        _ input: ListSecurityProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSecurityProfilesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listSecurityProfiles,
            inputKey: \ListSecurityProfilesRequest.nextToken,
            outputKey: \ListSecurityProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the Device Defender security profiles attached to a target (thing group).  Requires permission to access the ListSecurityProfilesForTarget action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSecurityProfilesForTargetPaginator<Result>(
        _ input: ListSecurityProfilesForTargetRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSecurityProfilesForTargetResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listSecurityProfilesForTarget,
            inputKey: \ListSecurityProfilesForTargetRequest.nextToken,
            outputKey: \ListSecurityProfilesForTargetResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSecurityProfilesForTargetPaginator(
        _ input: ListSecurityProfilesForTargetRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSecurityProfilesForTargetResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listSecurityProfilesForTarget,
            inputKey: \ListSecurityProfilesForTargetRequest.nextToken,
            outputKey: \ListSecurityProfilesForTargetResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all of the streams in your Amazon Web Services account.
    ///  		       Requires permission to access the ListStreams action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listStreamsPaginator<Result>(
        _ input: ListStreamsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListStreamsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listStreams,
            inputKey: \ListStreamsRequest.nextToken,
            outputKey: \ListStreamsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listStreamsPaginator(
        _ input: ListStreamsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListStreamsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listStreams,
            inputKey: \ListStreamsRequest.nextToken,
            outputKey: \ListStreamsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the tags (metadata) you have assigned to the resource.
    ///  		       Requires permission to access the ListTagsForResource action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTagsForResourcePaginator<Result>(
        _ input: ListTagsForResourceRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTagsForResourceResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTagsForResource,
            inputKey: \ListTagsForResourceRequest.nextToken,
            outputKey: \ListTagsForResourceResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTagsForResourcePaginator(
        _ input: ListTagsForResourceRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTagsForResourceResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTagsForResource,
            inputKey: \ListTagsForResourceRequest.nextToken,
            outputKey: \ListTagsForResourceResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List targets for the specified policy. Requires permission to access the ListTargetsForPolicy action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTargetsForPolicyPaginator<Result>(
        _ input: ListTargetsForPolicyRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTargetsForPolicyResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTargetsForPolicy,
            inputKey: \ListTargetsForPolicyRequest.marker,
            outputKey: \ListTargetsForPolicyResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTargetsForPolicyPaginator(
        _ input: ListTargetsForPolicyRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTargetsForPolicyResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTargetsForPolicy,
            inputKey: \ListTargetsForPolicyRequest.marker,
            outputKey: \ListTargetsForPolicyResponse.nextMarker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the targets (thing groups) associated with a given Device Defender security profile. Requires permission to access the ListTargetsForSecurityProfile action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTargetsForSecurityProfilePaginator<Result>(
        _ input: ListTargetsForSecurityProfileRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTargetsForSecurityProfileResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTargetsForSecurityProfile,
            inputKey: \ListTargetsForSecurityProfileRequest.nextToken,
            outputKey: \ListTargetsForSecurityProfileResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTargetsForSecurityProfilePaginator(
        _ input: ListTargetsForSecurityProfileRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTargetsForSecurityProfileResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTargetsForSecurityProfile,
            inputKey: \ListTargetsForSecurityProfileRequest.nextToken,
            outputKey: \ListTargetsForSecurityProfileResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List the thing groups in your account.
    ///  		       Requires permission to access the ListThingGroups action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingGroupsPaginator<Result>(
        _ input: ListThingGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingGroupsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingGroups,
            inputKey: \ListThingGroupsRequest.nextToken,
            outputKey: \ListThingGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingGroupsPaginator(
        _ input: ListThingGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingGroupsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingGroups,
            inputKey: \ListThingGroupsRequest.nextToken,
            outputKey: \ListThingGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List the thing groups to which the specified thing belongs.
    ///  		       Requires permission to access the ListThingGroupsForThing action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingGroupsForThingPaginator<Result>(
        _ input: ListThingGroupsForThingRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingGroupsForThingResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingGroupsForThing,
            inputKey: \ListThingGroupsForThingRequest.nextToken,
            outputKey: \ListThingGroupsForThingResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingGroupsForThingPaginator(
        _ input: ListThingGroupsForThingRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingGroupsForThingResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingGroupsForThing,
            inputKey: \ListThingGroupsForThingRequest.nextToken,
            outputKey: \ListThingGroupsForThingResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the principals associated with the specified thing. A principal can be X.509
    ///  			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    ///  			identities.
    ///  		       Requires permission to access the ListThingPrincipals action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingPrincipalsPaginator<Result>(
        _ input: ListThingPrincipalsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingPrincipalsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingPrincipals,
            inputKey: \ListThingPrincipalsRequest.nextToken,
            outputKey: \ListThingPrincipalsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingPrincipalsPaginator(
        _ input: ListThingPrincipalsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingPrincipalsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingPrincipals,
            inputKey: \ListThingPrincipalsRequest.nextToken,
            outputKey: \ListThingPrincipalsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Information about the thing registration tasks.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingRegistrationTaskReportsPaginator<Result>(
        _ input: ListThingRegistrationTaskReportsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingRegistrationTaskReportsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingRegistrationTaskReports,
            inputKey: \ListThingRegistrationTaskReportsRequest.nextToken,
            outputKey: \ListThingRegistrationTaskReportsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingRegistrationTaskReportsPaginator(
        _ input: ListThingRegistrationTaskReportsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingRegistrationTaskReportsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingRegistrationTaskReports,
            inputKey: \ListThingRegistrationTaskReportsRequest.nextToken,
            outputKey: \ListThingRegistrationTaskReportsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List bulk thing provisioning tasks.
    ///  		       Requires permission to access the ListThingRegistrationTasks action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingRegistrationTasksPaginator<Result>(
        _ input: ListThingRegistrationTasksRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingRegistrationTasksResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingRegistrationTasks,
            inputKey: \ListThingRegistrationTasksRequest.nextToken,
            outputKey: \ListThingRegistrationTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingRegistrationTasksPaginator(
        _ input: ListThingRegistrationTasksRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingRegistrationTasksResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingRegistrationTasks,
            inputKey: \ListThingRegistrationTasksRequest.nextToken,
            outputKey: \ListThingRegistrationTasksResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the existing thing types.
    ///  		       Requires permission to access the ListThingTypes action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingTypesPaginator<Result>(
        _ input: ListThingTypesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingTypesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingTypes,
            inputKey: \ListThingTypesRequest.nextToken,
            outputKey: \ListThingTypesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingTypesPaginator(
        _ input: ListThingTypesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingTypesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingTypes,
            inputKey: \ListThingTypesRequest.nextToken,
            outputKey: \ListThingTypesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists your things. Use the attributeName and
    ///  				attributeValue parameters to filter your things.
    ///  			For example, calling ListThings with attributeName=Color and
    ///  			attributeValue=Red retrieves all things in the registry that contain an attribute
    ///  				Color with the value Red.
    ///  		       Requires permission to access the ListThings action.
    ///
    ///
    ///  			         You will not be charged for calling this API if an Access denied error is returned. You will also not be charged if no attributes or pagination token was provided in request and no pagination token and no results were returned.
    ///
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingsPaginator<Result>(
        _ input: ListThingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThings,
            inputKey: \ListThingsRequest.nextToken,
            outputKey: \ListThingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingsPaginator(
        _ input: ListThingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThings,
            inputKey: \ListThingsRequest.nextToken,
            outputKey: \ListThingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the things you have added to the given billing group.
    ///  		       Requires permission to access the ListThingsInBillingGroup action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingsInBillingGroupPaginator<Result>(
        _ input: ListThingsInBillingGroupRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingsInBillingGroupResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingsInBillingGroup,
            inputKey: \ListThingsInBillingGroupRequest.nextToken,
            outputKey: \ListThingsInBillingGroupResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingsInBillingGroupPaginator(
        _ input: ListThingsInBillingGroupRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingsInBillingGroupResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingsInBillingGroup,
            inputKey: \ListThingsInBillingGroupRequest.nextToken,
            outputKey: \ListThingsInBillingGroupResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the things in the specified group.
    ///  		       Requires permission to access the ListThingsInThingGroup action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listThingsInThingGroupPaginator<Result>(
        _ input: ListThingsInThingGroupRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListThingsInThingGroupResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listThingsInThingGroup,
            inputKey: \ListThingsInThingGroupRequest.nextToken,
            outputKey: \ListThingsInThingGroupResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listThingsInThingGroupPaginator(
        _ input: ListThingsInThingGroupRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListThingsInThingGroupResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listThingsInThingGroup,
            inputKey: \ListThingsInThingGroupRequest.nextToken,
            outputKey: \ListThingsInThingGroupResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all the topic rule destinations in your Amazon Web Services account. Requires permission to access the ListTopicRuleDestinations action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTopicRuleDestinationsPaginator<Result>(
        _ input: ListTopicRuleDestinationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTopicRuleDestinationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTopicRuleDestinations,
            inputKey: \ListTopicRuleDestinationsRequest.nextToken,
            outputKey: \ListTopicRuleDestinationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTopicRuleDestinationsPaginator(
        _ input: ListTopicRuleDestinationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTopicRuleDestinationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTopicRuleDestinations,
            inputKey: \ListTopicRuleDestinationsRequest.nextToken,
            outputKey: \ListTopicRuleDestinationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the rules for the specific topic. Requires permission to access the ListTopicRules action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTopicRulesPaginator<Result>(
        _ input: ListTopicRulesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTopicRulesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTopicRules,
            inputKey: \ListTopicRulesRequest.nextToken,
            outputKey: \ListTopicRulesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTopicRulesPaginator(
        _ input: ListTopicRulesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTopicRulesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTopicRules,
            inputKey: \ListTopicRulesRequest.nextToken,
            outputKey: \ListTopicRulesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists logging levels. Requires permission to access the ListV2LoggingLevels action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listV2LoggingLevelsPaginator<Result>(
        _ input: ListV2LoggingLevelsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListV2LoggingLevelsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listV2LoggingLevels,
            inputKey: \ListV2LoggingLevelsRequest.nextToken,
            outputKey: \ListV2LoggingLevelsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listV2LoggingLevelsPaginator(
        _ input: ListV2LoggingLevelsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListV2LoggingLevelsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listV2LoggingLevels,
            inputKey: \ListV2LoggingLevelsRequest.nextToken,
            outputKey: \ListV2LoggingLevelsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the Device Defender security profile violations discovered during the given time period.  You can use filters to limit the results to those alerts issued for a particular security profile,  behavior, or thing (device). Requires permission to access the ListViolationEvents action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listViolationEventsPaginator<Result>(
        _ input: ListViolationEventsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListViolationEventsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listViolationEvents,
            inputKey: \ListViolationEventsRequest.nextToken,
            outputKey: \ListViolationEventsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listViolationEventsPaginator(
        _ input: ListViolationEventsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListViolationEventsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listViolationEvents,
            inputKey: \ListViolationEventsRequest.nextToken,
            outputKey: \ListViolationEventsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension IoT.GetBehaviorModelTrainingSummariesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.GetBehaviorModelTrainingSummariesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )
    }
}

extension IoT.ListActiveViolationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListActiveViolationsRequest {
        return .init(
            behaviorCriteriaType: self.behaviorCriteriaType,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            thingName: self.thingName,
            verificationState: self.verificationState
        )
    }
}

extension IoT.ListAttachedPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAttachedPoliciesRequest {
        return .init(
            marker: token,
            pageSize: self.pageSize,
            recursive: self.recursive,
            target: self.target
        )
    }
}

extension IoT.ListAuditFindingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditFindingsRequest {
        return .init(
            checkName: self.checkName,
            endTime: self.endTime,
            listSuppressedFindings: self.listSuppressedFindings,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier,
            startTime: self.startTime,
            taskId: self.taskId
        )
    }
}

extension IoT.ListAuditMitigationActionsExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditMitigationActionsExecutionsRequest {
        return .init(
            actionStatus: self.actionStatus,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId
        )
    }
}

extension IoT.ListAuditMitigationActionsTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditMitigationActionsTasksRequest {
        return .init(
            auditTaskId: self.auditTaskId,
            endTime: self.endTime,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus
        )
    }
}

extension IoT.ListAuditSuppressionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditSuppressionsRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            checkName: self.checkName,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier
        )
    }
}

extension IoT.ListAuditTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditTasksRequest {
        return .init(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus,
            taskType: self.taskType
        )
    }
}

extension IoT.ListAuthorizersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListAuthorizersRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            status: self.status
        )
    }
}

extension IoT.ListBillingGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListBillingGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token
        )
    }
}

extension IoT.ListCACertificatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListCACertificatesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListCertificatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListCertificatesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListCertificatesByCARequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListCertificatesByCARequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            caCertificateId: self.caCertificateId,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListCustomMetricsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListCustomMetricsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListDetectMitigationActionsExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListDetectMitigationActionsExecutionsRequest {
        return .init(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskId: self.taskId,
            thingName: self.thingName,
            violationId: self.violationId
        )
    }
}

extension IoT.ListDetectMitigationActionsTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListDetectMitigationActionsTasksRequest {
        return .init(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )
    }
}

extension IoT.ListDimensionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListDimensionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListDomainConfigurationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListDomainConfigurationsRequest {
        return .init(
            marker: token,
            pageSize: self.pageSize,
            serviceType: self.serviceType
        )
    }
}

extension IoT.ListFleetMetricsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListFleetMetricsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListIndicesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListIndicesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListJobExecutionsForJobRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListJobExecutionsForJobRequest {
        return .init(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension IoT.ListJobExecutionsForThingRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListJobExecutionsForThingRequest {
        return .init(
            jobId: self.jobId,
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            thingName: self.thingName
        )
    }
}

extension IoT.ListJobTemplatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListJobTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListJobsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListJobsRequest {
        return .init(
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            targetSelection: self.targetSelection,
            thingGroupId: self.thingGroupId,
            thingGroupName: self.thingGroupName
        )
    }
}

extension IoT.ListMitigationActionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListMitigationActionsRequest {
        return .init(
            actionType: self.actionType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListOTAUpdatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListOTAUpdatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            otaUpdateStatus: self.otaUpdateStatus
        )
    }
}

extension IoT.ListOutgoingCertificatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListOutgoingCertificatesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListPoliciesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListPolicyPrincipalsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListPolicyPrincipalsRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )
    }
}

extension IoT.ListPrincipalPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListPrincipalPoliciesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            principal: self.principal
        )
    }
}

extension IoT.ListPrincipalThingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListPrincipalThingsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal
        )
    }
}

extension IoT.ListProvisioningTemplateVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListProvisioningTemplateVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            templateName: self.templateName
        )
    }
}

extension IoT.ListProvisioningTemplatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListProvisioningTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListRoleAliasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListRoleAliasesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListScheduledAuditsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListScheduledAuditsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListSecurityProfilesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListSecurityProfilesRequest {
        return .init(
            dimensionName: self.dimensionName,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token
        )
    }
}

extension IoT.ListSecurityProfilesForTargetRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListSecurityProfilesForTargetRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            securityProfileTargetArn: self.securityProfileTargetArn
        )
    }
}

extension IoT.ListStreamsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListStreamsRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListTagsForResourceRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListTagsForResourceRequest {
        return .init(
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension IoT.ListTargetsForPolicyRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListTargetsForPolicyRequest {
        return .init(
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )
    }
}

extension IoT.ListTargetsForSecurityProfileRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListTargetsForSecurityProfileRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )
    }
}

extension IoT.ListThingGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token,
            parentGroup: self.parentGroup,
            recursive: self.recursive
        )
    }
}

extension IoT.ListThingGroupsForThingRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingGroupsForThingRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )
    }
}

extension IoT.ListThingPrincipalsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingPrincipalsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )
    }
}

extension IoT.ListThingRegistrationTaskReportsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingRegistrationTaskReportsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            reportType: self.reportType,
            taskId: self.taskId
        )
    }
}

extension IoT.ListThingRegistrationTasksRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingRegistrationTasksRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension IoT.ListThingTypesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingTypesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName
        )
    }
}

extension IoT.ListThingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingsRequest {
        return .init(
            attributeName: self.attributeName,
            attributeValue: self.attributeValue,
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName,
            usePrefixAttributeValue: self.usePrefixAttributeValue
        )
    }
}

extension IoT.ListThingsInBillingGroupRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingsInBillingGroupRequest {
        return .init(
            billingGroupName: self.billingGroupName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListThingsInThingGroupRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListThingsInThingGroupRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            thingGroupName: self.thingGroupName
        )
    }
}

extension IoT.ListTopicRuleDestinationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListTopicRuleDestinationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListTopicRulesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListTopicRulesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            ruleDisabled: self.ruleDisabled,
            topic: self.topic
        )
    }
}

extension IoT.ListV2LoggingLevelsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListV2LoggingLevelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            targetType: self.targetType
        )
    }
}

extension IoT.ListViolationEventsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> IoT.ListViolationEventsRequest {
        return .init(
            behaviorCriteriaType: self.behaviorCriteriaType,
            endTime: self.endTime,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            startTime: self.startTime,
            thingName: self.thingName,
            verificationState: self.verificationState
        )
    }
}
