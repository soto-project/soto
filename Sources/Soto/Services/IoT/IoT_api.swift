//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS IoT service.
///
/// IoT IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the Amazon Web Services cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices. The service endpoints that expose this API are listed in Amazon Web Services IoT Core Endpoints and Quotas. You must use the endpoint for the region that has the resources you want to access. The service name used by Amazon Web Services Signature Version 4 to sign the request is: execute-api. For more information about how IoT works, see the Developer Guide. For information about how to use the credentials provider for IoT, see Authorizing Direct Calls to Amazon Web Services Services.
public struct IoT: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the IoT client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "IoT",
            serviceIdentifier: "iot",
            serviceProtocol: .restjson,
            apiVersion: "2015-05-28",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: IoTErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "iot-fips.ca-central-1.amazonaws.com",
            "us-east-1": "iot-fips.us-east-1.amazonaws.com",
            "us-east-2": "iot-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "iot-fips.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "iot-fips.us-gov-west-1.amazonaws.com",
            "us-west-1": "iot-fips.us-west-1.amazonaws.com",
            "us-west-2": "iot-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Accepts a pending certificate transfer. The default state of the certificate is INACTIVE. To check for pending certificate transfers, call ListCertificates to enumerate your certificates. Requires permission to access the AcceptCertificateTransfer action.
    @Sendable
    @inlinable
    public func acceptCertificateTransfer(_ input: AcceptCertificateTransferRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "AcceptCertificateTransfer", 
            path: "/accept-certificate-transfer/{certificateId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Accepts a pending certificate transfer. The default state of the certificate is INACTIVE. To check for pending certificate transfers, call ListCertificates to enumerate your certificates. Requires permission to access the AcceptCertificateTransfer action.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - setAsActive: Specifies whether the certificate is active.
    ///   - logger: Logger use during operation
    @inlinable
    public func acceptCertificateTransfer(
        certificateId: String,
        setAsActive: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = AcceptCertificateTransferRequest(
            certificateId: certificateId, 
            setAsActive: setAsActive
        )
        return try await self.acceptCertificateTransfer(input, logger: logger)
    }

    /// Adds a thing to a billing group. Requires permission to access the AddThingToBillingGroup action.
    @Sendable
    @inlinable
    public func addThingToBillingGroup(_ input: AddThingToBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AddThingToBillingGroupResponse {
        try await self.client.execute(
            operation: "AddThingToBillingGroup", 
            path: "/billing-groups/addThingToBillingGroup", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a thing to a billing group. Requires permission to access the AddThingToBillingGroup action.
    ///
    /// Parameters:
    ///   - billingGroupArn: The ARN of the billing group.
    ///   - billingGroupName: The name of the billing group.  This call is asynchronous. It might take several seconds for the detachment to propagate.
    ///   - thingArn: The ARN of the thing to be added to the billing group.
    ///   - thingName: The name of the thing to be added to the billing group.
    ///   - logger: Logger use during operation
    @inlinable
    public func addThingToBillingGroup(
        billingGroupArn: String? = nil,
        billingGroupName: String? = nil,
        thingArn: String? = nil,
        thingName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AddThingToBillingGroupResponse {
        let input = AddThingToBillingGroupRequest(
            billingGroupArn: billingGroupArn, 
            billingGroupName: billingGroupName, 
            thingArn: thingArn, 
            thingName: thingName
        )
        return try await self.addThingToBillingGroup(input, logger: logger)
    }

    /// Adds a thing to a thing group. Requires permission to access the AddThingToThingGroup action.
    @Sendable
    @inlinable
    public func addThingToThingGroup(_ input: AddThingToThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AddThingToThingGroupResponse {
        try await self.client.execute(
            operation: "AddThingToThingGroup", 
            path: "/thing-groups/addThingToThingGroup", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a thing to a thing group. Requires permission to access the AddThingToThingGroup action.
    ///
    /// Parameters:
    ///   - overrideDynamicGroups: Override dynamic thing groups with static thing groups when 10-group limit is
    ///   - thingArn: The ARN of the thing to add to a group.
    ///   - thingGroupArn: The ARN of the group to which you are adding a thing.
    ///   - thingGroupName: The name of the group to which you are adding a thing.
    ///   - thingName: The name of the thing to add to a group.
    ///   - logger: Logger use during operation
    @inlinable
    public func addThingToThingGroup(
        overrideDynamicGroups: Bool? = nil,
        thingArn: String? = nil,
        thingGroupArn: String? = nil,
        thingGroupName: String? = nil,
        thingName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AddThingToThingGroupResponse {
        let input = AddThingToThingGroupRequest(
            overrideDynamicGroups: overrideDynamicGroups, 
            thingArn: thingArn, 
            thingGroupArn: thingGroupArn, 
            thingGroupName: thingGroupName, 
            thingName: thingName
        )
        return try await self.addThingToThingGroup(input, logger: logger)
    }

    /// Associates the selected software bill of materials (SBOM) with a specific software package version. Requires permission to access the AssociateSbomWithPackageVersion action.
    @Sendable
    @inlinable
    public func associateSbomWithPackageVersion(_ input: AssociateSbomWithPackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateSbomWithPackageVersionResponse {
        try await self.client.execute(
            operation: "AssociateSbomWithPackageVersion", 
            path: "/packages/{packageName}/versions/{versionName}/sbom", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates the selected software bill of materials (SBOM) with a specific software package version. Requires permission to access the AssociateSbomWithPackageVersion action.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    ///   - packageName: The name of the new software package.
    ///   - sbom: 
    ///   - versionName: The name of the new package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateSbomWithPackageVersion(
        clientToken: String? = AssociateSbomWithPackageVersionRequest.idempotencyToken(),
        packageName: String,
        sbom: Sbom,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateSbomWithPackageVersionResponse {
        let input = AssociateSbomWithPackageVersionRequest(
            clientToken: clientToken, 
            packageName: packageName, 
            sbom: sbom, 
            versionName: versionName
        )
        return try await self.associateSbomWithPackageVersion(input, logger: logger)
    }

    /// Associates a group with a continuous job. The following criteria must be met:    The job must have been created with the targetSelection field set to "CONTINUOUS".   The job status must currently be "IN_PROGRESS".   The total number of targets associated with a job must not exceed 100.   Requires permission to access the AssociateTargetsWithJob action.
    @Sendable
    @inlinable
    public func associateTargetsWithJob(_ input: AssociateTargetsWithJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateTargetsWithJobResponse {
        try await self.client.execute(
            operation: "AssociateTargetsWithJob", 
            path: "/jobs/{jobId}/targets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a group with a continuous job. The following criteria must be met:    The job must have been created with the targetSelection field set to "CONTINUOUS".   The job status must currently be "IN_PROGRESS".   The total number of targets associated with a job must not exceed 100.   Requires permission to access the AssociateTargetsWithJob action.
    ///
    /// Parameters:
    ///   - comment: An optional comment string describing why the job was associated with the targets.
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - targets: A list of thing group ARNs that define the targets of the job.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateTargetsWithJob(
        comment: String? = nil,
        jobId: String,
        namespaceId: String? = nil,
        targets: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateTargetsWithJobResponse {
        let input = AssociateTargetsWithJobRequest(
            comment: comment, 
            jobId: jobId, 
            namespaceId: namespaceId, 
            targets: targets
        )
        return try await self.associateTargetsWithJob(input, logger: logger)
    }

    /// Attaches the specified policy to the specified principal (certificate or other credential). Requires permission to access the AttachPolicy action.
    @Sendable
    @inlinable
    public func attachPolicy(_ input: AttachPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "AttachPolicy", 
            path: "/target-policies/{policyName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Attaches the specified policy to the specified principal (certificate or other credential). Requires permission to access the AttachPolicy action.
    ///
    /// Parameters:
    ///   - policyName: The name of the policy to attach.
    ///   - target: The identity to which the policy is attached. For example, a thing group or a certificate.
    ///   - logger: Logger use during operation
    @inlinable
    public func attachPolicy(
        policyName: String,
        target: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = AttachPolicyRequest(
            policyName: policyName, 
            target: target
        )
        return try await self.attachPolicy(input, logger: logger)
    }

    /// Attaches the specified policy to the specified principal (certificate or other credential).  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use AttachPolicy instead. Requires permission to access the AttachPrincipalPolicy action.
    @Sendable
    @inlinable
    public func attachPrincipalPolicy(_ input: AttachPrincipalPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "AttachPrincipalPolicy", 
            path: "/principal-policies/{policyName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Attaches the specified policy to the specified principal (certificate or other credential).  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use AttachPolicy instead. Requires permission to access the AttachPrincipalPolicy action.
    ///
    /// Parameters:
    ///   - policyName: The policy name.
    ///   - principal: The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func attachPrincipalPolicy(
        policyName: String,
        principal: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = AttachPrincipalPolicyRequest(
            policyName: policyName, 
            principal: principal
        )
        return try await self.attachPrincipalPolicy(input, logger: logger)
    }

    /// Associates a Device Defender security profile with a thing group or this account. Each  thing group or account can have up to five security profiles associated with it. Requires permission to access the AttachSecurityProfile action.
    @Sendable
    @inlinable
    public func attachSecurityProfile(_ input: AttachSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AttachSecurityProfileResponse {
        try await self.client.execute(
            operation: "AttachSecurityProfile", 
            path: "/security-profiles/{securityProfileName}/targets", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a Device Defender security profile with a thing group or this account. Each  thing group or account can have up to five security profiles associated with it. Requires permission to access the AttachSecurityProfile action.
    ///
    /// Parameters:
    ///   - securityProfileName: The security profile that is attached.
    ///   - securityProfileTargetArn: The ARN of the target (thing group) to which the security profile is attached.
    ///   - logger: Logger use during operation
    @inlinable
    public func attachSecurityProfile(
        securityProfileName: String,
        securityProfileTargetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AttachSecurityProfileResponse {
        let input = AttachSecurityProfileRequest(
            securityProfileName: securityProfileName, 
            securityProfileTargetArn: securityProfileTargetArn
        )
        return try await self.attachSecurityProfile(input, logger: logger)
    }

    /// Attaches the specified principal to the specified thing. A principal can be X.509
    /// 			certificates, Amazon Cognito identities or federated identities. Requires permission to access the AttachThingPrincipal action.
    @Sendable
    @inlinable
    public func attachThingPrincipal(_ input: AttachThingPrincipalRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AttachThingPrincipalResponse {
        try await self.client.execute(
            operation: "AttachThingPrincipal", 
            path: "/things/{thingName}/principals", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Attaches the specified principal to the specified thing. A principal can be X.509
    /// 			certificates, Amazon Cognito identities or federated identities. Requires permission to access the AttachThingPrincipal action.
    ///
    /// Parameters:
    ///   - principal: The principal, which can be a certificate ARN (as returned from the
    ///   - thingName: The name of the thing.
    ///   - thingPrincipalType: The type of the relation you want to specify when you attach a principal to a thing.    EXCLUSIVE_THING - Attaches the specified principal to the specified thing, exclusively.
    ///   - logger: Logger use during operation
    @inlinable
    public func attachThingPrincipal(
        principal: String,
        thingName: String,
        thingPrincipalType: ThingPrincipalType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AttachThingPrincipalResponse {
        let input = AttachThingPrincipalRequest(
            principal: principal, 
            thingName: thingName, 
            thingPrincipalType: thingPrincipalType
        )
        return try await self.attachThingPrincipal(input, logger: logger)
    }

    /// Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs. Requires permission to access the CancelAuditMitigationActionsTask action.
    @Sendable
    @inlinable
    public func cancelAuditMitigationActionsTask(_ input: CancelAuditMitigationActionsTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelAuditMitigationActionsTaskResponse {
        try await self.client.execute(
            operation: "CancelAuditMitigationActionsTask", 
            path: "/audit/mitigationactions/tasks/{taskId}/cancel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs. Requires permission to access the CancelAuditMitigationActionsTask action.
    ///
    /// Parameters:
    ///   - taskId: The unique identifier for the task that you want to cancel.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelAuditMitigationActionsTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelAuditMitigationActionsTaskResponse {
        let input = CancelAuditMitigationActionsTaskRequest(
            taskId: taskId
        )
        return try await self.cancelAuditMitigationActionsTask(input, logger: logger)
    }

    /// Cancels an audit that is in progress. The audit can be either scheduled or on demand. If the audit isn't in progress, an "InvalidRequestException" occurs. Requires permission to access the CancelAuditTask action.
    @Sendable
    @inlinable
    public func cancelAuditTask(_ input: CancelAuditTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelAuditTaskResponse {
        try await self.client.execute(
            operation: "CancelAuditTask", 
            path: "/audit/tasks/{taskId}/cancel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels an audit that is in progress. The audit can be either scheduled or on demand. If the audit isn't in progress, an "InvalidRequestException" occurs. Requires permission to access the CancelAuditTask action.
    ///
    /// Parameters:
    ///   - taskId: The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelAuditTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelAuditTaskResponse {
        let input = CancelAuditTaskRequest(
            taskId: taskId
        )
        return try await self.cancelAuditTask(input, logger: logger)
    }

    /// Cancels a pending transfer for the specified certificate.  Note Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use RejectCertificateTransfer instead.) After transfer, IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled. After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE. Requires permission to access the CancelCertificateTransfer action.
    @Sendable
    @inlinable
    public func cancelCertificateTransfer(_ input: CancelCertificateTransferRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CancelCertificateTransfer", 
            path: "/cancel-certificate-transfer/{certificateId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels a pending transfer for the specified certificate.  Note Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use RejectCertificateTransfer instead.) After transfer, IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled. After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE. Requires permission to access the CancelCertificateTransfer action.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelCertificateTransfer(
        certificateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CancelCertificateTransferRequest(
            certificateId: certificateId
        )
        return try await self.cancelCertificateTransfer(input, logger: logger)
    }

    ///  Cancels a Device Defender ML Detect mitigation action.  Requires permission to access the CancelDetectMitigationActionsTask action.
    @Sendable
    @inlinable
    public func cancelDetectMitigationActionsTask(_ input: CancelDetectMitigationActionsTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelDetectMitigationActionsTaskResponse {
        try await self.client.execute(
            operation: "CancelDetectMitigationActionsTask", 
            path: "/detect/mitigationactions/tasks/{taskId}/cancel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Cancels a Device Defender ML Detect mitigation action.  Requires permission to access the CancelDetectMitigationActionsTask action.
    ///
    /// Parameters:
    ///   - taskId:  The unique identifier of the task.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelDetectMitigationActionsTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelDetectMitigationActionsTaskResponse {
        let input = CancelDetectMitigationActionsTaskRequest(
            taskId: taskId
        )
        return try await self.cancelDetectMitigationActionsTask(input, logger: logger)
    }

    /// Cancels a job. Requires permission to access the CancelJob action.
    @Sendable
    @inlinable
    public func cancelJob(_ input: CancelJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelJobResponse {
        try await self.client.execute(
            operation: "CancelJob", 
            path: "/jobs/{jobId}/cancel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels a job. Requires permission to access the CancelJob action.
    ///
    /// Parameters:
    ///   - comment: An optional comment string describing why the job was canceled.
    ///   - force: (Optional) If true job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is false. Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - reasonCode: (Optional)A reason code string that explains why the job was canceled.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelJob(
        comment: String? = nil,
        force: Bool? = nil,
        jobId: String,
        reasonCode: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelJobResponse {
        let input = CancelJobRequest(
            comment: comment, 
            force: force, 
            jobId: jobId, 
            reasonCode: reasonCode
        )
        return try await self.cancelJob(input, logger: logger)
    }

    /// Cancels the execution of a job for a given thing. Requires permission to access the CancelJobExecution action.
    @Sendable
    @inlinable
    public func cancelJobExecution(_ input: CancelJobExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CancelJobExecution", 
            path: "/things/{thingName}/jobs/{jobId}/cancel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels the execution of a job for a given thing. Requires permission to access the CancelJobExecution action.
    ///
    /// Parameters:
    ///   - expectedVersion: (Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)
    ///   - force: (Optional) If true the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set force to true, then an InvalidStateTransitionException will be thrown. The default is false. Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.
    ///   - jobId: The ID of the job to be canceled.
    ///   - statusDetails: A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.
    ///   - thingName: The name of the thing whose execution of the job will be canceled.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelJobExecution(
        expectedVersion: Int64? = nil,
        force: Bool? = nil,
        jobId: String,
        statusDetails: [String: String]? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CancelJobExecutionRequest(
            expectedVersion: expectedVersion, 
            force: force, 
            jobId: jobId, 
            statusDetails: statusDetails, 
            thingName: thingName
        )
        return try await self.cancelJobExecution(input, logger: logger)
    }

    /// Clears the default authorizer. Requires permission to access the ClearDefaultAuthorizer action.
    @Sendable
    @inlinable
    public func clearDefaultAuthorizer(_ input: ClearDefaultAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ClearDefaultAuthorizerResponse {
        try await self.client.execute(
            operation: "ClearDefaultAuthorizer", 
            path: "/default-authorizer", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Clears the default authorizer. Requires permission to access the ClearDefaultAuthorizer action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func clearDefaultAuthorizer(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ClearDefaultAuthorizerResponse {
        let input = ClearDefaultAuthorizerRequest(
        )
        return try await self.clearDefaultAuthorizer(input, logger: logger)
    }

    /// Confirms a topic rule destination. When you create a rule requiring a destination, IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling ConfirmTopicRuleDestination to confirm that you own or have access to the endpoint. Requires permission to access the ConfirmTopicRuleDestination action.
    @Sendable
    @inlinable
    public func confirmTopicRuleDestination(_ input: ConfirmTopicRuleDestinationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ConfirmTopicRuleDestinationResponse {
        try await self.client.execute(
            operation: "ConfirmTopicRuleDestination", 
            path: "/confirmdestination/{confirmationToken+}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Confirms a topic rule destination. When you create a rule requiring a destination, IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling ConfirmTopicRuleDestination to confirm that you own or have access to the endpoint. Requires permission to access the ConfirmTopicRuleDestination action.
    ///
    /// Parameters:
    ///   - confirmationToken: The token used to confirm ownership or access to the topic rule confirmation URL.
    ///   - logger: Logger use during operation
    @inlinable
    public func confirmTopicRuleDestination(
        confirmationToken: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ConfirmTopicRuleDestinationResponse {
        let input = ConfirmTopicRuleDestinationRequest(
            confirmationToken: confirmationToken
        )
        return try await self.confirmTopicRuleDestination(input, logger: logger)
    }

    ///  Creates a Device Defender audit suppression.  Requires permission to access the CreateAuditSuppression action.
    @Sendable
    @inlinable
    public func createAuditSuppression(_ input: CreateAuditSuppressionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAuditSuppressionResponse {
        try await self.client.execute(
            operation: "CreateAuditSuppression", 
            path: "/audit/suppressions/create", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a Device Defender audit suppression.  Requires permission to access the CreateAuditSuppression action.
    ///
    /// Parameters:
    ///   - checkName: 
    ///   - clientRequestToken:  Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    ///   - description:  The description of the audit suppression.
    ///   - expirationDate:  The epoch timestamp in seconds at which this suppression expires.
    ///   - resourceIdentifier: 
    ///   - suppressIndefinitely:  Indicates whether a suppression should exist indefinitely or not.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAuditSuppression(
        checkName: String,
        clientRequestToken: String = CreateAuditSuppressionRequest.idempotencyToken(),
        description: String? = nil,
        expirationDate: Date? = nil,
        resourceIdentifier: ResourceIdentifier,
        suppressIndefinitely: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAuditSuppressionResponse {
        let input = CreateAuditSuppressionRequest(
            checkName: checkName, 
            clientRequestToken: clientRequestToken, 
            description: description, 
            expirationDate: expirationDate, 
            resourceIdentifier: resourceIdentifier, 
            suppressIndefinitely: suppressIndefinitely
        )
        return try await self.createAuditSuppression(input, logger: logger)
    }

    /// Creates an authorizer. Requires permission to access the CreateAuthorizer action.
    @Sendable
    @inlinable
    public func createAuthorizer(_ input: CreateAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAuthorizerResponse {
        try await self.client.execute(
            operation: "CreateAuthorizer", 
            path: "/authorizer/{authorizerName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an authorizer. Requires permission to access the CreateAuthorizer action.
    ///
    /// Parameters:
    ///   - authorizerFunctionArn: The ARN of the authorizer's Lambda function.
    ///   - authorizerName: The authorizer name.
    ///   - enableCachingForHttp: When true, the result from the authorizerâ€™s Lambda function is
    ///   - signingDisabled: Specifies whether IoT validates the token signature in an authorization request.
    ///   - status: The status of the create authorizer request.
    ///   - tags: Metadata which can be used to manage the custom authorizer.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - tokenKeyName: The name of the token key used to extract the token from the HTTP headers.
    ///   - tokenSigningPublicKeys: The public keys used to verify the digital signature returned by your custom authentication service.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAuthorizer(
        authorizerFunctionArn: String,
        authorizerName: String,
        enableCachingForHttp: Bool? = nil,
        signingDisabled: Bool? = nil,
        status: AuthorizerStatus? = nil,
        tags: [Tag]? = nil,
        tokenKeyName: String? = nil,
        tokenSigningPublicKeys: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAuthorizerResponse {
        let input = CreateAuthorizerRequest(
            authorizerFunctionArn: authorizerFunctionArn, 
            authorizerName: authorizerName, 
            enableCachingForHttp: enableCachingForHttp, 
            signingDisabled: signingDisabled, 
            status: status, 
            tags: tags, 
            tokenKeyName: tokenKeyName, 
            tokenSigningPublicKeys: tokenSigningPublicKeys
        )
        return try await self.createAuthorizer(input, logger: logger)
    }

    /// Creates a billing group. If this call is made multiple times using
    /// 			the same billing group name and configuration, the call will succeed. If this call is made with
    /// 			the same billing group name but different configuration a ResourceAlreadyExistsException is thrown. Requires permission to access the CreateBillingGroup action.
    @Sendable
    @inlinable
    public func createBillingGroup(_ input: CreateBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBillingGroupResponse {
        try await self.client.execute(
            operation: "CreateBillingGroup", 
            path: "/billing-groups/{billingGroupName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a billing group. If this call is made multiple times using
    /// 			the same billing group name and configuration, the call will succeed. If this call is made with
    /// 			the same billing group name but different configuration a ResourceAlreadyExistsException is thrown. Requires permission to access the CreateBillingGroup action.
    ///
    /// Parameters:
    ///   - billingGroupName: The name you wish to give to the billing group.
    ///   - billingGroupProperties: The properties of the billing group.
    ///   - tags: Metadata which can be used to manage the billing group.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBillingGroup(
        billingGroupName: String,
        billingGroupProperties: BillingGroupProperties? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBillingGroupResponse {
        let input = CreateBillingGroupRequest(
            billingGroupName: billingGroupName, 
            billingGroupProperties: billingGroupProperties, 
            tags: tags
        )
        return try await self.createBillingGroup(input, logger: logger)
    }

    /// Creates an X.509 certificate using the specified certificate signing request.  Requires permission to access the CreateCertificateFromCsr action.   The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256, NIST P-384, or NIST P-521 curves. For supported certificates, consult  Certificate signing algorithms supported by IoT.    Reusing the same certificate signing request (CSR) results in a distinct certificate.  You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs. In the following commands, we assume that a set of CSRs are located inside of the directory my-csr-directory: On Linux and OS X, the command is:   $ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}  This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr Amazon Web Services CLI command to create a certificate for the corresponding CSR.  You can also run the aws iot create-certificate-from-csr part of the command in parallel to speed up the certificate creation process:  $ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}   On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:  > ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}   On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:  > forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"
    @Sendable
    @inlinable
    public func createCertificateFromCsr(_ input: CreateCertificateFromCsrRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCertificateFromCsrResponse {
        try await self.client.execute(
            operation: "CreateCertificateFromCsr", 
            path: "/certificates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an X.509 certificate using the specified certificate signing request.  Requires permission to access the CreateCertificateFromCsr action.   The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256, NIST P-384, or NIST P-521 curves. For supported certificates, consult  Certificate signing algorithms supported by IoT.    Reusing the same certificate signing request (CSR) results in a distinct certificate.  You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs. In the following commands, we assume that a set of CSRs are located inside of the directory my-csr-directory: On Linux and OS X, the command is:   $ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}  This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr Amazon Web Services CLI command to create a certificate for the corresponding CSR.  You can also run the aws iot create-certificate-from-csr part of the command in parallel to speed up the certificate creation process:  $ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}   On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:  > ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}   On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:  > forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"
    ///
    /// Parameters:
    ///   - certificateSigningRequest: The certificate signing request (CSR).
    ///   - setAsActive: Specifies whether the certificate is active.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCertificateFromCsr(
        certificateSigningRequest: String,
        setAsActive: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCertificateFromCsrResponse {
        let input = CreateCertificateFromCsrRequest(
            certificateSigningRequest: certificateSigningRequest, 
            setAsActive: setAsActive
        )
        return try await self.createCertificateFromCsr(input, logger: logger)
    }

    /// Creates an Amazon Web Services IoT Core certificate provider. You can use Amazon Web Services IoT Core certificate provider to customize how to sign a certificate signing request (CSR) in IoT fleet provisioning. For more information, see Customizing certificate signing using Amazon Web Services IoT Core certificate provider from Amazon Web Services IoT Core Developer Guide. Requires permission to access the CreateCertificateProvider action.  After you create a certificate provider, the behavior of  CreateCertificateFromCsr API for fleet provisioning will change and all API calls to CreateCertificateFromCsr will invoke the certificate provider to create the certificates. It can take up to a few minutes for this behavior to change after a certificate provider is created.
    @Sendable
    @inlinable
    public func createCertificateProvider(_ input: CreateCertificateProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCertificateProviderResponse {
        try await self.client.execute(
            operation: "CreateCertificateProvider", 
            path: "/certificate-providers/{certificateProviderName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Amazon Web Services IoT Core certificate provider. You can use Amazon Web Services IoT Core certificate provider to customize how to sign a certificate signing request (CSR) in IoT fleet provisioning. For more information, see Customizing certificate signing using Amazon Web Services IoT Core certificate provider from Amazon Web Services IoT Core Developer Guide. Requires permission to access the CreateCertificateProvider action.  After you create a certificate provider, the behavior of  CreateCertificateFromCsr API for fleet provisioning will change and all API calls to CreateCertificateFromCsr will invoke the certificate provider to create the certificates. It can take up to a few minutes for this behavior to change after a certificate provider is created.
    ///
    /// Parameters:
    ///   - accountDefaultForOperations: A list of the operations that the certificate provider will use to generate certificates.  Valid value: CreateCertificateFromCsr.
    ///   - certificateProviderName: The name of the certificate provider.
    ///   - clientToken: A string that you can optionally pass in the CreateCertificateProvider request to make sure  the request is idempotent.
    ///   - lambdaFunctionArn: The ARN of the Lambda function that defines the authentication logic.
    ///   - tags: Metadata which can be used to manage the certificate provider.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCertificateProvider(
        accountDefaultForOperations: [CertificateProviderOperation],
        certificateProviderName: String,
        clientToken: String? = CreateCertificateProviderRequest.idempotencyToken(),
        lambdaFunctionArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCertificateProviderResponse {
        let input = CreateCertificateProviderRequest(
            accountDefaultForOperations: accountDefaultForOperations, 
            certificateProviderName: certificateProviderName, 
            clientToken: clientToken, 
            lambdaFunctionArn: lambdaFunctionArn, 
            tags: tags
        )
        return try await self.createCertificateProvider(input, logger: logger)
    }

    /// Creates a command. A command contains reusable configurations that can be applied before they are sent to the devices.
    @Sendable
    @inlinable
    public func createCommand(_ input: CreateCommandRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCommandResponse {
        try await self.client.execute(
            operation: "CreateCommand", 
            path: "/commands/{commandId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a command. A command contains reusable configurations that can be applied before they are sent to the devices.
    ///
    /// Parameters:
    ///   - commandId: A unique identifier for the command. We recommend using UUID. Alpha-numeric characters, hyphens, and underscores are valid for use here.
    ///   - description: A short text decription of the command.
    ///   - displayName: The user-friendly name in the console for the command. This name doesn't have to be unique. You can update the user-friendly name after you define it.
    ///   - mandatoryParameters: A list of parameters that are required by the StartCommandExecution API. These parameters need to be specified only when using the AWS-IoT-FleetWise namespace. You can either specify them here or when running the command using the StartCommandExecution API.
    ///   - namespace: The namespace of the command. The MQTT reserved topics and validations will be used for command executions according to the namespace setting.
    ///   - payload: The payload object for the command. You must specify this information when using the AWS-IoT namespace. You can upload a static payload file from your local storage that contains the  instructions for the device to process. The payload file can use any format. To make sure that the device correctly interprets the payload, we recommend you to specify the payload content type.
    ///   - roleArn: The IAM role that you must provide when using the AWS-IoT-FleetWise namespace. The role grants IoT Device Management the permission to access IoT FleetWise resources  for generating the payload for the command. This field is not required when you use the AWS-IoT namespace.
    ///   - tags: Name-value pairs that are used as metadata to manage a command.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCommand(
        commandId: String,
        description: String? = nil,
        displayName: String? = nil,
        mandatoryParameters: [CommandParameter]? = nil,
        namespace: CommandNamespace? = nil,
        payload: CommandPayload? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCommandResponse {
        let input = CreateCommandRequest(
            commandId: commandId, 
            description: description, 
            displayName: displayName, 
            mandatoryParameters: mandatoryParameters, 
            namespace: namespace, 
            payload: payload, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createCommand(input, logger: logger)
    }

    ///  Use this API to define a Custom Metric published by your devices to Device Defender.  Requires permission to access the CreateCustomMetric action.
    @Sendable
    @inlinable
    public func createCustomMetric(_ input: CreateCustomMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCustomMetricResponse {
        try await self.client.execute(
            operation: "CreateCustomMetric", 
            path: "/custom-metric/{metricName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Use this API to define a Custom Metric published by your devices to Device Defender.  Requires permission to access the CreateCustomMetric action.
    ///
    /// Parameters:
    ///   - clientRequestToken: Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    ///   - displayName:  The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.
    ///   - metricName:  The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with aws:. You can't change the name after you define it.
    ///   - metricType:  The type of the custom metric.   The type number only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.
    ///   - tags:  Metadata that can be used to manage the custom metric.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCustomMetric(
        clientRequestToken: String = CreateCustomMetricRequest.idempotencyToken(),
        displayName: String? = nil,
        metricName: String,
        metricType: CustomMetricType,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCustomMetricResponse {
        let input = CreateCustomMetricRequest(
            clientRequestToken: clientRequestToken, 
            displayName: displayName, 
            metricName: metricName, 
            metricType: metricType, 
            tags: tags
        )
        return try await self.createCustomMetric(input, logger: logger)
    }

    /// Create a dimension that you can use to limit the scope of a metric used in a security profile for IoT Device Defender.  For example, using a TOPIC_FILTER dimension, you can narrow down the scope of the metric only to MQTT topics whose name match the pattern specified in the dimension. Requires permission to access the CreateDimension action.
    @Sendable
    @inlinable
    public func createDimension(_ input: CreateDimensionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDimensionResponse {
        try await self.client.execute(
            operation: "CreateDimension", 
            path: "/dimensions/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a dimension that you can use to limit the scope of a metric used in a security profile for IoT Device Defender.  For example, using a TOPIC_FILTER dimension, you can narrow down the scope of the metric only to MQTT topics whose name match the pattern specified in the dimension. Requires permission to access the CreateDimension action.
    ///
    /// Parameters:
    ///   - clientRequestToken: Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs.  If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    ///   - name: A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.
    ///   - stringValues: Specifies the value or list of values for the dimension. For TOPIC_FILTER dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
    ///   - tags: Metadata that can be used to manage the dimension.
    ///   - type: Specifies the type of dimension. Supported types: TOPIC_FILTER.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDimension(
        clientRequestToken: String = CreateDimensionRequest.idempotencyToken(),
        name: String,
        stringValues: [String],
        tags: [Tag]? = nil,
        type: DimensionType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDimensionResponse {
        let input = CreateDimensionRequest(
            clientRequestToken: clientRequestToken, 
            name: name, 
            stringValues: stringValues, 
            tags: tags, 
            type: type
        )
        return try await self.createDimension(input, logger: logger)
    }

    /// Creates a domain configuration. Requires permission to access the CreateDomainConfiguration action.
    @Sendable
    @inlinable
    public func createDomainConfiguration(_ input: CreateDomainConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDomainConfigurationResponse {
        try await self.client.execute(
            operation: "CreateDomainConfiguration", 
            path: "/domainConfigurations/{domainConfigurationName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a domain configuration. Requires permission to access the CreateDomainConfiguration action.
    ///
    /// Parameters:
    ///   - applicationProtocol: An enumerated string that speciï¬es the application-layer protocol.    SECURE_MQTT - MQTT over TLS.      MQTT_WSS - MQTT over WebSocket.      HTTPS - HTTP over TLS.      DEFAULT - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol.  For more information, see Device communication protocols.
    ///   - authenticationType: An enumerated string that speciï¬es the authentication type.    CUSTOM_AUTH_X509 - Use custom authentication and authorization with additional details from the X.509 client certificate.      CUSTOM_AUTH - Use custom authentication and authorization. For more information, see Custom authentication and authorization.      AWS_X509 - Use X.509 client certificates without custom authentication and authorization. For more information, see X.509 client certificates.      AWS_SIGV4 - Use Amazon Web Services Signature Version 4. For more information, see IAM users, groups, and roles.      DEFAULT - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see Device communication protocols.
    ///   - authorizerConfig: An object that specifies the authorization service for a domain.
    ///   - clientCertificateConfig: An object that speciï¬es the client certificate conï¬guration for a domain.
    ///   - domainConfigurationName: The name of the domain configuration. This value must be unique to a region.
    ///   - domainName: The name of the domain.
    ///   - serverCertificateArns: The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN.  This value is not required for Amazon Web Services-managed domains.
    ///   - serverCertificateConfig: The server certificate configuration.
    ///   - serviceType: The type of service delivered by the endpoint.  Amazon Web Services IoT Core currently supports only the DATA service type.
    ///   - tags: Metadata which can be used to manage the domain configuration.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - tlsConfig: An object that specifies the TLS configuration for a domain.
    ///   - validationCertificateArn: The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority.  This value is not required for Amazon Web Services-managed domains.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDomainConfiguration(
        applicationProtocol: ApplicationProtocol? = nil,
        authenticationType: AuthenticationType? = nil,
        authorizerConfig: AuthorizerConfig? = nil,
        clientCertificateConfig: ClientCertificateConfig? = nil,
        domainConfigurationName: String,
        domainName: String? = nil,
        serverCertificateArns: [String]? = nil,
        serverCertificateConfig: ServerCertificateConfig? = nil,
        serviceType: ServiceType? = nil,
        tags: [Tag]? = nil,
        tlsConfig: TlsConfig? = nil,
        validationCertificateArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDomainConfigurationResponse {
        let input = CreateDomainConfigurationRequest(
            applicationProtocol: applicationProtocol, 
            authenticationType: authenticationType, 
            authorizerConfig: authorizerConfig, 
            clientCertificateConfig: clientCertificateConfig, 
            domainConfigurationName: domainConfigurationName, 
            domainName: domainName, 
            serverCertificateArns: serverCertificateArns, 
            serverCertificateConfig: serverCertificateConfig, 
            serviceType: serviceType, 
            tags: tags, 
            tlsConfig: tlsConfig, 
            validationCertificateArn: validationCertificateArn
        )
        return try await self.createDomainConfiguration(input, logger: logger)
    }

    /// Creates a dynamic thing group. Requires permission to access the CreateDynamicThingGroup action.
    @Sendable
    @inlinable
    public func createDynamicThingGroup(_ input: CreateDynamicThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDynamicThingGroupResponse {
        try await self.client.execute(
            operation: "CreateDynamicThingGroup", 
            path: "/dynamic-thing-groups/{thingGroupName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a dynamic thing group. Requires permission to access the CreateDynamicThingGroup action.
    ///
    /// Parameters:
    ///   - indexName: The dynamic thing group index name.  Currently one index is supported: AWS_Things.
    ///   - queryString: The dynamic thing group search query string. See Query Syntax for information about query string syntax.
    ///   - queryVersion: The dynamic thing group query version.  Currently one query version is supported: "2017-09-30". If not specified, the
    ///   - tags: Metadata which can be used to manage the dynamic thing group.
    ///   - thingGroupName: The dynamic thing group name to create.
    ///   - thingGroupProperties: The dynamic thing group properties.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDynamicThingGroup(
        indexName: String? = nil,
        queryString: String,
        queryVersion: String? = nil,
        tags: [Tag]? = nil,
        thingGroupName: String,
        thingGroupProperties: ThingGroupProperties? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDynamicThingGroupResponse {
        let input = CreateDynamicThingGroupRequest(
            indexName: indexName, 
            queryString: queryString, 
            queryVersion: queryVersion, 
            tags: tags, 
            thingGroupName: thingGroupName, 
            thingGroupProperties: thingGroupProperties
        )
        return try await self.createDynamicThingGroup(input, logger: logger)
    }

    /// Creates a fleet metric. Requires permission to access the CreateFleetMetric action.
    @Sendable
    @inlinable
    public func createFleetMetric(_ input: CreateFleetMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFleetMetricResponse {
        try await self.client.execute(
            operation: "CreateFleetMetric", 
            path: "/fleet-metric/{metricName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a fleet metric. Requires permission to access the CreateFleetMetric action.
    ///
    /// Parameters:
    ///   - aggregationField: The field to aggregate.
    ///   - aggregationType: The type of the aggregation query.
    ///   - description: The fleet metric description.
    ///   - indexName: The name of the index to search.
    ///   - metricName: The name of the fleet metric to create.
    ///   - period: The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    ///   - queryString: The search query string.
    ///   - queryVersion: The query version.
    ///   - tags: Metadata, which can be used to manage the fleet metric.
    ///   - unit: Used to support unit transformation such as milliseconds to seconds. The unit must be supported by CW metric. Default to null.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFleetMetric(
        aggregationField: String,
        aggregationType: AggregationType,
        description: String? = nil,
        indexName: String? = nil,
        metricName: String,
        period: Int,
        queryString: String,
        queryVersion: String? = nil,
        tags: [Tag]? = nil,
        unit: FleetMetricUnit? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFleetMetricResponse {
        let input = CreateFleetMetricRequest(
            aggregationField: aggregationField, 
            aggregationType: aggregationType, 
            description: description, 
            indexName: indexName, 
            metricName: metricName, 
            period: period, 
            queryString: queryString, 
            queryVersion: queryVersion, 
            tags: tags, 
            unit: unit
        )
        return try await self.createFleetMetric(input, logger: logger)
    }

    /// Creates a job. Requires permission to access the CreateJob action.
    @Sendable
    @inlinable
    public func createJob(_ input: CreateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobResponse {
        try await self.client.execute(
            operation: "CreateJob", 
            path: "/jobs/{jobId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a job. Requires permission to access the CreateJob action.
    ///
    /// Parameters:
    ///   - abortConfig: Allows you to create the criteria to abort a job.
    ///   - description: A short text description of the job.
    ///   - destinationPackageVersions: The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. The package version must be in either the Published or Deprecated state when the job deploys. For more information, see Package version lifecycle.   Note:The following Length Constraints relates to a single ARN. Up to 25 package version ARNs are allowed.
    ///   - document: The job document. Required if you don't specify a value for documentSource.
    ///   - documentParameters: Parameters of an Amazon Web Services managed template that you can specify to create the job document.   documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    ///   - documentSource: An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for document. For example, --document-source https://s3.region-code.amazonaws.com/example-firmware/device-firmware.1.0  For more information, see Methods for accessing a bucket.
    ///   - jobExecutionsRetryConfig: Allows you to create the criteria to retry a job.
    ///   - jobExecutionsRolloutConfig: Allows you to create a staged rollout of the job.
    ///   - jobId: A job identifier which must be unique for your account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
    ///   - jobTemplateArn: The ARN of the job template used to create the job.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - presignedUrlConfig: Configuration information for pre-signed S3 URLs.
    ///   - schedulingConfig: The configuration that allows you to schedule a job for a future date and time in addition to specifying the end behavior for each job execution.
    ///   - tags: Metadata which can be used to manage the job.
    ///   - targets: A list of things and thing groups to which the job should be sent.
    ///   - targetSelection: Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.  We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    ///   - timeoutConfig: Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to TIMED_OUT.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJob(
        abortConfig: AbortConfig? = nil,
        description: String? = nil,
        destinationPackageVersions: [String]? = nil,
        document: String? = nil,
        documentParameters: [String: String]? = nil,
        documentSource: String? = nil,
        jobExecutionsRetryConfig: JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobId: String,
        jobTemplateArn: String? = nil,
        namespaceId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        schedulingConfig: SchedulingConfig? = nil,
        tags: [Tag]? = nil,
        targets: [String],
        targetSelection: TargetSelection? = nil,
        timeoutConfig: TimeoutConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobResponse {
        let input = CreateJobRequest(
            abortConfig: abortConfig, 
            description: description, 
            destinationPackageVersions: destinationPackageVersions, 
            document: document, 
            documentParameters: documentParameters, 
            documentSource: documentSource, 
            jobExecutionsRetryConfig: jobExecutionsRetryConfig, 
            jobExecutionsRolloutConfig: jobExecutionsRolloutConfig, 
            jobId: jobId, 
            jobTemplateArn: jobTemplateArn, 
            namespaceId: namespaceId, 
            presignedUrlConfig: presignedUrlConfig, 
            schedulingConfig: schedulingConfig, 
            tags: tags, 
            targets: targets, 
            targetSelection: targetSelection, 
            timeoutConfig: timeoutConfig
        )
        return try await self.createJob(input, logger: logger)
    }

    /// Creates a job template. Requires permission to access the CreateJobTemplate action.
    @Sendable
    @inlinable
    public func createJobTemplate(_ input: CreateJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobTemplateResponse {
        try await self.client.execute(
            operation: "CreateJobTemplate", 
            path: "/job-templates/{jobTemplateId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a job template. Requires permission to access the CreateJobTemplate action.
    ///
    /// Parameters:
    ///   - abortConfig: 
    ///   - description: A description of the job document.
    ///   - destinationPackageVersions: The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. The package version must be in either the Published or Deprecated state when the job deploys. For more information, see Package version lifecycle.  Note:The following Length Constraints relates to a single ARN. Up to 25 package version ARNs are allowed.
    ///   - document: The job document. Required if you don't specify a value for documentSource.
    ///   - documentSource: An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for document. For example, --document-source https://s3.region-code.amazonaws.com/example-firmware/device-firmware.1.0  For more information, see Methods for accessing a bucket.
    ///   - jobArn: The ARN of the job to use as the basis for the job template.
    ///   - jobExecutionsRetryConfig: Allows you to create the criteria to retry a job.
    ///   - jobExecutionsRolloutConfig: 
    ///   - jobTemplateId: A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.
    ///   - maintenanceWindows: Allows you to configure an optional maintenance window for the rollout of a job document to all devices in the target group for a job.
    ///   - presignedUrlConfig: 
    ///   - tags: Metadata that can be used to manage the job template.
    ///   - timeoutConfig: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createJobTemplate(
        abortConfig: AbortConfig? = nil,
        description: String,
        destinationPackageVersions: [String]? = nil,
        document: String? = nil,
        documentSource: String? = nil,
        jobArn: String? = nil,
        jobExecutionsRetryConfig: JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobTemplateId: String,
        maintenanceWindows: [MaintenanceWindow]? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        tags: [Tag]? = nil,
        timeoutConfig: TimeoutConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobTemplateResponse {
        let input = CreateJobTemplateRequest(
            abortConfig: abortConfig, 
            description: description, 
            destinationPackageVersions: destinationPackageVersions, 
            document: document, 
            documentSource: documentSource, 
            jobArn: jobArn, 
            jobExecutionsRetryConfig: jobExecutionsRetryConfig, 
            jobExecutionsRolloutConfig: jobExecutionsRolloutConfig, 
            jobTemplateId: jobTemplateId, 
            maintenanceWindows: maintenanceWindows, 
            presignedUrlConfig: presignedUrlConfig, 
            tags: tags, 
            timeoutConfig: timeoutConfig
        )
        return try await self.createJobTemplate(input, logger: logger)
    }

    /// Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call CreateKeysAndCertificate over MQTT from a device, for more information, see Provisioning MQTT API.  Note This is the only time IoT issues the private key for this certificate, so it is important to keep it in a secure location. Requires permission to access the CreateKeysAndCertificate action.
    @Sendable
    @inlinable
    public func createKeysAndCertificate(_ input: CreateKeysAndCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateKeysAndCertificateResponse {
        try await self.client.execute(
            operation: "CreateKeysAndCertificate", 
            path: "/keys-and-certificate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call CreateKeysAndCertificate over MQTT from a device, for more information, see Provisioning MQTT API.  Note This is the only time IoT issues the private key for this certificate, so it is important to keep it in a secure location. Requires permission to access the CreateKeysAndCertificate action.
    ///
    /// Parameters:
    ///   - setAsActive: Specifies whether the certificate is active.
    ///   - logger: Logger use during operation
    @inlinable
    public func createKeysAndCertificate(
        setAsActive: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateKeysAndCertificateResponse {
        let input = CreateKeysAndCertificateRequest(
            setAsActive: setAsActive
        )
        return try await self.createKeysAndCertificate(input, logger: logger)
    }

    /// Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Only certain types of mitigation actions can be applied to specific check names.  For more information, see Mitigation actions. Each mitigation action can apply only one type of change. Requires permission to access the CreateMitigationAction action.
    @Sendable
    @inlinable
    public func createMitigationAction(_ input: CreateMitigationActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMitigationActionResponse {
        try await self.client.execute(
            operation: "CreateMitigationAction", 
            path: "/mitigationactions/actions/{actionName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Only certain types of mitigation actions can be applied to specific check names.  For more information, see Mitigation actions. Each mitigation action can apply only one type of change. Requires permission to access the CreateMitigationAction action.
    ///
    /// Parameters:
    ///   - actionName: A friendly name for the action. Choose a friendly name that accurately describes the action (for example, EnableLoggingAction).
    ///   - actionParams: Defines the type of action and the parameters for that action.
    ///   - roleArn: The ARN of the IAM role that is used to apply the mitigation action.
    ///   - tags: Metadata that can be used to manage the mitigation action.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMitigationAction(
        actionName: String,
        actionParams: MitigationActionParams,
        roleArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMitigationActionResponse {
        let input = CreateMitigationActionRequest(
            actionName: actionName, 
            actionParams: actionParams, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createMitigationAction(input, logger: logger)
    }

    /// Creates an IoT OTA update on a target group of things or groups. Requires permission to access the CreateOTAUpdate action.
    @Sendable
    @inlinable
    public func createOTAUpdate(_ input: CreateOTAUpdateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateOTAUpdateResponse {
        try await self.client.execute(
            operation: "CreateOTAUpdate", 
            path: "/otaUpdates/{otaUpdateId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an IoT OTA update on a target group of things or groups. Requires permission to access the CreateOTAUpdate action.
    ///
    /// Parameters:
    ///   - additionalParameters: A list of additional OTA update parameters, which are name-value pairs.  They won't be sent to devices as a part of the Job document.
    ///   - awsJobAbortConfig: The criteria that determine when and how a job abort takes place.
    ///   - awsJobExecutionsRolloutConfig: Configuration for the rollout of OTA updates.
    ///   - awsJobPresignedUrlConfig: Configuration information for pre-signed URLs.
    ///   - awsJobTimeoutConfig: Specifies the amount of time each device has to finish its execution of the job.  A timer is  started when the job execution status is set to IN_PROGRESS. If the job execution  status is not set to another terminal state before the timer expires, it will be automatically  set to TIMED_OUT.
    ///   - description: The description of the OTA update.
    ///   - files: The files to be streamed by the OTA update.
    ///   - otaUpdateId: The ID of the OTA update to be created.
    ///   - protocols: The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.
    ///   - roleArn: The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources  to create an OTA update job.
    ///   - tags: Metadata which can be used to manage updates.
    ///   - targets: The devices targeted to receive OTA updates.
    ///   - targetSelection: Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.
    ///   - logger: Logger use during operation
    @inlinable
    public func createOTAUpdate(
        additionalParameters: [String: String]? = nil,
        awsJobAbortConfig: AwsJobAbortConfig? = nil,
        awsJobExecutionsRolloutConfig: AwsJobExecutionsRolloutConfig? = nil,
        awsJobPresignedUrlConfig: AwsJobPresignedUrlConfig? = nil,
        awsJobTimeoutConfig: AwsJobTimeoutConfig? = nil,
        description: String? = nil,
        files: [OTAUpdateFile],
        otaUpdateId: String,
        protocols: [`Protocol`]? = nil,
        roleArn: String,
        tags: [Tag]? = nil,
        targets: [String],
        targetSelection: TargetSelection? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateOTAUpdateResponse {
        let input = CreateOTAUpdateRequest(
            additionalParameters: additionalParameters, 
            awsJobAbortConfig: awsJobAbortConfig, 
            awsJobExecutionsRolloutConfig: awsJobExecutionsRolloutConfig, 
            awsJobPresignedUrlConfig: awsJobPresignedUrlConfig, 
            awsJobTimeoutConfig: awsJobTimeoutConfig, 
            description: description, 
            files: files, 
            otaUpdateId: otaUpdateId, 
            protocols: protocols, 
            roleArn: roleArn, 
            tags: tags, 
            targets: targets, 
            targetSelection: targetSelection
        )
        return try await self.createOTAUpdate(input, logger: logger)
    }

    /// Creates an IoT software package that can be deployed to your fleet. Requires permission to access the CreatePackage and GetIndexingConfiguration actions.
    @Sendable
    @inlinable
    public func createPackage(_ input: CreatePackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePackageResponse {
        try await self.client.execute(
            operation: "CreatePackage", 
            path: "/packages/{packageName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an IoT software package that can be deployed to your fleet. Requires permission to access the CreatePackage and GetIndexingConfiguration actions.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - description: A summary of the package being created. This can be used to outline the package's contents or purpose.
    ///   - packageName: The name of the new software package.
    ///   - tags: Metadata that can be used to manage the package.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPackage(
        clientToken: String? = CreatePackageRequest.idempotencyToken(),
        description: String? = nil,
        packageName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePackageResponse {
        let input = CreatePackageRequest(
            clientToken: clientToken, 
            description: description, 
            packageName: packageName, 
            tags: tags
        )
        return try await self.createPackage(input, logger: logger)
    }

    /// Creates a new version for an existing IoT software package. Requires permission to access the CreatePackageVersion and GetIndexingConfiguration actions.
    @Sendable
    @inlinable
    public func createPackageVersion(_ input: CreatePackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePackageVersionResponse {
        try await self.client.execute(
            operation: "CreatePackageVersion", 
            path: "/packages/{packageName}/versions/{versionName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new version for an existing IoT software package. Requires permission to access the CreatePackageVersion and GetIndexingConfiguration actions.
    ///
    /// Parameters:
    ///   - artifact: The various build components created during the build process such as libraries and configuration files that make up a software package version.
    ///   - attributes: Metadata that can be used to define a package versionâ€™s configuration. For example, the S3 file location, configuration options that are being sent to the device or fleet. The combined size of all the attributes on a package version is limited to 3KB.
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - description: A summary of the package version being created. This can be used to outline the package's contents or purpose.
    ///   - packageName: The name of the associated software package.
    ///   - recipe: The inline job document associated with a software package version used for a quick job deployment.
    ///   - tags: Metadata that can be used to manage the package version.
    ///   - versionName: The name of the new package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPackageVersion(
        artifact: PackageVersionArtifact? = nil,
        attributes: [String: String]? = nil,
        clientToken: String? = CreatePackageVersionRequest.idempotencyToken(),
        description: String? = nil,
        packageName: String,
        recipe: String? = nil,
        tags: [String: String]? = nil,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePackageVersionResponse {
        let input = CreatePackageVersionRequest(
            artifact: artifact, 
            attributes: attributes, 
            clientToken: clientToken, 
            description: description, 
            packageName: packageName, 
            recipe: recipe, 
            tags: tags, 
            versionName: versionName
        )
        return try await self.createPackageVersion(input, logger: logger)
    }

    /// Creates an IoT policy. The created policy is the default version for the policy. This operation creates a policy version with a version identifier of 1 and sets 1 as the policy's default version. Requires permission to access the CreatePolicy action.
    @Sendable
    @inlinable
    public func createPolicy(_ input: CreatePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyResponse {
        try await self.client.execute(
            operation: "CreatePolicy", 
            path: "/policies/{policyName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an IoT policy. The created policy is the default version for the policy. This operation creates a policy version with a version identifier of 1 and sets 1 as the policy's default version. Requires permission to access the CreatePolicy action.
    ///
    /// Parameters:
    ///   - policyDocument: The JSON document that describes the policy. policyDocument must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.
    ///   - policyName: The policy name.
    ///   - tags: Metadata which can be used to manage the policy.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicy(
        policyDocument: String,
        policyName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyResponse {
        let input = CreatePolicyRequest(
            policyDocument: policyDocument, 
            policyName: policyName, 
            tags: tags
        )
        return try await self.createPolicy(input, logger: logger)
    }

    /// Creates a new version of the specified IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use DeletePolicyVersion to delete an existing version before you create a new one. Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached). Requires permission to access the CreatePolicyVersion action.
    @Sendable
    @inlinable
    public func createPolicyVersion(_ input: CreatePolicyVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePolicyVersionResponse {
        try await self.client.execute(
            operation: "CreatePolicyVersion", 
            path: "/policies/{policyName}/version", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new version of the specified IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use DeletePolicyVersion to delete an existing version before you create a new one. Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached). Requires permission to access the CreatePolicyVersion action.
    ///
    /// Parameters:
    ///   - policyDocument: The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.
    ///   - policyName: The policy name.
    ///   - setAsDefault: Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
    ///   - logger: Logger use during operation
    @inlinable
    public func createPolicyVersion(
        policyDocument: String,
        policyName: String,
        setAsDefault: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePolicyVersionResponse {
        let input = CreatePolicyVersionRequest(
            policyDocument: policyDocument, 
            policyName: policyName, 
            setAsDefault: setAsDefault
        )
        return try await self.createPolicyVersion(input, logger: logger)
    }

    /// Creates a provisioning claim. Requires permission to access the CreateProvisioningClaim action.
    @Sendable
    @inlinable
    public func createProvisioningClaim(_ input: CreateProvisioningClaimRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProvisioningClaimResponse {
        try await self.client.execute(
            operation: "CreateProvisioningClaim", 
            path: "/provisioning-templates/{templateName}/provisioning-claim", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a provisioning claim. Requires permission to access the CreateProvisioningClaim action.
    ///
    /// Parameters:
    ///   - templateName: The name of the provisioning template to use.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProvisioningClaim(
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProvisioningClaimResponse {
        let input = CreateProvisioningClaimRequest(
            templateName: templateName
        )
        return try await self.createProvisioningClaim(input, logger: logger)
    }

    /// Creates a provisioning template. Requires permission to access the CreateProvisioningTemplate action.
    @Sendable
    @inlinable
    public func createProvisioningTemplate(_ input: CreateProvisioningTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProvisioningTemplateResponse {
        try await self.client.execute(
            operation: "CreateProvisioningTemplate", 
            path: "/provisioning-templates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a provisioning template. Requires permission to access the CreateProvisioningTemplate action.
    ///
    /// Parameters:
    ///   - description: The description of the provisioning template.
    ///   - enabled: True to enable the provisioning template, otherwise false.
    ///   - preProvisioningHook: Creates a pre-provisioning hook template. Only supports template of type FLEET_PROVISIONING. For more information about provisioning template types, see type.
    ///   - provisioningRoleArn: The role ARN for the role associated with the provisioning template. This IoT role grants permission to provision a device.
    ///   - tags: Metadata which can be used to manage the provisioning template.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - templateBody: The JSON formatted contents of the provisioning template.
    ///   - templateName: The name of the provisioning template.
    ///   - type: The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: Provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProvisioningTemplate(
        description: String? = nil,
        enabled: Bool? = nil,
        preProvisioningHook: ProvisioningHook? = nil,
        provisioningRoleArn: String,
        tags: [Tag]? = nil,
        templateBody: String,
        templateName: String,
        type: TemplateType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProvisioningTemplateResponse {
        let input = CreateProvisioningTemplateRequest(
            description: description, 
            enabled: enabled, 
            preProvisioningHook: preProvisioningHook, 
            provisioningRoleArn: provisioningRoleArn, 
            tags: tags, 
            templateBody: templateBody, 
            templateName: templateName, 
            type: type
        )
        return try await self.createProvisioningTemplate(input, logger: logger)
    }

    /// Creates a new version of a provisioning template. Requires permission to access the CreateProvisioningTemplateVersion action.
    @Sendable
    @inlinable
    public func createProvisioningTemplateVersion(_ input: CreateProvisioningTemplateVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateProvisioningTemplateVersionResponse {
        try await self.client.execute(
            operation: "CreateProvisioningTemplateVersion", 
            path: "/provisioning-templates/{templateName}/versions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new version of a provisioning template. Requires permission to access the CreateProvisioningTemplateVersion action.
    ///
    /// Parameters:
    ///   - setAsDefault: Sets a fleet provision template version as the default version.
    ///   - templateBody: The JSON formatted contents of the provisioning template.
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createProvisioningTemplateVersion(
        setAsDefault: Bool? = nil,
        templateBody: String,
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateProvisioningTemplateVersionResponse {
        let input = CreateProvisioningTemplateVersionRequest(
            setAsDefault: setAsDefault, 
            templateBody: templateBody, 
            templateName: templateName
        )
        return try await self.createProvisioningTemplateVersion(input, logger: logger)
    }

    /// Creates a role alias. Requires permission to access the CreateRoleAlias action.  The value of  credentialDurationSeconds must be less than or equal to the maximum session  duration of the IAM role that the role alias references. For more information, see   Modifying a role maximum session duration (Amazon Web Services API) from the Amazon Web Services Identity and Access Management User Guide.
    @Sendable
    @inlinable
    public func createRoleAlias(_ input: CreateRoleAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRoleAliasResponse {
        try await self.client.execute(
            operation: "CreateRoleAlias", 
            path: "/role-aliases/{roleAlias}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a role alias. Requires permission to access the CreateRoleAlias action.  The value of  credentialDurationSeconds must be less than or equal to the maximum session  duration of the IAM role that the role alias references. For more information, see   Modifying a role maximum session duration (Amazon Web Services API) from the Amazon Web Services Identity and Access Management User Guide.
    ///
    /// Parameters:
    ///   - credentialDurationSeconds: How long (in seconds) the credentials will be valid. The default value is 3,600 seconds. This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.
    ///   - roleAlias: The role alias that points to a role ARN. This allows you to change the role without having to update the device.
    ///   - roleArn: The role ARN.
    ///   - tags: Metadata which can be used to manage the role alias.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - logger: Logger use during operation
    @inlinable
    public func createRoleAlias(
        credentialDurationSeconds: Int? = nil,
        roleAlias: String,
        roleArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRoleAliasResponse {
        let input = CreateRoleAliasRequest(
            credentialDurationSeconds: credentialDurationSeconds, 
            roleAlias: roleAlias, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createRoleAlias(input, logger: logger)
    }

    /// Creates a scheduled audit that is run at a specified  time interval. Requires permission to access the CreateScheduledAudit action.
    @Sendable
    @inlinable
    public func createScheduledAudit(_ input: CreateScheduledAuditRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScheduledAuditResponse {
        try await self.client.execute(
            operation: "CreateScheduledAudit", 
            path: "/audit/scheduledaudits/{scheduledAuditName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a scheduled audit that is run at a specified  time interval. Requires permission to access the CreateScheduledAudit action.
    ///
    /// Parameters:
    ///   - dayOfMonth: The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to MONTHLY. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the LAST day of the month.
    ///   - dayOfWeek: The day of the week on which the scheduled audit takes place, either SUN, MON, TUE, WED, THU, FRI, or SAT. This field is required if the frequency parameter is set to WEEKLY or BIWEEKLY.
    ///   - frequency: How often the scheduled audit takes place, either DAILY, WEEKLY, BIWEEKLY or MONTHLY. The start time of each audit is determined by the system.
    ///   - scheduledAuditName: The name you want to give to the scheduled audit. (Max. 128 chars)
    ///   - tags: Metadata that can be used to manage the scheduled audit.
    ///   - targetCheckNames: Which checks are performed during the scheduled audit. Checks must be enabled  for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration  to select which checks are enabled.)
    ///   - logger: Logger use during operation
    @inlinable
    public func createScheduledAudit(
        dayOfMonth: String? = nil,
        dayOfWeek: DayOfWeek? = nil,
        frequency: AuditFrequency,
        scheduledAuditName: String,
        tags: [Tag]? = nil,
        targetCheckNames: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScheduledAuditResponse {
        let input = CreateScheduledAuditRequest(
            dayOfMonth: dayOfMonth, 
            dayOfWeek: dayOfWeek, 
            frequency: frequency, 
            scheduledAuditName: scheduledAuditName, 
            tags: tags, 
            targetCheckNames: targetCheckNames
        )
        return try await self.createScheduledAudit(input, logger: logger)
    }

    /// Creates a Device Defender security profile. Requires permission to access the CreateSecurityProfile action.
    @Sendable
    @inlinable
    public func createSecurityProfile(_ input: CreateSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSecurityProfileResponse {
        try await self.client.execute(
            operation: "CreateSecurityProfile", 
            path: "/security-profiles/{securityProfileName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Device Defender security profile. Requires permission to access the CreateSecurityProfile action.
    ///
    /// Parameters:
    ///   - additionalMetricsToRetainV2: A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    ///   - alertTargets: Specifies the destinations to which alerts are sent. (Alerts are always sent to the  console.) Alerts are generated when a device (thing) violates a behavior.
    ///   - behaviors: Specifies the behaviors that, when violated by a device (thing), cause an alert.
    ///   - metricsExportConfig: Specifies the MQTT topic and role ARN required for metric export.
    ///   - securityProfileDescription: A description of the security profile.
    ///   - securityProfileName: The name you are giving to the security profile.
    ///   - tags: Metadata that can be used to manage the security profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSecurityProfile(
        additionalMetricsToRetainV2: [MetricToRetain]? = nil,
        alertTargets: [AlertTargetType: AlertTarget]? = nil,
        behaviors: [Behavior]? = nil,
        metricsExportConfig: MetricsExportConfig? = nil,
        securityProfileDescription: String? = nil,
        securityProfileName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSecurityProfileResponse {
        let input = CreateSecurityProfileRequest(
            additionalMetricsToRetainV2: additionalMetricsToRetainV2, 
            alertTargets: alertTargets, 
            behaviors: behaviors, 
            metricsExportConfig: metricsExportConfig, 
            securityProfileDescription: securityProfileDescription, 
            securityProfileName: securityProfileName, 
            tags: tags
        )
        return try await self.createSecurityProfile(input, logger: logger)
    }

    /// Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. Requires permission to access the CreateStream action.
    @Sendable
    @inlinable
    public func createStream(_ input: CreateStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStreamResponse {
        try await self.client.execute(
            operation: "CreateStream", 
            path: "/streams/{streamId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. Requires permission to access the CreateStream action.
    ///
    /// Parameters:
    ///   - description: A description of the stream.
    ///   - files: The files to stream.
    ///   - roleArn: An IAM role that allows the IoT service principal to access your S3 files.
    ///   - streamId: The stream ID.
    ///   - tags: Metadata which can be used to manage streams.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStream(
        description: String? = nil,
        files: [StreamFile],
        roleArn: String,
        streamId: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStreamResponse {
        let input = CreateStreamRequest(
            description: description, 
            files: files, 
            roleArn: roleArn, 
            streamId: streamId, 
            tags: tags
        )
        return try await self.createStream(input, logger: logger)
    }

    /// Creates a thing record in the registry. If this call is made multiple times using
    /// 			the same thing name and configuration, the call will succeed. If this call is made with
    /// 			the same thing name but different configuration a
    /// 				ResourceAlreadyExistsException is thrown.  This is a control plane operation. See Authorization for
    /// 				information about authorizing control plane actions.  Requires permission to access the CreateThing action.
    @Sendable
    @inlinable
    public func createThing(_ input: CreateThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateThingResponse {
        try await self.client.execute(
            operation: "CreateThing", 
            path: "/things/{thingName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a thing record in the registry. If this call is made multiple times using
    /// 			the same thing name and configuration, the call will succeed. If this call is made with
    /// 			the same thing name but different configuration a
    /// 				ResourceAlreadyExistsException is thrown.  This is a control plane operation. See Authorization for
    /// 				information about authorizing control plane actions.  Requires permission to access the CreateThing action.
    ///
    /// Parameters:
    ///   - attributePayload: The attribute payload, which consists of up to three name/value pairs in a JSON
    ///   - billingGroupName: The name of the billing group the thing will be added to.
    ///   - thingName: The name of the thing to create. You can't change a thing's name after you create it. To change a thing's name, you must create a
    ///   - thingTypeName: The name of the thing type associated with the new thing.
    ///   - logger: Logger use during operation
    @inlinable
    public func createThing(
        attributePayload: AttributePayload? = nil,
        billingGroupName: String? = nil,
        thingName: String,
        thingTypeName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateThingResponse {
        let input = CreateThingRequest(
            attributePayload: attributePayload, 
            billingGroupName: billingGroupName, 
            thingName: thingName, 
            thingTypeName: thingTypeName
        )
        return try await self.createThing(input, logger: logger)
    }

    /// Create a thing group.  This is a control plane operation. See Authorization for
    /// 				information about authorizing control plane actions. If the ThingGroup that you create has the exact same attributes as an existing
    /// 					ThingGroup, you will get a 200 success response.
    /// 			  Requires permission to access the CreateThingGroup action.
    @Sendable
    @inlinable
    public func createThingGroup(_ input: CreateThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateThingGroupResponse {
        try await self.client.execute(
            operation: "CreateThingGroup", 
            path: "/thing-groups/{thingGroupName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a thing group.  This is a control plane operation. See Authorization for
    /// 				information about authorizing control plane actions. If the ThingGroup that you create has the exact same attributes as an existing
    /// 					ThingGroup, you will get a 200 success response.
    /// 			  Requires permission to access the CreateThingGroup action.
    ///
    /// Parameters:
    ///   - parentGroupName: The name of the parent thing group.
    ///   - tags: Metadata which can be used to manage the thing group.
    ///   - thingGroupName: The thing group name to create.
    ///   - thingGroupProperties: The thing group properties.
    ///   - logger: Logger use during operation
    @inlinable
    public func createThingGroup(
        parentGroupName: String? = nil,
        tags: [Tag]? = nil,
        thingGroupName: String,
        thingGroupProperties: ThingGroupProperties? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateThingGroupResponse {
        let input = CreateThingGroupRequest(
            parentGroupName: parentGroupName, 
            tags: tags, 
            thingGroupName: thingGroupName, 
            thingGroupProperties: thingGroupProperties
        )
        return try await self.createThingGroup(input, logger: logger)
    }

    /// Creates a new thing type. If this call is made multiple times using
    /// 			the same thing type name and configuration, the call will succeed. If this call is made with
    /// 			the same thing type name but different configuration a ResourceAlreadyExistsException is thrown.
    /// 		 Requires permission to access the CreateThingType action.
    @Sendable
    @inlinable
    public func createThingType(_ input: CreateThingTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateThingTypeResponse {
        try await self.client.execute(
            operation: "CreateThingType", 
            path: "/thing-types/{thingTypeName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new thing type. If this call is made multiple times using
    /// 			the same thing type name and configuration, the call will succeed. If this call is made with
    /// 			the same thing type name but different configuration a ResourceAlreadyExistsException is thrown.
    /// 		 Requires permission to access the CreateThingType action.
    ///
    /// Parameters:
    ///   - tags: Metadata which can be used to manage the thing type.
    ///   - thingTypeName: The name of the thing type.
    ///   - thingTypeProperties: The ThingTypeProperties for the thing type to create. It contains information about
    ///   - logger: Logger use during operation
    @inlinable
    public func createThingType(
        tags: [Tag]? = nil,
        thingTypeName: String,
        thingTypeProperties: ThingTypeProperties? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateThingTypeResponse {
        let input = CreateThingTypeRequest(
            tags: tags, 
            thingTypeName: thingTypeName, 
            thingTypeProperties: thingTypeProperties
        )
        return try await self.createThingType(input, logger: logger)
    }

    /// Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule. Requires permission to access the CreateTopicRule action.
    @Sendable
    @inlinable
    public func createTopicRule(_ input: CreateTopicRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CreateTopicRule", 
            path: "/rules/{ruleName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule. Requires permission to access the CreateTopicRule action.
    ///
    /// Parameters:
    ///   - ruleName: The name of the rule.
    ///   - tags: Metadata which can be used to manage the topic rule.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - topicRulePayload: The rule payload.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTopicRule(
        ruleName: String,
        tags: String? = nil,
        topicRulePayload: TopicRulePayload,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CreateTopicRuleRequest(
            ruleName: ruleName, 
            tags: tags, 
            topicRulePayload: topicRulePayload
        )
        return try await self.createTopicRule(input, logger: logger)
    }

    /// Creates a topic rule destination. The destination must be confirmed prior to use. Requires permission to access the CreateTopicRuleDestination action.
    @Sendable
    @inlinable
    public func createTopicRuleDestination(_ input: CreateTopicRuleDestinationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTopicRuleDestinationResponse {
        try await self.client.execute(
            operation: "CreateTopicRuleDestination", 
            path: "/destinations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a topic rule destination. The destination must be confirmed prior to use. Requires permission to access the CreateTopicRuleDestination action.
    ///
    /// Parameters:
    ///   - destinationConfiguration: The topic rule destination configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTopicRuleDestination(
        destinationConfiguration: TopicRuleDestinationConfiguration,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTopicRuleDestinationResponse {
        let input = CreateTopicRuleDestinationRequest(
            destinationConfiguration: destinationConfiguration
        )
        return try await self.createTopicRuleDestination(input, logger: logger)
    }

    /// Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to  disabled.   Requires permission to access the DeleteAccountAuditConfiguration action.
    @Sendable
    @inlinable
    public func deleteAccountAuditConfiguration(_ input: DeleteAccountAuditConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAccountAuditConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteAccountAuditConfiguration", 
            path: "/audit/configuration", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to  disabled.   Requires permission to access the DeleteAccountAuditConfiguration action.
    ///
    /// Parameters:
    ///   - deleteScheduledAudits: If true, all scheduled audits are deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAccountAuditConfiguration(
        deleteScheduledAudits: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAccountAuditConfigurationResponse {
        let input = DeleteAccountAuditConfigurationRequest(
            deleteScheduledAudits: deleteScheduledAudits
        )
        return try await self.deleteAccountAuditConfiguration(input, logger: logger)
    }

    ///  Deletes a Device Defender audit suppression.  Requires permission to access the DeleteAuditSuppression action.
    @Sendable
    @inlinable
    public func deleteAuditSuppression(_ input: DeleteAuditSuppressionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAuditSuppressionResponse {
        try await self.client.execute(
            operation: "DeleteAuditSuppression", 
            path: "/audit/suppressions/delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a Device Defender audit suppression.  Requires permission to access the DeleteAuditSuppression action.
    ///
    /// Parameters:
    ///   - checkName: 
    ///   - resourceIdentifier: 
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAuditSuppression(
        checkName: String,
        resourceIdentifier: ResourceIdentifier,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAuditSuppressionResponse {
        let input = DeleteAuditSuppressionRequest(
            checkName: checkName, 
            resourceIdentifier: resourceIdentifier
        )
        return try await self.deleteAuditSuppression(input, logger: logger)
    }

    /// Deletes an authorizer. Requires permission to access the DeleteAuthorizer action.
    @Sendable
    @inlinable
    public func deleteAuthorizer(_ input: DeleteAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAuthorizerResponse {
        try await self.client.execute(
            operation: "DeleteAuthorizer", 
            path: "/authorizer/{authorizerName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an authorizer. Requires permission to access the DeleteAuthorizer action.
    ///
    /// Parameters:
    ///   - authorizerName: The name of the authorizer to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAuthorizer(
        authorizerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAuthorizerResponse {
        let input = DeleteAuthorizerRequest(
            authorizerName: authorizerName
        )
        return try await self.deleteAuthorizer(input, logger: logger)
    }

    /// Deletes the billing group. Requires permission to access the DeleteBillingGroup action.
    @Sendable
    @inlinable
    public func deleteBillingGroup(_ input: DeleteBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBillingGroupResponse {
        try await self.client.execute(
            operation: "DeleteBillingGroup", 
            path: "/billing-groups/{billingGroupName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the billing group. Requires permission to access the DeleteBillingGroup action.
    ///
    /// Parameters:
    ///   - billingGroupName: The name of the billing group.
    ///   - expectedVersion: The expected version of the billing group. If the version of the billing group does
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBillingGroup(
        billingGroupName: String,
        expectedVersion: Int64? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBillingGroupResponse {
        let input = DeleteBillingGroupRequest(
            billingGroupName: billingGroupName, 
            expectedVersion: expectedVersion
        )
        return try await self.deleteBillingGroup(input, logger: logger)
    }

    /// Deletes a registered CA certificate. Requires permission to access the DeleteCACertificate action.
    @Sendable
    @inlinable
    public func deleteCACertificate(_ input: DeleteCACertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCACertificateResponse {
        try await self.client.execute(
            operation: "DeleteCACertificate", 
            path: "/cacertificate/{certificateId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a registered CA certificate. Requires permission to access the DeleteCACertificate action.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCACertificate(
        certificateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCACertificateResponse {
        let input = DeleteCACertificateRequest(
            certificateId: certificateId
        )
        return try await self.deleteCACertificate(input, logger: logger)
    }

    /// Deletes the specified certificate. A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the DetachPolicy action to detach all policies. Next, use the UpdateCertificate action to set the certificate to the INACTIVE status. Requires permission to access the DeleteCertificate action.
    @Sendable
    @inlinable
    public func deleteCertificate(_ input: DeleteCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteCertificate", 
            path: "/certificates/{certificateId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified certificate. A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the DetachPolicy action to detach all policies. Next, use the UpdateCertificate action to set the certificate to the INACTIVE status. Requires permission to access the DeleteCertificate action.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - forceDelete: Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCertificate(
        certificateId: String,
        forceDelete: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteCertificateRequest(
            certificateId: certificateId, 
            forceDelete: forceDelete
        )
        return try await self.deleteCertificate(input, logger: logger)
    }

    /// Deletes a certificate provider. Requires permission to access the DeleteCertificateProvider action.  If you delete the certificate provider resource, the behavior of CreateCertificateFromCsr will resume, and IoT will create certificates signed by IoT from a certificate signing request (CSR).
    @Sendable
    @inlinable
    public func deleteCertificateProvider(_ input: DeleteCertificateProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCertificateProviderResponse {
        try await self.client.execute(
            operation: "DeleteCertificateProvider", 
            path: "/certificate-providers/{certificateProviderName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a certificate provider. Requires permission to access the DeleteCertificateProvider action.  If you delete the certificate provider resource, the behavior of CreateCertificateFromCsr will resume, and IoT will create certificates signed by IoT from a certificate signing request (CSR).
    ///
    /// Parameters:
    ///   - certificateProviderName: The name of the certificate provider.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCertificateProvider(
        certificateProviderName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCertificateProviderResponse {
        let input = DeleteCertificateProviderRequest(
            certificateProviderName: certificateProviderName
        )
        return try await self.deleteCertificateProvider(input, logger: logger)
    }

    /// Delete a command resource.
    @Sendable
    @inlinable
    public func deleteCommand(_ input: DeleteCommandRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCommandResponse {
        try await self.client.execute(
            operation: "DeleteCommand", 
            path: "/commands/{commandId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a command resource.
    ///
    /// Parameters:
    ///   - commandId: The unique identifier of the command to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCommand(
        commandId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCommandResponse {
        let input = DeleteCommandRequest(
            commandId: commandId
        )
        return try await self.deleteCommand(input, logger: logger)
    }

    /// Delete a command execution.  Only command executions that enter a terminal state can be deleted from your account.
    @Sendable
    @inlinable
    public func deleteCommandExecution(_ input: DeleteCommandExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCommandExecutionResponse {
        try await self.client.execute(
            operation: "DeleteCommandExecution", 
            path: "/command-executions/{executionId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a command execution.  Only command executions that enter a terminal state can be deleted from your account.
    ///
    /// Parameters:
    ///   - executionId: The unique identifier of the command execution that you want to delete from your account.
    ///   - targetArn: The Amazon Resource Number (ARN) of the target device for which you want to delete command executions.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCommandExecution(
        executionId: String,
        targetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCommandExecutionResponse {
        let input = DeleteCommandExecutionRequest(
            executionId: executionId, 
            targetArn: targetArn
        )
        return try await self.deleteCommandExecution(input, logger: logger)
    }

    ///  Deletes a Device Defender detect custom metric.  Requires permission to access the DeleteCustomMetric action.  Before you can delete a custom metric, you must first remove the custom metric from all security profiles it's a part of. The security profile associated with the custom metric can be found using the ListSecurityProfiles API with metricName set to your custom metric name.
    @Sendable
    @inlinable
    public func deleteCustomMetric(_ input: DeleteCustomMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCustomMetricResponse {
        try await self.client.execute(
            operation: "DeleteCustomMetric", 
            path: "/custom-metric/{metricName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a Device Defender detect custom metric.  Requires permission to access the DeleteCustomMetric action.  Before you can delete a custom metric, you must first remove the custom metric from all security profiles it's a part of. The security profile associated with the custom metric can be found using the ListSecurityProfiles API with metricName set to your custom metric name.
    ///
    /// Parameters:
    ///   - metricName:  The name of the custom metric.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCustomMetric(
        metricName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCustomMetricResponse {
        let input = DeleteCustomMetricRequest(
            metricName: metricName
        )
        return try await self.deleteCustomMetric(input, logger: logger)
    }

    /// Removes the specified dimension from your Amazon Web Services accounts. Requires permission to access the DeleteDimension action.
    @Sendable
    @inlinable
    public func deleteDimension(_ input: DeleteDimensionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDimensionResponse {
        try await self.client.execute(
            operation: "DeleteDimension", 
            path: "/dimensions/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified dimension from your Amazon Web Services accounts. Requires permission to access the DeleteDimension action.
    ///
    /// Parameters:
    ///   - name: The unique identifier for the dimension that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDimension(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDimensionResponse {
        let input = DeleteDimensionRequest(
            name: name
        )
        return try await self.deleteDimension(input, logger: logger)
    }

    /// Deletes the specified domain configuration. Requires permission to access the DeleteDomainConfiguration action.
    @Sendable
    @inlinable
    public func deleteDomainConfiguration(_ input: DeleteDomainConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDomainConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteDomainConfiguration", 
            path: "/domainConfigurations/{domainConfigurationName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified domain configuration. Requires permission to access the DeleteDomainConfiguration action.
    ///
    /// Parameters:
    ///   - domainConfigurationName: The name of the domain configuration to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDomainConfiguration(
        domainConfigurationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDomainConfigurationResponse {
        let input = DeleteDomainConfigurationRequest(
            domainConfigurationName: domainConfigurationName
        )
        return try await self.deleteDomainConfiguration(input, logger: logger)
    }

    /// Deletes a dynamic thing group. Requires permission to access the DeleteDynamicThingGroup action.
    @Sendable
    @inlinable
    public func deleteDynamicThingGroup(_ input: DeleteDynamicThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDynamicThingGroupResponse {
        try await self.client.execute(
            operation: "DeleteDynamicThingGroup", 
            path: "/dynamic-thing-groups/{thingGroupName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a dynamic thing group. Requires permission to access the DeleteDynamicThingGroup action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the dynamic thing group to delete.
    ///   - thingGroupName: The name of the dynamic thing group to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDynamicThingGroup(
        expectedVersion: Int64? = nil,
        thingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDynamicThingGroupResponse {
        let input = DeleteDynamicThingGroupRequest(
            expectedVersion: expectedVersion, 
            thingGroupName: thingGroupName
        )
        return try await self.deleteDynamicThingGroup(input, logger: logger)
    }

    /// Deletes the specified fleet metric.  Returns successfully with no error if the deletion is successful or you specify a fleet metric that doesn't exist. Requires permission to access the DeleteFleetMetric action.
    @Sendable
    @inlinable
    public func deleteFleetMetric(_ input: DeleteFleetMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteFleetMetric", 
            path: "/fleet-metric/{metricName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified fleet metric.  Returns successfully with no error if the deletion is successful or you specify a fleet metric that doesn't exist. Requires permission to access the DeleteFleetMetric action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the fleet metric to delete.
    ///   - metricName: The name of the fleet metric to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFleetMetric(
        expectedVersion: Int64? = nil,
        metricName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteFleetMetricRequest(
            expectedVersion: expectedVersion, 
            metricName: metricName
        )
        return try await self.deleteFleetMetric(input, logger: logger)
    }

    /// Deletes a job and its related job executions. Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error. Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur. Requires permission to access the DeleteJob action.
    @Sendable
    @inlinable
    public func deleteJob(_ input: DeleteJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteJob", 
            path: "/jobs/{jobId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a job and its related job executions. Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error. Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur. Requires permission to access the DeleteJob action.
    ///
    /// Parameters:
    ///   - force: (Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.  Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.
    ///   - jobId: The ID of the job to be deleted. After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJob(
        force: Bool? = nil,
        jobId: String,
        namespaceId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteJobRequest(
            force: force, 
            jobId: jobId, 
            namespaceId: namespaceId
        )
        return try await self.deleteJob(input, logger: logger)
    }

    /// Deletes a job execution. Requires permission to access the DeleteJobExecution action.
    @Sendable
    @inlinable
    public func deleteJobExecution(_ input: DeleteJobExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteJobExecution", 
            path: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a job execution. Requires permission to access the DeleteJobExecution action.
    ///
    /// Parameters:
    ///   - executionNumber: The ID of the job execution to be deleted. The executionNumber refers to the execution of a particular job on a particular device. Note that once a job execution is deleted, the executionNumber may be reused by IoT, so be sure you get and use the correct value here.
    ///   - force: (Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.  Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.
    ///   - jobId: The ID of the job whose execution on a particular device will be deleted.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - thingName: The name of the thing whose job execution will be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJobExecution(
        executionNumber: Int64,
        force: Bool? = nil,
        jobId: String,
        namespaceId: String? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteJobExecutionRequest(
            executionNumber: executionNumber, 
            force: force, 
            jobId: jobId, 
            namespaceId: namespaceId, 
            thingName: thingName
        )
        return try await self.deleteJobExecution(input, logger: logger)
    }

    /// Deletes the specified job template.
    @Sendable
    @inlinable
    public func deleteJobTemplate(_ input: DeleteJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteJobTemplate", 
            path: "/job-templates/{jobTemplateId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified job template.
    ///
    /// Parameters:
    ///   - jobTemplateId: The unique identifier of the job template to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJobTemplate(
        jobTemplateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteJobTemplateRequest(
            jobTemplateId: jobTemplateId
        )
        return try await self.deleteJobTemplate(input, logger: logger)
    }

    /// Deletes a defined mitigation action from your Amazon Web Services accounts. Requires permission to access the DeleteMitigationAction action.
    @Sendable
    @inlinable
    public func deleteMitigationAction(_ input: DeleteMitigationActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMitigationActionResponse {
        try await self.client.execute(
            operation: "DeleteMitigationAction", 
            path: "/mitigationactions/actions/{actionName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a defined mitigation action from your Amazon Web Services accounts. Requires permission to access the DeleteMitigationAction action.
    ///
    /// Parameters:
    ///   - actionName: The name of the mitigation action that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMitigationAction(
        actionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMitigationActionResponse {
        let input = DeleteMitigationActionRequest(
            actionName: actionName
        )
        return try await self.deleteMitigationAction(input, logger: logger)
    }

    /// Delete an OTA update. Requires permission to access the DeleteOTAUpdate action.
    @Sendable
    @inlinable
    public func deleteOTAUpdate(_ input: DeleteOTAUpdateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteOTAUpdateResponse {
        try await self.client.execute(
            operation: "DeleteOTAUpdate", 
            path: "/otaUpdates/{otaUpdateId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an OTA update. Requires permission to access the DeleteOTAUpdate action.
    ///
    /// Parameters:
    ///   - deleteStream: When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.
    ///   - forceDeleteAWSJob: When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the  job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.
    ///   - otaUpdateId: The ID of the OTA update to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteOTAUpdate(
        deleteStream: Bool? = nil,
        forceDeleteAWSJob: Bool? = nil,
        otaUpdateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteOTAUpdateResponse {
        let input = DeleteOTAUpdateRequest(
            deleteStream: deleteStream, 
            forceDeleteAWSJob: forceDeleteAWSJob, 
            otaUpdateId: otaUpdateId
        )
        return try await self.deleteOTAUpdate(input, logger: logger)
    }

    /// Deletes a specific version from a software package.  Note: All package versions must be deleted before deleting the software package. Requires permission to access the DeletePackageVersion action.
    @Sendable
    @inlinable
    public func deletePackage(_ input: DeletePackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePackageResponse {
        try await self.client.execute(
            operation: "DeletePackage", 
            path: "/packages/{packageName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific version from a software package.  Note: All package versions must be deleted before deleting the software package. Requires permission to access the DeletePackageVersion action.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - packageName: The name of the target software package.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePackage(
        clientToken: String? = DeletePackageRequest.idempotencyToken(),
        packageName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePackageResponse {
        let input = DeletePackageRequest(
            clientToken: clientToken, 
            packageName: packageName
        )
        return try await self.deletePackage(input, logger: logger)
    }

    /// Deletes a specific version from a software package.  Note: If a package version is designated as default, you must remove the designation from the software package using the UpdatePackage action.
    @Sendable
    @inlinable
    public func deletePackageVersion(_ input: DeletePackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePackageVersionResponse {
        try await self.client.execute(
            operation: "DeletePackageVersion", 
            path: "/packages/{packageName}/versions/{versionName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific version from a software package.  Note: If a package version is designated as default, you must remove the designation from the software package using the UpdatePackage action.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - packageName: The name of the associated software package.
    ///   - versionName: The name of the target package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePackageVersion(
        clientToken: String? = DeletePackageVersionRequest.idempotencyToken(),
        packageName: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePackageVersionResponse {
        let input = DeletePackageVersionRequest(
            clientToken: clientToken, 
            packageName: packageName, 
            versionName: versionName
        )
        return try await self.deletePackageVersion(input, logger: logger)
    }

    /// Deletes the specified policy. A policy cannot be deleted if it has non-default versions or it is attached to any certificate. To delete a policy, use the DeletePolicyVersion action to delete all non-default versions of the policy; use the DetachPolicy action to detach the policy from any certificate; and then use the DeletePolicy action to delete the policy. When a policy is deleted using DeletePolicy, its default version is deleted with it.  Because of the distributed nature of Amazon Web Services, it can take up to five minutes after a policy is detached before it's ready to be deleted.  Requires permission to access the DeletePolicy action.
    @Sendable
    @inlinable
    public func deletePolicy(_ input: DeletePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeletePolicy", 
            path: "/policies/{policyName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified policy. A policy cannot be deleted if it has non-default versions or it is attached to any certificate. To delete a policy, use the DeletePolicyVersion action to delete all non-default versions of the policy; use the DetachPolicy action to detach the policy from any certificate; and then use the DeletePolicy action to delete the policy. When a policy is deleted using DeletePolicy, its default version is deleted with it.  Because of the distributed nature of Amazon Web Services, it can take up to five minutes after a policy is detached before it's ready to be deleted.  Requires permission to access the DeletePolicy action.
    ///
    /// Parameters:
    ///   - policyName: The name of the policy to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicy(
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeletePolicyRequest(
            policyName: policyName
        )
        return try await self.deletePolicy(input, logger: logger)
    }

    /// Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this action. To delete the default version of a policy, use DeletePolicy. To find out which version of a policy is marked as the default version, use ListPolicyVersions. Requires permission to access the DeletePolicyVersion action.
    @Sendable
    @inlinable
    public func deletePolicyVersion(_ input: DeletePolicyVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeletePolicyVersion", 
            path: "/policies/{policyName}/version/{policyVersionId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this action. To delete the default version of a policy, use DeletePolicy. To find out which version of a policy is marked as the default version, use ListPolicyVersions. Requires permission to access the DeletePolicyVersion action.
    ///
    /// Parameters:
    ///   - policyName: The name of the policy.
    ///   - policyVersionId: The policy version ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicyVersion(
        policyName: String,
        policyVersionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeletePolicyVersionRequest(
            policyName: policyName, 
            policyVersionId: policyVersionId
        )
        return try await self.deletePolicyVersion(input, logger: logger)
    }

    /// Deletes a provisioning template. Requires permission to access the DeleteProvisioningTemplate action.
    @Sendable
    @inlinable
    public func deleteProvisioningTemplate(_ input: DeleteProvisioningTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteProvisioningTemplateResponse {
        try await self.client.execute(
            operation: "DeleteProvisioningTemplate", 
            path: "/provisioning-templates/{templateName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a provisioning template. Requires permission to access the DeleteProvisioningTemplate action.
    ///
    /// Parameters:
    ///   - templateName: The name of the fleet provision template to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteProvisioningTemplate(
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteProvisioningTemplateResponse {
        let input = DeleteProvisioningTemplateRequest(
            templateName: templateName
        )
        return try await self.deleteProvisioningTemplate(input, logger: logger)
    }

    /// Deletes a provisioning template version. Requires permission to access the DeleteProvisioningTemplateVersion action.
    @Sendable
    @inlinable
    public func deleteProvisioningTemplateVersion(_ input: DeleteProvisioningTemplateVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteProvisioningTemplateVersionResponse {
        try await self.client.execute(
            operation: "DeleteProvisioningTemplateVersion", 
            path: "/provisioning-templates/{templateName}/versions/{versionId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a provisioning template version. Requires permission to access the DeleteProvisioningTemplateVersion action.
    ///
    /// Parameters:
    ///   - templateName: The name of the provisioning template version to delete.
    ///   - versionId: The provisioning template version ID to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteProvisioningTemplateVersion(
        templateName: String,
        versionId: Int,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteProvisioningTemplateVersionResponse {
        let input = DeleteProvisioningTemplateVersionRequest(
            templateName: templateName, 
            versionId: versionId
        )
        return try await self.deleteProvisioningTemplateVersion(input, logger: logger)
    }

    /// Deletes a CA certificate registration code. Requires permission to access the DeleteRegistrationCode action.
    @Sendable
    @inlinable
    public func deleteRegistrationCode(_ input: DeleteRegistrationCodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRegistrationCodeResponse {
        try await self.client.execute(
            operation: "DeleteRegistrationCode", 
            path: "/registrationcode", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a CA certificate registration code. Requires permission to access the DeleteRegistrationCode action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRegistrationCode(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRegistrationCodeResponse {
        let input = DeleteRegistrationCodeRequest(
        )
        return try await self.deleteRegistrationCode(input, logger: logger)
    }

    /// Deletes a role alias Requires permission to access the DeleteRoleAlias action.
    @Sendable
    @inlinable
    public func deleteRoleAlias(_ input: DeleteRoleAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRoleAliasResponse {
        try await self.client.execute(
            operation: "DeleteRoleAlias", 
            path: "/role-aliases/{roleAlias}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a role alias Requires permission to access the DeleteRoleAlias action.
    ///
    /// Parameters:
    ///   - roleAlias: The role alias to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRoleAlias(
        roleAlias: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRoleAliasResponse {
        let input = DeleteRoleAliasRequest(
            roleAlias: roleAlias
        )
        return try await self.deleteRoleAlias(input, logger: logger)
    }

    /// Deletes a scheduled audit. Requires permission to access the DeleteScheduledAudit action.
    @Sendable
    @inlinable
    public func deleteScheduledAudit(_ input: DeleteScheduledAuditRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteScheduledAuditResponse {
        try await self.client.execute(
            operation: "DeleteScheduledAudit", 
            path: "/audit/scheduledaudits/{scheduledAuditName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a scheduled audit. Requires permission to access the DeleteScheduledAudit action.
    ///
    /// Parameters:
    ///   - scheduledAuditName: The name of the scheduled audit you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteScheduledAudit(
        scheduledAuditName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteScheduledAuditResponse {
        let input = DeleteScheduledAuditRequest(
            scheduledAuditName: scheduledAuditName
        )
        return try await self.deleteScheduledAudit(input, logger: logger)
    }

    /// Deletes a Device Defender security profile. Requires permission to access the DeleteSecurityProfile action.
    @Sendable
    @inlinable
    public func deleteSecurityProfile(_ input: DeleteSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSecurityProfileResponse {
        try await self.client.execute(
            operation: "DeleteSecurityProfile", 
            path: "/security-profiles/{securityProfileName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a Device Defender security profile. Requires permission to access the DeleteSecurityProfile action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a VersionConflictException is thrown.
    ///   - securityProfileName: The name of the security profile to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSecurityProfile(
        expectedVersion: Int64? = nil,
        securityProfileName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSecurityProfileResponse {
        let input = DeleteSecurityProfileRequest(
            expectedVersion: expectedVersion, 
            securityProfileName: securityProfileName
        )
        return try await self.deleteSecurityProfile(input, logger: logger)
    }

    /// Deletes a stream. Requires permission to access the DeleteStream action.
    @Sendable
    @inlinable
    public func deleteStream(_ input: DeleteStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStreamResponse {
        try await self.client.execute(
            operation: "DeleteStream", 
            path: "/streams/{streamId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a stream. Requires permission to access the DeleteStream action.
    ///
    /// Parameters:
    ///   - streamId: The stream ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStream(
        streamId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStreamResponse {
        let input = DeleteStreamRequest(
            streamId: streamId
        )
        return try await self.deleteStream(input, logger: logger)
    }

    /// Deletes the specified thing. Returns successfully with no error if the deletion is
    /// 			successful or you specify a thing that doesn't exist. Requires permission to access the DeleteThing action.
    @Sendable
    @inlinable
    public func deleteThing(_ input: DeleteThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteThingResponse {
        try await self.client.execute(
            operation: "DeleteThing", 
            path: "/things/{thingName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified thing. Returns successfully with no error if the deletion is
    /// 			successful or you specify a thing that doesn't exist. Requires permission to access the DeleteThing action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the thing record in the registry. If the version of the
    ///   - thingName: The name of the thing to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteThing(
        expectedVersion: Int64? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteThingResponse {
        let input = DeleteThingRequest(
            expectedVersion: expectedVersion, 
            thingName: thingName
        )
        return try await self.deleteThing(input, logger: logger)
    }

    /// Deletes a thing group. Requires permission to access the DeleteThingGroup action.
    @Sendable
    @inlinable
    public func deleteThingGroup(_ input: DeleteThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteThingGroupResponse {
        try await self.client.execute(
            operation: "DeleteThingGroup", 
            path: "/thing-groups/{thingGroupName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a thing group. Requires permission to access the DeleteThingGroup action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the thing group to delete.
    ///   - thingGroupName: The name of the thing group to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteThingGroup(
        expectedVersion: Int64? = nil,
        thingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteThingGroupResponse {
        let input = DeleteThingGroupRequest(
            expectedVersion: expectedVersion, 
            thingGroupName: thingGroupName
        )
        return try await self.deleteThingGroup(input, logger: logger)
    }

    /// Deletes the specified thing type. You cannot delete a thing type if it has things
    /// 			associated with it. To delete a thing type, first mark it as deprecated by calling DeprecateThingType, then remove any associated things by calling UpdateThing to change the thing type on any associated thing, and
    /// 			finally use DeleteThingType to delete the thing type. Requires permission to access the DeleteThingType action.
    @Sendable
    @inlinable
    public func deleteThingType(_ input: DeleteThingTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteThingTypeResponse {
        try await self.client.execute(
            operation: "DeleteThingType", 
            path: "/thing-types/{thingTypeName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified thing type. You cannot delete a thing type if it has things
    /// 			associated with it. To delete a thing type, first mark it as deprecated by calling DeprecateThingType, then remove any associated things by calling UpdateThing to change the thing type on any associated thing, and
    /// 			finally use DeleteThingType to delete the thing type. Requires permission to access the DeleteThingType action.
    ///
    /// Parameters:
    ///   - thingTypeName: The name of the thing type.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteThingType(
        thingTypeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteThingTypeResponse {
        let input = DeleteThingTypeRequest(
            thingTypeName: thingTypeName
        )
        return try await self.deleteThingType(input, logger: logger)
    }

    /// Deletes the rule. Requires permission to access the DeleteTopicRule action.
    @Sendable
    @inlinable
    public func deleteTopicRule(_ input: DeleteTopicRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteTopicRule", 
            path: "/rules/{ruleName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the rule. Requires permission to access the DeleteTopicRule action.
    ///
    /// Parameters:
    ///   - ruleName: The name of the rule.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTopicRule(
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteTopicRuleRequest(
            ruleName: ruleName
        )
        return try await self.deleteTopicRule(input, logger: logger)
    }

    /// Deletes a topic rule destination. Requires permission to access the DeleteTopicRuleDestination action.
    @Sendable
    @inlinable
    public func deleteTopicRuleDestination(_ input: DeleteTopicRuleDestinationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTopicRuleDestinationResponse {
        try await self.client.execute(
            operation: "DeleteTopicRuleDestination", 
            path: "/destinations/{arn+}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a topic rule destination. Requires permission to access the DeleteTopicRuleDestination action.
    ///
    /// Parameters:
    ///   - arn: The ARN of the topic rule destination to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTopicRuleDestination(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTopicRuleDestinationResponse {
        let input = DeleteTopicRuleDestinationRequest(
            arn: arn
        )
        return try await self.deleteTopicRuleDestination(input, logger: logger)
    }

    /// Deletes a logging level. Requires permission to access the DeleteV2LoggingLevel action.
    @Sendable
    @inlinable
    public func deleteV2LoggingLevel(_ input: DeleteV2LoggingLevelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteV2LoggingLevel", 
            path: "/v2LoggingLevel", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a logging level. Requires permission to access the DeleteV2LoggingLevel action.
    ///
    /// Parameters:
    ///   - targetName: The name of the resource for which you are configuring logging.
    ///   - targetType: The type of resource for which you are configuring logging. Must be THING_Group.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteV2LoggingLevel(
        targetName: String,
        targetType: LogTargetType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteV2LoggingLevelRequest(
            targetName: targetName, 
            targetType: targetType
        )
        return try await self.deleteV2LoggingLevel(input, logger: logger)
    }

    /// Deprecates a thing type. You can not associate new things with deprecated thing
    /// 			type. Requires permission to access the DeprecateThingType action.
    @Sendable
    @inlinable
    public func deprecateThingType(_ input: DeprecateThingTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeprecateThingTypeResponse {
        try await self.client.execute(
            operation: "DeprecateThingType", 
            path: "/thing-types/{thingTypeName}/deprecate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deprecates a thing type. You can not associate new things with deprecated thing
    /// 			type. Requires permission to access the DeprecateThingType action.
    ///
    /// Parameters:
    ///   - thingTypeName: The name of the thing type to deprecate.
    ///   - undoDeprecate: Whether to undeprecate a deprecated thing type. If true, the thing type will not be deprecated anymore and you can
    ///   - logger: Logger use during operation
    @inlinable
    public func deprecateThingType(
        thingTypeName: String,
        undoDeprecate: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeprecateThingTypeResponse {
        let input = DeprecateThingTypeRequest(
            thingTypeName: thingTypeName, 
            undoDeprecate: undoDeprecate
        )
        return try await self.deprecateThingType(input, logger: logger)
    }

    /// Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled. Requires permission to access the DescribeAccountAuditConfiguration action.
    @Sendable
    @inlinable
    public func describeAccountAuditConfiguration(_ input: DescribeAccountAuditConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAccountAuditConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeAccountAuditConfiguration", 
            path: "/audit/configuration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled. Requires permission to access the DescribeAccountAuditConfiguration action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAccountAuditConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAccountAuditConfigurationResponse {
        let input = DescribeAccountAuditConfigurationRequest(
        )
        return try await self.describeAccountAuditConfiguration(input, logger: logger)
    }

    /// Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and the start time when the audit that returned the finding. Requires permission to access the DescribeAuditFinding action.
    @Sendable
    @inlinable
    public func describeAuditFinding(_ input: DescribeAuditFindingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAuditFindingResponse {
        try await self.client.execute(
            operation: "DescribeAuditFinding", 
            path: "/audit/findings/{findingId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and the start time when the audit that returned the finding. Requires permission to access the DescribeAuditFinding action.
    ///
    /// Parameters:
    ///   - findingId: A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAuditFinding(
        findingId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAuditFindingResponse {
        let input = DescribeAuditFindingRequest(
            findingId: findingId
        )
        return try await self.describeAuditFinding(input, logger: logger)
    }

    /// Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
    @Sendable
    @inlinable
    public func describeAuditMitigationActionsTask(_ input: DescribeAuditMitigationActionsTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAuditMitigationActionsTaskResponse {
        try await self.client.execute(
            operation: "DescribeAuditMitigationActionsTask", 
            path: "/audit/mitigationactions/tasks/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
    ///
    /// Parameters:
    ///   - taskId: The unique identifier for the audit mitigation task.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAuditMitigationActionsTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAuditMitigationActionsTaskResponse {
        let input = DescribeAuditMitigationActionsTaskRequest(
            taskId: taskId
        )
        return try await self.describeAuditMitigationActionsTask(input, logger: logger)
    }

    ///  Gets information about a Device Defender audit suppression.
    @Sendable
    @inlinable
    public func describeAuditSuppression(_ input: DescribeAuditSuppressionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAuditSuppressionResponse {
        try await self.client.execute(
            operation: "DescribeAuditSuppression", 
            path: "/audit/suppressions/describe", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Gets information about a Device Defender audit suppression.
    ///
    /// Parameters:
    ///   - checkName: 
    ///   - resourceIdentifier: 
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAuditSuppression(
        checkName: String,
        resourceIdentifier: ResourceIdentifier,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAuditSuppressionResponse {
        let input = DescribeAuditSuppressionRequest(
            checkName: checkName, 
            resourceIdentifier: resourceIdentifier
        )
        return try await self.describeAuditSuppression(input, logger: logger)
    }

    /// Gets information about a Device Defender audit. Requires permission to access the DescribeAuditTask action.
    @Sendable
    @inlinable
    public func describeAuditTask(_ input: DescribeAuditTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAuditTaskResponse {
        try await self.client.execute(
            operation: "DescribeAuditTask", 
            path: "/audit/tasks/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a Device Defender audit. Requires permission to access the DescribeAuditTask action.
    ///
    /// Parameters:
    ///   - taskId: The ID of the audit whose information you want to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAuditTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAuditTaskResponse {
        let input = DescribeAuditTaskRequest(
            taskId: taskId
        )
        return try await self.describeAuditTask(input, logger: logger)
    }

    /// Describes an authorizer. Requires permission to access the DescribeAuthorizer action.
    @Sendable
    @inlinable
    public func describeAuthorizer(_ input: DescribeAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAuthorizerResponse {
        try await self.client.execute(
            operation: "DescribeAuthorizer", 
            path: "/authorizer/{authorizerName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an authorizer. Requires permission to access the DescribeAuthorizer action.
    ///
    /// Parameters:
    ///   - authorizerName: The name of the authorizer to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAuthorizer(
        authorizerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAuthorizerResponse {
        let input = DescribeAuthorizerRequest(
            authorizerName: authorizerName
        )
        return try await self.describeAuthorizer(input, logger: logger)
    }

    /// Returns information about a billing group. Requires permission to access the DescribeBillingGroup action.
    @Sendable
    @inlinable
    public func describeBillingGroup(_ input: DescribeBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBillingGroupResponse {
        try await self.client.execute(
            operation: "DescribeBillingGroup", 
            path: "/billing-groups/{billingGroupName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a billing group. Requires permission to access the DescribeBillingGroup action.
    ///
    /// Parameters:
    ///   - billingGroupName: The name of the billing group.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBillingGroup(
        billingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBillingGroupResponse {
        let input = DescribeBillingGroupRequest(
            billingGroupName: billingGroupName
        )
        return try await self.describeBillingGroup(input, logger: logger)
    }

    /// Describes a registered CA certificate. Requires permission to access the DescribeCACertificate action.
    @Sendable
    @inlinable
    public func describeCACertificate(_ input: DescribeCACertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCACertificateResponse {
        try await self.client.execute(
            operation: "DescribeCACertificate", 
            path: "/cacertificate/{certificateId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a registered CA certificate. Requires permission to access the DescribeCACertificate action.
    ///
    /// Parameters:
    ///   - certificateId: The CA certificate identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCACertificate(
        certificateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeCACertificateResponse {
        let input = DescribeCACertificateRequest(
            certificateId: certificateId
        )
        return try await self.describeCACertificate(input, logger: logger)
    }

    /// Gets information about the specified certificate. Requires permission to access the DescribeCertificate action.
    @Sendable
    @inlinable
    public func describeCertificate(_ input: DescribeCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCertificateResponse {
        try await self.client.execute(
            operation: "DescribeCertificate", 
            path: "/certificates/{certificateId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified certificate. Requires permission to access the DescribeCertificate action.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCertificate(
        certificateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeCertificateResponse {
        let input = DescribeCertificateRequest(
            certificateId: certificateId
        )
        return try await self.describeCertificate(input, logger: logger)
    }

    /// Describes a certificate provider. Requires permission to access the DescribeCertificateProvider action.
    @Sendable
    @inlinable
    public func describeCertificateProvider(_ input: DescribeCertificateProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCertificateProviderResponse {
        try await self.client.execute(
            operation: "DescribeCertificateProvider", 
            path: "/certificate-providers/{certificateProviderName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a certificate provider. Requires permission to access the DescribeCertificateProvider action.
    ///
    /// Parameters:
    ///   - certificateProviderName: The name of the certificate provider.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCertificateProvider(
        certificateProviderName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeCertificateProviderResponse {
        let input = DescribeCertificateProviderRequest(
            certificateProviderName: certificateProviderName
        )
        return try await self.describeCertificateProvider(input, logger: logger)
    }

    ///  Gets information about a Device Defender detect custom metric.  Requires permission to access the DescribeCustomMetric action.
    @Sendable
    @inlinable
    public func describeCustomMetric(_ input: DescribeCustomMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCustomMetricResponse {
        try await self.client.execute(
            operation: "DescribeCustomMetric", 
            path: "/custom-metric/{metricName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Gets information about a Device Defender detect custom metric.  Requires permission to access the DescribeCustomMetric action.
    ///
    /// Parameters:
    ///   - metricName:  The name of the custom metric.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCustomMetric(
        metricName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeCustomMetricResponse {
        let input = DescribeCustomMetricRequest(
            metricName: metricName
        )
        return try await self.describeCustomMetric(input, logger: logger)
    }

    /// Describes the default authorizer. Requires permission to access the DescribeDefaultAuthorizer action.
    @Sendable
    @inlinable
    public func describeDefaultAuthorizer(_ input: DescribeDefaultAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDefaultAuthorizerResponse {
        try await self.client.execute(
            operation: "DescribeDefaultAuthorizer", 
            path: "/default-authorizer", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the default authorizer. Requires permission to access the DescribeDefaultAuthorizer action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDefaultAuthorizer(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDefaultAuthorizerResponse {
        let input = DescribeDefaultAuthorizerRequest(
        )
        return try await self.describeDefaultAuthorizer(input, logger: logger)
    }

    ///  Gets information about a Device Defender ML Detect mitigation action.  Requires permission to access the DescribeDetectMitigationActionsTask action.
    @Sendable
    @inlinable
    public func describeDetectMitigationActionsTask(_ input: DescribeDetectMitigationActionsTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDetectMitigationActionsTaskResponse {
        try await self.client.execute(
            operation: "DescribeDetectMitigationActionsTask", 
            path: "/detect/mitigationactions/tasks/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Gets information about a Device Defender ML Detect mitigation action.  Requires permission to access the DescribeDetectMitigationActionsTask action.
    ///
    /// Parameters:
    ///   - taskId:  The unique identifier of the task.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDetectMitigationActionsTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDetectMitigationActionsTaskResponse {
        let input = DescribeDetectMitigationActionsTaskRequest(
            taskId: taskId
        )
        return try await self.describeDetectMitigationActionsTask(input, logger: logger)
    }

    /// Provides details about a dimension that is defined in your Amazon Web Services accounts. Requires permission to access the DescribeDimension action.
    @Sendable
    @inlinable
    public func describeDimension(_ input: DescribeDimensionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDimensionResponse {
        try await self.client.execute(
            operation: "DescribeDimension", 
            path: "/dimensions/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides details about a dimension that is defined in your Amazon Web Services accounts. Requires permission to access the DescribeDimension action.
    ///
    /// Parameters:
    ///   - name: The unique identifier for the dimension.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDimension(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDimensionResponse {
        let input = DescribeDimensionRequest(
            name: name
        )
        return try await self.describeDimension(input, logger: logger)
    }

    /// Gets summary information about a domain configuration. Requires permission to access the DescribeDomainConfiguration action.
    @Sendable
    @inlinable
    public func describeDomainConfiguration(_ input: DescribeDomainConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDomainConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeDomainConfiguration", 
            path: "/domainConfigurations/{domainConfigurationName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets summary information about a domain configuration. Requires permission to access the DescribeDomainConfiguration action.
    ///
    /// Parameters:
    ///   - domainConfigurationName: The name of the domain configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDomainConfiguration(
        domainConfigurationName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDomainConfigurationResponse {
        let input = DescribeDomainConfigurationRequest(
            domainConfigurationName: domainConfigurationName
        )
        return try await self.describeDomainConfiguration(input, logger: logger)
    }

    /// Returns or creates a unique endpoint specific to the Amazon Web Services account making the call.  The first time DescribeEndpoint is called, an endpoint is created. All subsequent calls to DescribeEndpoint return the same endpoint.  Requires permission to access the DescribeEndpoint action.
    @Sendable
    @inlinable
    public func describeEndpoint(_ input: DescribeEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEndpointResponse {
        try await self.client.execute(
            operation: "DescribeEndpoint", 
            path: "/endpoint", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns or creates a unique endpoint specific to the Amazon Web Services account making the call.  The first time DescribeEndpoint is called, an endpoint is created. All subsequent calls to DescribeEndpoint return the same endpoint.  Requires permission to access the DescribeEndpoint action.
    ///
    /// Parameters:
    ///   - endpointType: The endpoint type. Valid endpoint types include:    iot:Data - Returns a VeriSign signed data endpoint.      iot:Data-ATS - Returns an ATS signed data endpoint.      iot:CredentialProvider - Returns an IoT credentials provider API endpoint.      iot:Jobs - Returns an IoT device management Jobs API endpoint.   We strongly recommend that customers use the newer iot:Data-ATS endpoint type to avoid  issues related to the widespread distrust of Symantec certificate authorities. ATS Signed Certificates are more secure and are trusted by most popular browsers.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeEndpoint(
        endpointType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeEndpointResponse {
        let input = DescribeEndpointRequest(
            endpointType: endpointType
        )
        return try await self.describeEndpoint(input, logger: logger)
    }

    /// Describes event configurations. Requires permission to access the DescribeEventConfigurations action.
    @Sendable
    @inlinable
    public func describeEventConfigurations(_ input: DescribeEventConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEventConfigurationsResponse {
        try await self.client.execute(
            operation: "DescribeEventConfigurations", 
            path: "/event-configurations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes event configurations. Requires permission to access the DescribeEventConfigurations action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func describeEventConfigurations(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeEventConfigurationsResponse {
        let input = DescribeEventConfigurationsRequest(
        )
        return try await self.describeEventConfigurations(input, logger: logger)
    }

    /// Gets information about the specified fleet metric. Requires permission to access the DescribeFleetMetric action.
    @Sendable
    @inlinable
    public func describeFleetMetric(_ input: DescribeFleetMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFleetMetricResponse {
        try await self.client.execute(
            operation: "DescribeFleetMetric", 
            path: "/fleet-metric/{metricName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified fleet metric. Requires permission to access the DescribeFleetMetric action.
    ///
    /// Parameters:
    ///   - metricName: The name of the fleet metric to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeFleetMetric(
        metricName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeFleetMetricResponse {
        let input = DescribeFleetMetricRequest(
            metricName: metricName
        )
        return try await self.describeFleetMetric(input, logger: logger)
    }

    /// Describes a search index. Requires permission to access the DescribeIndex action.
    @Sendable
    @inlinable
    public func describeIndex(_ input: DescribeIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeIndexResponse {
        try await self.client.execute(
            operation: "DescribeIndex", 
            path: "/indices/{indexName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a search index. Requires permission to access the DescribeIndex action.
    ///
    /// Parameters:
    ///   - indexName: The index name.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeIndex(
        indexName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeIndexResponse {
        let input = DescribeIndexRequest(
            indexName: indexName
        )
        return try await self.describeIndex(input, logger: logger)
    }

    /// Describes a job. Requires permission to access the DescribeJob action.
    @Sendable
    @inlinable
    public func describeJob(_ input: DescribeJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobResponse {
        try await self.client.execute(
            operation: "DescribeJob", 
            path: "/jobs/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a job. Requires permission to access the DescribeJob action.
    ///
    /// Parameters:
    ///   - beforeSubstitution: Provides a view of the job document before and after the substitution parameters have been resolved with their exact values.
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJob(
        beforeSubstitution: Bool? = nil,
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobResponse {
        let input = DescribeJobRequest(
            beforeSubstitution: beforeSubstitution, 
            jobId: jobId
        )
        return try await self.describeJob(input, logger: logger)
    }

    /// Describes a job execution. Requires permission to access the DescribeJobExecution action.
    @Sendable
    @inlinable
    public func describeJobExecution(_ input: DescribeJobExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobExecutionResponse {
        try await self.client.execute(
            operation: "DescribeJobExecution", 
            path: "/things/{thingName}/jobs/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a job execution. Requires permission to access the DescribeJobExecution action.
    ///
    /// Parameters:
    ///   - executionNumber: A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - thingName: The name of the thing on which the job execution is running.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobExecution(
        executionNumber: Int64? = nil,
        jobId: String,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobExecutionResponse {
        let input = DescribeJobExecutionRequest(
            executionNumber: executionNumber, 
            jobId: jobId, 
            thingName: thingName
        )
        return try await self.describeJobExecution(input, logger: logger)
    }

    /// Returns information about a job template.
    @Sendable
    @inlinable
    public func describeJobTemplate(_ input: DescribeJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobTemplateResponse {
        try await self.client.execute(
            operation: "DescribeJobTemplate", 
            path: "/job-templates/{jobTemplateId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a job template.
    ///
    /// Parameters:
    ///   - jobTemplateId: The unique identifier of the job template.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobTemplate(
        jobTemplateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobTemplateResponse {
        let input = DescribeJobTemplateRequest(
            jobTemplateId: jobTemplateId
        )
        return try await self.describeJobTemplate(input, logger: logger)
    }

    /// View details of a managed job template.
    @Sendable
    @inlinable
    public func describeManagedJobTemplate(_ input: DescribeManagedJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeManagedJobTemplateResponse {
        try await self.client.execute(
            operation: "DescribeManagedJobTemplate", 
            path: "/managed-job-templates/{templateName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// View details of a managed job template.
    ///
    /// Parameters:
    ///   - templateName: The unique name of a managed job template, which is required.
    ///   - templateVersion: An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeManagedJobTemplate(
        templateName: String,
        templateVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeManagedJobTemplateResponse {
        let input = DescribeManagedJobTemplateRequest(
            templateName: templateName, 
            templateVersion: templateVersion
        )
        return try await self.describeManagedJobTemplate(input, logger: logger)
    }

    /// Gets information about a mitigation action. Requires permission to access the DescribeMitigationAction action.
    @Sendable
    @inlinable
    public func describeMitigationAction(_ input: DescribeMitigationActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMitigationActionResponse {
        try await self.client.execute(
            operation: "DescribeMitigationAction", 
            path: "/mitigationactions/actions/{actionName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a mitigation action. Requires permission to access the DescribeMitigationAction action.
    ///
    /// Parameters:
    ///   - actionName: The friendly name that uniquely identifies the mitigation action.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeMitigationAction(
        actionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeMitigationActionResponse {
        let input = DescribeMitigationActionRequest(
            actionName: actionName
        )
        return try await self.describeMitigationAction(input, logger: logger)
    }

    /// Returns information about a provisioning template. Requires permission to access the DescribeProvisioningTemplate action.
    @Sendable
    @inlinable
    public func describeProvisioningTemplate(_ input: DescribeProvisioningTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeProvisioningTemplateResponse {
        try await self.client.execute(
            operation: "DescribeProvisioningTemplate", 
            path: "/provisioning-templates/{templateName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a provisioning template. Requires permission to access the DescribeProvisioningTemplate action.
    ///
    /// Parameters:
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeProvisioningTemplate(
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeProvisioningTemplateResponse {
        let input = DescribeProvisioningTemplateRequest(
            templateName: templateName
        )
        return try await self.describeProvisioningTemplate(input, logger: logger)
    }

    /// Returns information about a provisioning template version. Requires permission to access the DescribeProvisioningTemplateVersion action.
    @Sendable
    @inlinable
    public func describeProvisioningTemplateVersion(_ input: DescribeProvisioningTemplateVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeProvisioningTemplateVersionResponse {
        try await self.client.execute(
            operation: "DescribeProvisioningTemplateVersion", 
            path: "/provisioning-templates/{templateName}/versions/{versionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a provisioning template version. Requires permission to access the DescribeProvisioningTemplateVersion action.
    ///
    /// Parameters:
    ///   - templateName: The template name.
    ///   - versionId: The provisioning template version ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeProvisioningTemplateVersion(
        templateName: String,
        versionId: Int,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeProvisioningTemplateVersionResponse {
        let input = DescribeProvisioningTemplateVersionRequest(
            templateName: templateName, 
            versionId: versionId
        )
        return try await self.describeProvisioningTemplateVersion(input, logger: logger)
    }

    /// Describes a role alias. Requires permission to access the DescribeRoleAlias action.
    @Sendable
    @inlinable
    public func describeRoleAlias(_ input: DescribeRoleAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRoleAliasResponse {
        try await self.client.execute(
            operation: "DescribeRoleAlias", 
            path: "/role-aliases/{roleAlias}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a role alias. Requires permission to access the DescribeRoleAlias action.
    ///
    /// Parameters:
    ///   - roleAlias: The role alias to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRoleAlias(
        roleAlias: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRoleAliasResponse {
        let input = DescribeRoleAliasRequest(
            roleAlias: roleAlias
        )
        return try await self.describeRoleAlias(input, logger: logger)
    }

    /// Gets information about a scheduled audit. Requires permission to access the DescribeScheduledAudit action.
    @Sendable
    @inlinable
    public func describeScheduledAudit(_ input: DescribeScheduledAuditRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeScheduledAuditResponse {
        try await self.client.execute(
            operation: "DescribeScheduledAudit", 
            path: "/audit/scheduledaudits/{scheduledAuditName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a scheduled audit. Requires permission to access the DescribeScheduledAudit action.
    ///
    /// Parameters:
    ///   - scheduledAuditName: The name of the scheduled audit whose information you want to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeScheduledAudit(
        scheduledAuditName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeScheduledAuditResponse {
        let input = DescribeScheduledAuditRequest(
            scheduledAuditName: scheduledAuditName
        )
        return try await self.describeScheduledAudit(input, logger: logger)
    }

    /// Gets information about a Device Defender security profile. Requires permission to access the DescribeSecurityProfile action.
    @Sendable
    @inlinable
    public func describeSecurityProfile(_ input: DescribeSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSecurityProfileResponse {
        try await self.client.execute(
            operation: "DescribeSecurityProfile", 
            path: "/security-profiles/{securityProfileName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a Device Defender security profile. Requires permission to access the DescribeSecurityProfile action.
    ///
    /// Parameters:
    ///   - securityProfileName: The name of the security profile whose information you want to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSecurityProfile(
        securityProfileName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSecurityProfileResponse {
        let input = DescribeSecurityProfileRequest(
            securityProfileName: securityProfileName
        )
        return try await self.describeSecurityProfile(input, logger: logger)
    }

    /// Gets information about a stream. Requires permission to access the DescribeStream action.
    @Sendable
    @inlinable
    public func describeStream(_ input: DescribeStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeStreamResponse {
        try await self.client.execute(
            operation: "DescribeStream", 
            path: "/streams/{streamId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a stream. Requires permission to access the DescribeStream action.
    ///
    /// Parameters:
    ///   - streamId: The stream ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeStream(
        streamId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeStreamResponse {
        let input = DescribeStreamRequest(
            streamId: streamId
        )
        return try await self.describeStream(input, logger: logger)
    }

    /// Gets information about the specified thing. Requires permission to access the DescribeThing action.
    @Sendable
    @inlinable
    public func describeThing(_ input: DescribeThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeThingResponse {
        try await self.client.execute(
            operation: "DescribeThing", 
            path: "/things/{thingName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified thing. Requires permission to access the DescribeThing action.
    ///
    /// Parameters:
    ///   - thingName: The name of the thing.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeThing(
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeThingResponse {
        let input = DescribeThingRequest(
            thingName: thingName
        )
        return try await self.describeThing(input, logger: logger)
    }

    /// Describe a thing group. Requires permission to access the DescribeThingGroup action.
    @Sendable
    @inlinable
    public func describeThingGroup(_ input: DescribeThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeThingGroupResponse {
        try await self.client.execute(
            operation: "DescribeThingGroup", 
            path: "/thing-groups/{thingGroupName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describe a thing group. Requires permission to access the DescribeThingGroup action.
    ///
    /// Parameters:
    ///   - thingGroupName: The name of the thing group.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeThingGroup(
        thingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeThingGroupResponse {
        let input = DescribeThingGroupRequest(
            thingGroupName: thingGroupName
        )
        return try await self.describeThingGroup(input, logger: logger)
    }

    /// Describes a bulk thing provisioning task. Requires permission to access the DescribeThingRegistrationTask action.
    @Sendable
    @inlinable
    public func describeThingRegistrationTask(_ input: DescribeThingRegistrationTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeThingRegistrationTaskResponse {
        try await self.client.execute(
            operation: "DescribeThingRegistrationTask", 
            path: "/thing-registration-tasks/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a bulk thing provisioning task. Requires permission to access the DescribeThingRegistrationTask action.
    ///
    /// Parameters:
    ///   - taskId: The task ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeThingRegistrationTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeThingRegistrationTaskResponse {
        let input = DescribeThingRegistrationTaskRequest(
            taskId: taskId
        )
        return try await self.describeThingRegistrationTask(input, logger: logger)
    }

    /// Gets information about the specified thing type. Requires permission to access the DescribeThingType action.
    @Sendable
    @inlinable
    public func describeThingType(_ input: DescribeThingTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeThingTypeResponse {
        try await self.client.execute(
            operation: "DescribeThingType", 
            path: "/thing-types/{thingTypeName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified thing type. Requires permission to access the DescribeThingType action.
    ///
    /// Parameters:
    ///   - thingTypeName: The name of the thing type.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeThingType(
        thingTypeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeThingTypeResponse {
        let input = DescribeThingTypeRequest(
            thingTypeName: thingTypeName
        )
        return try await self.describeThingType(input, logger: logger)
    }

    /// Detaches a policy from the specified target.  Because of the distributed nature of Amazon Web Services, it can take up to five minutes after a policy is detached before it's ready to be deleted.  Requires permission to access the DetachPolicy action.
    @Sendable
    @inlinable
    public func detachPolicy(_ input: DetachPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DetachPolicy", 
            path: "/target-policies/{policyName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Detaches a policy from the specified target.  Because of the distributed nature of Amazon Web Services, it can take up to five minutes after a policy is detached before it's ready to be deleted.  Requires permission to access the DetachPolicy action.
    ///
    /// Parameters:
    ///   - policyName: The policy to detach.
    ///   - target: The target from which the policy will be detached.
    ///   - logger: Logger use during operation
    @inlinable
    public func detachPolicy(
        policyName: String,
        target: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DetachPolicyRequest(
            policyName: policyName, 
            target: target
        )
        return try await self.detachPolicy(input, logger: logger)
    }

    /// Removes the specified policy from the specified certificate.  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use DetachPolicy instead. Requires permission to access the DetachPrincipalPolicy action.
    @Sendable
    @inlinable
    public func detachPrincipalPolicy(_ input: DetachPrincipalPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DetachPrincipalPolicy", 
            path: "/principal-policies/{policyName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified policy from the specified certificate.  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use DetachPolicy instead. Requires permission to access the DetachPrincipalPolicy action.
    ///
    /// Parameters:
    ///   - policyName: The name of the policy to detach.
    ///   - principal: The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - logger: Logger use during operation
    @inlinable
    public func detachPrincipalPolicy(
        policyName: String,
        principal: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DetachPrincipalPolicyRequest(
            policyName: policyName, 
            principal: principal
        )
        return try await self.detachPrincipalPolicy(input, logger: logger)
    }

    /// Disassociates a Device Defender security profile from a thing group or from this account. Requires permission to access the DetachSecurityProfile action.
    @Sendable
    @inlinable
    public func detachSecurityProfile(_ input: DetachSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DetachSecurityProfileResponse {
        try await self.client.execute(
            operation: "DetachSecurityProfile", 
            path: "/security-profiles/{securityProfileName}/targets", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates a Device Defender security profile from a thing group or from this account. Requires permission to access the DetachSecurityProfile action.
    ///
    /// Parameters:
    ///   - securityProfileName: The security profile that is detached.
    ///   - securityProfileTargetArn: The ARN of the thing group from which the security profile is detached.
    ///   - logger: Logger use during operation
    @inlinable
    public func detachSecurityProfile(
        securityProfileName: String,
        securityProfileTargetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DetachSecurityProfileResponse {
        let input = DetachSecurityProfileRequest(
            securityProfileName: securityProfileName, 
            securityProfileTargetArn: securityProfileTargetArn
        )
        return try await self.detachSecurityProfile(input, logger: logger)
    }

    /// Detaches the specified principal from the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.  This call is asynchronous. It might take several seconds for the detachment to
    /// 				propagate.  Requires permission to access the DetachThingPrincipal action.
    @Sendable
    @inlinable
    public func detachThingPrincipal(_ input: DetachThingPrincipalRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DetachThingPrincipalResponse {
        try await self.client.execute(
            operation: "DetachThingPrincipal", 
            path: "/things/{thingName}/principals", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Detaches the specified principal from the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.  This call is asynchronous. It might take several seconds for the detachment to
    /// 				propagate.  Requires permission to access the DetachThingPrincipal action.
    ///
    /// Parameters:
    ///   - principal: If the principal is a certificate, this value must be ARN of the certificate. If
    ///   - thingName: The name of the thing.
    ///   - logger: Logger use during operation
    @inlinable
    public func detachThingPrincipal(
        principal: String,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DetachThingPrincipalResponse {
        let input = DetachThingPrincipalRequest(
            principal: principal, 
            thingName: thingName
        )
        return try await self.detachThingPrincipal(input, logger: logger)
    }

    /// Disables the rule. Requires permission to access the DisableTopicRule action.
    @Sendable
    @inlinable
    public func disableTopicRule(_ input: DisableTopicRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DisableTopicRule", 
            path: "/rules/{ruleName}/disable", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disables the rule. Requires permission to access the DisableTopicRule action.
    ///
    /// Parameters:
    ///   - ruleName: The name of the rule to disable.
    ///   - logger: Logger use during operation
    @inlinable
    public func disableTopicRule(
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DisableTopicRuleRequest(
            ruleName: ruleName
        )
        return try await self.disableTopicRule(input, logger: logger)
    }

    /// Disassociates the selected software bill of materials (SBOM) from a specific software package version. Requires permission to access the DisassociateSbomWithPackageVersion action.
    @Sendable
    @inlinable
    public func disassociateSbomFromPackageVersion(_ input: DisassociateSbomFromPackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateSbomFromPackageVersionResponse {
        try await self.client.execute(
            operation: "DisassociateSbomFromPackageVersion", 
            path: "/packages/{packageName}/versions/{versionName}/sbom", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates the selected software bill of materials (SBOM) from a specific software package version. Requires permission to access the DisassociateSbomWithPackageVersion action.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    ///   - packageName: The name of the new software package.
    ///   - versionName: The name of the new package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateSbomFromPackageVersion(
        clientToken: String? = DisassociateSbomFromPackageVersionRequest.idempotencyToken(),
        packageName: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateSbomFromPackageVersionResponse {
        let input = DisassociateSbomFromPackageVersionRequest(
            clientToken: clientToken, 
            packageName: packageName, 
            versionName: versionName
        )
        return try await self.disassociateSbomFromPackageVersion(input, logger: logger)
    }

    /// Enables the rule. Requires permission to access the EnableTopicRule action.
    @Sendable
    @inlinable
    public func enableTopicRule(_ input: EnableTopicRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "EnableTopicRule", 
            path: "/rules/{ruleName}/enable", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables the rule. Requires permission to access the EnableTopicRule action.
    ///
    /// Parameters:
    ///   - ruleName: The name of the topic rule to enable.
    ///   - logger: Logger use during operation
    @inlinable
    public func enableTopicRule(
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = EnableTopicRuleRequest(
            ruleName: ruleName
        )
        return try await self.enableTopicRule(input, logger: logger)
    }

    ///  Returns a Device Defender's ML Detect Security Profile training model's status.  Requires permission to access the GetBehaviorModelTrainingSummaries action.
    @Sendable
    @inlinable
    public func getBehaviorModelTrainingSummaries(_ input: GetBehaviorModelTrainingSummariesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBehaviorModelTrainingSummariesResponse {
        try await self.client.execute(
            operation: "GetBehaviorModelTrainingSummaries", 
            path: "/behavior-model-training/summaries", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Returns a Device Defender's ML Detect Security Profile training model's status.  Requires permission to access the GetBehaviorModelTrainingSummaries action.
    ///
    /// Parameters:
    ///   - maxResults:  The maximum number of results to return at one time. The default is 10.
    ///   - nextToken:  The token for the next set of results.
    ///   - securityProfileName:  The name of the security profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBehaviorModelTrainingSummaries(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBehaviorModelTrainingSummariesResponse {
        let input = GetBehaviorModelTrainingSummariesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            securityProfileName: securityProfileName
        )
        return try await self.getBehaviorModelTrainingSummaries(input, logger: logger)
    }

    /// Aggregates on indexed data with search queries pertaining to particular fields.  Requires permission to access the GetBucketsAggregation action.
    @Sendable
    @inlinable
    public func getBucketsAggregation(_ input: GetBucketsAggregationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBucketsAggregationResponse {
        try await self.client.execute(
            operation: "GetBucketsAggregation", 
            path: "/indices/buckets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Aggregates on indexed data with search queries pertaining to particular fields.  Requires permission to access the GetBucketsAggregation action.
    ///
    /// Parameters:
    ///   - aggregationField: The aggregation field.
    ///   - bucketsAggregationType: The basic control of the response shape and the bucket aggregation type to perform.
    ///   - indexName: The name of the index to search.
    ///   - queryString: The search query string.
    ///   - queryVersion: The version of the query.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBucketsAggregation(
        aggregationField: String,
        bucketsAggregationType: BucketsAggregationType,
        indexName: String? = nil,
        queryString: String,
        queryVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBucketsAggregationResponse {
        let input = GetBucketsAggregationRequest(
            aggregationField: aggregationField, 
            bucketsAggregationType: bucketsAggregationType, 
            indexName: indexName, 
            queryString: queryString, 
            queryVersion: queryVersion
        )
        return try await self.getBucketsAggregation(input, logger: logger)
    }

    /// Returns the approximate count of unique values that match the query. Requires permission to access the GetCardinality action.
    @Sendable
    @inlinable
    public func getCardinality(_ input: GetCardinalityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCardinalityResponse {
        try await self.client.execute(
            operation: "GetCardinality", 
            path: "/indices/cardinality", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the approximate count of unique values that match the query. Requires permission to access the GetCardinality action.
    ///
    /// Parameters:
    ///   - aggregationField: The field to aggregate.
    ///   - indexName: The name of the index to search.
    ///   - queryString: The search query string.
    ///   - queryVersion: The query version.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCardinality(
        aggregationField: String? = nil,
        indexName: String? = nil,
        queryString: String,
        queryVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCardinalityResponse {
        let input = GetCardinalityRequest(
            aggregationField: aggregationField, 
            indexName: indexName, 
            queryString: queryString, 
            queryVersion: queryVersion
        )
        return try await self.getCardinality(input, logger: logger)
    }

    /// Gets information about the specified command.
    @Sendable
    @inlinable
    public func getCommand(_ input: GetCommandRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCommandResponse {
        try await self.client.execute(
            operation: "GetCommand", 
            path: "/commands/{commandId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified command.
    ///
    /// Parameters:
    ///   - commandId: The unique identifier of the command for which you want to retrieve information.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCommand(
        commandId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCommandResponse {
        let input = GetCommandRequest(
            commandId: commandId
        )
        return try await self.getCommand(input, logger: logger)
    }

    /// Gets information about the specific command execution on a single device.
    @Sendable
    @inlinable
    public func getCommandExecution(_ input: GetCommandExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCommandExecutionResponse {
        try await self.client.execute(
            operation: "GetCommandExecution", 
            path: "/command-executions/{executionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specific command execution on a single device.
    ///
    /// Parameters:
    ///   - executionId: The unique identifier for the command execution. This information is returned as a response of the StartCommandExecution API request.
    ///   - includeResult: Can be used to specify whether to include the result of the command execution in the GetCommandExecution API response. Your device can use this field to provide additional information about the command execution. You only need to specify this field when using the AWS-IoT namespace.
    ///   - targetArn: The Amazon Resource Number (ARN) of the device on which the command execution is being performed.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCommandExecution(
        executionId: String,
        includeResult: Bool? = nil,
        targetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCommandExecutionResponse {
        let input = GetCommandExecutionRequest(
            executionId: executionId, 
            includeResult: includeResult, 
            targetArn: targetArn
        )
        return try await self.getCommandExecution(input, logger: logger)
    }

    /// Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the IoT device gateway. Requires permission to access the GetEffectivePolicies action.
    @Sendable
    @inlinable
    public func getEffectivePolicies(_ input: GetEffectivePoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEffectivePoliciesResponse {
        try await self.client.execute(
            operation: "GetEffectivePolicies", 
            path: "/effective-policies", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the IoT device gateway. Requires permission to access the GetEffectivePolicies action.
    ///
    /// Parameters:
    ///   - cognitoIdentityPoolId: The Cognito identity pool ID.
    ///   - principal: The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - thingName: The thing name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEffectivePolicies(
        cognitoIdentityPoolId: String? = nil,
        principal: String? = nil,
        thingName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEffectivePoliciesResponse {
        let input = GetEffectivePoliciesRequest(
            cognitoIdentityPoolId: cognitoIdentityPoolId, 
            principal: principal, 
            thingName: thingName
        )
        return try await self.getEffectivePolicies(input, logger: logger)
    }

    /// Gets the indexing configuration. Requires permission to access the GetIndexingConfiguration action.
    @Sendable
    @inlinable
    public func getIndexingConfiguration(_ input: GetIndexingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIndexingConfigurationResponse {
        try await self.client.execute(
            operation: "GetIndexingConfiguration", 
            path: "/indexing/config", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the indexing configuration. Requires permission to access the GetIndexingConfiguration action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getIndexingConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIndexingConfigurationResponse {
        let input = GetIndexingConfigurationRequest(
        )
        return try await self.getIndexingConfiguration(input, logger: logger)
    }

    /// Gets a job document. Requires permission to access the GetJobDocument action.
    @Sendable
    @inlinable
    public func getJobDocument(_ input: GetJobDocumentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobDocumentResponse {
        try await self.client.execute(
            operation: "GetJobDocument", 
            path: "/jobs/{jobId}/job-document", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a job document. Requires permission to access the GetJobDocument action.
    ///
    /// Parameters:
    ///   - beforeSubstitution: Provides a view of the job document before and after the substitution parameters have been resolved with their exact values.
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJobDocument(
        beforeSubstitution: Bool? = nil,
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobDocumentResponse {
        let input = GetJobDocumentRequest(
            beforeSubstitution: beforeSubstitution, 
            jobId: jobId
        )
        return try await self.getJobDocument(input, logger: logger)
    }

    /// Gets the logging options. NOTE: use of this command is not recommended. Use GetV2LoggingOptions instead. Requires permission to access the GetLoggingOptions action.
    @Sendable
    @inlinable
    public func getLoggingOptions(_ input: GetLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLoggingOptionsResponse {
        try await self.client.execute(
            operation: "GetLoggingOptions", 
            path: "/loggingOptions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the logging options. NOTE: use of this command is not recommended. Use GetV2LoggingOptions instead. Requires permission to access the GetLoggingOptions action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getLoggingOptions(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLoggingOptionsResponse {
        let input = GetLoggingOptionsRequest(
        )
        return try await self.getLoggingOptions(input, logger: logger)
    }

    /// Gets an OTA update. Requires permission to access the GetOTAUpdate action.
    @Sendable
    @inlinable
    public func getOTAUpdate(_ input: GetOTAUpdateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetOTAUpdateResponse {
        try await self.client.execute(
            operation: "GetOTAUpdate", 
            path: "/otaUpdates/{otaUpdateId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an OTA update. Requires permission to access the GetOTAUpdate action.
    ///
    /// Parameters:
    ///   - otaUpdateId: The OTA update ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getOTAUpdate(
        otaUpdateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetOTAUpdateResponse {
        let input = GetOTAUpdateRequest(
            otaUpdateId: otaUpdateId
        )
        return try await self.getOTAUpdate(input, logger: logger)
    }

    /// Gets information about the specified software package. Requires permission to access the GetPackage action.
    @Sendable
    @inlinable
    public func getPackage(_ input: GetPackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPackageResponse {
        try await self.client.execute(
            operation: "GetPackage", 
            path: "/packages/{packageName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified software package. Requires permission to access the GetPackage action.
    ///
    /// Parameters:
    ///   - packageName: The name of the target software package.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPackage(
        packageName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPackageResponse {
        let input = GetPackageRequest(
            packageName: packageName
        )
        return try await self.getPackage(input, logger: logger)
    }

    /// Gets information about the specified software package's configuration. Requires permission to access the GetPackageConfiguration action.
    @Sendable
    @inlinable
    public func getPackageConfiguration(_ input: GetPackageConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPackageConfigurationResponse {
        try await self.client.execute(
            operation: "GetPackageConfiguration", 
            path: "/package-configuration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified software package's configuration. Requires permission to access the GetPackageConfiguration action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getPackageConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPackageConfigurationResponse {
        let input = GetPackageConfigurationRequest(
        )
        return try await self.getPackageConfiguration(input, logger: logger)
    }

    /// Gets information about the specified package version.  Requires permission to access the GetPackageVersion action.
    @Sendable
    @inlinable
    public func getPackageVersion(_ input: GetPackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPackageVersionResponse {
        try await self.client.execute(
            operation: "GetPackageVersion", 
            path: "/packages/{packageName}/versions/{versionName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified package version.  Requires permission to access the GetPackageVersion action.
    ///
    /// Parameters:
    ///   - packageName: The name of the associated package.
    ///   - versionName: The name of the target package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPackageVersion(
        packageName: String,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPackageVersionResponse {
        let input = GetPackageVersionRequest(
            packageName: packageName, 
            versionName: versionName
        )
        return try await self.getPackageVersion(input, logger: logger)
    }

    /// Groups the aggregated values that match the query into percentile groupings. The default  percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own  when you call GetPercentiles. This function returns a value for each  percentile group specified (or the default percentile groupings). The percentile group  "1" contains the aggregated field value that occurs in approximately one percent of the  values that match the query. The percentile group "5" contains the aggregated field value  that occurs in approximately five percent of the values that match the query, and so on.  The result is an approximation, the more values that match the query, the more accurate  the percentile values. Requires permission to access the GetPercentiles action.
    @Sendable
    @inlinable
    public func getPercentiles(_ input: GetPercentilesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPercentilesResponse {
        try await self.client.execute(
            operation: "GetPercentiles", 
            path: "/indices/percentiles", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Groups the aggregated values that match the query into percentile groupings. The default  percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own  when you call GetPercentiles. This function returns a value for each  percentile group specified (or the default percentile groupings). The percentile group  "1" contains the aggregated field value that occurs in approximately one percent of the  values that match the query. The percentile group "5" contains the aggregated field value  that occurs in approximately five percent of the values that match the query, and so on.  The result is an approximation, the more values that match the query, the more accurate  the percentile values. Requires permission to access the GetPercentiles action.
    ///
    /// Parameters:
    ///   - aggregationField: The field to aggregate.
    ///   - indexName: The name of the index to search.
    ///   - percents: The percentile groups returned.
    ///   - queryString: The search query string.
    ///   - queryVersion: The query version.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPercentiles(
        aggregationField: String? = nil,
        indexName: String? = nil,
        percents: [Double]? = nil,
        queryString: String,
        queryVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPercentilesResponse {
        let input = GetPercentilesRequest(
            aggregationField: aggregationField, 
            indexName: indexName, 
            percents: percents, 
            queryString: queryString, 
            queryVersion: queryVersion
        )
        return try await self.getPercentiles(input, logger: logger)
    }

    /// Gets information about the specified policy with the policy document of the default version. Requires permission to access the GetPolicy action.
    @Sendable
    @inlinable
    public func getPolicy(_ input: GetPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyResponse {
        try await self.client.execute(
            operation: "GetPolicy", 
            path: "/policies/{policyName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified policy with the policy document of the default version. Requires permission to access the GetPolicy action.
    ///
    /// Parameters:
    ///   - policyName: The name of the policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicy(
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyResponse {
        let input = GetPolicyRequest(
            policyName: policyName
        )
        return try await self.getPolicy(input, logger: logger)
    }

    /// Gets information about the specified policy version. Requires permission to access the GetPolicyVersion action.
    @Sendable
    @inlinable
    public func getPolicyVersion(_ input: GetPolicyVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyVersionResponse {
        try await self.client.execute(
            operation: "GetPolicyVersion", 
            path: "/policies/{policyName}/version/{policyVersionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified policy version. Requires permission to access the GetPolicyVersion action.
    ///
    /// Parameters:
    ///   - policyName: The name of the policy.
    ///   - policyVersionId: The policy version ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicyVersion(
        policyName: String,
        policyVersionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyVersionResponse {
        let input = GetPolicyVersionRequest(
            policyName: policyName, 
            policyVersionId: policyVersionId
        )
        return try await self.getPolicyVersion(input, logger: logger)
    }

    /// Gets a registration code used to register a CA certificate with IoT. IoT will create a registration code as part of this API call if the registration code doesn't exist or has been deleted. If you already have a registration code, this API call will return the same registration code. Requires permission to access the GetRegistrationCode action.
    @Sendable
    @inlinable
    public func getRegistrationCode(_ input: GetRegistrationCodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRegistrationCodeResponse {
        try await self.client.execute(
            operation: "GetRegistrationCode", 
            path: "/registrationcode", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a registration code used to register a CA certificate with IoT. IoT will create a registration code as part of this API call if the registration code doesn't exist or has been deleted. If you already have a registration code, this API call will return the same registration code. Requires permission to access the GetRegistrationCode action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getRegistrationCode(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRegistrationCodeResponse {
        let input = GetRegistrationCodeRequest(
        )
        return try await self.getRegistrationCode(input, logger: logger)
    }

    /// Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type String, only the count statistic is returned. Requires permission to access the GetStatistics action.
    @Sendable
    @inlinable
    public func getStatistics(_ input: GetStatisticsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStatisticsResponse {
        try await self.client.execute(
            operation: "GetStatistics", 
            path: "/indices/statistics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type String, only the count statistic is returned. Requires permission to access the GetStatistics action.
    ///
    /// Parameters:
    ///   - aggregationField: The aggregation field name.
    ///   - indexName: The name of the index to search. The default value is AWS_Things.
    ///   - queryString: The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.
    ///   - queryVersion: The version of the query used to search.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStatistics(
        aggregationField: String? = nil,
        indexName: String? = nil,
        queryString: String,
        queryVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStatisticsResponse {
        let input = GetStatisticsRequest(
            aggregationField: aggregationField, 
            indexName: indexName, 
            queryString: queryString, 
            queryVersion: queryVersion
        )
        return try await self.getStatistics(input, logger: logger)
    }

    /// Retrieves the live connectivity status per device.
    @Sendable
    @inlinable
    public func getThingConnectivityData(_ input: GetThingConnectivityDataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetThingConnectivityDataResponse {
        try await self.client.execute(
            operation: "GetThingConnectivityData", 
            path: "/things/{thingName}/connectivity-data", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the live connectivity status per device.
    ///
    /// Parameters:
    ///   - thingName: The name of your IoT thing.
    ///   - logger: Logger use during operation
    @inlinable
    public func getThingConnectivityData(
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetThingConnectivityDataResponse {
        let input = GetThingConnectivityDataRequest(
            thingName: thingName
        )
        return try await self.getThingConnectivityData(input, logger: logger)
    }

    /// Gets information about the rule. Requires permission to access the GetTopicRule action.
    @Sendable
    @inlinable
    public func getTopicRule(_ input: GetTopicRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTopicRuleResponse {
        try await self.client.execute(
            operation: "GetTopicRule", 
            path: "/rules/{ruleName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the rule. Requires permission to access the GetTopicRule action.
    ///
    /// Parameters:
    ///   - ruleName: The name of the rule.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTopicRule(
        ruleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTopicRuleResponse {
        let input = GetTopicRuleRequest(
            ruleName: ruleName
        )
        return try await self.getTopicRule(input, logger: logger)
    }

    /// Gets information about a topic rule destination. Requires permission to access the GetTopicRuleDestination action.
    @Sendable
    @inlinable
    public func getTopicRuleDestination(_ input: GetTopicRuleDestinationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTopicRuleDestinationResponse {
        try await self.client.execute(
            operation: "GetTopicRuleDestination", 
            path: "/destinations/{arn+}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a topic rule destination. Requires permission to access the GetTopicRuleDestination action.
    ///
    /// Parameters:
    ///   - arn: The ARN of the topic rule destination.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTopicRuleDestination(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTopicRuleDestinationResponse {
        let input = GetTopicRuleDestinationRequest(
            arn: arn
        )
        return try await self.getTopicRuleDestination(input, logger: logger)
    }

    /// Gets the fine grained logging options. Requires permission to access the GetV2LoggingOptions action.
    @Sendable
    @inlinable
    public func getV2LoggingOptions(_ input: GetV2LoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetV2LoggingOptionsResponse {
        try await self.client.execute(
            operation: "GetV2LoggingOptions", 
            path: "/v2LoggingOptions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the fine grained logging options. Requires permission to access the GetV2LoggingOptions action.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getV2LoggingOptions(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetV2LoggingOptionsResponse {
        let input = GetV2LoggingOptionsRequest(
        )
        return try await self.getV2LoggingOptions(input, logger: logger)
    }

    /// Lists the active violations for a given Device Defender security profile. Requires permission to access the ListActiveViolations action.
    @Sendable
    @inlinable
    public func listActiveViolations(_ input: ListActiveViolationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListActiveViolationsResponse {
        try await self.client.execute(
            operation: "ListActiveViolations", 
            path: "/active-violations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the active violations for a given Device Defender security profile. Requires permission to access the ListActiveViolations action.
    ///
    /// Parameters:
    ///   - behaviorCriteriaType:  The criteria for a behavior.
    ///   - listSuppressedAlerts:  A list of all suppressed alerts.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - securityProfileName: The name of the Device Defender security profile for which violations are listed.
    ///   - thingName: The name of the thing whose active violations are listed.
    ///   - verificationState: The verification state of the violation (detect alarm).
    ///   - logger: Logger use during operation
    @inlinable
    public func listActiveViolations(
        behaviorCriteriaType: BehaviorCriteriaType? = nil,
        listSuppressedAlerts: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil,
        thingName: String? = nil,
        verificationState: VerificationState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListActiveViolationsResponse {
        let input = ListActiveViolationsRequest(
            behaviorCriteriaType: behaviorCriteriaType, 
            listSuppressedAlerts: listSuppressedAlerts, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            securityProfileName: securityProfileName, 
            thingName: thingName, 
            verificationState: verificationState
        )
        return try await self.listActiveViolations(input, logger: logger)
    }

    /// Lists the policies attached to the specified thing group. Requires permission to access the ListAttachedPolicies action.
    @Sendable
    @inlinable
    public func listAttachedPolicies(_ input: ListAttachedPoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAttachedPoliciesResponse {
        try await self.client.execute(
            operation: "ListAttachedPolicies", 
            path: "/attached-policies/{target}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the policies attached to the specified thing group. Requires permission to access the ListAttachedPolicies action.
    ///
    /// Parameters:
    ///   - marker: The token to retrieve the next set of results.
    ///   - pageSize: The maximum number of results to be returned per request.
    ///   - recursive: When true, recursively list attached policies.
    ///   - target: The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - logger: Logger use during operation
    @inlinable
    public func listAttachedPolicies(
        marker: String? = nil,
        pageSize: Int? = nil,
        recursive: Bool? = nil,
        target: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAttachedPoliciesResponse {
        let input = ListAttachedPoliciesRequest(
            marker: marker, 
            pageSize: pageSize, 
            recursive: recursive, 
            target: target
        )
        return try await self.listAttachedPolicies(input, logger: logger)
    }

    /// Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 90 days.) Requires permission to access the ListAuditFindings action.
    @Sendable
    @inlinable
    public func listAuditFindings(_ input: ListAuditFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAuditFindingsResponse {
        try await self.client.execute(
            operation: "ListAuditFindings", 
            path: "/audit/findings", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 90 days.) Requires permission to access the ListAuditFindings action.
    ///
    /// Parameters:
    ///   - checkName: A filter to limit results to the findings for the specified audit check.
    ///   - endTime: A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - listSuppressedFindings:  Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken: The token for the next set of results.
    ///   - resourceIdentifier: Information identifying the noncompliant resource.
    ///   - startTime: A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - taskId: A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAuditFindings(
        checkName: String? = nil,
        endTime: Date? = nil,
        listSuppressedFindings: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        startTime: Date? = nil,
        taskId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAuditFindingsResponse {
        let input = ListAuditFindingsRequest(
            checkName: checkName, 
            endTime: endTime, 
            listSuppressedFindings: listSuppressedFindings, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceIdentifier: resourceIdentifier, 
            startTime: startTime, 
            taskId: taskId
        )
        return try await self.listAuditFindings(input, logger: logger)
    }

    /// Gets the status of audit mitigation action tasks that were executed. Requires permission to access the ListAuditMitigationActionsExecutions action.
    @Sendable
    @inlinable
    public func listAuditMitigationActionsExecutions(_ input: ListAuditMitigationActionsExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAuditMitigationActionsExecutionsResponse {
        try await self.client.execute(
            operation: "ListAuditMitigationActionsExecutions", 
            path: "/audit/mitigationactions/executions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the status of audit mitigation action tasks that were executed. Requires permission to access the ListAuditMitigationActionsExecutions action.
    ///
    /// Parameters:
    ///   - actionStatus: Specify this filter to limit results to those with a specific status.
    ///   - findingId: Specify this filter to limit results to those that were applied to a specific audit finding.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken: The token for the next set of results.
    ///   - taskId: Specify this filter to limit results to actions for a specific audit mitigation actions task.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAuditMitigationActionsExecutions(
        actionStatus: AuditMitigationActionsExecutionStatus? = nil,
        findingId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAuditMitigationActionsExecutionsResponse {
        let input = ListAuditMitigationActionsExecutionsRequest(
            actionStatus: actionStatus, 
            findingId: findingId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            taskId: taskId
        )
        return try await self.listAuditMitigationActionsExecutions(input, logger: logger)
    }

    /// Gets a list of audit mitigation action tasks that match the specified filters. Requires permission to access the ListAuditMitigationActionsTasks action.
    @Sendable
    @inlinable
    public func listAuditMitigationActionsTasks(_ input: ListAuditMitigationActionsTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAuditMitigationActionsTasksResponse {
        try await self.client.execute(
            operation: "ListAuditMitigationActionsTasks", 
            path: "/audit/mitigationactions/tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of audit mitigation action tasks that match the specified filters. Requires permission to access the ListAuditMitigationActionsTasks action.
    ///
    /// Parameters:
    ///   - auditTaskId: Specify this filter to limit results to tasks that were applied to results for a specific audit.
    ///   - endTime: Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
    ///   - findingId: Specify this filter to limit results to tasks that were applied to a specific audit finding.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken: The token for the next set of results.
    ///   - startTime: Specify this filter to limit results to tasks that began on or after a specific date and time.
    ///   - taskStatus: Specify this filter to limit results to tasks that are in a specific state.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAuditMitigationActionsTasks(
        auditTaskId: String? = nil,
        endTime: Date,
        findingId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        taskStatus: AuditMitigationActionsTaskStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAuditMitigationActionsTasksResponse {
        let input = ListAuditMitigationActionsTasksRequest(
            auditTaskId: auditTaskId, 
            endTime: endTime, 
            findingId: findingId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime, 
            taskStatus: taskStatus
        )
        return try await self.listAuditMitigationActionsTasks(input, logger: logger)
    }

    ///  Lists your Device Defender audit listings.  Requires permission to access the ListAuditSuppressions action.
    @Sendable
    @inlinable
    public func listAuditSuppressions(_ input: ListAuditSuppressionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAuditSuppressionsResponse {
        try await self.client.execute(
            operation: "ListAuditSuppressions", 
            path: "/audit/suppressions/list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists your Device Defender audit listings.  Requires permission to access the ListAuditSuppressions action.
    ///
    /// Parameters:
    ///   - ascendingOrder:  Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, ascendingOrder=true.
    ///   - checkName: 
    ///   - maxResults:  The maximum number of results to return at one time. The default is 25.
    ///   - nextToken:  The token for the next set of results.
    ///   - resourceIdentifier: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listAuditSuppressions(
        ascendingOrder: Bool? = nil,
        checkName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAuditSuppressionsResponse {
        let input = ListAuditSuppressionsRequest(
            ascendingOrder: ascendingOrder, 
            checkName: checkName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceIdentifier: resourceIdentifier
        )
        return try await self.listAuditSuppressions(input, logger: logger)
    }

    /// Lists the Device Defender audits that have been performed during a given time period. Requires permission to access the ListAuditTasks action.
    @Sendable
    @inlinable
    public func listAuditTasks(_ input: ListAuditTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAuditTasksResponse {
        try await self.client.execute(
            operation: "ListAuditTasks", 
            path: "/audit/tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the Device Defender audits that have been performed during a given time period. Requires permission to access the ListAuditTasks action.
    ///
    /// Parameters:
    ///   - endTime: The end of the time period.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken: The token for the next set of results.
    ///   - startTime: The beginning of the time period. Audit information is retained for a  limited time (90 days). Requesting a start time prior to what is retained  results in an "InvalidRequestException".
    ///   - taskStatus: A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
    ///   - taskType: A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
    ///   - logger: Logger use during operation
    @inlinable
    public func listAuditTasks(
        endTime: Date,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        taskStatus: AuditTaskStatus? = nil,
        taskType: AuditTaskType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAuditTasksResponse {
        let input = ListAuditTasksRequest(
            endTime: endTime, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime, 
            taskStatus: taskStatus, 
            taskType: taskType
        )
        return try await self.listAuditTasks(input, logger: logger)
    }

    /// Lists the authorizers registered in your account. Requires permission to access the ListAuthorizers action.
    @Sendable
    @inlinable
    public func listAuthorizers(_ input: ListAuthorizersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAuthorizersResponse {
        try await self.client.execute(
            operation: "ListAuthorizers", 
            path: "/authorizers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the authorizers registered in your account. Requires permission to access the ListAuthorizers action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Return the list of authorizers in ascending alphabetical order.
    ///   - marker: A marker used to get the next set of results.
    ///   - pageSize: The maximum number of results to return at one time.
    ///   - status: The status of the list authorizers request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAuthorizers(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        status: AuthorizerStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAuthorizersResponse {
        let input = ListAuthorizersRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize, 
            status: status
        )
        return try await self.listAuthorizers(input, logger: logger)
    }

    /// Lists the billing groups you have created. Requires permission to access the ListBillingGroups action.
    @Sendable
    @inlinable
    public func listBillingGroups(_ input: ListBillingGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBillingGroupsResponse {
        try await self.client.execute(
            operation: "ListBillingGroups", 
            path: "/billing-groups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the billing groups you have created. Requires permission to access the ListBillingGroups action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return per request.
    ///   - namePrefixFilter: Limit the results to billing groups whose names have the given prefix.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listBillingGroups(
        maxResults: Int? = nil,
        namePrefixFilter: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBillingGroupsResponse {
        let input = ListBillingGroupsRequest(
            maxResults: maxResults, 
            namePrefixFilter: namePrefixFilter, 
            nextToken: nextToken
        )
        return try await self.listBillingGroups(input, logger: logger)
    }

    /// Lists the CA certificates registered for your Amazon Web Services account. The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results. Requires permission to access the ListCACertificates action.
    @Sendable
    @inlinable
    public func listCACertificates(_ input: ListCACertificatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCACertificatesResponse {
        try await self.client.execute(
            operation: "ListCACertificates", 
            path: "/cacertificates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the CA certificates registered for your Amazon Web Services account. The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results. Requires permission to access the ListCACertificates action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Determines the order of the results.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCACertificates(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        templateName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCACertificatesResponse {
        let input = ListCACertificatesRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize, 
            templateName: templateName
        )
        return try await self.listCACertificates(input, logger: logger)
    }

    /// Lists all your certificate providers in your Amazon Web Services account. Requires permission to access the ListCertificateProviders action.
    @Sendable
    @inlinable
    public func listCertificateProviders(_ input: ListCertificateProvidersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCertificateProvidersResponse {
        try await self.client.execute(
            operation: "ListCertificateProviders", 
            path: "/certificate-providers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all your certificate providers in your Amazon Web Services account. Requires permission to access the ListCertificateProviders action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Returns the list of certificate providers in ascending alphabetical order.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCertificateProviders(
        ascendingOrder: Bool? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCertificateProvidersResponse {
        let input = ListCertificateProvidersRequest(
            ascendingOrder: ascendingOrder, 
            nextToken: nextToken
        )
        return try await self.listCertificateProviders(input, logger: logger)
    }

    /// Lists the certificates registered in your Amazon Web Services account. The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results. Requires permission to access the ListCertificates action.
    @Sendable
    @inlinable
    public func listCertificates(_ input: ListCertificatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCertificatesResponse {
        try await self.client.execute(
            operation: "ListCertificates", 
            path: "/certificates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the certificates registered in your Amazon Web Services account. The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results. Requires permission to access the ListCertificates action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCertificates(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCertificatesResponse {
        let input = ListCertificatesRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize
        )
        return try await self.listCertificates(input, logger: logger)
    }

    /// List the device certificates signed by the specified CA certificate. Requires permission to access the ListCertificatesByCA action.
    @Sendable
    @inlinable
    public func listCertificatesByCA(_ input: ListCertificatesByCARequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCertificatesByCAResponse {
        try await self.client.execute(
            operation: "ListCertificatesByCA", 
            path: "/certificates-by-ca/{caCertificateId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the device certificates signed by the specified CA certificate. Requires permission to access the ListCertificatesByCA action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    ///   - caCertificateId: The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCertificatesByCA(
        ascendingOrder: Bool? = nil,
        caCertificateId: String,
        marker: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCertificatesByCAResponse {
        let input = ListCertificatesByCARequest(
            ascendingOrder: ascendingOrder, 
            caCertificateId: caCertificateId, 
            marker: marker, 
            pageSize: pageSize
        )
        return try await self.listCertificatesByCA(input, logger: logger)
    }

    /// List all command executions.    You must provide only the startedTimeFilter or  the completedTimeFilter information. If you provide  both time filters, the API will generate an error. You can use  this information to retrieve a list of command executions  within a specific timeframe.   You must provide only the commandArn or  the thingArn information depending on whether you want to list executions for a specific command or an IoT thing. If you provide  both fields, the API will generate an error.   For more information about considerations for using this API, see List command executions in your account (CLI).
    @Sendable
    @inlinable
    public func listCommandExecutions(_ input: ListCommandExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCommandExecutionsResponse {
        try await self.client.execute(
            operation: "ListCommandExecutions", 
            path: "/command-executions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all command executions.    You must provide only the startedTimeFilter or  the completedTimeFilter information. If you provide  both time filters, the API will generate an error. You can use  this information to retrieve a list of command executions  within a specific timeframe.   You must provide only the commandArn or  the thingArn information depending on whether you want to list executions for a specific command or an IoT thing. If you provide  both fields, the API will generate an error.   For more information about considerations for using this API, see List command executions in your account (CLI).
    ///
    /// Parameters:
    ///   - commandArn: The Amazon Resource Number (ARN) of the command. You can use this information to list all command executions for a particular command.
    ///   - completedTimeFilter: List all command executions that completed any time before or after the date and time that you specify. The date and time uses the format yyyy-MM-dd'T'HH:mm.
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - namespace: The namespace of the command.
    ///   - nextToken: To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    ///   - sortOrder: Specify whether to list the command executions that were created in the ascending or descending order. By default, the API returns all commands in the descending order based on the start time or completion time of the executions, that are determined by the startTimeFilter and completeTimeFilter parameters.
    ///   - startedTimeFilter: List all command executions that started any time before or after the date and time that you specify. The date and time uses the format yyyy-MM-dd'T'HH:mm.
    ///   - status: List all command executions for the device that have a particular status. For example, you can filter the list to display only command executions that have failed or timed out.
    ///   - targetArn: The Amazon Resource Number (ARN) of the target device. You can use this information to list all command executions for a particular device.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCommandExecutions(
        commandArn: String? = nil,
        completedTimeFilter: TimeFilter? = nil,
        maxResults: Int? = nil,
        namespace: CommandNamespace? = nil,
        nextToken: String? = nil,
        sortOrder: SortOrder? = nil,
        startedTimeFilter: TimeFilter? = nil,
        status: CommandExecutionStatus? = nil,
        targetArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCommandExecutionsResponse {
        let input = ListCommandExecutionsRequest(
            commandArn: commandArn, 
            completedTimeFilter: completedTimeFilter, 
            maxResults: maxResults, 
            namespace: namespace, 
            nextToken: nextToken, 
            sortOrder: sortOrder, 
            startedTimeFilter: startedTimeFilter, 
            status: status, 
            targetArn: targetArn
        )
        return try await self.listCommandExecutions(input, logger: logger)
    }

    /// List all commands in your account.
    @Sendable
    @inlinable
    public func listCommands(_ input: ListCommandsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCommandsResponse {
        try await self.client.execute(
            operation: "ListCommands", 
            path: "/commands", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all commands in your account.
    ///
    /// Parameters:
    ///   - commandParameterName: A filter that can be used to display the list of commands that have a specific command parameter name.
    ///   - maxResults: The maximum number of results to return in this operation. By default, the API returns up to a maximum of 25 results. You can override this default value to return up to a maximum of 100 results for this operation.
    ///   - namespace: The namespace of the command. By default, the API returns all commands that have been created for both AWS-IoT and AWS-IoT-FleetWise namespaces. You can override this default value if you want to return all commands that have been created only for a specific namespace.
    ///   - nextToken: To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    ///   - sortOrder: Specify whether to list the commands that you have created in the ascending or descending order. By default, the API returns all commands in the descending order based on the time that they were created.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCommands(
        commandParameterName: String? = nil,
        maxResults: Int? = nil,
        namespace: CommandNamespace? = nil,
        nextToken: String? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCommandsResponse {
        let input = ListCommandsRequest(
            commandParameterName: commandParameterName, 
            maxResults: maxResults, 
            namespace: namespace, 
            nextToken: nextToken, 
            sortOrder: sortOrder
        )
        return try await self.listCommands(input, logger: logger)
    }

    ///  Lists your Device Defender detect custom metrics.  Requires permission to access the ListCustomMetrics action.
    @Sendable
    @inlinable
    public func listCustomMetrics(_ input: ListCustomMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCustomMetricsResponse {
        try await self.client.execute(
            operation: "ListCustomMetrics", 
            path: "/custom-metrics", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists your Device Defender detect custom metrics.  Requires permission to access the ListCustomMetrics action.
    ///
    /// Parameters:
    ///   - maxResults:  The maximum number of results to return at one time. The default is 25.
    ///   - nextToken:  The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCustomMetrics(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCustomMetricsResponse {
        let input = ListCustomMetricsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listCustomMetrics(input, logger: logger)
    }

    ///  Lists mitigation actions executions for a Device Defender ML Detect Security Profile.  Requires permission to access the ListDetectMitigationActionsExecutions action.
    @Sendable
    @inlinable
    public func listDetectMitigationActionsExecutions(_ input: ListDetectMitigationActionsExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDetectMitigationActionsExecutionsResponse {
        try await self.client.execute(
            operation: "ListDetectMitigationActionsExecutions", 
            path: "/detect/mitigationactions/executions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists mitigation actions executions for a Device Defender ML Detect Security Profile.  Requires permission to access the ListDetectMitigationActionsExecutions action.
    ///
    /// Parameters:
    ///   - endTime:  The end of the time period for which ML Detect mitigation actions executions are returned.
    ///   - maxResults:  The maximum number of results to return at one time. The default is 25.
    ///   - nextToken:  The token for the next set of results.
    ///   - startTime:  A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - taskId:  The unique identifier of the task.
    ///   - thingName:  The name of the thing whose mitigation actions are listed.
    ///   - violationId:  The unique identifier of the violation.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDetectMitigationActionsExecutions(
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil,
        taskId: String? = nil,
        thingName: String? = nil,
        violationId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDetectMitigationActionsExecutionsResponse {
        let input = ListDetectMitigationActionsExecutionsRequest(
            endTime: endTime, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime, 
            taskId: taskId, 
            thingName: thingName, 
            violationId: violationId
        )
        return try await self.listDetectMitigationActionsExecutions(input, logger: logger)
    }

    ///  List of Device Defender ML Detect mitigation actions tasks.  Requires permission to access the ListDetectMitigationActionsTasks action.
    @Sendable
    @inlinable
    public func listDetectMitigationActionsTasks(_ input: ListDetectMitigationActionsTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDetectMitigationActionsTasksResponse {
        try await self.client.execute(
            operation: "ListDetectMitigationActionsTasks", 
            path: "/detect/mitigationactions/tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  List of Device Defender ML Detect mitigation actions tasks.  Requires permission to access the ListDetectMitigationActionsTasks action.
    ///
    /// Parameters:
    ///   - endTime:  The end of the time period for which ML Detect mitigation actions tasks are returned.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken:  The token for the next set of results.
    ///   - startTime:  A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDetectMitigationActionsTasks(
        endTime: Date,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDetectMitigationActionsTasksResponse {
        let input = ListDetectMitigationActionsTasksRequest(
            endTime: endTime, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime
        )
        return try await self.listDetectMitigationActionsTasks(input, logger: logger)
    }

    /// List the set of dimensions that are defined for your Amazon Web Services accounts. Requires permission to access the ListDimensions action.
    @Sendable
    @inlinable
    public func listDimensions(_ input: ListDimensionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDimensionsResponse {
        try await self.client.execute(
            operation: "ListDimensions", 
            path: "/dimensions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the set of dimensions that are defined for your Amazon Web Services accounts. Requires permission to access the ListDimensions action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to retrieve at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDimensions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDimensionsResponse {
        let input = ListDimensionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDimensions(input, logger: logger)
    }

    /// Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name. Requires permission to access the ListDomainConfigurations action.
    @Sendable
    @inlinable
    public func listDomainConfigurations(_ input: ListDomainConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDomainConfigurationsResponse {
        try await self.client.execute(
            operation: "ListDomainConfigurations", 
            path: "/domainConfigurations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name. Requires permission to access the ListDomainConfigurations action.
    ///
    /// Parameters:
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - serviceType: The type of service delivered by the endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDomainConfigurations(
        marker: String? = nil,
        pageSize: Int? = nil,
        serviceType: ServiceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDomainConfigurationsResponse {
        let input = ListDomainConfigurationsRequest(
            marker: marker, 
            pageSize: pageSize, 
            serviceType: serviceType
        )
        return try await self.listDomainConfigurations(input, logger: logger)
    }

    /// Lists all your fleet metrics.  Requires permission to access the ListFleetMetrics action.
    @Sendable
    @inlinable
    public func listFleetMetrics(_ input: ListFleetMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFleetMetricsResponse {
        try await self.client.execute(
            operation: "ListFleetMetrics", 
            path: "/fleet-metrics", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all your fleet metrics.  Requires permission to access the ListFleetMetrics action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken value from a previous response;  otherwise null to receive the first set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFleetMetrics(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFleetMetricsResponse {
        let input = ListFleetMetricsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFleetMetrics(input, logger: logger)
    }

    /// Lists the search indices. Requires permission to access the ListIndices action.
    @Sendable
    @inlinable
    public func listIndices(_ input: ListIndicesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIndicesResponse {
        try await self.client.execute(
            operation: "ListIndices", 
            path: "/indices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the search indices. Requires permission to access the ListIndices action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: The token used to get the next set of results, or null if there are no additional results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIndices(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIndicesResponse {
        let input = ListIndicesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listIndices(input, logger: logger)
    }

    /// Lists the job executions for a job. Requires permission to access the ListJobExecutionsForJob action.
    @Sendable
    @inlinable
    public func listJobExecutionsForJob(_ input: ListJobExecutionsForJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobExecutionsForJobResponse {
        try await self.client.execute(
            operation: "ListJobExecutionsForJob", 
            path: "/jobs/{jobId}/things", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the job executions for a job. Requires permission to access the ListJobExecutionsForJob action.
    ///
    /// Parameters:
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - maxResults: The maximum number of results to be returned per request.
    ///   - nextToken: The token to retrieve the next set of results.
    ///   - status: The status of the job.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobExecutionsForJob(
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: JobExecutionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobExecutionsForJobResponse {
        let input = ListJobExecutionsForJobRequest(
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listJobExecutionsForJob(input, logger: logger)
    }

    /// Lists the job executions for the specified thing. Requires permission to access the ListJobExecutionsForThing action.
    @Sendable
    @inlinable
    public func listJobExecutionsForThing(_ input: ListJobExecutionsForThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobExecutionsForThingResponse {
        try await self.client.execute(
            operation: "ListJobExecutionsForThing", 
            path: "/things/{thingName}/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the job executions for the specified thing. Requires permission to access the ListJobExecutionsForThing action.
    ///
    /// Parameters:
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - maxResults: The maximum number of results to be returned per request.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - nextToken: The token to retrieve the next set of results.
    ///   - status: An optional filter that lets you search for jobs that have the specified status.
    ///   - thingName: The thing name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobExecutionsForThing(
        jobId: String? = nil,
        maxResults: Int? = nil,
        namespaceId: String? = nil,
        nextToken: String? = nil,
        status: JobExecutionStatus? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobExecutionsForThingResponse {
        let input = ListJobExecutionsForThingRequest(
            jobId: jobId, 
            maxResults: maxResults, 
            namespaceId: namespaceId, 
            nextToken: nextToken, 
            status: status, 
            thingName: thingName
        )
        return try await self.listJobExecutionsForThing(input, logger: logger)
    }

    /// Returns a list of job templates. Requires permission to access the ListJobTemplates action.
    @Sendable
    @inlinable
    public func listJobTemplates(_ input: ListJobTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobTemplatesResponse {
        try await self.client.execute(
            operation: "ListJobTemplates", 
            path: "/job-templates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of job templates. Requires permission to access the ListJobTemplates action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the list.
    ///   - nextToken: The token to use to return the next set of results in the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobTemplatesResponse {
        let input = ListJobTemplatesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listJobTemplates(input, logger: logger)
    }

    /// Lists jobs. Requires permission to access the ListJobs action.
    @Sendable
    @inlinable
    public func listJobs(_ input: ListJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobsResponse {
        try await self.client.execute(
            operation: "ListJobs", 
            path: "/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists jobs. Requires permission to access the ListJobs action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return per request.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - nextToken: The token to retrieve the next set of results.
    ///   - status: An optional filter that lets you search for jobs that have the specified status.
    ///   - targetSelection: Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.   We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    ///   - thingGroupId: A filter that limits the returned jobs to those for the specified group.
    ///   - thingGroupName: A filter that limits the returned jobs to those for the specified group.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobs(
        maxResults: Int? = nil,
        namespaceId: String? = nil,
        nextToken: String? = nil,
        status: JobStatus? = nil,
        targetSelection: TargetSelection? = nil,
        thingGroupId: String? = nil,
        thingGroupName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobsResponse {
        let input = ListJobsRequest(
            maxResults: maxResults, 
            namespaceId: namespaceId, 
            nextToken: nextToken, 
            status: status, 
            targetSelection: targetSelection, 
            thingGroupId: thingGroupId, 
            thingGroupName: thingGroupName
        )
        return try await self.listJobs(input, logger: logger)
    }

    /// Returns a list of managed job templates.
    @Sendable
    @inlinable
    public func listManagedJobTemplates(_ input: ListManagedJobTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListManagedJobTemplatesResponse {
        try await self.client.execute(
            operation: "ListManagedJobTemplates", 
            path: "/managed-job-templates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of managed job templates.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of entries that can be returned.
    ///   - nextToken: The token to retrieve the next set of results.
    ///   - templateName: An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listManagedJobTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        templateName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListManagedJobTemplatesResponse {
        let input = ListManagedJobTemplatesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            templateName: templateName
        )
        return try await self.listManagedJobTemplates(input, logger: logger)
    }

    /// Lists the values reported for an IoT Device Defender metric (device-side metric, cloud-side metric, or custom metric)  by the given thing during the specified time period.
    @Sendable
    @inlinable
    public func listMetricValues(_ input: ListMetricValuesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMetricValuesResponse {
        try await self.client.execute(
            operation: "ListMetricValues", 
            path: "/metric-values", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the values reported for an IoT Device Defender metric (device-side metric, cloud-side metric, or custom metric)  by the given thing during the specified time period.
    ///
    /// Parameters:
    ///   - dimensionName: The dimension name.
    ///   - dimensionValueOperator: The dimension value operator.
    ///   - endTime: The end of the time period for which metric values are returned.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - metricName: The name of the security profile metric for which values are returned.
    ///   - nextToken: The token for the next set of results.
    ///   - startTime: The start of the time period for which metric values are returned.
    ///   - thingName: The name of the thing for which security profile metric values are returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMetricValues(
        dimensionName: String? = nil,
        dimensionValueOperator: DimensionValueOperator? = nil,
        endTime: Date,
        maxResults: Int? = nil,
        metricName: String,
        nextToken: String? = nil,
        startTime: Date,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMetricValuesResponse {
        let input = ListMetricValuesRequest(
            dimensionName: dimensionName, 
            dimensionValueOperator: dimensionValueOperator, 
            endTime: endTime, 
            maxResults: maxResults, 
            metricName: metricName, 
            nextToken: nextToken, 
            startTime: startTime, 
            thingName: thingName
        )
        return try await self.listMetricValues(input, logger: logger)
    }

    /// Gets a list of all mitigation actions that match the specified filter criteria. Requires permission to access the ListMitigationActions action.
    @Sendable
    @inlinable
    public func listMitigationActions(_ input: ListMitigationActionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMitigationActionsResponse {
        try await self.client.execute(
            operation: "ListMitigationActions", 
            path: "/mitigationactions/actions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of all mitigation actions that match the specified filter criteria. Requires permission to access the ListMitigationActions action.
    ///
    /// Parameters:
    ///   - actionType: Specify a value to limit the result to mitigation actions with a specific action type.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMitigationActions(
        actionType: MitigationActionType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMitigationActionsResponse {
        let input = ListMitigationActionsRequest(
            actionType: actionType, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMitigationActions(input, logger: logger)
    }

    /// Lists OTA updates. Requires permission to access the ListOTAUpdates action.
    @Sendable
    @inlinable
    public func listOTAUpdates(_ input: ListOTAUpdatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListOTAUpdatesResponse {
        try await self.client.execute(
            operation: "ListOTAUpdates", 
            path: "/otaUpdates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists OTA updates. Requires permission to access the ListOTAUpdates action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: A token used to retrieve the next set of results.
    ///   - otaUpdateStatus: The OTA update job status.
    ///   - logger: Logger use during operation
    @inlinable
    public func listOTAUpdates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        otaUpdateStatus: OTAUpdateStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListOTAUpdatesResponse {
        let input = ListOTAUpdatesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            otaUpdateStatus: otaUpdateStatus
        )
        return try await self.listOTAUpdates(input, logger: logger)
    }

    /// Lists certificates that are being transferred but not yet accepted. Requires permission to access the ListOutgoingCertificates action.
    @Sendable
    @inlinable
    public func listOutgoingCertificates(_ input: ListOutgoingCertificatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListOutgoingCertificatesResponse {
        try await self.client.execute(
            operation: "ListOutgoingCertificates", 
            path: "/certificates-out-going", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists certificates that are being transferred but not yet accepted. Requires permission to access the ListOutgoingCertificates action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - logger: Logger use during operation
    @inlinable
    public func listOutgoingCertificates(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListOutgoingCertificatesResponse {
        let input = ListOutgoingCertificatesRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize
        )
        return try await self.listOutgoingCertificates(input, logger: logger)
    }

    /// Lists the software package versions associated to the account. Requires permission to access the ListPackageVersions action.
    @Sendable
    @inlinable
    public func listPackageVersions(_ input: ListPackageVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPackageVersionsResponse {
        try await self.client.execute(
            operation: "ListPackageVersions", 
            path: "/packages/{packageName}/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the software package versions associated to the account. Requires permission to access the ListPackageVersions action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - packageName: The name of the target software package.
    ///   - status: The status of the package version. For more information, see Package version lifecycle.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPackageVersions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        packageName: String,
        status: PackageVersionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPackageVersionsResponse {
        let input = ListPackageVersionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            packageName: packageName, 
            status: status
        )
        return try await self.listPackageVersions(input, logger: logger)
    }

    /// Lists the software packages associated to the account. Requires permission to access the ListPackages action.
    @Sendable
    @inlinable
    public func listPackages(_ input: ListPackagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPackagesResponse {
        try await self.client.execute(
            operation: "ListPackages", 
            path: "/packages", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the software packages associated to the account. Requires permission to access the ListPackages action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results returned at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPackages(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPackagesResponse {
        let input = ListPackagesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPackages(input, logger: logger)
    }

    /// Lists your policies. Requires permission to access the ListPolicies action.
    @Sendable
    @inlinable
    public func listPolicies(_ input: ListPoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPoliciesResponse {
        try await self.client.execute(
            operation: "ListPolicies", 
            path: "/policies", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists your policies. Requires permission to access the ListPolicies action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Specifies the order for results. If true, the results are returned in ascending creation order.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicies(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPoliciesResponse {
        let input = ListPoliciesRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize
        )
        return try await self.listPolicies(input, logger: logger)
    }

    /// Lists the principals associated with the specified policy.  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use ListTargetsForPolicy instead. Requires permission to access the ListPolicyPrincipals action.
    @Sendable
    @inlinable
    public func listPolicyPrincipals(_ input: ListPolicyPrincipalsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyPrincipalsResponse {
        try await self.client.execute(
            operation: "ListPolicyPrincipals", 
            path: "/policy-principals", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the principals associated with the specified policy.  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use ListTargetsForPolicy instead. Requires permission to access the ListPolicyPrincipals action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Specifies the order for results. If true, the results are returned in ascending creation order.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - policyName: The policy name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyPrincipals(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyPrincipalsResponse {
        let input = ListPolicyPrincipalsRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize, 
            policyName: policyName
        )
        return try await self.listPolicyPrincipals(input, logger: logger)
    }

    /// Lists the versions of the specified policy and identifies the default version. Requires permission to access the ListPolicyVersions action.
    @Sendable
    @inlinable
    public func listPolicyVersions(_ input: ListPolicyVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPolicyVersionsResponse {
        try await self.client.execute(
            operation: "ListPolicyVersions", 
            path: "/policies/{policyName}/version", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the versions of the specified policy and identifies the default version. Requires permission to access the ListPolicyVersions action.
    ///
    /// Parameters:
    ///   - policyName: The policy name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPolicyVersions(
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPolicyVersionsResponse {
        let input = ListPolicyVersionsRequest(
            policyName: policyName
        )
        return try await self.listPolicyVersions(input, logger: logger)
    }

    /// Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in AmazonCognito Identity format.  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use ListAttachedPolicies instead. Requires permission to access the ListPrincipalPolicies action.
    @Sendable
    @inlinable
    public func listPrincipalPolicies(_ input: ListPrincipalPoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPrincipalPoliciesResponse {
        try await self.client.execute(
            operation: "ListPrincipalPolicies", 
            path: "/principal-policies", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in AmazonCognito Identity format.  Note: This action is deprecated and works as expected for backward compatibility, but we won't add enhancements. Use ListAttachedPolicies instead. Requires permission to access the ListPrincipalPolicies action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Specifies the order for results. If true, results are returned in ascending creation order.
    ///   - marker: The marker for the next set of results.
    ///   - pageSize: The result page size.
    ///   - principal: The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - logger: Logger use during operation
    @inlinable
    public func listPrincipalPolicies(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        principal: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPrincipalPoliciesResponse {
        let input = ListPrincipalPoliciesRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize, 
            principal: principal
        )
        return try await self.listPrincipalPolicies(input, logger: logger)
    }

    /// Lists the things associated with the specified principal. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.  Requires permission to access the ListPrincipalThings action.
    @Sendable
    @inlinable
    public func listPrincipalThings(_ input: ListPrincipalThingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPrincipalThingsResponse {
        try await self.client.execute(
            operation: "ListPrincipalThings", 
            path: "/principals/things", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the things associated with the specified principal. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities.  Requires permission to access the ListPrincipalThings action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - principal: The principal.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPrincipalThings(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPrincipalThingsResponse {
        let input = ListPrincipalThingsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            principal: principal
        )
        return try await self.listPrincipalThings(input, logger: logger)
    }

    /// Lists the things associated with the specified principal. A principal can be an X.509
    /// 			certificate or an Amazon Cognito ID. Requires permission to access the ListPrincipalThings action.
    @Sendable
    @inlinable
    public func listPrincipalThingsV2(_ input: ListPrincipalThingsV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPrincipalThingsV2Response {
        try await self.client.execute(
            operation: "ListPrincipalThingsV2", 
            path: "/principals/things-v2", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the things associated with the specified principal. A principal can be an X.509
    /// 			certificate or an Amazon Cognito ID. Requires permission to access the ListPrincipalThings action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - principal: The principal. A principal can be an X.509 certificate or an Amazon Cognito ID.
    ///   - thingPrincipalType: The type of the relation you want to filter in the response. If no value is provided in
    ///   - logger: Logger use during operation
    @inlinable
    public func listPrincipalThingsV2(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principal: String,
        thingPrincipalType: ThingPrincipalType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPrincipalThingsV2Response {
        let input = ListPrincipalThingsV2Request(
            maxResults: maxResults, 
            nextToken: nextToken, 
            principal: principal, 
            thingPrincipalType: thingPrincipalType
        )
        return try await self.listPrincipalThingsV2(input, logger: logger)
    }

    /// A list of provisioning template versions. Requires permission to access the ListProvisioningTemplateVersions action.
    @Sendable
    @inlinable
    public func listProvisioningTemplateVersions(_ input: ListProvisioningTemplateVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProvisioningTemplateVersionsResponse {
        try await self.client.execute(
            operation: "ListProvisioningTemplateVersions", 
            path: "/provisioning-templates/{templateName}/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A list of provisioning template versions. Requires permission to access the ListProvisioningTemplateVersions action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: A token to retrieve the next set of results.
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func listProvisioningTemplateVersions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProvisioningTemplateVersionsResponse {
        let input = ListProvisioningTemplateVersionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            templateName: templateName
        )
        return try await self.listProvisioningTemplateVersions(input, logger: logger)
    }

    /// Lists the provisioning templates in your Amazon Web Services account. Requires permission to access the ListProvisioningTemplates action.
    @Sendable
    @inlinable
    public func listProvisioningTemplates(_ input: ListProvisioningTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListProvisioningTemplatesResponse {
        try await self.client.execute(
            operation: "ListProvisioningTemplates", 
            path: "/provisioning-templates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the provisioning templates in your Amazon Web Services account. Requires permission to access the ListProvisioningTemplates action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: A token to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listProvisioningTemplates(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListProvisioningTemplatesResponse {
        let input = ListProvisioningTemplatesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listProvisioningTemplates(input, logger: logger)
    }

    /// The related resources of an Audit finding.  The following resources can be returned from calling this API:   DEVICE_CERTIFICATE   CA_CERTIFICATE   IOT_POLICY   COGNITO_IDENTITY_POOL   CLIENT_ID   ACCOUNT_SETTINGS   ROLE_ALIAS   IAM_ROLE   ISSUER_CERTIFICATE    This API is similar to DescribeAuditFinding's RelatedResources     but provides pagination and is not limited to 10 resources.  When calling DescribeAuditFinding for the intermediate CA revoked for  active device certificates check, RelatedResources will not be populated. You must use this API, ListRelatedResourcesForAuditFinding, to list the certificates.
    @Sendable
    @inlinable
    public func listRelatedResourcesForAuditFinding(_ input: ListRelatedResourcesForAuditFindingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRelatedResourcesForAuditFindingResponse {
        try await self.client.execute(
            operation: "ListRelatedResourcesForAuditFinding", 
            path: "/audit/relatedResources", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The related resources of an Audit finding.  The following resources can be returned from calling this API:   DEVICE_CERTIFICATE   CA_CERTIFICATE   IOT_POLICY   COGNITO_IDENTITY_POOL   CLIENT_ID   ACCOUNT_SETTINGS   ROLE_ALIAS   IAM_ROLE   ISSUER_CERTIFICATE    This API is similar to DescribeAuditFinding's RelatedResources     but provides pagination and is not limited to 10 resources.  When calling DescribeAuditFinding for the intermediate CA revoked for  active device certificates check, RelatedResources will not be populated. You must use this API, ListRelatedResourcesForAuditFinding, to list the certificates.
    ///
    /// Parameters:
    ///   - findingId: The finding Id.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: A token that can be used to retrieve the next set of results,  or null if there are no additional results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRelatedResourcesForAuditFinding(
        findingId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRelatedResourcesForAuditFindingResponse {
        let input = ListRelatedResourcesForAuditFindingRequest(
            findingId: findingId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listRelatedResourcesForAuditFinding(input, logger: logger)
    }

    /// Lists the role aliases registered in your account. Requires permission to access the ListRoleAliases action.
    @Sendable
    @inlinable
    public func listRoleAliases(_ input: ListRoleAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRoleAliasesResponse {
        try await self.client.execute(
            operation: "ListRoleAliases", 
            path: "/role-aliases", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the role aliases registered in your account. Requires permission to access the ListRoleAliases action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Return the list of role aliases in ascending alphabetical order.
    ///   - marker: A marker used to get the next set of results.
    ///   - pageSize: The maximum number of results to return at one time.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRoleAliases(
        ascendingOrder: Bool? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRoleAliasesResponse {
        let input = ListRoleAliasesRequest(
            ascendingOrder: ascendingOrder, 
            marker: marker, 
            pageSize: pageSize
        )
        return try await self.listRoleAliases(input, logger: logger)
    }

    /// The validation results for all software bill of materials (SBOM) attached to a specific software package version. Requires permission to access the ListSbomValidationResults action.
    @Sendable
    @inlinable
    public func listSbomValidationResults(_ input: ListSbomValidationResultsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSbomValidationResultsResponse {
        try await self.client.execute(
            operation: "ListSbomValidationResults", 
            path: "/packages/{packageName}/versions/{versionName}/sbom-validation-results", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The validation results for all software bill of materials (SBOM) attached to a specific software package version. Requires permission to access the ListSbomValidationResults action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: A token that can be used to retrieve the next set of results, or null if there are no additional results.
    ///   - packageName: The name of the new software package.
    ///   - validationResult: The end result of the
    ///   - versionName: The name of the new package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSbomValidationResults(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        packageName: String,
        validationResult: SbomValidationResult? = nil,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSbomValidationResultsResponse {
        let input = ListSbomValidationResultsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            packageName: packageName, 
            validationResult: validationResult, 
            versionName: versionName
        )
        return try await self.listSbomValidationResults(input, logger: logger)
    }

    /// Lists all of your scheduled audits. Requires permission to access the ListScheduledAudits action.
    @Sendable
    @inlinable
    public func listScheduledAudits(_ input: ListScheduledAuditsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListScheduledAuditsResponse {
        try await self.client.execute(
            operation: "ListScheduledAudits", 
            path: "/audit/scheduledaudits", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of your scheduled audits. Requires permission to access the ListScheduledAudits action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listScheduledAudits(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListScheduledAuditsResponse {
        let input = ListScheduledAuditsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listScheduledAudits(input, logger: logger)
    }

    /// Lists the Device Defender security profiles you've created. You can filter security profiles by dimension or custom metric. Requires permission to access the ListSecurityProfiles action.   dimensionName and metricName cannot be used in the same request.
    @Sendable
    @inlinable
    public func listSecurityProfiles(_ input: ListSecurityProfilesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSecurityProfilesResponse {
        try await self.client.execute(
            operation: "ListSecurityProfiles", 
            path: "/security-profiles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the Device Defender security profiles you've created. You can filter security profiles by dimension or custom metric. Requires permission to access the ListSecurityProfiles action.   dimensionName and metricName cannot be used in the same request.
    ///
    /// Parameters:
    ///   - dimensionName: A filter to limit results to the security profiles that use the defined dimension. Cannot be used with metricName
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - metricName:  The name of the custom metric. Cannot be used with dimensionName.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSecurityProfiles(
        dimensionName: String? = nil,
        maxResults: Int? = nil,
        metricName: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSecurityProfilesResponse {
        let input = ListSecurityProfilesRequest(
            dimensionName: dimensionName, 
            maxResults: maxResults, 
            metricName: metricName, 
            nextToken: nextToken
        )
        return try await self.listSecurityProfiles(input, logger: logger)
    }

    /// Lists the Device Defender security profiles attached to a target (thing group). Requires permission to access the ListSecurityProfilesForTarget action.
    @Sendable
    @inlinable
    public func listSecurityProfilesForTarget(_ input: ListSecurityProfilesForTargetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSecurityProfilesForTargetResponse {
        try await self.client.execute(
            operation: "ListSecurityProfilesForTarget", 
            path: "/security-profiles-for-target", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the Device Defender security profiles attached to a target (thing group). Requires permission to access the ListSecurityProfilesForTarget action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - recursive: If true, return child groups too.
    ///   - securityProfileTargetArn: The ARN of the target (thing group) whose attached security profiles you want to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSecurityProfilesForTarget(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recursive: Bool? = nil,
        securityProfileTargetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSecurityProfilesForTargetResponse {
        let input = ListSecurityProfilesForTargetRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            recursive: recursive, 
            securityProfileTargetArn: securityProfileTargetArn
        )
        return try await self.listSecurityProfilesForTarget(input, logger: logger)
    }

    /// Lists all of the streams in your Amazon Web Services account. Requires permission to access the ListStreams action.
    @Sendable
    @inlinable
    public func listStreams(_ input: ListStreamsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStreamsResponse {
        try await self.client.execute(
            operation: "ListStreams", 
            path: "/streams", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the streams in your Amazon Web Services account. Requires permission to access the ListStreams action.
    ///
    /// Parameters:
    ///   - ascendingOrder: Set to true to return the list of streams in ascending order.
    ///   - maxResults: The maximum number of results to return at a time.
    ///   - nextToken: A token used to get the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStreams(
        ascendingOrder: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStreamsResponse {
        let input = ListStreamsRequest(
            ascendingOrder: ascendingOrder, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listStreams(input, logger: logger)
    }

    /// Lists the tags (metadata) you have assigned to the resource. Requires permission to access the ListTagsForResource action.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags (metadata) you have assigned to the resource. Requires permission to access the ListTagsForResource action.
    ///
    /// Parameters:
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - resourceArn: The ARN of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// List targets for the specified policy. Requires permission to access the ListTargetsForPolicy action.
    @Sendable
    @inlinable
    public func listTargetsForPolicy(_ input: ListTargetsForPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTargetsForPolicyResponse {
        try await self.client.execute(
            operation: "ListTargetsForPolicy", 
            path: "/policy-targets/{policyName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List targets for the specified policy. Requires permission to access the ListTargetsForPolicy action.
    ///
    /// Parameters:
    ///   - marker: A marker used to get the next set of results.
    ///   - pageSize: The maximum number of results to return at one time.
    ///   - policyName: The policy name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTargetsForPolicy(
        marker: String? = nil,
        pageSize: Int? = nil,
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTargetsForPolicyResponse {
        let input = ListTargetsForPolicyRequest(
            marker: marker, 
            pageSize: pageSize, 
            policyName: policyName
        )
        return try await self.listTargetsForPolicy(input, logger: logger)
    }

    /// Lists the targets (thing groups) associated with a given Device Defender security profile. Requires permission to access the ListTargetsForSecurityProfile action.
    @Sendable
    @inlinable
    public func listTargetsForSecurityProfile(_ input: ListTargetsForSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTargetsForSecurityProfileResponse {
        try await self.client.execute(
            operation: "ListTargetsForSecurityProfile", 
            path: "/security-profiles/{securityProfileName}/targets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the targets (thing groups) associated with a given Device Defender security profile. Requires permission to access the ListTargetsForSecurityProfile action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - securityProfileName: The security profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTargetsForSecurityProfile(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTargetsForSecurityProfileResponse {
        let input = ListTargetsForSecurityProfileRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            securityProfileName: securityProfileName
        )
        return try await self.listTargetsForSecurityProfile(input, logger: logger)
    }

    /// List the thing groups in your account. Requires permission to access the ListThingGroups action.
    @Sendable
    @inlinable
    public func listThingGroups(_ input: ListThingGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingGroupsResponse {
        try await self.client.execute(
            operation: "ListThingGroups", 
            path: "/thing-groups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the thing groups in your account. Requires permission to access the ListThingGroups action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - namePrefixFilter: A filter that limits the results to those with the specified name prefix.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - parentGroup: A filter that limits the results to those with the specified parent group.
    ///   - recursive: If true, return child groups as well.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingGroups(
        maxResults: Int? = nil,
        namePrefixFilter: String? = nil,
        nextToken: String? = nil,
        parentGroup: String? = nil,
        recursive: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingGroupsResponse {
        let input = ListThingGroupsRequest(
            maxResults: maxResults, 
            namePrefixFilter: namePrefixFilter, 
            nextToken: nextToken, 
            parentGroup: parentGroup, 
            recursive: recursive
        )
        return try await self.listThingGroups(input, logger: logger)
    }

    /// List the thing groups to which the specified thing belongs. Requires permission to access the ListThingGroupsForThing action.
    @Sendable
    @inlinable
    public func listThingGroupsForThing(_ input: ListThingGroupsForThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingGroupsForThingResponse {
        try await self.client.execute(
            operation: "ListThingGroupsForThing", 
            path: "/things/{thingName}/thing-groups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the thing groups to which the specified thing belongs. Requires permission to access the ListThingGroupsForThing action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - thingName: The thing name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingGroupsForThing(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingGroupsForThingResponse {
        let input = ListThingGroupsForThingRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            thingName: thingName
        )
        return try await self.listThingGroupsForThing(input, logger: logger)
    }

    /// Lists the principals associated with the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities. Requires permission to access the ListThingPrincipals action.
    @Sendable
    @inlinable
    public func listThingPrincipals(_ input: ListThingPrincipalsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingPrincipalsResponse {
        try await self.client.execute(
            operation: "ListThingPrincipals", 
            path: "/things/{thingName}/principals", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the principals associated with the specified thing. A principal can be X.509
    /// 			certificates, IAM users, groups, and roles, Amazon Cognito identities or federated
    /// 			identities. Requires permission to access the ListThingPrincipals action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - thingName: The name of the thing.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingPrincipals(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingPrincipalsResponse {
        let input = ListThingPrincipalsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            thingName: thingName
        )
        return try await self.listThingPrincipals(input, logger: logger)
    }

    /// Lists the principals associated with the specified thing. A principal can be an X.509
    /// 			certificate or an Amazon Cognito ID. Requires permission to access the ListThingPrincipals action.
    @Sendable
    @inlinable
    public func listThingPrincipalsV2(_ input: ListThingPrincipalsV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingPrincipalsV2Response {
        try await self.client.execute(
            operation: "ListThingPrincipalsV2", 
            path: "/things/{thingName}/principals-v2", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the principals associated with the specified thing. A principal can be an X.509
    /// 			certificate or an Amazon Cognito ID. Requires permission to access the ListThingPrincipals action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - thingName: The name of the thing.
    ///   - thingPrincipalType: The type of the relation you want to filter in the response. If no value is provided in
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingPrincipalsV2(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingName: String,
        thingPrincipalType: ThingPrincipalType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingPrincipalsV2Response {
        let input = ListThingPrincipalsV2Request(
            maxResults: maxResults, 
            nextToken: nextToken, 
            thingName: thingName, 
            thingPrincipalType: thingPrincipalType
        )
        return try await self.listThingPrincipalsV2(input, logger: logger)
    }

    /// Information about the thing registration tasks.
    @Sendable
    @inlinable
    public func listThingRegistrationTaskReports(_ input: ListThingRegistrationTaskReportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingRegistrationTaskReportsResponse {
        try await self.client.execute(
            operation: "ListThingRegistrationTaskReports", 
            path: "/thing-registration-tasks/{taskId}/reports", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Information about the thing registration tasks.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return per request.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - reportType: The type of task report.
    ///   - taskId: The id of the task.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingRegistrationTaskReports(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        reportType: ReportType,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingRegistrationTaskReportsResponse {
        let input = ListThingRegistrationTaskReportsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            reportType: reportType, 
            taskId: taskId
        )
        return try await self.listThingRegistrationTaskReports(input, logger: logger)
    }

    /// List bulk thing provisioning tasks. Requires permission to access the ListThingRegistrationTasks action.
    @Sendable
    @inlinable
    public func listThingRegistrationTasks(_ input: ListThingRegistrationTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingRegistrationTasksResponse {
        try await self.client.execute(
            operation: "ListThingRegistrationTasks", 
            path: "/thing-registration-tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List bulk thing provisioning tasks. Requires permission to access the ListThingRegistrationTasks action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - status: The status of the bulk thing provisioning task.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingRegistrationTasks(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: Status? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingRegistrationTasksResponse {
        let input = ListThingRegistrationTasksRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listThingRegistrationTasks(input, logger: logger)
    }

    /// Lists the existing thing types. Requires permission to access the ListThingTypes action.
    @Sendable
    @inlinable
    public func listThingTypes(_ input: ListThingTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingTypesResponse {
        try await self.client.execute(
            operation: "ListThingTypes", 
            path: "/thing-types", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the existing thing types. Requires permission to access the ListThingTypes action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - thingTypeName: The name of the thing type.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingTypes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingTypeName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingTypesResponse {
        let input = ListThingTypesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            thingTypeName: thingTypeName
        )
        return try await self.listThingTypes(input, logger: logger)
    }

    /// Lists your things. Use the attributeName and attributeValue parameters to filter your things. For example,
    /// 			calling ListThings with attributeName=Color and attributeValue=Red
    /// 			retrieves all things in the registry that contain an attribute Color with the value Red. For more
    /// 			information, see List Things from the Amazon Web Services IoT Core Developer
    /// 				Guide. Requires permission to access the ListThings action.  You will not be charged for calling this API if an Access denied error is returned. You will also not be charged if no attributes or pagination token was provided in request and no pagination token and no results were returned.
    @Sendable
    @inlinable
    public func listThings(_ input: ListThingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingsResponse {
        try await self.client.execute(
            operation: "ListThings", 
            path: "/things", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists your things. Use the attributeName and attributeValue parameters to filter your things. For example,
    /// 			calling ListThings with attributeName=Color and attributeValue=Red
    /// 			retrieves all things in the registry that contain an attribute Color with the value Red. For more
    /// 			information, see List Things from the Amazon Web Services IoT Core Developer
    /// 				Guide. Requires permission to access the ListThings action.  You will not be charged for calling this API if an Access denied error is returned. You will also not be charged if no attributes or pagination token was provided in request and no pagination token and no results were returned.
    ///
    /// Parameters:
    ///   - attributeName: The attribute name used to search for things.
    ///   - attributeValue: The attribute value used to search for things.
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - thingTypeName: The name of the thing type used to search for things.
    ///   - usePrefixAttributeValue: When true, the action returns the thing resources with attribute values that start with the attributeValue provided. When false, or not present, the action returns only the thing
    ///   - logger: Logger use during operation
    @inlinable
    public func listThings(
        attributeName: String? = nil,
        attributeValue: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        thingTypeName: String? = nil,
        usePrefixAttributeValue: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingsResponse {
        let input = ListThingsRequest(
            attributeName: attributeName, 
            attributeValue: attributeValue, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            thingTypeName: thingTypeName, 
            usePrefixAttributeValue: usePrefixAttributeValue
        )
        return try await self.listThings(input, logger: logger)
    }

    /// Lists the things you have added to the given billing group. Requires permission to access the ListThingsInBillingGroup action.
    @Sendable
    @inlinable
    public func listThingsInBillingGroup(_ input: ListThingsInBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingsInBillingGroupResponse {
        try await self.client.execute(
            operation: "ListThingsInBillingGroup", 
            path: "/billing-groups/{billingGroupName}/things", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the things you have added to the given billing group. Requires permission to access the ListThingsInBillingGroup action.
    ///
    /// Parameters:
    ///   - billingGroupName: The name of the billing group.
    ///   - maxResults: The maximum number of results to return per request.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingsInBillingGroup(
        billingGroupName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingsInBillingGroupResponse {
        let input = ListThingsInBillingGroupRequest(
            billingGroupName: billingGroupName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listThingsInBillingGroup(input, logger: logger)
    }

    /// Lists the things in the specified group. Requires permission to access the ListThingsInThingGroup action.
    @Sendable
    @inlinable
    public func listThingsInThingGroup(_ input: ListThingsInThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListThingsInThingGroupResponse {
        try await self.client.execute(
            operation: "ListThingsInThingGroup", 
            path: "/thing-groups/{thingGroupName}/things", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the things in the specified group. Requires permission to access the ListThingsInThingGroup action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: To retrieve the next set of results, the nextToken
    ///   - recursive: When true, list things in this thing group and in all child groups as
    ///   - thingGroupName: The thing group name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listThingsInThingGroup(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recursive: Bool? = nil,
        thingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListThingsInThingGroupResponse {
        let input = ListThingsInThingGroupRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            recursive: recursive, 
            thingGroupName: thingGroupName
        )
        return try await self.listThingsInThingGroup(input, logger: logger)
    }

    /// Lists all the topic rule destinations in your Amazon Web Services account. Requires permission to access the ListTopicRuleDestinations action.
    @Sendable
    @inlinable
    public func listTopicRuleDestinations(_ input: ListTopicRuleDestinationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTopicRuleDestinationsResponse {
        try await self.client.execute(
            operation: "ListTopicRuleDestinations", 
            path: "/destinations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the topic rule destinations in your Amazon Web Services account. Requires permission to access the ListTopicRuleDestinations action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTopicRuleDestinations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTopicRuleDestinationsResponse {
        let input = ListTopicRuleDestinationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listTopicRuleDestinations(input, logger: logger)
    }

    /// Lists the rules for the specific topic. Requires permission to access the ListTopicRules action.
    @Sendable
    @inlinable
    public func listTopicRules(_ input: ListTopicRulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTopicRulesResponse {
        try await self.client.execute(
            operation: "ListTopicRules", 
            path: "/rules", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the rules for the specific topic. Requires permission to access the ListTopicRules action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    ///   - ruleDisabled: Specifies whether the rule is disabled.
    ///   - topic: The topic.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTopicRules(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        ruleDisabled: Bool? = nil,
        topic: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTopicRulesResponse {
        let input = ListTopicRulesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            ruleDisabled: ruleDisabled, 
            topic: topic
        )
        return try await self.listTopicRules(input, logger: logger)
    }

    /// Lists logging levels. Requires permission to access the ListV2LoggingLevels action.
    @Sendable
    @inlinable
    public func listV2LoggingLevels(_ input: ListV2LoggingLevelsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListV2LoggingLevelsResponse {
        try await self.client.execute(
            operation: "ListV2LoggingLevels", 
            path: "/v2LoggingLevel", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists logging levels. Requires permission to access the ListV2LoggingLevels action.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    ///   - targetType: The type of resource for which you are configuring logging. Must be THING_Group.
    ///   - logger: Logger use during operation
    @inlinable
    public func listV2LoggingLevels(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        targetType: LogTargetType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListV2LoggingLevelsResponse {
        let input = ListV2LoggingLevelsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            targetType: targetType
        )
        return try await self.listV2LoggingLevels(input, logger: logger)
    }

    /// Lists the Device Defender security profile violations discovered during the given time period.  You can use filters to limit the results to those alerts issued for a particular security profile,  behavior, or thing (device). Requires permission to access the ListViolationEvents action.
    @Sendable
    @inlinable
    public func listViolationEvents(_ input: ListViolationEventsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListViolationEventsResponse {
        try await self.client.execute(
            operation: "ListViolationEvents", 
            path: "/violation-events", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the Device Defender security profile violations discovered during the given time period.  You can use filters to limit the results to those alerts issued for a particular security profile,  behavior, or thing (device). Requires permission to access the ListViolationEvents action.
    ///
    /// Parameters:
    ///   - behaviorCriteriaType:  The criteria for a behavior.
    ///   - endTime: The end time for the alerts to be listed.
    ///   - listSuppressedAlerts:  A list of all suppressed alerts.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - nextToken: The token for the next set of results.
    ///   - securityProfileName: A filter to limit results to those alerts generated by the specified security profile.
    ///   - startTime: The start time for the alerts to be listed.
    ///   - thingName: A filter to limit results to those alerts caused by the specified thing.
    ///   - verificationState: The verification state of the violation (detect alarm).
    ///   - logger: Logger use during operation
    @inlinable
    public func listViolationEvents(
        behaviorCriteriaType: BehaviorCriteriaType? = nil,
        endTime: Date,
        listSuppressedAlerts: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        securityProfileName: String? = nil,
        startTime: Date,
        thingName: String? = nil,
        verificationState: VerificationState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListViolationEventsResponse {
        let input = ListViolationEventsRequest(
            behaviorCriteriaType: behaviorCriteriaType, 
            endTime: endTime, 
            listSuppressedAlerts: listSuppressedAlerts, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            securityProfileName: securityProfileName, 
            startTime: startTime, 
            thingName: thingName, 
            verificationState: verificationState
        )
        return try await self.listViolationEvents(input, logger: logger)
    }

    /// Set a verification state and provide a description of that verification state on a violation (detect alarm).
    @Sendable
    @inlinable
    public func putVerificationStateOnViolation(_ input: PutVerificationStateOnViolationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutVerificationStateOnViolationResponse {
        try await self.client.execute(
            operation: "PutVerificationStateOnViolation", 
            path: "/violations/verification-state/{violationId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Set a verification state and provide a description of that verification state on a violation (detect alarm).
    ///
    /// Parameters:
    ///   - verificationState: The verification state of the violation.
    ///   - verificationStateDescription: The description of the verification state of the violation (detect alarm).
    ///   - violationId: The violation ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func putVerificationStateOnViolation(
        verificationState: VerificationState,
        verificationStateDescription: String? = nil,
        violationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutVerificationStateOnViolationResponse {
        let input = PutVerificationStateOnViolationRequest(
            verificationState: verificationState, 
            verificationStateDescription: verificationStateDescription, 
            violationId: violationId
        )
        return try await self.putVerificationStateOnViolation(input, logger: logger)
    }

    /// Registers a CA certificate with Amazon Web Services IoT Core. There is no limit to the number of CA certificates you can register in your Amazon Web Services account. You can register up to 10 CA certificates with the same CA subject field per Amazon Web Services account. Requires permission to access the RegisterCACertificate action.
    @Sendable
    @inlinable
    public func registerCACertificate(_ input: RegisterCACertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterCACertificateResponse {
        try await self.client.execute(
            operation: "RegisterCACertificate", 
            path: "/cacertificate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Registers a CA certificate with Amazon Web Services IoT Core. There is no limit to the number of CA certificates you can register in your Amazon Web Services account. You can register up to 10 CA certificates with the same CA subject field per Amazon Web Services account. Requires permission to access the RegisterCACertificate action.
    ///
    /// Parameters:
    ///   - allowAutoRegistration: Allows this CA certificate to be used for auto registration of device certificates.
    ///   - caCertificate: The CA certificate.
    ///   - certificateMode: Describes the certificate mode in which the Certificate Authority (CA) will be registered. If the verificationCertificate field is not provided, set certificateMode to be SNI_ONLY. If the verificationCertificate field is provided, set certificateMode to be DEFAULT. When certificateMode is not provided, it defaults to DEFAULT. All the device certificates that are registered using this CA will be registered in the same certificate mode as the CA. For more information about certificate mode for device certificates, see   certificate mode.
    ///   - registrationConfig: Information about the registration configuration.
    ///   - setAsActive: A boolean value that specifies if the CA certificate is set to active. Valid values: ACTIVE | INACTIVE
    ///   - tags: Metadata which can be used to manage the CA certificate.  For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    ///   - verificationCertificate: The private key verification certificate. If certificateMode is SNI_ONLY, the verificationCertificate field must be empty. If certificateMode is DEFAULT or not provided, the verificationCertificate field must not be empty.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerCACertificate(
        allowAutoRegistration: Bool? = nil,
        caCertificate: String,
        certificateMode: CertificateMode? = nil,
        registrationConfig: RegistrationConfig? = nil,
        setAsActive: Bool? = nil,
        tags: [Tag]? = nil,
        verificationCertificate: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterCACertificateResponse {
        let input = RegisterCACertificateRequest(
            allowAutoRegistration: allowAutoRegistration, 
            caCertificate: caCertificate, 
            certificateMode: certificateMode, 
            registrationConfig: registrationConfig, 
            setAsActive: setAsActive, 
            tags: tags, 
            verificationCertificate: verificationCertificate
        )
        return try await self.registerCACertificate(input, logger: logger)
    }

    /// Registers a device certificate with IoT in the same certificate mode as the signing CA. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered. Requires permission to access the RegisterCertificate action.
    @Sendable
    @inlinable
    public func registerCertificate(_ input: RegisterCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterCertificateResponse {
        try await self.client.execute(
            operation: "RegisterCertificate", 
            path: "/certificate/register", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Registers a device certificate with IoT in the same certificate mode as the signing CA. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered. Requires permission to access the RegisterCertificate action.
    ///
    /// Parameters:
    ///   - caCertificatePem: The CA certificate used to sign the device certificate being registered.
    ///   - certificatePem: The certificate data, in PEM format.
    ///   - status: The status of the register certificate request. Valid values that you can use include  ACTIVE, INACTIVE, and REVOKED.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerCertificate(
        caCertificatePem: String? = nil,
        certificatePem: String,
        status: CertificateStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterCertificateResponse {
        let input = RegisterCertificateRequest(
            caCertificatePem: caCertificatePem, 
            certificatePem: certificatePem, 
            status: status
        )
        return try await self.registerCertificate(input, logger: logger)
    }

    /// Register a certificate that does not have a certificate authority (CA).  For supported certificates, consult  Certificate signing algorithms supported by IoT.
    @Sendable
    @inlinable
    public func registerCertificateWithoutCA(_ input: RegisterCertificateWithoutCARequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterCertificateWithoutCAResponse {
        try await self.client.execute(
            operation: "RegisterCertificateWithoutCA", 
            path: "/certificate/register-no-ca", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Register a certificate that does not have a certificate authority (CA).  For supported certificates, consult  Certificate signing algorithms supported by IoT.
    ///
    /// Parameters:
    ///   - certificatePem: The certificate data, in PEM format.
    ///   - status: The status of the register certificate request.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerCertificateWithoutCA(
        certificatePem: String,
        status: CertificateStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterCertificateWithoutCAResponse {
        let input = RegisterCertificateWithoutCARequest(
            certificatePem: certificatePem, 
            status: status
        )
        return try await self.registerCertificateWithoutCA(input, logger: logger)
    }

    /// Provisions a thing in the device registry. RegisterThing calls other IoT control plane APIs. These calls might exceed your account level  IoT Throttling Limits and cause throttle errors. Please contact Amazon Web Services Customer Support to raise your throttling limits if necessary. Requires permission to access the RegisterThing action.
    @Sendable
    @inlinable
    public func registerThing(_ input: RegisterThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterThingResponse {
        try await self.client.execute(
            operation: "RegisterThing", 
            path: "/things", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provisions a thing in the device registry. RegisterThing calls other IoT control plane APIs. These calls might exceed your account level  IoT Throttling Limits and cause throttle errors. Please contact Amazon Web Services Customer Support to raise your throttling limits if necessary. Requires permission to access the RegisterThing action.
    ///
    /// Parameters:
    ///   - parameters: The parameters for provisioning a thing. See Provisioning Templates for more information.
    ///   - templateBody: The provisioning template. See Provisioning Devices That Have Device Certificates for more information.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerThing(
        parameters: [String: String]? = nil,
        templateBody: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterThingResponse {
        let input = RegisterThingRequest(
            parameters: parameters, 
            templateBody: templateBody
        )
        return try await self.registerThing(input, logger: logger)
    }

    /// Rejects a pending certificate transfer. After IoT rejects a certificate transfer, the certificate status changes from PENDING_TRANSFER to INACTIVE. To check for pending certificate transfers, call ListCertificates to enumerate your certificates. This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state. Requires permission to access the RejectCertificateTransfer action.
    @Sendable
    @inlinable
    public func rejectCertificateTransfer(_ input: RejectCertificateTransferRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "RejectCertificateTransfer", 
            path: "/reject-certificate-transfer/{certificateId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Rejects a pending certificate transfer. After IoT rejects a certificate transfer, the certificate status changes from PENDING_TRANSFER to INACTIVE. To check for pending certificate transfers, call ListCertificates to enumerate your certificates. This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state. Requires permission to access the RejectCertificateTransfer action.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - rejectReason: The reason the certificate transfer was rejected.
    ///   - logger: Logger use during operation
    @inlinable
    public func rejectCertificateTransfer(
        certificateId: String,
        rejectReason: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = RejectCertificateTransferRequest(
            certificateId: certificateId, 
            rejectReason: rejectReason
        )
        return try await self.rejectCertificateTransfer(input, logger: logger)
    }

    /// Removes the given thing from the billing group. Requires permission to access the RemoveThingFromBillingGroup action.  This call is asynchronous. It might take several seconds for the detachment to propagate.
    @Sendable
    @inlinable
    public func removeThingFromBillingGroup(_ input: RemoveThingFromBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveThingFromBillingGroupResponse {
        try await self.client.execute(
            operation: "RemoveThingFromBillingGroup", 
            path: "/billing-groups/removeThingFromBillingGroup", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the given thing from the billing group. Requires permission to access the RemoveThingFromBillingGroup action.  This call is asynchronous. It might take several seconds for the detachment to propagate.
    ///
    /// Parameters:
    ///   - billingGroupArn: The ARN of the billing group.
    ///   - billingGroupName: The name of the billing group.
    ///   - thingArn: The ARN of the thing to be removed from the billing group.
    ///   - thingName: The name of the thing to be removed from the billing group.
    ///   - logger: Logger use during operation
    @inlinable
    public func removeThingFromBillingGroup(
        billingGroupArn: String? = nil,
        billingGroupName: String? = nil,
        thingArn: String? = nil,
        thingName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RemoveThingFromBillingGroupResponse {
        let input = RemoveThingFromBillingGroupRequest(
            billingGroupArn: billingGroupArn, 
            billingGroupName: billingGroupName, 
            thingArn: thingArn, 
            thingName: thingName
        )
        return try await self.removeThingFromBillingGroup(input, logger: logger)
    }

    /// Remove the specified thing from the specified group. You must specify either a thingGroupArn or a
    /// 			thingGroupName to identify the thing group and
    /// 			either a thingArn or a thingName to
    /// 			identify the thing to remove from the thing group.
    /// 		 Requires permission to access the RemoveThingFromThingGroup action.
    @Sendable
    @inlinable
    public func removeThingFromThingGroup(_ input: RemoveThingFromThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveThingFromThingGroupResponse {
        try await self.client.execute(
            operation: "RemoveThingFromThingGroup", 
            path: "/thing-groups/removeThingFromThingGroup", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Remove the specified thing from the specified group. You must specify either a thingGroupArn or a
    /// 			thingGroupName to identify the thing group and
    /// 			either a thingArn or a thingName to
    /// 			identify the thing to remove from the thing group.
    /// 		 Requires permission to access the RemoveThingFromThingGroup action.
    ///
    /// Parameters:
    ///   - thingArn: The ARN of the thing to remove from the group.
    ///   - thingGroupArn: The group ARN.
    ///   - thingGroupName: The group name.
    ///   - thingName: The name of the thing to remove from the group.
    ///   - logger: Logger use during operation
    @inlinable
    public func removeThingFromThingGroup(
        thingArn: String? = nil,
        thingGroupArn: String? = nil,
        thingGroupName: String? = nil,
        thingName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RemoveThingFromThingGroupResponse {
        let input = RemoveThingFromThingGroupRequest(
            thingArn: thingArn, 
            thingGroupArn: thingGroupArn, 
            thingGroupName: thingGroupName, 
            thingName: thingName
        )
        return try await self.removeThingFromThingGroup(input, logger: logger)
    }

    /// Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule. Requires permission to access the ReplaceTopicRule action.
    @Sendable
    @inlinable
    public func replaceTopicRule(_ input: ReplaceTopicRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "ReplaceTopicRule", 
            path: "/rules/{ruleName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule. Requires permission to access the ReplaceTopicRule action.
    ///
    /// Parameters:
    ///   - ruleName: The name of the rule.
    ///   - topicRulePayload: The rule payload.
    ///   - logger: Logger use during operation
    @inlinable
    public func replaceTopicRule(
        ruleName: String,
        topicRulePayload: TopicRulePayload,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = ReplaceTopicRuleRequest(
            ruleName: ruleName, 
            topicRulePayload: topicRulePayload
        )
        return try await self.replaceTopicRule(input, logger: logger)
    }

    /// The query search index. Requires permission to access the SearchIndex action.
    @Sendable
    @inlinable
    public func searchIndex(_ input: SearchIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchIndexResponse {
        try await self.client.execute(
            operation: "SearchIndex", 
            path: "/indices/search", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The query search index. Requires permission to access the SearchIndex action.
    ///
    /// Parameters:
    ///   - indexName: The search index name.
    ///   - maxResults: The maximum number of results to return per page at one time. This maximum number cannot exceed 100. The response might contain fewer results but will never contain more. You can use  nextToken to retrieve the next set of results until nextToken returns NULL.
    ///   - nextToken: The token used to get the next set of results, or null if there are no additional results.
    ///   - queryString: The search query string. For more information about the search query syntax, see Query syntax.
    ///   - queryVersion: The query version.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchIndex(
        indexName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queryString: String,
        queryVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchIndexResponse {
        let input = SearchIndexRequest(
            indexName: indexName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queryString: queryString, 
            queryVersion: queryVersion
        )
        return try await self.searchIndex(input, logger: logger)
    }

    /// Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer. Requires permission to access the SetDefaultAuthorizer action.
    @Sendable
    @inlinable
    public func setDefaultAuthorizer(_ input: SetDefaultAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SetDefaultAuthorizerResponse {
        try await self.client.execute(
            operation: "SetDefaultAuthorizer", 
            path: "/default-authorizer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer. Requires permission to access the SetDefaultAuthorizer action.
    ///
    /// Parameters:
    ///   - authorizerName: The authorizer name.
    ///   - logger: Logger use during operation
    @inlinable
    public func setDefaultAuthorizer(
        authorizerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SetDefaultAuthorizerResponse {
        let input = SetDefaultAuthorizerRequest(
            authorizerName: authorizerName
        )
        return try await self.setDefaultAuthorizer(input, logger: logger)
    }

    /// Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicies action. Requires permission to access the SetDefaultPolicyVersion action.
    @Sendable
    @inlinable
    public func setDefaultPolicyVersion(_ input: SetDefaultPolicyVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "SetDefaultPolicyVersion", 
            path: "/policies/{policyName}/version/{policyVersionId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicies action. Requires permission to access the SetDefaultPolicyVersion action.
    ///
    /// Parameters:
    ///   - policyName: The policy name.
    ///   - policyVersionId: The policy version ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func setDefaultPolicyVersion(
        policyName: String,
        policyVersionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = SetDefaultPolicyVersionRequest(
            policyName: policyName, 
            policyVersionId: policyVersionId
        )
        return try await self.setDefaultPolicyVersion(input, logger: logger)
    }

    /// Sets the logging options. NOTE: use of this command is not recommended. Use SetV2LoggingOptions instead. Requires permission to access the SetLoggingOptions action.
    @Sendable
    @inlinable
    public func setLoggingOptions(_ input: SetLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "SetLoggingOptions", 
            path: "/loggingOptions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the logging options. NOTE: use of this command is not recommended. Use SetV2LoggingOptions instead. Requires permission to access the SetLoggingOptions action.
    ///
    /// Parameters:
    ///   - loggingOptionsPayload: The logging options payload.
    ///   - logger: Logger use during operation
    @inlinable
    public func setLoggingOptions(
        loggingOptionsPayload: LoggingOptionsPayload,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = SetLoggingOptionsRequest(
            loggingOptionsPayload: loggingOptionsPayload
        )
        return try await self.setLoggingOptions(input, logger: logger)
    }

    /// Sets the logging level. Requires permission to access the SetV2LoggingLevel action.
    @Sendable
    @inlinable
    public func setV2LoggingLevel(_ input: SetV2LoggingLevelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "SetV2LoggingLevel", 
            path: "/v2LoggingLevel", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the logging level. Requires permission to access the SetV2LoggingLevel action.
    ///
    /// Parameters:
    ///   - logLevel: The log level.
    ///   - logTarget: The log target.
    ///   - logger: Logger use during operation
    @inlinable
    public func setV2LoggingLevel(
        logLevel: LogLevel,
        logTarget: LogTarget,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = SetV2LoggingLevelRequest(
            logLevel: logLevel, 
            logTarget: logTarget
        )
        return try await self.setV2LoggingLevel(input, logger: logger)
    }

    /// Sets the logging options for the V2 logging service. Requires permission to access the SetV2LoggingOptions action.
    @Sendable
    @inlinable
    public func setV2LoggingOptions(_ input: SetV2LoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "SetV2LoggingOptions", 
            path: "/v2LoggingOptions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the logging options for the V2 logging service. Requires permission to access the SetV2LoggingOptions action.
    ///
    /// Parameters:
    ///   - defaultLogLevel: The default logging level.
    ///   - disableAllLogs: If true all logs are disabled. The default is false.
    ///   - roleArn: The ARN of the role that allows IoT to write to Cloudwatch logs.
    ///   - logger: Logger use during operation
    @inlinable
    public func setV2LoggingOptions(
        defaultLogLevel: LogLevel? = nil,
        disableAllLogs: Bool? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = SetV2LoggingOptionsRequest(
            defaultLogLevel: defaultLogLevel, 
            disableAllLogs: disableAllLogs, 
            roleArn: roleArn
        )
        return try await self.setV2LoggingOptions(input, logger: logger)
    }

    /// Starts a task that applies a set of mitigation actions to the specified target. Requires permission to access the StartAuditMitigationActionsTask action.
    @Sendable
    @inlinable
    public func startAuditMitigationActionsTask(_ input: StartAuditMitigationActionsTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartAuditMitigationActionsTaskResponse {
        try await self.client.execute(
            operation: "StartAuditMitigationActionsTask", 
            path: "/audit/mitigationactions/tasks/{taskId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a task that applies a set of mitigation actions to the specified target. Requires permission to access the StartAuditMitigationActionsTask action.
    ///
    /// Parameters:
    ///   - auditCheckToActionsMapping: For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.
    ///   - clientRequestToken: Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.
    ///   - target: Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.
    ///   - taskId: A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
    ///   - logger: Logger use during operation
    @inlinable
    public func startAuditMitigationActionsTask(
        auditCheckToActionsMapping: [String: [String]],
        clientRequestToken: String = StartAuditMitigationActionsTaskRequest.idempotencyToken(),
        target: AuditMitigationActionsTaskTarget,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartAuditMitigationActionsTaskResponse {
        let input = StartAuditMitigationActionsTaskRequest(
            auditCheckToActionsMapping: auditCheckToActionsMapping, 
            clientRequestToken: clientRequestToken, 
            target: target, 
            taskId: taskId
        )
        return try await self.startAuditMitigationActionsTask(input, logger: logger)
    }

    ///  Starts a Device Defender ML Detect mitigation actions task.  Requires permission to access the StartDetectMitigationActionsTask action.
    @Sendable
    @inlinable
    public func startDetectMitigationActionsTask(_ input: StartDetectMitigationActionsTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartDetectMitigationActionsTaskResponse {
        try await self.client.execute(
            operation: "StartDetectMitigationActionsTask", 
            path: "/detect/mitigationactions/tasks/{taskId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Starts a Device Defender ML Detect mitigation actions task.  Requires permission to access the StartDetectMitigationActionsTask action.
    ///
    /// Parameters:
    ///   - actions:  The actions to be performed when a device has unexpected behavior.
    ///   - clientRequestToken:  Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    ///   - includeOnlyActiveViolations:  Specifies to list only active violations.
    ///   - includeSuppressedAlerts:  Specifies to include suppressed alerts.
    ///   - target:  Specifies the ML Detect findings to which the mitigation actions are applied.
    ///   - taskId:  The unique identifier of the task.
    ///   - violationEventOccurrenceRange:  Specifies the time period of which violation events occurred between.
    ///   - logger: Logger use during operation
    @inlinable
    public func startDetectMitigationActionsTask(
        actions: [String],
        clientRequestToken: String = StartDetectMitigationActionsTaskRequest.idempotencyToken(),
        includeOnlyActiveViolations: Bool? = nil,
        includeSuppressedAlerts: Bool? = nil,
        target: DetectMitigationActionsTaskTarget,
        taskId: String,
        violationEventOccurrenceRange: ViolationEventOccurrenceRange? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartDetectMitigationActionsTaskResponse {
        let input = StartDetectMitigationActionsTaskRequest(
            actions: actions, 
            clientRequestToken: clientRequestToken, 
            includeOnlyActiveViolations: includeOnlyActiveViolations, 
            includeSuppressedAlerts: includeSuppressedAlerts, 
            target: target, 
            taskId: taskId, 
            violationEventOccurrenceRange: violationEventOccurrenceRange
        )
        return try await self.startDetectMitigationActionsTask(input, logger: logger)
    }

    /// Starts an on-demand Device Defender audit. Requires permission to access the StartOnDemandAuditTask action.
    @Sendable
    @inlinable
    public func startOnDemandAuditTask(_ input: StartOnDemandAuditTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartOnDemandAuditTaskResponse {
        try await self.client.execute(
            operation: "StartOnDemandAuditTask", 
            path: "/audit/tasks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an on-demand Device Defender audit. Requires permission to access the StartOnDemandAuditTask action.
    ///
    /// Parameters:
    ///   - targetCheckNames: Which checks are performed during the audit. The checks you specify must be enabled  for your account or an exception occurs. Use DescribeAccountAuditConfiguration  to see the list of all checks, including those that are enabled or  UpdateAccountAuditConfiguration to select which checks are enabled.
    ///   - logger: Logger use during operation
    @inlinable
    public func startOnDemandAuditTask(
        targetCheckNames: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartOnDemandAuditTaskResponse {
        let input = StartOnDemandAuditTaskRequest(
            targetCheckNames: targetCheckNames
        )
        return try await self.startOnDemandAuditTask(input, logger: logger)
    }

    /// Creates a bulk thing provisioning task. Requires permission to access the StartThingRegistrationTask action.
    @Sendable
    @inlinable
    public func startThingRegistrationTask(_ input: StartThingRegistrationTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartThingRegistrationTaskResponse {
        try await self.client.execute(
            operation: "StartThingRegistrationTask", 
            path: "/thing-registration-tasks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a bulk thing provisioning task. Requires permission to access the StartThingRegistrationTask action.
    ///
    /// Parameters:
    ///   - inputFileBucket: The S3 bucket that contains the input file.
    ///   - inputFileKey: The name of input file within the S3 bucket. This file contains a newline delimited
    ///   - roleArn: The IAM role ARN that grants permission the input file.
    ///   - templateBody: The provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func startThingRegistrationTask(
        inputFileBucket: String,
        inputFileKey: String,
        roleArn: String,
        templateBody: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartThingRegistrationTaskResponse {
        let input = StartThingRegistrationTaskRequest(
            inputFileBucket: inputFileBucket, 
            inputFileKey: inputFileKey, 
            roleArn: roleArn, 
            templateBody: templateBody
        )
        return try await self.startThingRegistrationTask(input, logger: logger)
    }

    /// Cancels a bulk thing provisioning task. Requires permission to access the StopThingRegistrationTask action.
    @Sendable
    @inlinable
    public func stopThingRegistrationTask(_ input: StopThingRegistrationTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopThingRegistrationTaskResponse {
        try await self.client.execute(
            operation: "StopThingRegistrationTask", 
            path: "/thing-registration-tasks/{taskId}/cancel", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels a bulk thing provisioning task. Requires permission to access the StopThingRegistrationTask action.
    ///
    /// Parameters:
    ///   - taskId: The bulk thing provisioning task ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopThingRegistrationTask(
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopThingRegistrationTaskResponse {
        let input = StopThingRegistrationTaskRequest(
            taskId: taskId
        )
        return try await self.stopThingRegistrationTask(input, logger: logger)
    }

    /// Adds to or modifies the tags of the given resource. Tags are metadata which can be
    /// 			used to manage a resource. Requires permission to access the TagResource action.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds to or modifies the tags of the given resource. Tags are metadata which can be
    /// 			used to manage a resource. Requires permission to access the TagResource action.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource.
    ///   - tags: The new or modified tags for the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Tests if a specified principal is authorized to perform an IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the IoT device gateway. Requires permission to access the TestAuthorization action.
    @Sendable
    @inlinable
    public func testAuthorization(_ input: TestAuthorizationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TestAuthorizationResponse {
        try await self.client.execute(
            operation: "TestAuthorization", 
            path: "/test-authorization", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Tests if a specified principal is authorized to perform an IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the IoT device gateway. Requires permission to access the TestAuthorization action.
    ///
    /// Parameters:
    ///   - authInfos: A list of authorization info objects. Simulating authorization will create a response for each authInfo object in the list.
    ///   - clientId: The MQTT client ID.
    ///   - cognitoIdentityPoolId: The Cognito identity pool ID.
    ///   - policyNamesToAdd: When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.
    ///   - policyNamesToSkip: When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.
    ///   - principal: The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - logger: Logger use during operation
    @inlinable
    public func testAuthorization(
        authInfos: [AuthInfo],
        clientId: String? = nil,
        cognitoIdentityPoolId: String? = nil,
        policyNamesToAdd: [String]? = nil,
        policyNamesToSkip: [String]? = nil,
        principal: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TestAuthorizationResponse {
        let input = TestAuthorizationRequest(
            authInfos: authInfos, 
            clientId: clientId, 
            cognitoIdentityPoolId: cognitoIdentityPoolId, 
            policyNamesToAdd: policyNamesToAdd, 
            policyNamesToSkip: policyNamesToSkip, 
            principal: principal
        )
        return try await self.testAuthorization(input, logger: logger)
    }

    /// Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the IoT device gateway. Requires permission to access the TestInvokeAuthorizer action.
    @Sendable
    @inlinable
    public func testInvokeAuthorizer(_ input: TestInvokeAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TestInvokeAuthorizerResponse {
        try await self.client.execute(
            operation: "TestInvokeAuthorizer", 
            path: "/authorizer/{authorizerName}/test", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the IoT device gateway. Requires permission to access the TestInvokeAuthorizer action.
    ///
    /// Parameters:
    ///   - authorizerName: The custom authorizer name.
    ///   - httpContext: Specifies a test HTTP authorization request.
    ///   - mqttContext: Specifies a test MQTT authorization request.
    ///   - tlsContext: Specifies a test TLS authorization request.
    ///   - token: The token returned by your custom authentication service.
    ///   - tokenSignature: The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.
    ///   - logger: Logger use during operation
    @inlinable
    public func testInvokeAuthorizer(
        authorizerName: String,
        httpContext: HttpContext? = nil,
        mqttContext: MqttContext? = nil,
        tlsContext: TlsContext? = nil,
        token: String? = nil,
        tokenSignature: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TestInvokeAuthorizerResponse {
        let input = TestInvokeAuthorizerRequest(
            authorizerName: authorizerName, 
            httpContext: httpContext, 
            mqttContext: mqttContext, 
            tlsContext: tlsContext, 
            token: token, 
            tokenSignature: tokenSignature
        )
        return try await self.testInvokeAuthorizer(input, logger: logger)
    }

    /// Transfers the specified certificate to the specified Amazon Web Services account. Requires permission to access the TransferCertificate action. You can cancel the transfer until it is acknowledged by the recipient. No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target. The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate action to deactivate it. The certificate must not have any policies attached to it. You can use the DetachPolicy action to detach them.
    @Sendable
    @inlinable
    public func transferCertificate(_ input: TransferCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TransferCertificateResponse {
        try await self.client.execute(
            operation: "TransferCertificate", 
            path: "/transfer-certificate/{certificateId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Transfers the specified certificate to the specified Amazon Web Services account. Requires permission to access the TransferCertificate action. You can cancel the transfer until it is acknowledged by the recipient. No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target. The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate action to deactivate it. The certificate must not have any policies attached to it. You can use the DetachPolicy action to detach them.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - targetAwsAccount: The Amazon Web Services account.
    ///   - transferMessage: The transfer message.
    ///   - logger: Logger use during operation
    @inlinable
    public func transferCertificate(
        certificateId: String,
        targetAwsAccount: String,
        transferMessage: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TransferCertificateResponse {
        let input = TransferCertificateRequest(
            certificateId: certificateId, 
            targetAwsAccount: targetAwsAccount, 
            transferMessage: transferMessage
        )
        return try await self.transferCertificate(input, logger: logger)
    }

    /// Removes the given tags (metadata) from the resource. Requires permission to access the UntagResource action.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/untag", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the given tags (metadata) from the resource. Requires permission to access the UntagResource action.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource.
    ///   - tagKeys: A list of the keys of the tags to be removed from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled. Requires permission to access the UpdateAccountAuditConfiguration action.
    @Sendable
    @inlinable
    public func updateAccountAuditConfiguration(_ input: UpdateAccountAuditConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAccountAuditConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateAccountAuditConfiguration", 
            path: "/audit/configuration", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled. Requires permission to access the UpdateAccountAuditConfiguration action.
    ///
    /// Parameters:
    ///   - auditCheckConfigurations: Specifies which audit checks are enabled and disabled for this account. Use  DescribeAccountAuditConfiguration to see the list of all checks, including those  that are currently enabled. Some data collection might start immediately when certain checks are enabled.  When a check is disabled, any data collected so far in relation to the check is deleted. You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself. On the first call to UpdateAccountAuditConfiguration, this parameter is required and must specify at least one enabled check.
    ///   - auditNotificationTargetConfigurations: Information about the targets to which audit notifications are sent.
    ///   - roleArn: The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAccountAuditConfiguration(
        auditCheckConfigurations: [String: AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [AuditNotificationType: AuditNotificationTarget]? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAccountAuditConfigurationResponse {
        let input = UpdateAccountAuditConfigurationRequest(
            auditCheckConfigurations: auditCheckConfigurations, 
            auditNotificationTargetConfigurations: auditNotificationTargetConfigurations, 
            roleArn: roleArn
        )
        return try await self.updateAccountAuditConfiguration(input, logger: logger)
    }

    ///  Updates a Device Defender audit suppression.
    @Sendable
    @inlinable
    public func updateAuditSuppression(_ input: UpdateAuditSuppressionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAuditSuppressionResponse {
        try await self.client.execute(
            operation: "UpdateAuditSuppression", 
            path: "/audit/suppressions/update", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a Device Defender audit suppression.
    ///
    /// Parameters:
    ///   - checkName: 
    ///   - description:  The description of the audit suppression.
    ///   - expirationDate:  The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
    ///   - resourceIdentifier: 
    ///   - suppressIndefinitely:  Indicates whether a suppression should exist indefinitely or not.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAuditSuppression(
        checkName: String,
        description: String? = nil,
        expirationDate: Date? = nil,
        resourceIdentifier: ResourceIdentifier,
        suppressIndefinitely: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAuditSuppressionResponse {
        let input = UpdateAuditSuppressionRequest(
            checkName: checkName, 
            description: description, 
            expirationDate: expirationDate, 
            resourceIdentifier: resourceIdentifier, 
            suppressIndefinitely: suppressIndefinitely
        )
        return try await self.updateAuditSuppression(input, logger: logger)
    }

    /// Updates an authorizer. Requires permission to access the UpdateAuthorizer action.
    @Sendable
    @inlinable
    public func updateAuthorizer(_ input: UpdateAuthorizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAuthorizerResponse {
        try await self.client.execute(
            operation: "UpdateAuthorizer", 
            path: "/authorizer/{authorizerName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an authorizer. Requires permission to access the UpdateAuthorizer action.
    ///
    /// Parameters:
    ///   - authorizerFunctionArn: The ARN of the authorizer's Lambda function.
    ///   - authorizerName: The authorizer name.
    ///   - enableCachingForHttp: When true, the result from the authorizerâ€™s Lambda function is
    ///   - status: The status of the update authorizer request.
    ///   - tokenKeyName: The key used to extract the token from the HTTP headers.
    ///   - tokenSigningPublicKeys: The public keys used to verify the token signature.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAuthorizer(
        authorizerFunctionArn: String? = nil,
        authorizerName: String,
        enableCachingForHttp: Bool? = nil,
        status: AuthorizerStatus? = nil,
        tokenKeyName: String? = nil,
        tokenSigningPublicKeys: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAuthorizerResponse {
        let input = UpdateAuthorizerRequest(
            authorizerFunctionArn: authorizerFunctionArn, 
            authorizerName: authorizerName, 
            enableCachingForHttp: enableCachingForHttp, 
            status: status, 
            tokenKeyName: tokenKeyName, 
            tokenSigningPublicKeys: tokenSigningPublicKeys
        )
        return try await self.updateAuthorizer(input, logger: logger)
    }

    /// Updates information about the billing group. Requires permission to access the UpdateBillingGroup action.
    @Sendable
    @inlinable
    public func updateBillingGroup(_ input: UpdateBillingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBillingGroupResponse {
        try await self.client.execute(
            operation: "UpdateBillingGroup", 
            path: "/billing-groups/{billingGroupName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates information about the billing group. Requires permission to access the UpdateBillingGroup action.
    ///
    /// Parameters:
    ///   - billingGroupName: The name of the billing group.
    ///   - billingGroupProperties: The properties of the billing group.
    ///   - expectedVersion: The expected version of the billing group. If the version of the billing group does
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBillingGroup(
        billingGroupName: String,
        billingGroupProperties: BillingGroupProperties,
        expectedVersion: Int64? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBillingGroupResponse {
        let input = UpdateBillingGroupRequest(
            billingGroupName: billingGroupName, 
            billingGroupProperties: billingGroupProperties, 
            expectedVersion: expectedVersion
        )
        return try await self.updateBillingGroup(input, logger: logger)
    }

    /// Updates a registered CA certificate. Requires permission to access the UpdateCACertificate action.
    @Sendable
    @inlinable
    public func updateCACertificate(_ input: UpdateCACertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateCACertificate", 
            path: "/cacertificate/{certificateId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a registered CA certificate. Requires permission to access the UpdateCACertificate action.
    ///
    /// Parameters:
    ///   - certificateId: The CA certificate identifier.
    ///   - newAutoRegistrationStatus: The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
    ///   - newStatus: The updated status of the CA certificate.  Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
    ///   - registrationConfig: Information about the registration configuration.
    ///   - removeAutoRegistration: If true, removes auto registration.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCACertificate(
        certificateId: String,
        newAutoRegistrationStatus: AutoRegistrationStatus? = nil,
        newStatus: CACertificateStatus? = nil,
        registrationConfig: RegistrationConfig? = nil,
        removeAutoRegistration: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateCACertificateRequest(
            certificateId: certificateId, 
            newAutoRegistrationStatus: newAutoRegistrationStatus, 
            newStatus: newStatus, 
            registrationConfig: registrationConfig, 
            removeAutoRegistration: removeAutoRegistration
        )
        return try await self.updateCACertificate(input, logger: logger)
    }

    /// Updates the status of the specified certificate. This operation is idempotent. Requires permission to access the UpdateCertificate action. Certificates must be in the ACTIVE state to authenticate devices that use a certificate to connect to IoT. Within a few minutes of updating a certificate from the ACTIVE state to any other state, IoT disconnects all devices that used that certificate to connect. Devices cannot use a certificate that is not in the ACTIVE state to reconnect.
    @Sendable
    @inlinable
    public func updateCertificate(_ input: UpdateCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateCertificate", 
            path: "/certificates/{certificateId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the status of the specified certificate. This operation is idempotent. Requires permission to access the UpdateCertificate action. Certificates must be in the ACTIVE state to authenticate devices that use a certificate to connect to IoT. Within a few minutes of updating a certificate from the ACTIVE state to any other state, IoT disconnects all devices that used that certificate to connect. Devices cannot use a certificate that is not in the ACTIVE state to reconnect.
    ///
    /// Parameters:
    ///   - certificateId: The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    ///   - newStatus: The new status.  Note: Setting the status to PENDING_TRANSFER  or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They  are not intended for developer use.  Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCertificate(
        certificateId: String,
        newStatus: CertificateStatus,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateCertificateRequest(
            certificateId: certificateId, 
            newStatus: newStatus
        )
        return try await self.updateCertificate(input, logger: logger)
    }

    /// Updates a certificate provider. Requires permission to access the UpdateCertificateProvider action.
    @Sendable
    @inlinable
    public func updateCertificateProvider(_ input: UpdateCertificateProviderRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCertificateProviderResponse {
        try await self.client.execute(
            operation: "UpdateCertificateProvider", 
            path: "/certificate-providers/{certificateProviderName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a certificate provider. Requires permission to access the UpdateCertificateProvider action.
    ///
    /// Parameters:
    ///   - accountDefaultForOperations: A list of the operations that the certificate provider will use to generate certificates.  Valid value: CreateCertificateFromCsr.
    ///   - certificateProviderName: The name of the certificate provider.
    ///   - lambdaFunctionArn: The Lambda function ARN that's associated with the certificate provider.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCertificateProvider(
        accountDefaultForOperations: [CertificateProviderOperation]? = nil,
        certificateProviderName: String,
        lambdaFunctionArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCertificateProviderResponse {
        let input = UpdateCertificateProviderRequest(
            accountDefaultForOperations: accountDefaultForOperations, 
            certificateProviderName: certificateProviderName, 
            lambdaFunctionArn: lambdaFunctionArn
        )
        return try await self.updateCertificateProvider(input, logger: logger)
    }

    /// Update information about a command or mark a command for deprecation.
    @Sendable
    @inlinable
    public func updateCommand(_ input: UpdateCommandRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCommandResponse {
        try await self.client.execute(
            operation: "UpdateCommand", 
            path: "/commands/{commandId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update information about a command or mark a command for deprecation.
    ///
    /// Parameters:
    ///   - commandId: The unique identifier of the command to be updated.
    ///   - deprecated: A boolean that you can use to specify whether to deprecate a command.
    ///   - description: A short text description of the command.
    ///   - displayName: The new user-friendly name to use in the console for the command.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCommand(
        commandId: String,
        deprecated: Bool? = nil,
        description: String? = nil,
        displayName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCommandResponse {
        let input = UpdateCommandRequest(
            commandId: commandId, 
            deprecated: deprecated, 
            description: description, 
            displayName: displayName
        )
        return try await self.updateCommand(input, logger: logger)
    }

    /// Updates a Device Defender detect custom metric.  Requires permission to access the UpdateCustomMetric action.
    @Sendable
    @inlinable
    public func updateCustomMetric(_ input: UpdateCustomMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCustomMetricResponse {
        try await self.client.execute(
            operation: "UpdateCustomMetric", 
            path: "/custom-metric/{metricName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a Device Defender detect custom metric.  Requires permission to access the UpdateCustomMetric action.
    ///
    /// Parameters:
    ///   - displayName:  Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated.
    ///   - metricName:  The name of the custom metric. Cannot be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCustomMetric(
        displayName: String,
        metricName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCustomMetricResponse {
        let input = UpdateCustomMetricRequest(
            displayName: displayName, 
            metricName: metricName
        )
        return try await self.updateCustomMetric(input, logger: logger)
    }

    /// Updates the definition for a dimension. You cannot change the type of a dimension after it is created (you can delete it and recreate it). Requires permission to access the UpdateDimension action.
    @Sendable
    @inlinable
    public func updateDimension(_ input: UpdateDimensionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDimensionResponse {
        try await self.client.execute(
            operation: "UpdateDimension", 
            path: "/dimensions/{name}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the definition for a dimension. You cannot change the type of a dimension after it is created (you can delete it and recreate it). Requires permission to access the UpdateDimension action.
    ///
    /// Parameters:
    ///   - name: A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.
    ///   - stringValues: Specifies the value or list of values for the dimension. For TOPIC_FILTER dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDimension(
        name: String,
        stringValues: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDimensionResponse {
        let input = UpdateDimensionRequest(
            name: name, 
            stringValues: stringValues
        )
        return try await self.updateDimension(input, logger: logger)
    }

    /// Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated. Requires permission to access the UpdateDomainConfiguration action.
    @Sendable
    @inlinable
    public func updateDomainConfiguration(_ input: UpdateDomainConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDomainConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateDomainConfiguration", 
            path: "/domainConfigurations/{domainConfigurationName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated. Requires permission to access the UpdateDomainConfiguration action.
    ///
    /// Parameters:
    ///   - applicationProtocol: An enumerated string that speciï¬es the application-layer protocol.    SECURE_MQTT - MQTT over TLS.      MQTT_WSS - MQTT over WebSocket.      HTTPS - HTTP over TLS.      DEFAULT - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol.  For more information, see Device communication protocols.
    ///   - authenticationType: An enumerated string that speciï¬es the authentication type.    CUSTOM_AUTH_X509 - Use custom authentication and authorization with additional details from the X.509 client certificate.      CUSTOM_AUTH - Use custom authentication and authorization. For more information, see Custom authentication and authorization.      AWS_X509 - Use X.509 client certificates without custom authentication and authorization. For more information, see X.509 client certificates.      AWS_SIGV4 - Use Amazon Web Services Signature Version 4. For more information, see IAM users, groups, and roles.      DEFAULT  - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see Device communication protocols.
    ///   - authorizerConfig: An object that specifies the authorization service for a domain.
    ///   - clientCertificateConfig: An object that speciï¬es the client certificate conï¬guration for a domain.
    ///   - domainConfigurationName: The name of the domain configuration to be updated.
    ///   - domainConfigurationStatus: The status to which the domain configuration should be updated.
    ///   - removeAuthorizerConfig: Removes the authorization configuration from a domain.
    ///   - serverCertificateConfig: The server certificate configuration.
    ///   - tlsConfig: An object that specifies the TLS configuration for a domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDomainConfiguration(
        applicationProtocol: ApplicationProtocol? = nil,
        authenticationType: AuthenticationType? = nil,
        authorizerConfig: AuthorizerConfig? = nil,
        clientCertificateConfig: ClientCertificateConfig? = nil,
        domainConfigurationName: String,
        domainConfigurationStatus: DomainConfigurationStatus? = nil,
        removeAuthorizerConfig: Bool? = nil,
        serverCertificateConfig: ServerCertificateConfig? = nil,
        tlsConfig: TlsConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDomainConfigurationResponse {
        let input = UpdateDomainConfigurationRequest(
            applicationProtocol: applicationProtocol, 
            authenticationType: authenticationType, 
            authorizerConfig: authorizerConfig, 
            clientCertificateConfig: clientCertificateConfig, 
            domainConfigurationName: domainConfigurationName, 
            domainConfigurationStatus: domainConfigurationStatus, 
            removeAuthorizerConfig: removeAuthorizerConfig, 
            serverCertificateConfig: serverCertificateConfig, 
            tlsConfig: tlsConfig
        )
        return try await self.updateDomainConfiguration(input, logger: logger)
    }

    /// Updates a dynamic thing group. Requires permission to access the UpdateDynamicThingGroup action.
    @Sendable
    @inlinable
    public func updateDynamicThingGroup(_ input: UpdateDynamicThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDynamicThingGroupResponse {
        try await self.client.execute(
            operation: "UpdateDynamicThingGroup", 
            path: "/dynamic-thing-groups/{thingGroupName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a dynamic thing group. Requires permission to access the UpdateDynamicThingGroup action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the dynamic thing group to update.
    ///   - indexName: The dynamic thing group index to update.  Currently one index is supported: AWS_Things.
    ///   - queryString: The dynamic thing group search query string to update.
    ///   - queryVersion: The dynamic thing group query version to update.  Currently one query version is supported: "2017-09-30". If not specified, the
    ///   - thingGroupName: The name of the dynamic thing group to update.
    ///   - thingGroupProperties: The dynamic thing group properties to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDynamicThingGroup(
        expectedVersion: Int64? = nil,
        indexName: String? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil,
        thingGroupName: String,
        thingGroupProperties: ThingGroupProperties,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDynamicThingGroupResponse {
        let input = UpdateDynamicThingGroupRequest(
            expectedVersion: expectedVersion, 
            indexName: indexName, 
            queryString: queryString, 
            queryVersion: queryVersion, 
            thingGroupName: thingGroupName, 
            thingGroupProperties: thingGroupProperties
        )
        return try await self.updateDynamicThingGroup(input, logger: logger)
    }

    /// Updates the event configurations. Requires permission to access the UpdateEventConfigurations action.
    @Sendable
    @inlinable
    public func updateEventConfigurations(_ input: UpdateEventConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEventConfigurationsResponse {
        try await self.client.execute(
            operation: "UpdateEventConfigurations", 
            path: "/event-configurations", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the event configurations. Requires permission to access the UpdateEventConfigurations action.
    ///
    /// Parameters:
    ///   - eventConfigurations: The new event configuration values.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateEventConfigurations(
        eventConfigurations: [EventType: Configuration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEventConfigurationsResponse {
        let input = UpdateEventConfigurationsRequest(
            eventConfigurations: eventConfigurations
        )
        return try await self.updateEventConfigurations(input, logger: logger)
    }

    /// Updates the data for a fleet metric. Requires permission to access the UpdateFleetMetric action.
    @Sendable
    @inlinable
    public func updateFleetMetric(_ input: UpdateFleetMetricRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateFleetMetric", 
            path: "/fleet-metric/{metricName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the data for a fleet metric. Requires permission to access the UpdateFleetMetric action.
    ///
    /// Parameters:
    ///   - aggregationField: The field to aggregate.
    ///   - aggregationType: The type of the aggregation query.
    ///   - description: The description of the fleet metric.
    ///   - expectedVersion: The expected version of the fleet metric record in the registry.
    ///   - indexName: The name of the index to search.
    ///   - metricName: The name of the fleet metric to update.
    ///   - period: The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    ///   - queryString: The search query string.
    ///   - queryVersion: The version of the query.
    ///   - unit: Used to support unit transformation such as milliseconds to seconds. The unit must be supported by CW metric.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFleetMetric(
        aggregationField: String? = nil,
        aggregationType: AggregationType? = nil,
        description: String? = nil,
        expectedVersion: Int64? = nil,
        indexName: String,
        metricName: String,
        period: Int? = nil,
        queryString: String? = nil,
        queryVersion: String? = nil,
        unit: FleetMetricUnit? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateFleetMetricRequest(
            aggregationField: aggregationField, 
            aggregationType: aggregationType, 
            description: description, 
            expectedVersion: expectedVersion, 
            indexName: indexName, 
            metricName: metricName, 
            period: period, 
            queryString: queryString, 
            queryVersion: queryVersion, 
            unit: unit
        )
        return try await self.updateFleetMetric(input, logger: logger)
    }

    /// Updates the search configuration. Requires permission to access the UpdateIndexingConfiguration action.
    @Sendable
    @inlinable
    public func updateIndexingConfiguration(_ input: UpdateIndexingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIndexingConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateIndexingConfiguration", 
            path: "/indexing/config", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the search configuration. Requires permission to access the UpdateIndexingConfiguration action.
    ///
    /// Parameters:
    ///   - thingGroupIndexingConfiguration: Thing group indexing configuration.
    ///   - thingIndexingConfiguration: Thing indexing configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIndexingConfiguration(
        thingGroupIndexingConfiguration: ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: ThingIndexingConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIndexingConfigurationResponse {
        let input = UpdateIndexingConfigurationRequest(
            thingGroupIndexingConfiguration: thingGroupIndexingConfiguration, 
            thingIndexingConfiguration: thingIndexingConfiguration
        )
        return try await self.updateIndexingConfiguration(input, logger: logger)
    }

    /// Updates supported fields of the specified job. Requires permission to access the UpdateJob action.
    @Sendable
    @inlinable
    public func updateJob(_ input: UpdateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateJob", 
            path: "/jobs/{jobId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates supported fields of the specified job. Requires permission to access the UpdateJob action.
    ///
    /// Parameters:
    ///   - abortConfig: Allows you to create criteria to abort a job.
    ///   - description: A short text description of the job.
    ///   - jobExecutionsRetryConfig: Allows you to create the criteria to retry a job.
    ///   - jobExecutionsRolloutConfig: Allows you to create a staged rollout of the job.
    ///   - jobId: The ID of the job to be updated.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - presignedUrlConfig: Configuration information for pre-signed S3 URLs.
    ///   - timeoutConfig: Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to TIMED_OUT.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateJob(
        abortConfig: AbortConfig? = nil,
        description: String? = nil,
        jobExecutionsRetryConfig: JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: JobExecutionsRolloutConfig? = nil,
        jobId: String,
        namespaceId: String? = nil,
        presignedUrlConfig: PresignedUrlConfig? = nil,
        timeoutConfig: TimeoutConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateJobRequest(
            abortConfig: abortConfig, 
            description: description, 
            jobExecutionsRetryConfig: jobExecutionsRetryConfig, 
            jobExecutionsRolloutConfig: jobExecutionsRolloutConfig, 
            jobId: jobId, 
            namespaceId: namespaceId, 
            presignedUrlConfig: presignedUrlConfig, 
            timeoutConfig: timeoutConfig
        )
        return try await self.updateJob(input, logger: logger)
    }

    /// Updates the definition for the specified mitigation action. Requires permission to access the UpdateMitigationAction action.
    @Sendable
    @inlinable
    public func updateMitigationAction(_ input: UpdateMitigationActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMitigationActionResponse {
        try await self.client.execute(
            operation: "UpdateMitigationAction", 
            path: "/mitigationactions/actions/{actionName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the definition for the specified mitigation action. Requires permission to access the UpdateMitigationAction action.
    ///
    /// Parameters:
    ///   - actionName: The friendly name for the mitigation action. You cannot change the name by using UpdateMitigationAction. Instead, you must delete and recreate the mitigation action with the new name.
    ///   - actionParams: Defines the type of action and the parameters for that action.
    ///   - roleArn: The ARN of the IAM role that is used to apply the mitigation action.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMitigationAction(
        actionName: String,
        actionParams: MitigationActionParams? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMitigationActionResponse {
        let input = UpdateMitigationActionRequest(
            actionName: actionName, 
            actionParams: actionParams, 
            roleArn: roleArn
        )
        return try await self.updateMitigationAction(input, logger: logger)
    }

    /// Updates the supported fields for a specific software package. Requires permission to access the UpdatePackage and GetIndexingConfiguration actions.
    @Sendable
    @inlinable
    public func updatePackage(_ input: UpdatePackageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePackageResponse {
        try await self.client.execute(
            operation: "UpdatePackage", 
            path: "/packages/{packageName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the supported fields for a specific software package. Requires permission to access the UpdatePackage and GetIndexingConfiguration actions.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - defaultVersionName: The name of the default package version.  Note: You cannot name a defaultVersion and set unsetDefaultVersion equal to true at the same time.
    ///   - description: The package description.
    ///   - packageName: The name of the target software package.
    ///   - unsetDefaultVersion: Indicates whether you want to remove the named default package version from the software package.  Set as true to remove the default package version.   Note: You cannot name a defaultVersion and set unsetDefaultVersion equal to true at the same time.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePackage(
        clientToken: String? = UpdatePackageRequest.idempotencyToken(),
        defaultVersionName: String? = nil,
        description: String? = nil,
        packageName: String,
        unsetDefaultVersion: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePackageResponse {
        let input = UpdatePackageRequest(
            clientToken: clientToken, 
            defaultVersionName: defaultVersionName, 
            description: description, 
            packageName: packageName, 
            unsetDefaultVersion: unsetDefaultVersion
        )
        return try await self.updatePackage(input, logger: logger)
    }

    /// Updates the software package configuration. Requires permission to access the UpdatePackageConfiguration and iam:PassRole actions.
    @Sendable
    @inlinable
    public func updatePackageConfiguration(_ input: UpdatePackageConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePackageConfigurationResponse {
        try await self.client.execute(
            operation: "UpdatePackageConfiguration", 
            path: "/package-configuration", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the software package configuration. Requires permission to access the UpdatePackageConfiguration and iam:PassRole actions.
    ///
    /// Parameters:
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - versionUpdateByJobsConfig: Configuration to manage job's package version reporting. This updates the thing's reserved named shadow that the job targets.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePackageConfiguration(
        clientToken: String? = UpdatePackageConfigurationRequest.idempotencyToken(),
        versionUpdateByJobsConfig: VersionUpdateByJobsConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePackageConfigurationResponse {
        let input = UpdatePackageConfigurationRequest(
            clientToken: clientToken, 
            versionUpdateByJobsConfig: versionUpdateByJobsConfig
        )
        return try await self.updatePackageConfiguration(input, logger: logger)
    }

    /// Updates the supported fields for a specific package version. Requires permission to access the UpdatePackageVersion and GetIndexingConfiguration actions.
    @Sendable
    @inlinable
    public func updatePackageVersion(_ input: UpdatePackageVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePackageVersionResponse {
        try await self.client.execute(
            operation: "UpdatePackageVersion", 
            path: "/packages/{packageName}/versions/{versionName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the supported fields for a specific package version. Requires permission to access the UpdatePackageVersion and GetIndexingConfiguration actions.
    ///
    /// Parameters:
    ///   - action: The status that the package version should be assigned. For more information, see Package version lifecycle.
    ///   - artifact: The various components that make up a software package version.
    ///   - attributes: Metadata that can be used to define a package versionâ€™s configuration. For example, the Amazon S3 file location, configuration options that are being sent to the device or fleet.   Note: Attributes can be updated only when the package version is in a draft state. The combined size of all the attributes on a package version is limited to 3KB.
    ///   - clientToken: A unique case-sensitive identifier that you can provide to ensure the idempotency of the request.  Don't reuse this client token if a new idempotent request is required.
    ///   - description: The package version description.
    ///   - packageName: The name of the associated software package.
    ///   - recipe: The inline job document associated with a software package version used for a quick job deployment.
    ///   - versionName: The name of the target package version.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePackageVersion(
        action: PackageVersionAction? = nil,
        artifact: PackageVersionArtifact? = nil,
        attributes: [String: String]? = nil,
        clientToken: String? = UpdatePackageVersionRequest.idempotencyToken(),
        description: String? = nil,
        packageName: String,
        recipe: String? = nil,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePackageVersionResponse {
        let input = UpdatePackageVersionRequest(
            action: action, 
            artifact: artifact, 
            attributes: attributes, 
            clientToken: clientToken, 
            description: description, 
            packageName: packageName, 
            recipe: recipe, 
            versionName: versionName
        )
        return try await self.updatePackageVersion(input, logger: logger)
    }

    /// Updates a provisioning template. Requires permission to access the UpdateProvisioningTemplate action.
    @Sendable
    @inlinable
    public func updateProvisioningTemplate(_ input: UpdateProvisioningTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateProvisioningTemplateResponse {
        try await self.client.execute(
            operation: "UpdateProvisioningTemplate", 
            path: "/provisioning-templates/{templateName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a provisioning template. Requires permission to access the UpdateProvisioningTemplate action.
    ///
    /// Parameters:
    ///   - defaultVersionId: The ID of the default provisioning template version.
    ///   - description: The description of the provisioning template.
    ///   - enabled: True to enable the provisioning template, otherwise false.
    ///   - preProvisioningHook: Updates the pre-provisioning hook template. Only supports template of type FLEET_PROVISIONING. For more information about provisioning template types, see type.
    ///   - provisioningRoleArn: The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.
    ///   - removePreProvisioningHook: Removes pre-provisioning hook template.
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateProvisioningTemplate(
        defaultVersionId: Int? = nil,
        description: String? = nil,
        enabled: Bool? = nil,
        preProvisioningHook: ProvisioningHook? = nil,
        provisioningRoleArn: String? = nil,
        removePreProvisioningHook: Bool? = nil,
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateProvisioningTemplateResponse {
        let input = UpdateProvisioningTemplateRequest(
            defaultVersionId: defaultVersionId, 
            description: description, 
            enabled: enabled, 
            preProvisioningHook: preProvisioningHook, 
            provisioningRoleArn: provisioningRoleArn, 
            removePreProvisioningHook: removePreProvisioningHook, 
            templateName: templateName
        )
        return try await self.updateProvisioningTemplate(input, logger: logger)
    }

    /// Updates a role alias. Requires permission to access the UpdateRoleAlias action.  The value of  credentialDurationSeconds must be less than or equal to the maximum session duration of the IAM role that the role alias references. For more information, see  Modifying a role maximum session duration (Amazon Web Services API) from the Amazon Web Services Identity and Access Management User Guide.
    @Sendable
    @inlinable
    public func updateRoleAlias(_ input: UpdateRoleAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRoleAliasResponse {
        try await self.client.execute(
            operation: "UpdateRoleAlias", 
            path: "/role-aliases/{roleAlias}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a role alias. Requires permission to access the UpdateRoleAlias action.  The value of  credentialDurationSeconds must be less than or equal to the maximum session duration of the IAM role that the role alias references. For more information, see  Modifying a role maximum session duration (Amazon Web Services API) from the Amazon Web Services Identity and Access Management User Guide.
    ///
    /// Parameters:
    ///   - credentialDurationSeconds: The number of seconds the credential will be valid. This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.
    ///   - roleAlias: The role alias to update.
    ///   - roleArn: The role ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRoleAlias(
        credentialDurationSeconds: Int? = nil,
        roleAlias: String,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRoleAliasResponse {
        let input = UpdateRoleAliasRequest(
            credentialDurationSeconds: credentialDurationSeconds, 
            roleAlias: roleAlias, 
            roleArn: roleArn
        )
        return try await self.updateRoleAlias(input, logger: logger)
    }

    /// Updates a scheduled audit, including which checks are performed and how often the audit takes place. Requires permission to access the UpdateScheduledAudit action.
    @Sendable
    @inlinable
    public func updateScheduledAudit(_ input: UpdateScheduledAuditRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateScheduledAuditResponse {
        try await self.client.execute(
            operation: "UpdateScheduledAudit", 
            path: "/audit/scheduledaudits/{scheduledAuditName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a scheduled audit, including which checks are performed and how often the audit takes place. Requires permission to access the UpdateScheduledAudit action.
    ///
    /// Parameters:
    ///   - dayOfMonth: The day of the month on which the scheduled audit takes place. This can be 1 through 31 or LAST. This field is required if the frequency parameter is set to MONTHLY. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.
    ///   - dayOfWeek: The day of the week on which the scheduled audit takes place. This can be one of SUN, MON, TUE, WED, THU, FRI, or SAT. This field is required if the "frequency" parameter is set to WEEKLY or BIWEEKLY.
    ///   - frequency: How often the scheduled audit takes place, either DAILY, WEEKLY, BIWEEKLY, or MONTHLY. The start time of each audit is determined by the system.
    ///   - scheduledAuditName: The name of the scheduled audit. (Max. 128 chars)
    ///   - targetCheckNames: Which checks are performed during the scheduled audit. Checks must be enabled  for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration  to select which checks are enabled.)
    ///   - logger: Logger use during operation
    @inlinable
    public func updateScheduledAudit(
        dayOfMonth: String? = nil,
        dayOfWeek: DayOfWeek? = nil,
        frequency: AuditFrequency? = nil,
        scheduledAuditName: String,
        targetCheckNames: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateScheduledAuditResponse {
        let input = UpdateScheduledAuditRequest(
            dayOfMonth: dayOfMonth, 
            dayOfWeek: dayOfWeek, 
            frequency: frequency, 
            scheduledAuditName: scheduledAuditName, 
            targetCheckNames: targetCheckNames
        )
        return try await self.updateScheduledAudit(input, logger: logger)
    }

    /// Updates a Device Defender security profile. Requires permission to access the UpdateSecurityProfile action.
    @Sendable
    @inlinable
    public func updateSecurityProfile(_ input: UpdateSecurityProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSecurityProfileResponse {
        try await self.client.execute(
            operation: "UpdateSecurityProfile", 
            path: "/security-profiles/{securityProfileName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a Device Defender security profile. Requires permission to access the UpdateSecurityProfile action.
    ///
    /// Parameters:
    ///   - additionalMetricsToRetainV2: A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    ///   - alertTargets: Where the alerts are sent. (Alerts are always sent to the console.)
    ///   - behaviors: Specifies the behaviors that, when violated by a device (thing), cause an alert.
    ///   - deleteAdditionalMetricsToRetain: If true, delete all additionalMetricsToRetain defined for this  security profile. If any additionalMetricsToRetain are defined in the current  invocation, an exception occurs.
    ///   - deleteAlertTargets: If true, delete all alertTargets defined for this security profile.  If any alertTargets are defined in the current invocation, an exception occurs.
    ///   - deleteBehaviors: If true, delete all behaviors defined for this security profile.  If any behaviors are defined in the current invocation, an exception occurs.
    ///   - deleteMetricsExportConfig: Set the value as true to delete metrics export related configurations.
    ///   - expectedVersion: The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a VersionConflictException is thrown.
    ///   - metricsExportConfig: Specifies the MQTT topic and role ARN required for metric export.
    ///   - securityProfileDescription: A description of the security profile.
    ///   - securityProfileName: The name of the security profile you want to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSecurityProfile(
        additionalMetricsToRetainV2: [MetricToRetain]? = nil,
        alertTargets: [AlertTargetType: AlertTarget]? = nil,
        behaviors: [Behavior]? = nil,
        deleteAdditionalMetricsToRetain: Bool? = nil,
        deleteAlertTargets: Bool? = nil,
        deleteBehaviors: Bool? = nil,
        deleteMetricsExportConfig: Bool? = nil,
        expectedVersion: Int64? = nil,
        metricsExportConfig: MetricsExportConfig? = nil,
        securityProfileDescription: String? = nil,
        securityProfileName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSecurityProfileResponse {
        let input = UpdateSecurityProfileRequest(
            additionalMetricsToRetainV2: additionalMetricsToRetainV2, 
            alertTargets: alertTargets, 
            behaviors: behaviors, 
            deleteAdditionalMetricsToRetain: deleteAdditionalMetricsToRetain, 
            deleteAlertTargets: deleteAlertTargets, 
            deleteBehaviors: deleteBehaviors, 
            deleteMetricsExportConfig: deleteMetricsExportConfig, 
            expectedVersion: expectedVersion, 
            metricsExportConfig: metricsExportConfig, 
            securityProfileDescription: securityProfileDescription, 
            securityProfileName: securityProfileName
        )
        return try await self.updateSecurityProfile(input, logger: logger)
    }

    /// Updates an existing stream. The stream version will be incremented by one. Requires permission to access the UpdateStream action.
    @Sendable
    @inlinable
    public func updateStream(_ input: UpdateStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStreamResponse {
        try await self.client.execute(
            operation: "UpdateStream", 
            path: "/streams/{streamId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing stream. The stream version will be incremented by one. Requires permission to access the UpdateStream action.
    ///
    /// Parameters:
    ///   - description: The description of the stream.
    ///   - files: The files associated with the stream.
    ///   - roleArn: An IAM role that allows the IoT service principal assumes to access your S3 files.
    ///   - streamId: The stream ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStream(
        description: String? = nil,
        files: [StreamFile]? = nil,
        roleArn: String? = nil,
        streamId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStreamResponse {
        let input = UpdateStreamRequest(
            description: description, 
            files: files, 
            roleArn: roleArn, 
            streamId: streamId
        )
        return try await self.updateStream(input, logger: logger)
    }

    /// Updates the data for a thing. Requires permission to access the UpdateThing action.
    @Sendable
    @inlinable
    public func updateThing(_ input: UpdateThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateThingResponse {
        try await self.client.execute(
            operation: "UpdateThing", 
            path: "/things/{thingName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the data for a thing. Requires permission to access the UpdateThing action.
    ///
    /// Parameters:
    ///   - attributePayload: A list of thing attributes, a JSON string containing name-value pairs. For
    ///   - expectedVersion: The expected version of the thing record in the registry. If the version of the
    ///   - removeThingType: Remove a thing type association. If true, the
    ///   - thingName: The name of the thing to update. You can't change a thing's name. To change a thing's name, you must create a
    ///   - thingTypeName: The name of the thing type.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateThing(
        attributePayload: AttributePayload? = nil,
        expectedVersion: Int64? = nil,
        removeThingType: Bool? = nil,
        thingName: String,
        thingTypeName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateThingResponse {
        let input = UpdateThingRequest(
            attributePayload: attributePayload, 
            expectedVersion: expectedVersion, 
            removeThingType: removeThingType, 
            thingName: thingName, 
            thingTypeName: thingTypeName
        )
        return try await self.updateThing(input, logger: logger)
    }

    /// Update a thing group. Requires permission to access the UpdateThingGroup action.
    @Sendable
    @inlinable
    public func updateThingGroup(_ input: UpdateThingGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateThingGroupResponse {
        try await self.client.execute(
            operation: "UpdateThingGroup", 
            path: "/thing-groups/{thingGroupName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a thing group. Requires permission to access the UpdateThingGroup action.
    ///
    /// Parameters:
    ///   - expectedVersion: The expected version of the thing group. If this does not match the version of the
    ///   - thingGroupName: The thing group to update.
    ///   - thingGroupProperties: The thing group properties.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateThingGroup(
        expectedVersion: Int64? = nil,
        thingGroupName: String,
        thingGroupProperties: ThingGroupProperties,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateThingGroupResponse {
        let input = UpdateThingGroupRequest(
            expectedVersion: expectedVersion, 
            thingGroupName: thingGroupName, 
            thingGroupProperties: thingGroupProperties
        )
        return try await self.updateThingGroup(input, logger: logger)
    }

    /// Updates the groups to which the thing belongs. Requires permission to access the UpdateThingGroupsForThing action.
    @Sendable
    @inlinable
    public func updateThingGroupsForThing(_ input: UpdateThingGroupsForThingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateThingGroupsForThingResponse {
        try await self.client.execute(
            operation: "UpdateThingGroupsForThing", 
            path: "/thing-groups/updateThingGroupsForThing", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the groups to which the thing belongs. Requires permission to access the UpdateThingGroupsForThing action.
    ///
    /// Parameters:
    ///   - overrideDynamicGroups: Override dynamic thing groups with static thing groups when 10-group limit is
    ///   - thingGroupsToAdd: The groups to which the thing will be added.
    ///   - thingGroupsToRemove: The groups from which the thing will be removed.
    ///   - thingName: The thing whose group memberships will be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateThingGroupsForThing(
        overrideDynamicGroups: Bool? = nil,
        thingGroupsToAdd: [String]? = nil,
        thingGroupsToRemove: [String]? = nil,
        thingName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateThingGroupsForThingResponse {
        let input = UpdateThingGroupsForThingRequest(
            overrideDynamicGroups: overrideDynamicGroups, 
            thingGroupsToAdd: thingGroupsToAdd, 
            thingGroupsToRemove: thingGroupsToRemove, 
            thingName: thingName
        )
        return try await self.updateThingGroupsForThing(input, logger: logger)
    }

    /// Updates a thing type.
    @Sendable
    @inlinable
    public func updateThingType(_ input: UpdateThingTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateThingTypeResponse {
        try await self.client.execute(
            operation: "UpdateThingType", 
            path: "/thing-types/{thingTypeName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a thing type.
    ///
    /// Parameters:
    ///   - thingTypeName: The name of a thing type.
    ///   - thingTypeProperties: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateThingType(
        thingTypeName: String,
        thingTypeProperties: ThingTypeProperties? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateThingTypeResponse {
        let input = UpdateThingTypeRequest(
            thingTypeName: thingTypeName, 
            thingTypeProperties: thingTypeProperties
        )
        return try await self.updateThingType(input, logger: logger)
    }

    /// Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination. Requires permission to access the UpdateTopicRuleDestination action.
    @Sendable
    @inlinable
    public func updateTopicRuleDestination(_ input: UpdateTopicRuleDestinationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTopicRuleDestinationResponse {
        try await self.client.execute(
            operation: "UpdateTopicRuleDestination", 
            path: "/destinations", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination. Requires permission to access the UpdateTopicRuleDestination action.
    ///
    /// Parameters:
    ///   - arn: The ARN of the topic rule destination.
    ///   - status: The status of the topic rule destination. Valid values are:  IN_PROGRESS  A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.  ENABLED  Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination.  DISABLED  Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination.  ERROR  Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTopicRuleDestination(
        arn: String,
        status: TopicRuleDestinationStatus,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTopicRuleDestinationResponse {
        let input = UpdateTopicRuleDestinationRequest(
            arn: arn, 
            status: status
        )
        return try await self.updateTopicRuleDestination(input, logger: logger)
    }

    /// Validates a Device Defender security profile behaviors specification. Requires permission to access the ValidateSecurityProfileBehaviors action.
    @Sendable
    @inlinable
    public func validateSecurityProfileBehaviors(_ input: ValidateSecurityProfileBehaviorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ValidateSecurityProfileBehaviorsResponse {
        try await self.client.execute(
            operation: "ValidateSecurityProfileBehaviors", 
            path: "/security-profile-behaviors/validate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Validates a Device Defender security profile behaviors specification. Requires permission to access the ValidateSecurityProfileBehaviors action.
    ///
    /// Parameters:
    ///   - behaviors: Specifies the behaviors that, when violated by a device (thing), cause an alert.
    ///   - logger: Logger use during operation
    @inlinable
    public func validateSecurityProfileBehaviors(
        behaviors: [Behavior],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ValidateSecurityProfileBehaviorsResponse {
        let input = ValidateSecurityProfileBehaviorsRequest(
            behaviors: behaviors
        )
        return try await self.validateSecurityProfileBehaviors(input, logger: logger)
    }
}

extension IoT {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: IoT, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension IoT {
    /// Return PaginatorSequence for operation ``getBehaviorModelTrainingSummaries(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getBehaviorModelTrainingSummariesPaginator(
        _ input: GetBehaviorModelTrainingSummariesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetBehaviorModelTrainingSummariesRequest, GetBehaviorModelTrainingSummariesResponse> {
        return .init(
            input: input,
            command: self.getBehaviorModelTrainingSummaries,
            inputKey: \GetBehaviorModelTrainingSummariesRequest.nextToken,
            outputKey: \GetBehaviorModelTrainingSummariesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getBehaviorModelTrainingSummaries(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  The maximum number of results to return at one time. The default is 10.
    ///   - securityProfileName:  The name of the security profile.
    ///   - logger: Logger used for logging
    @inlinable
    public func getBehaviorModelTrainingSummariesPaginator(
        maxResults: Int? = nil,
        securityProfileName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetBehaviorModelTrainingSummariesRequest, GetBehaviorModelTrainingSummariesResponse> {
        let input = GetBehaviorModelTrainingSummariesRequest(
            maxResults: maxResults, 
            securityProfileName: securityProfileName
        )
        return self.getBehaviorModelTrainingSummariesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listActiveViolations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listActiveViolationsPaginator(
        _ input: ListActiveViolationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListActiveViolationsRequest, ListActiveViolationsResponse> {
        return .init(
            input: input,
            command: self.listActiveViolations,
            inputKey: \ListActiveViolationsRequest.nextToken,
            outputKey: \ListActiveViolationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listActiveViolations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - behaviorCriteriaType:  The criteria for a behavior.
    ///   - listSuppressedAlerts:  A list of all suppressed alerts.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - securityProfileName: The name of the Device Defender security profile for which violations are listed.
    ///   - thingName: The name of the thing whose active violations are listed.
    ///   - verificationState: The verification state of the violation (detect alarm).
    ///   - logger: Logger used for logging
    @inlinable
    public func listActiveViolationsPaginator(
        behaviorCriteriaType: BehaviorCriteriaType? = nil,
        listSuppressedAlerts: Bool? = nil,
        maxResults: Int? = nil,
        securityProfileName: String? = nil,
        thingName: String? = nil,
        verificationState: VerificationState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListActiveViolationsRequest, ListActiveViolationsResponse> {
        let input = ListActiveViolationsRequest(
            behaviorCriteriaType: behaviorCriteriaType, 
            listSuppressedAlerts: listSuppressedAlerts, 
            maxResults: maxResults, 
            securityProfileName: securityProfileName, 
            thingName: thingName, 
            verificationState: verificationState
        )
        return self.listActiveViolationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAttachedPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAttachedPoliciesPaginator(
        _ input: ListAttachedPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAttachedPoliciesRequest, ListAttachedPoliciesResponse> {
        return .init(
            input: input,
            command: self.listAttachedPolicies,
            inputKey: \ListAttachedPoliciesRequest.marker,
            outputKey: \ListAttachedPoliciesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAttachedPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of results to be returned per request.
    ///   - recursive: When true, recursively list attached policies.
    ///   - target: The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - logger: Logger used for logging
    @inlinable
    public func listAttachedPoliciesPaginator(
        pageSize: Int? = nil,
        recursive: Bool? = nil,
        target: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAttachedPoliciesRequest, ListAttachedPoliciesResponse> {
        let input = ListAttachedPoliciesRequest(
            pageSize: pageSize, 
            recursive: recursive, 
            target: target
        )
        return self.listAttachedPoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAuditFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditFindingsPaginator(
        _ input: ListAuditFindingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAuditFindingsRequest, ListAuditFindingsResponse> {
        return .init(
            input: input,
            command: self.listAuditFindings,
            inputKey: \ListAuditFindingsRequest.nextToken,
            outputKey: \ListAuditFindingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAuditFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - checkName: A filter to limit results to the findings for the specified audit check.
    ///   - endTime: A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - listSuppressedFindings:  Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - resourceIdentifier: Information identifying the noncompliant resource.
    ///   - startTime: A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - taskId: A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditFindingsPaginator(
        checkName: String? = nil,
        endTime: Date? = nil,
        listSuppressedFindings: Bool? = nil,
        maxResults: Int? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        startTime: Date? = nil,
        taskId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAuditFindingsRequest, ListAuditFindingsResponse> {
        let input = ListAuditFindingsRequest(
            checkName: checkName, 
            endTime: endTime, 
            listSuppressedFindings: listSuppressedFindings, 
            maxResults: maxResults, 
            resourceIdentifier: resourceIdentifier, 
            startTime: startTime, 
            taskId: taskId
        )
        return self.listAuditFindingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAuditMitigationActionsExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditMitigationActionsExecutionsPaginator(
        _ input: ListAuditMitigationActionsExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAuditMitigationActionsExecutionsRequest, ListAuditMitigationActionsExecutionsResponse> {
        return .init(
            input: input,
            command: self.listAuditMitigationActionsExecutions,
            inputKey: \ListAuditMitigationActionsExecutionsRequest.nextToken,
            outputKey: \ListAuditMitigationActionsExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAuditMitigationActionsExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - actionStatus: Specify this filter to limit results to those with a specific status.
    ///   - findingId: Specify this filter to limit results to those that were applied to a specific audit finding.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - taskId: Specify this filter to limit results to actions for a specific audit mitigation actions task.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditMitigationActionsExecutionsPaginator(
        actionStatus: AuditMitigationActionsExecutionStatus? = nil,
        findingId: String,
        maxResults: Int? = nil,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAuditMitigationActionsExecutionsRequest, ListAuditMitigationActionsExecutionsResponse> {
        let input = ListAuditMitigationActionsExecutionsRequest(
            actionStatus: actionStatus, 
            findingId: findingId, 
            maxResults: maxResults, 
            taskId: taskId
        )
        return self.listAuditMitigationActionsExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAuditMitigationActionsTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditMitigationActionsTasksPaginator(
        _ input: ListAuditMitigationActionsTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAuditMitigationActionsTasksRequest, ListAuditMitigationActionsTasksResponse> {
        return .init(
            input: input,
            command: self.listAuditMitigationActionsTasks,
            inputKey: \ListAuditMitigationActionsTasksRequest.nextToken,
            outputKey: \ListAuditMitigationActionsTasksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAuditMitigationActionsTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - auditTaskId: Specify this filter to limit results to tasks that were applied to results for a specific audit.
    ///   - endTime: Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
    ///   - findingId: Specify this filter to limit results to tasks that were applied to a specific audit finding.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - startTime: Specify this filter to limit results to tasks that began on or after a specific date and time.
    ///   - taskStatus: Specify this filter to limit results to tasks that are in a specific state.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditMitigationActionsTasksPaginator(
        auditTaskId: String? = nil,
        endTime: Date,
        findingId: String? = nil,
        maxResults: Int? = nil,
        startTime: Date,
        taskStatus: AuditMitigationActionsTaskStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAuditMitigationActionsTasksRequest, ListAuditMitigationActionsTasksResponse> {
        let input = ListAuditMitigationActionsTasksRequest(
            auditTaskId: auditTaskId, 
            endTime: endTime, 
            findingId: findingId, 
            maxResults: maxResults, 
            startTime: startTime, 
            taskStatus: taskStatus
        )
        return self.listAuditMitigationActionsTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAuditSuppressions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditSuppressionsPaginator(
        _ input: ListAuditSuppressionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAuditSuppressionsRequest, ListAuditSuppressionsResponse> {
        return .init(
            input: input,
            command: self.listAuditSuppressions,
            inputKey: \ListAuditSuppressionsRequest.nextToken,
            outputKey: \ListAuditSuppressionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAuditSuppressions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder:  Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, ascendingOrder=true.
    ///   - checkName: 
    ///   - maxResults:  The maximum number of results to return at one time. The default is 25.
    ///   - resourceIdentifier: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditSuppressionsPaginator(
        ascendingOrder: Bool? = nil,
        checkName: String? = nil,
        maxResults: Int? = nil,
        resourceIdentifier: ResourceIdentifier? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAuditSuppressionsRequest, ListAuditSuppressionsResponse> {
        let input = ListAuditSuppressionsRequest(
            ascendingOrder: ascendingOrder, 
            checkName: checkName, 
            maxResults: maxResults, 
            resourceIdentifier: resourceIdentifier
        )
        return self.listAuditSuppressionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAuditTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditTasksPaginator(
        _ input: ListAuditTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAuditTasksRequest, ListAuditTasksResponse> {
        return .init(
            input: input,
            command: self.listAuditTasks,
            inputKey: \ListAuditTasksRequest.nextToken,
            outputKey: \ListAuditTasksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAuditTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endTime: The end of the time period.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - startTime: The beginning of the time period. Audit information is retained for a  limited time (90 days). Requesting a start time prior to what is retained  results in an "InvalidRequestException".
    ///   - taskStatus: A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
    ///   - taskType: A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuditTasksPaginator(
        endTime: Date,
        maxResults: Int? = nil,
        startTime: Date,
        taskStatus: AuditTaskStatus? = nil,
        taskType: AuditTaskType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAuditTasksRequest, ListAuditTasksResponse> {
        let input = ListAuditTasksRequest(
            endTime: endTime, 
            maxResults: maxResults, 
            startTime: startTime, 
            taskStatus: taskStatus, 
            taskType: taskType
        )
        return self.listAuditTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAuthorizers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuthorizersPaginator(
        _ input: ListAuthorizersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAuthorizersRequest, ListAuthorizersResponse> {
        return .init(
            input: input,
            command: self.listAuthorizers,
            inputKey: \ListAuthorizersRequest.marker,
            outputKey: \ListAuthorizersResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAuthorizers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Return the list of authorizers in ascending alphabetical order.
    ///   - pageSize: The maximum number of results to return at one time.
    ///   - status: The status of the list authorizers request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAuthorizersPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        status: AuthorizerStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAuthorizersRequest, ListAuthorizersResponse> {
        let input = ListAuthorizersRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize, 
            status: status
        )
        return self.listAuthorizersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBillingGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillingGroupsPaginator(
        _ input: ListBillingGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBillingGroupsRequest, ListBillingGroupsResponse> {
        return .init(
            input: input,
            command: self.listBillingGroups,
            inputKey: \ListBillingGroupsRequest.nextToken,
            outputKey: \ListBillingGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBillingGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return per request.
    ///   - namePrefixFilter: Limit the results to billing groups whose names have the given prefix.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBillingGroupsPaginator(
        maxResults: Int? = nil,
        namePrefixFilter: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBillingGroupsRequest, ListBillingGroupsResponse> {
        let input = ListBillingGroupsRequest(
            maxResults: maxResults, 
            namePrefixFilter: namePrefixFilter
        )
        return self.listBillingGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCACertificates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCACertificatesPaginator(
        _ input: ListCACertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCACertificatesRequest, ListCACertificatesResponse> {
        return .init(
            input: input,
            command: self.listCACertificates,
            inputKey: \ListCACertificatesRequest.marker,
            outputKey: \ListCACertificatesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCACertificates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Determines the order of the results.
    ///   - pageSize: The result page size.
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCACertificatesPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        templateName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCACertificatesRequest, ListCACertificatesResponse> {
        let input = ListCACertificatesRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize, 
            templateName: templateName
        )
        return self.listCACertificatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCertificates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCertificatesPaginator(
        _ input: ListCertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCertificatesRequest, ListCertificatesResponse> {
        return .init(
            input: input,
            command: self.listCertificates,
            inputKey: \ListCertificatesRequest.marker,
            outputKey: \ListCertificatesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCertificates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    ///   - pageSize: The result page size.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCertificatesPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCertificatesRequest, ListCertificatesResponse> {
        let input = ListCertificatesRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize
        )
        return self.listCertificatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCertificatesByCA(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCertificatesByCAPaginator(
        _ input: ListCertificatesByCARequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCertificatesByCARequest, ListCertificatesByCAResponse> {
        return .init(
            input: input,
            command: self.listCertificatesByCA,
            inputKey: \ListCertificatesByCARequest.marker,
            outputKey: \ListCertificatesByCAResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCertificatesByCA(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    ///   - caCertificateId: The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
    ///   - pageSize: The result page size.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCertificatesByCAPaginator(
        ascendingOrder: Bool? = nil,
        caCertificateId: String,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCertificatesByCARequest, ListCertificatesByCAResponse> {
        let input = ListCertificatesByCARequest(
            ascendingOrder: ascendingOrder, 
            caCertificateId: caCertificateId, 
            pageSize: pageSize
        )
        return self.listCertificatesByCAPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCommandExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCommandExecutionsPaginator(
        _ input: ListCommandExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCommandExecutionsRequest, ListCommandExecutionsResponse> {
        return .init(
            input: input,
            command: self.listCommandExecutions,
            inputKey: \ListCommandExecutionsRequest.nextToken,
            outputKey: \ListCommandExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCommandExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - commandArn: The Amazon Resource Number (ARN) of the command. You can use this information to list all command executions for a particular command.
    ///   - completedTimeFilter: List all command executions that completed any time before or after the date and time that you specify. The date and time uses the format yyyy-MM-dd'T'HH:mm.
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - namespace: The namespace of the command.
    ///   - sortOrder: Specify whether to list the command executions that were created in the ascending or descending order. By default, the API returns all commands in the descending order based on the start time or completion time of the executions, that are determined by the startTimeFilter and completeTimeFilter parameters.
    ///   - startedTimeFilter: List all command executions that started any time before or after the date and time that you specify. The date and time uses the format yyyy-MM-dd'T'HH:mm.
    ///   - status: List all command executions for the device that have a particular status. For example, you can filter the list to display only command executions that have failed or timed out.
    ///   - targetArn: The Amazon Resource Number (ARN) of the target device. You can use this information to list all command executions for a particular device.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCommandExecutionsPaginator(
        commandArn: String? = nil,
        completedTimeFilter: TimeFilter? = nil,
        maxResults: Int? = nil,
        namespace: CommandNamespace? = nil,
        sortOrder: SortOrder? = nil,
        startedTimeFilter: TimeFilter? = nil,
        status: CommandExecutionStatus? = nil,
        targetArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCommandExecutionsRequest, ListCommandExecutionsResponse> {
        let input = ListCommandExecutionsRequest(
            commandArn: commandArn, 
            completedTimeFilter: completedTimeFilter, 
            maxResults: maxResults, 
            namespace: namespace, 
            sortOrder: sortOrder, 
            startedTimeFilter: startedTimeFilter, 
            status: status, 
            targetArn: targetArn
        )
        return self.listCommandExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCommands(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCommandsPaginator(
        _ input: ListCommandsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCommandsRequest, ListCommandsResponse> {
        return .init(
            input: input,
            command: self.listCommands,
            inputKey: \ListCommandsRequest.nextToken,
            outputKey: \ListCommandsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCommands(_:logger:)``.
    ///
    /// - Parameters:
    ///   - commandParameterName: A filter that can be used to display the list of commands that have a specific command parameter name.
    ///   - maxResults: The maximum number of results to return in this operation. By default, the API returns up to a maximum of 25 results. You can override this default value to return up to a maximum of 100 results for this operation.
    ///   - namespace: The namespace of the command. By default, the API returns all commands that have been created for both AWS-IoT and AWS-IoT-FleetWise namespaces. You can override this default value if you want to return all commands that have been created only for a specific namespace.
    ///   - sortOrder: Specify whether to list the commands that you have created in the ascending or descending order. By default, the API returns all commands in the descending order based on the time that they were created.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCommandsPaginator(
        commandParameterName: String? = nil,
        maxResults: Int? = nil,
        namespace: CommandNamespace? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCommandsRequest, ListCommandsResponse> {
        let input = ListCommandsRequest(
            commandParameterName: commandParameterName, 
            maxResults: maxResults, 
            namespace: namespace, 
            sortOrder: sortOrder
        )
        return self.listCommandsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCustomMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomMetricsPaginator(
        _ input: ListCustomMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCustomMetricsRequest, ListCustomMetricsResponse> {
        return .init(
            input: input,
            command: self.listCustomMetrics,
            inputKey: \ListCustomMetricsRequest.nextToken,
            outputKey: \ListCustomMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCustomMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults:  The maximum number of results to return at one time. The default is 25.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomMetricsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCustomMetricsRequest, ListCustomMetricsResponse> {
        let input = ListCustomMetricsRequest(
            maxResults: maxResults
        )
        return self.listCustomMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDetectMitigationActionsExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDetectMitigationActionsExecutionsPaginator(
        _ input: ListDetectMitigationActionsExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDetectMitigationActionsExecutionsRequest, ListDetectMitigationActionsExecutionsResponse> {
        return .init(
            input: input,
            command: self.listDetectMitigationActionsExecutions,
            inputKey: \ListDetectMitigationActionsExecutionsRequest.nextToken,
            outputKey: \ListDetectMitigationActionsExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDetectMitigationActionsExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endTime:  The end of the time period for which ML Detect mitigation actions executions are returned.
    ///   - maxResults:  The maximum number of results to return at one time. The default is 25.
    ///   - startTime:  A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - taskId:  The unique identifier of the task.
    ///   - thingName:  The name of the thing whose mitigation actions are listed.
    ///   - violationId:  The unique identifier of the violation.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDetectMitigationActionsExecutionsPaginator(
        endTime: Date? = nil,
        maxResults: Int? = nil,
        startTime: Date? = nil,
        taskId: String? = nil,
        thingName: String? = nil,
        violationId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDetectMitigationActionsExecutionsRequest, ListDetectMitigationActionsExecutionsResponse> {
        let input = ListDetectMitigationActionsExecutionsRequest(
            endTime: endTime, 
            maxResults: maxResults, 
            startTime: startTime, 
            taskId: taskId, 
            thingName: thingName, 
            violationId: violationId
        )
        return self.listDetectMitigationActionsExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDetectMitigationActionsTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDetectMitigationActionsTasksPaginator(
        _ input: ListDetectMitigationActionsTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDetectMitigationActionsTasksRequest, ListDetectMitigationActionsTasksResponse> {
        return .init(
            input: input,
            command: self.listDetectMitigationActionsTasks,
            inputKey: \ListDetectMitigationActionsTasksRequest.nextToken,
            outputKey: \ListDetectMitigationActionsTasksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDetectMitigationActionsTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endTime:  The end of the time period for which ML Detect mitigation actions tasks are returned.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - startTime:  A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDetectMitigationActionsTasksPaginator(
        endTime: Date,
        maxResults: Int? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDetectMitigationActionsTasksRequest, ListDetectMitigationActionsTasksResponse> {
        let input = ListDetectMitigationActionsTasksRequest(
            endTime: endTime, 
            maxResults: maxResults, 
            startTime: startTime
        )
        return self.listDetectMitigationActionsTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDimensions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDimensionsPaginator(
        _ input: ListDimensionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDimensionsRequest, ListDimensionsResponse> {
        return .init(
            input: input,
            command: self.listDimensions,
            inputKey: \ListDimensionsRequest.nextToken,
            outputKey: \ListDimensionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDimensions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to retrieve at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDimensionsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDimensionsRequest, ListDimensionsResponse> {
        let input = ListDimensionsRequest(
            maxResults: maxResults
        )
        return self.listDimensionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDomainConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDomainConfigurationsPaginator(
        _ input: ListDomainConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDomainConfigurationsRequest, ListDomainConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listDomainConfigurations,
            inputKey: \ListDomainConfigurationsRequest.marker,
            outputKey: \ListDomainConfigurationsResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDomainConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The result page size.
    ///   - serviceType: The type of service delivered by the endpoint.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDomainConfigurationsPaginator(
        pageSize: Int? = nil,
        serviceType: ServiceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDomainConfigurationsRequest, ListDomainConfigurationsResponse> {
        let input = ListDomainConfigurationsRequest(
            pageSize: pageSize, 
            serviceType: serviceType
        )
        return self.listDomainConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFleetMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetMetricsPaginator(
        _ input: ListFleetMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFleetMetricsRequest, ListFleetMetricsResponse> {
        return .init(
            input: input,
            command: self.listFleetMetrics,
            inputKey: \ListFleetMetricsRequest.nextToken,
            outputKey: \ListFleetMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFleetMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetMetricsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFleetMetricsRequest, ListFleetMetricsResponse> {
        let input = ListFleetMetricsRequest(
            maxResults: maxResults
        )
        return self.listFleetMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIndices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIndicesPaginator(
        _ input: ListIndicesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIndicesRequest, ListIndicesResponse> {
        return .init(
            input: input,
            command: self.listIndices,
            inputKey: \ListIndicesRequest.nextToken,
            outputKey: \ListIndicesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIndices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIndicesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIndicesRequest, ListIndicesResponse> {
        let input = ListIndicesRequest(
            maxResults: maxResults
        )
        return self.listIndicesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobExecutionsForJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobExecutionsForJobPaginator(
        _ input: ListJobExecutionsForJobRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobExecutionsForJobRequest, ListJobExecutionsForJobResponse> {
        return .init(
            input: input,
            command: self.listJobExecutionsForJob,
            inputKey: \ListJobExecutionsForJobRequest.nextToken,
            outputKey: \ListJobExecutionsForJobResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobExecutionsForJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - maxResults: The maximum number of results to be returned per request.
    ///   - status: The status of the job.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobExecutionsForJobPaginator(
        jobId: String,
        maxResults: Int? = nil,
        status: JobExecutionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobExecutionsForJobRequest, ListJobExecutionsForJobResponse> {
        let input = ListJobExecutionsForJobRequest(
            jobId: jobId, 
            maxResults: maxResults, 
            status: status
        )
        return self.listJobExecutionsForJobPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobExecutionsForThing(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobExecutionsForThingPaginator(
        _ input: ListJobExecutionsForThingRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobExecutionsForThingRequest, ListJobExecutionsForThingResponse> {
        return .init(
            input: input,
            command: self.listJobExecutionsForThing,
            inputKey: \ListJobExecutionsForThingRequest.nextToken,
            outputKey: \ListJobExecutionsForThingResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobExecutionsForThing(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobId: The unique identifier you assigned to this job when it was created.
    ///   - maxResults: The maximum number of results to be returned per request.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - status: An optional filter that lets you search for jobs that have the specified status.
    ///   - thingName: The thing name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobExecutionsForThingPaginator(
        jobId: String? = nil,
        maxResults: Int? = nil,
        namespaceId: String? = nil,
        status: JobExecutionStatus? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobExecutionsForThingRequest, ListJobExecutionsForThingResponse> {
        let input = ListJobExecutionsForThingRequest(
            jobId: jobId, 
            maxResults: maxResults, 
            namespaceId: namespaceId, 
            status: status, 
            thingName: thingName
        )
        return self.listJobExecutionsForThingPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobTemplatesPaginator(
        _ input: ListJobTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobTemplatesRequest, ListJobTemplatesResponse> {
        return .init(
            input: input,
            command: self.listJobTemplates,
            inputKey: \ListJobTemplatesRequest.nextToken,
            outputKey: \ListJobTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobTemplatesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobTemplatesRequest, ListJobTemplatesResponse> {
        let input = ListJobTemplatesRequest(
            maxResults: maxResults
        )
        return self.listJobTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        _ input: ListJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        return .init(
            input: input,
            command: self.listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return per request.
    ///   - namespaceId: The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.  $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/   The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see Setting up IoT Greengrass core devices.
    ///   - status: An optional filter that lets you search for jobs that have the specified status.
    ///   - targetSelection: Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.   We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    ///   - thingGroupId: A filter that limits the returned jobs to those for the specified group.
    ///   - thingGroupName: A filter that limits the returned jobs to those for the specified group.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        maxResults: Int? = nil,
        namespaceId: String? = nil,
        status: JobStatus? = nil,
        targetSelection: TargetSelection? = nil,
        thingGroupId: String? = nil,
        thingGroupName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        let input = ListJobsRequest(
            maxResults: maxResults, 
            namespaceId: namespaceId, 
            status: status, 
            targetSelection: targetSelection, 
            thingGroupId: thingGroupId, 
            thingGroupName: thingGroupName
        )
        return self.listJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listManagedJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedJobTemplatesPaginator(
        _ input: ListManagedJobTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListManagedJobTemplatesRequest, ListManagedJobTemplatesResponse> {
        return .init(
            input: input,
            command: self.listManagedJobTemplates,
            inputKey: \ListManagedJobTemplatesRequest.nextToken,
            outputKey: \ListManagedJobTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listManagedJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of entries that can be returned.
    ///   - templateName: An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedJobTemplatesPaginator(
        maxResults: Int? = nil,
        templateName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListManagedJobTemplatesRequest, ListManagedJobTemplatesResponse> {
        let input = ListManagedJobTemplatesRequest(
            maxResults: maxResults, 
            templateName: templateName
        )
        return self.listManagedJobTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMetricValues(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMetricValuesPaginator(
        _ input: ListMetricValuesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMetricValuesRequest, ListMetricValuesResponse> {
        return .init(
            input: input,
            command: self.listMetricValues,
            inputKey: \ListMetricValuesRequest.nextToken,
            outputKey: \ListMetricValuesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMetricValues(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dimensionName: The dimension name.
    ///   - dimensionValueOperator: The dimension value operator.
    ///   - endTime: The end of the time period for which metric values are returned.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - metricName: The name of the security profile metric for which values are returned.
    ///   - startTime: The start of the time period for which metric values are returned.
    ///   - thingName: The name of the thing for which security profile metric values are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMetricValuesPaginator(
        dimensionName: String? = nil,
        dimensionValueOperator: DimensionValueOperator? = nil,
        endTime: Date,
        maxResults: Int? = nil,
        metricName: String,
        startTime: Date,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMetricValuesRequest, ListMetricValuesResponse> {
        let input = ListMetricValuesRequest(
            dimensionName: dimensionName, 
            dimensionValueOperator: dimensionValueOperator, 
            endTime: endTime, 
            maxResults: maxResults, 
            metricName: metricName, 
            startTime: startTime, 
            thingName: thingName
        )
        return self.listMetricValuesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMitigationActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMitigationActionsPaginator(
        _ input: ListMitigationActionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMitigationActionsRequest, ListMitigationActionsResponse> {
        return .init(
            input: input,
            command: self.listMitigationActions,
            inputKey: \ListMitigationActionsRequest.nextToken,
            outputKey: \ListMitigationActionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMitigationActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - actionType: Specify a value to limit the result to mitigation actions with a specific action type.
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMitigationActionsPaginator(
        actionType: MitigationActionType? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMitigationActionsRequest, ListMitigationActionsResponse> {
        let input = ListMitigationActionsRequest(
            actionType: actionType, 
            maxResults: maxResults
        )
        return self.listMitigationActionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listOTAUpdates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listOTAUpdatesPaginator(
        _ input: ListOTAUpdatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListOTAUpdatesRequest, ListOTAUpdatesResponse> {
        return .init(
            input: input,
            command: self.listOTAUpdates,
            inputKey: \ListOTAUpdatesRequest.nextToken,
            outputKey: \ListOTAUpdatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listOTAUpdates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - otaUpdateStatus: The OTA update job status.
    ///   - logger: Logger used for logging
    @inlinable
    public func listOTAUpdatesPaginator(
        maxResults: Int? = nil,
        otaUpdateStatus: OTAUpdateStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListOTAUpdatesRequest, ListOTAUpdatesResponse> {
        let input = ListOTAUpdatesRequest(
            maxResults: maxResults, 
            otaUpdateStatus: otaUpdateStatus
        )
        return self.listOTAUpdatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listOutgoingCertificates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listOutgoingCertificatesPaginator(
        _ input: ListOutgoingCertificatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListOutgoingCertificatesRequest, ListOutgoingCertificatesResponse> {
        return .init(
            input: input,
            command: self.listOutgoingCertificates,
            inputKey: \ListOutgoingCertificatesRequest.marker,
            outputKey: \ListOutgoingCertificatesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listOutgoingCertificates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    ///   - pageSize: The result page size.
    ///   - logger: Logger used for logging
    @inlinable
    public func listOutgoingCertificatesPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListOutgoingCertificatesRequest, ListOutgoingCertificatesResponse> {
        let input = ListOutgoingCertificatesRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize
        )
        return self.listOutgoingCertificatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPackageVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackageVersionsPaginator(
        _ input: ListPackageVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPackageVersionsRequest, ListPackageVersionsResponse> {
        return .init(
            input: input,
            command: self.listPackageVersions,
            inputKey: \ListPackageVersionsRequest.nextToken,
            outputKey: \ListPackageVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPackageVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - packageName: The name of the target software package.
    ///   - status: The status of the package version. For more information, see Package version lifecycle.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackageVersionsPaginator(
        maxResults: Int? = nil,
        packageName: String,
        status: PackageVersionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPackageVersionsRequest, ListPackageVersionsResponse> {
        let input = ListPackageVersionsRequest(
            maxResults: maxResults, 
            packageName: packageName, 
            status: status
        )
        return self.listPackageVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPackages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackagesPaginator(
        _ input: ListPackagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPackagesRequest, ListPackagesResponse> {
        return .init(
            input: input,
            command: self.listPackages,
            inputKey: \ListPackagesRequest.nextToken,
            outputKey: \ListPackagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPackages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results returned at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPackagesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPackagesRequest, ListPackagesResponse> {
        let input = ListPackagesRequest(
            maxResults: maxResults
        )
        return self.listPackagesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPoliciesPaginator(
        _ input: ListPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPoliciesRequest, ListPoliciesResponse> {
        return .init(
            input: input,
            command: self.listPolicies,
            inputKey: \ListPoliciesRequest.marker,
            outputKey: \ListPoliciesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Specifies the order for results. If true, the results are returned in ascending creation order.
    ///   - pageSize: The result page size.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPoliciesPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPoliciesRequest, ListPoliciesResponse> {
        let input = ListPoliciesRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize
        )
        return self.listPoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPolicyPrincipals(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyPrincipalsPaginator(
        _ input: ListPolicyPrincipalsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPolicyPrincipalsRequest, ListPolicyPrincipalsResponse> {
        return .init(
            input: input,
            command: self.listPolicyPrincipals,
            inputKey: \ListPolicyPrincipalsRequest.marker,
            outputKey: \ListPolicyPrincipalsResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPolicyPrincipals(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Specifies the order for results. If true, the results are returned in ascending creation order.
    ///   - pageSize: The result page size.
    ///   - policyName: The policy name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPolicyPrincipalsPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPolicyPrincipalsRequest, ListPolicyPrincipalsResponse> {
        let input = ListPolicyPrincipalsRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize, 
            policyName: policyName
        )
        return self.listPolicyPrincipalsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPrincipalPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrincipalPoliciesPaginator(
        _ input: ListPrincipalPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPrincipalPoliciesRequest, ListPrincipalPoliciesResponse> {
        return .init(
            input: input,
            command: self.listPrincipalPolicies,
            inputKey: \ListPrincipalPoliciesRequest.marker,
            outputKey: \ListPrincipalPoliciesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPrincipalPolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Specifies the order for results. If true, results are returned in ascending creation order.
    ///   - pageSize: The result page size.
    ///   - principal: The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrincipalPoliciesPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        principal: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPrincipalPoliciesRequest, ListPrincipalPoliciesResponse> {
        let input = ListPrincipalPoliciesRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize, 
            principal: principal
        )
        return self.listPrincipalPoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPrincipalThings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrincipalThingsPaginator(
        _ input: ListPrincipalThingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPrincipalThingsRequest, ListPrincipalThingsResponse> {
        return .init(
            input: input,
            command: self.listPrincipalThings,
            inputKey: \ListPrincipalThingsRequest.nextToken,
            outputKey: \ListPrincipalThingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPrincipalThings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - principal: The principal.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrincipalThingsPaginator(
        maxResults: Int? = nil,
        principal: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPrincipalThingsRequest, ListPrincipalThingsResponse> {
        let input = ListPrincipalThingsRequest(
            maxResults: maxResults, 
            principal: principal
        )
        return self.listPrincipalThingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPrincipalThingsV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrincipalThingsV2Paginator(
        _ input: ListPrincipalThingsV2Request,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPrincipalThingsV2Request, ListPrincipalThingsV2Response> {
        return .init(
            input: input,
            command: self.listPrincipalThingsV2,
            inputKey: \ListPrincipalThingsV2Request.nextToken,
            outputKey: \ListPrincipalThingsV2Response.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPrincipalThingsV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - principal: The principal. A principal can be an X.509 certificate or an Amazon Cognito ID.
    ///   - thingPrincipalType: The type of the relation you want to filter in the response. If no value is provided in
    ///   - logger: Logger used for logging
    @inlinable
    public func listPrincipalThingsV2Paginator(
        maxResults: Int? = nil,
        principal: String,
        thingPrincipalType: ThingPrincipalType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPrincipalThingsV2Request, ListPrincipalThingsV2Response> {
        let input = ListPrincipalThingsV2Request(
            maxResults: maxResults, 
            principal: principal, 
            thingPrincipalType: thingPrincipalType
        )
        return self.listPrincipalThingsV2Paginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProvisioningTemplateVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProvisioningTemplateVersionsPaginator(
        _ input: ListProvisioningTemplateVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProvisioningTemplateVersionsRequest, ListProvisioningTemplateVersionsResponse> {
        return .init(
            input: input,
            command: self.listProvisioningTemplateVersions,
            inputKey: \ListProvisioningTemplateVersionsRequest.nextToken,
            outputKey: \ListProvisioningTemplateVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProvisioningTemplateVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - templateName: The name of the provisioning template.
    ///   - logger: Logger used for logging
    @inlinable
    public func listProvisioningTemplateVersionsPaginator(
        maxResults: Int? = nil,
        templateName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProvisioningTemplateVersionsRequest, ListProvisioningTemplateVersionsResponse> {
        let input = ListProvisioningTemplateVersionsRequest(
            maxResults: maxResults, 
            templateName: templateName
        )
        return self.listProvisioningTemplateVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listProvisioningTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listProvisioningTemplatesPaginator(
        _ input: ListProvisioningTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListProvisioningTemplatesRequest, ListProvisioningTemplatesResponse> {
        return .init(
            input: input,
            command: self.listProvisioningTemplates,
            inputKey: \ListProvisioningTemplatesRequest.nextToken,
            outputKey: \ListProvisioningTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listProvisioningTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listProvisioningTemplatesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListProvisioningTemplatesRequest, ListProvisioningTemplatesResponse> {
        let input = ListProvisioningTemplatesRequest(
            maxResults: maxResults
        )
        return self.listProvisioningTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRelatedResourcesForAuditFinding(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRelatedResourcesForAuditFindingPaginator(
        _ input: ListRelatedResourcesForAuditFindingRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRelatedResourcesForAuditFindingRequest, ListRelatedResourcesForAuditFindingResponse> {
        return .init(
            input: input,
            command: self.listRelatedResourcesForAuditFinding,
            inputKey: \ListRelatedResourcesForAuditFindingRequest.nextToken,
            outputKey: \ListRelatedResourcesForAuditFindingResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRelatedResourcesForAuditFinding(_:logger:)``.
    ///
    /// - Parameters:
    ///   - findingId: The finding Id.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRelatedResourcesForAuditFindingPaginator(
        findingId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRelatedResourcesForAuditFindingRequest, ListRelatedResourcesForAuditFindingResponse> {
        let input = ListRelatedResourcesForAuditFindingRequest(
            findingId: findingId, 
            maxResults: maxResults
        )
        return self.listRelatedResourcesForAuditFindingPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRoleAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRoleAliasesPaginator(
        _ input: ListRoleAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRoleAliasesRequest, ListRoleAliasesResponse> {
        return .init(
            input: input,
            command: self.listRoleAliases,
            inputKey: \ListRoleAliasesRequest.marker,
            outputKey: \ListRoleAliasesResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRoleAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Return the list of role aliases in ascending alphabetical order.
    ///   - pageSize: The maximum number of results to return at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRoleAliasesPaginator(
        ascendingOrder: Bool? = nil,
        pageSize: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRoleAliasesRequest, ListRoleAliasesResponse> {
        let input = ListRoleAliasesRequest(
            ascendingOrder: ascendingOrder, 
            pageSize: pageSize
        )
        return self.listRoleAliasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSbomValidationResults(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSbomValidationResultsPaginator(
        _ input: ListSbomValidationResultsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSbomValidationResultsRequest, ListSbomValidationResultsResponse> {
        return .init(
            input: input,
            command: self.listSbomValidationResults,
            inputKey: \ListSbomValidationResultsRequest.nextToken,
            outputKey: \ListSbomValidationResultsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSbomValidationResults(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - packageName: The name of the new software package.
    ///   - validationResult: The end result of the
    ///   - versionName: The name of the new package version.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSbomValidationResultsPaginator(
        maxResults: Int? = nil,
        packageName: String,
        validationResult: SbomValidationResult? = nil,
        versionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSbomValidationResultsRequest, ListSbomValidationResultsResponse> {
        let input = ListSbomValidationResultsRequest(
            maxResults: maxResults, 
            packageName: packageName, 
            validationResult: validationResult, 
            versionName: versionName
        )
        return self.listSbomValidationResultsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listScheduledAudits(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listScheduledAuditsPaginator(
        _ input: ListScheduledAuditsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListScheduledAuditsRequest, ListScheduledAuditsResponse> {
        return .init(
            input: input,
            command: self.listScheduledAudits,
            inputKey: \ListScheduledAuditsRequest.nextToken,
            outputKey: \ListScheduledAuditsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listScheduledAudits(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time. The default is 25.
    ///   - logger: Logger used for logging
    @inlinable
    public func listScheduledAuditsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListScheduledAuditsRequest, ListScheduledAuditsResponse> {
        let input = ListScheduledAuditsRequest(
            maxResults: maxResults
        )
        return self.listScheduledAuditsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSecurityProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSecurityProfilesPaginator(
        _ input: ListSecurityProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSecurityProfilesRequest, ListSecurityProfilesResponse> {
        return .init(
            input: input,
            command: self.listSecurityProfiles,
            inputKey: \ListSecurityProfilesRequest.nextToken,
            outputKey: \ListSecurityProfilesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSecurityProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dimensionName: A filter to limit results to the security profiles that use the defined dimension. Cannot be used with metricName
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - metricName:  The name of the custom metric. Cannot be used with dimensionName.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSecurityProfilesPaginator(
        dimensionName: String? = nil,
        maxResults: Int? = nil,
        metricName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSecurityProfilesRequest, ListSecurityProfilesResponse> {
        let input = ListSecurityProfilesRequest(
            dimensionName: dimensionName, 
            maxResults: maxResults, 
            metricName: metricName
        )
        return self.listSecurityProfilesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSecurityProfilesForTarget(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSecurityProfilesForTargetPaginator(
        _ input: ListSecurityProfilesForTargetRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSecurityProfilesForTargetRequest, ListSecurityProfilesForTargetResponse> {
        return .init(
            input: input,
            command: self.listSecurityProfilesForTarget,
            inputKey: \ListSecurityProfilesForTargetRequest.nextToken,
            outputKey: \ListSecurityProfilesForTargetResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSecurityProfilesForTarget(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - recursive: If true, return child groups too.
    ///   - securityProfileTargetArn: The ARN of the target (thing group) whose attached security profiles you want to get.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSecurityProfilesForTargetPaginator(
        maxResults: Int? = nil,
        recursive: Bool? = nil,
        securityProfileTargetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSecurityProfilesForTargetRequest, ListSecurityProfilesForTargetResponse> {
        let input = ListSecurityProfilesForTargetRequest(
            maxResults: maxResults, 
            recursive: recursive, 
            securityProfileTargetArn: securityProfileTargetArn
        )
        return self.listSecurityProfilesForTargetPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStreams(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamsPaginator(
        _ input: ListStreamsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStreamsRequest, ListStreamsResponse> {
        return .init(
            input: input,
            command: self.listStreams,
            inputKey: \ListStreamsRequest.nextToken,
            outputKey: \ListStreamsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStreams(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ascendingOrder: Set to true to return the list of streams in ascending order.
    ///   - maxResults: The maximum number of results to return at a time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamsPaginator(
        ascendingOrder: Bool? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStreamsRequest, ListStreamsResponse> {
        let input = ListStreamsRequest(
            ascendingOrder: ascendingOrder, 
            maxResults: maxResults
        )
        return self.listStreamsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTagsForResource(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTagsForResourcePaginator(
        _ input: ListTagsForResourceRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTagsForResourceRequest, ListTagsForResourceResponse> {
        return .init(
            input: input,
            command: self.listTagsForResource,
            inputKey: \ListTagsForResourceRequest.nextToken,
            outputKey: \ListTagsForResourceResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTagsForResource(_:logger:)``.
    ///
    /// - Parameters:
    ///   - resourceArn: The ARN of the resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTagsForResourcePaginator(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTagsForResourceRequest, ListTagsForResourceResponse> {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return self.listTagsForResourcePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTargetsForPolicy(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTargetsForPolicyPaginator(
        _ input: ListTargetsForPolicyRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTargetsForPolicyRequest, ListTargetsForPolicyResponse> {
        return .init(
            input: input,
            command: self.listTargetsForPolicy,
            inputKey: \ListTargetsForPolicyRequest.marker,
            outputKey: \ListTargetsForPolicyResponse.nextMarker,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTargetsForPolicy(_:logger:)``.
    ///
    /// - Parameters:
    ///   - pageSize: The maximum number of results to return at one time.
    ///   - policyName: The policy name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTargetsForPolicyPaginator(
        pageSize: Int? = nil,
        policyName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTargetsForPolicyRequest, ListTargetsForPolicyResponse> {
        let input = ListTargetsForPolicyRequest(
            pageSize: pageSize, 
            policyName: policyName
        )
        return self.listTargetsForPolicyPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTargetsForSecurityProfile(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTargetsForSecurityProfilePaginator(
        _ input: ListTargetsForSecurityProfileRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTargetsForSecurityProfileRequest, ListTargetsForSecurityProfileResponse> {
        return .init(
            input: input,
            command: self.listTargetsForSecurityProfile,
            inputKey: \ListTargetsForSecurityProfileRequest.nextToken,
            outputKey: \ListTargetsForSecurityProfileResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTargetsForSecurityProfile(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - securityProfileName: The security profile.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTargetsForSecurityProfilePaginator(
        maxResults: Int? = nil,
        securityProfileName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTargetsForSecurityProfileRequest, ListTargetsForSecurityProfileResponse> {
        let input = ListTargetsForSecurityProfileRequest(
            maxResults: maxResults, 
            securityProfileName: securityProfileName
        )
        return self.listTargetsForSecurityProfilePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingGroupsPaginator(
        _ input: ListThingGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingGroupsRequest, ListThingGroupsResponse> {
        return .init(
            input: input,
            command: self.listThingGroups,
            inputKey: \ListThingGroupsRequest.nextToken,
            outputKey: \ListThingGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - namePrefixFilter: A filter that limits the results to those with the specified name prefix.
    ///   - parentGroup: A filter that limits the results to those with the specified parent group.
    ///   - recursive: If true, return child groups as well.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingGroupsPaginator(
        maxResults: Int? = nil,
        namePrefixFilter: String? = nil,
        parentGroup: String? = nil,
        recursive: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingGroupsRequest, ListThingGroupsResponse> {
        let input = ListThingGroupsRequest(
            maxResults: maxResults, 
            namePrefixFilter: namePrefixFilter, 
            parentGroup: parentGroup, 
            recursive: recursive
        )
        return self.listThingGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingGroupsForThing(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingGroupsForThingPaginator(
        _ input: ListThingGroupsForThingRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingGroupsForThingRequest, ListThingGroupsForThingResponse> {
        return .init(
            input: input,
            command: self.listThingGroupsForThing,
            inputKey: \ListThingGroupsForThingRequest.nextToken,
            outputKey: \ListThingGroupsForThingResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingGroupsForThing(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - thingName: The thing name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingGroupsForThingPaginator(
        maxResults: Int? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingGroupsForThingRequest, ListThingGroupsForThingResponse> {
        let input = ListThingGroupsForThingRequest(
            maxResults: maxResults, 
            thingName: thingName
        )
        return self.listThingGroupsForThingPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingPrincipals(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingPrincipalsPaginator(
        _ input: ListThingPrincipalsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingPrincipalsRequest, ListThingPrincipalsResponse> {
        return .init(
            input: input,
            command: self.listThingPrincipals,
            inputKey: \ListThingPrincipalsRequest.nextToken,
            outputKey: \ListThingPrincipalsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingPrincipals(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - thingName: The name of the thing.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingPrincipalsPaginator(
        maxResults: Int? = nil,
        thingName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingPrincipalsRequest, ListThingPrincipalsResponse> {
        let input = ListThingPrincipalsRequest(
            maxResults: maxResults, 
            thingName: thingName
        )
        return self.listThingPrincipalsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingPrincipalsV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingPrincipalsV2Paginator(
        _ input: ListThingPrincipalsV2Request,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingPrincipalsV2Request, ListThingPrincipalsV2Response> {
        return .init(
            input: input,
            command: self.listThingPrincipalsV2,
            inputKey: \ListThingPrincipalsV2Request.nextToken,
            outputKey: \ListThingPrincipalsV2Response.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingPrincipalsV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - thingName: The name of the thing.
    ///   - thingPrincipalType: The type of the relation you want to filter in the response. If no value is provided in
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingPrincipalsV2Paginator(
        maxResults: Int? = nil,
        thingName: String,
        thingPrincipalType: ThingPrincipalType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingPrincipalsV2Request, ListThingPrincipalsV2Response> {
        let input = ListThingPrincipalsV2Request(
            maxResults: maxResults, 
            thingName: thingName, 
            thingPrincipalType: thingPrincipalType
        )
        return self.listThingPrincipalsV2Paginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingRegistrationTaskReports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingRegistrationTaskReportsPaginator(
        _ input: ListThingRegistrationTaskReportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingRegistrationTaskReportsRequest, ListThingRegistrationTaskReportsResponse> {
        return .init(
            input: input,
            command: self.listThingRegistrationTaskReports,
            inputKey: \ListThingRegistrationTaskReportsRequest.nextToken,
            outputKey: \ListThingRegistrationTaskReportsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingRegistrationTaskReports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return per request.
    ///   - reportType: The type of task report.
    ///   - taskId: The id of the task.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingRegistrationTaskReportsPaginator(
        maxResults: Int? = nil,
        reportType: ReportType,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingRegistrationTaskReportsRequest, ListThingRegistrationTaskReportsResponse> {
        let input = ListThingRegistrationTaskReportsRequest(
            maxResults: maxResults, 
            reportType: reportType, 
            taskId: taskId
        )
        return self.listThingRegistrationTaskReportsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingRegistrationTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingRegistrationTasksPaginator(
        _ input: ListThingRegistrationTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingRegistrationTasksRequest, ListThingRegistrationTasksResponse> {
        return .init(
            input: input,
            command: self.listThingRegistrationTasks,
            inputKey: \ListThingRegistrationTasksRequest.nextToken,
            outputKey: \ListThingRegistrationTasksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingRegistrationTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - status: The status of the bulk thing provisioning task.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingRegistrationTasksPaginator(
        maxResults: Int? = nil,
        status: Status? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingRegistrationTasksRequest, ListThingRegistrationTasksResponse> {
        let input = ListThingRegistrationTasksRequest(
            maxResults: maxResults, 
            status: status
        )
        return self.listThingRegistrationTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingTypesPaginator(
        _ input: ListThingTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingTypesRequest, ListThingTypesResponse> {
        return .init(
            input: input,
            command: self.listThingTypes,
            inputKey: \ListThingTypesRequest.nextToken,
            outputKey: \ListThingTypesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - thingTypeName: The name of the thing type.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingTypesPaginator(
        maxResults: Int? = nil,
        thingTypeName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingTypesRequest, ListThingTypesResponse> {
        let input = ListThingTypesRequest(
            maxResults: maxResults, 
            thingTypeName: thingTypeName
        )
        return self.listThingTypesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingsPaginator(
        _ input: ListThingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingsRequest, ListThingsResponse> {
        return .init(
            input: input,
            command: self.listThings,
            inputKey: \ListThingsRequest.nextToken,
            outputKey: \ListThingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - attributeName: The attribute name used to search for things.
    ///   - attributeValue: The attribute value used to search for things.
    ///   - maxResults: The maximum number of results to return in this operation.
    ///   - thingTypeName: The name of the thing type used to search for things.
    ///   - usePrefixAttributeValue: When true, the action returns the thing resources with attribute values that start with the attributeValue provided. When false, or not present, the action returns only the thing
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingsPaginator(
        attributeName: String? = nil,
        attributeValue: String? = nil,
        maxResults: Int? = nil,
        thingTypeName: String? = nil,
        usePrefixAttributeValue: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingsRequest, ListThingsResponse> {
        let input = ListThingsRequest(
            attributeName: attributeName, 
            attributeValue: attributeValue, 
            maxResults: maxResults, 
            thingTypeName: thingTypeName, 
            usePrefixAttributeValue: usePrefixAttributeValue
        )
        return self.listThingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingsInBillingGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingsInBillingGroupPaginator(
        _ input: ListThingsInBillingGroupRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingsInBillingGroupRequest, ListThingsInBillingGroupResponse> {
        return .init(
            input: input,
            command: self.listThingsInBillingGroup,
            inputKey: \ListThingsInBillingGroupRequest.nextToken,
            outputKey: \ListThingsInBillingGroupResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingsInBillingGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - billingGroupName: The name of the billing group.
    ///   - maxResults: The maximum number of results to return per request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingsInBillingGroupPaginator(
        billingGroupName: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingsInBillingGroupRequest, ListThingsInBillingGroupResponse> {
        let input = ListThingsInBillingGroupRequest(
            billingGroupName: billingGroupName, 
            maxResults: maxResults
        )
        return self.listThingsInBillingGroupPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listThingsInThingGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingsInThingGroupPaginator(
        _ input: ListThingsInThingGroupRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListThingsInThingGroupRequest, ListThingsInThingGroupResponse> {
        return .init(
            input: input,
            command: self.listThingsInThingGroup,
            inputKey: \ListThingsInThingGroupRequest.nextToken,
            outputKey: \ListThingsInThingGroupResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listThingsInThingGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - recursive: When true, list things in this thing group and in all child groups as
    ///   - thingGroupName: The thing group name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listThingsInThingGroupPaginator(
        maxResults: Int? = nil,
        recursive: Bool? = nil,
        thingGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListThingsInThingGroupRequest, ListThingsInThingGroupResponse> {
        let input = ListThingsInThingGroupRequest(
            maxResults: maxResults, 
            recursive: recursive, 
            thingGroupName: thingGroupName
        )
        return self.listThingsInThingGroupPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTopicRuleDestinations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTopicRuleDestinationsPaginator(
        _ input: ListTopicRuleDestinationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTopicRuleDestinationsRequest, ListTopicRuleDestinationsResponse> {
        return .init(
            input: input,
            command: self.listTopicRuleDestinations,
            inputKey: \ListTopicRuleDestinationsRequest.nextToken,
            outputKey: \ListTopicRuleDestinationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTopicRuleDestinations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTopicRuleDestinationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTopicRuleDestinationsRequest, ListTopicRuleDestinationsResponse> {
        let input = ListTopicRuleDestinationsRequest(
            maxResults: maxResults
        )
        return self.listTopicRuleDestinationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTopicRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTopicRulesPaginator(
        _ input: ListTopicRulesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTopicRulesRequest, ListTopicRulesResponse> {
        return .init(
            input: input,
            command: self.listTopicRules,
            inputKey: \ListTopicRulesRequest.nextToken,
            outputKey: \ListTopicRulesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTopicRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - ruleDisabled: Specifies whether the rule is disabled.
    ///   - topic: The topic.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTopicRulesPaginator(
        maxResults: Int? = nil,
        ruleDisabled: Bool? = nil,
        topic: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTopicRulesRequest, ListTopicRulesResponse> {
        let input = ListTopicRulesRequest(
            maxResults: maxResults, 
            ruleDisabled: ruleDisabled, 
            topic: topic
        )
        return self.listTopicRulesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listV2LoggingLevels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listV2LoggingLevelsPaginator(
        _ input: ListV2LoggingLevelsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListV2LoggingLevelsRequest, ListV2LoggingLevelsResponse> {
        return .init(
            input: input,
            command: self.listV2LoggingLevels,
            inputKey: \ListV2LoggingLevelsRequest.nextToken,
            outputKey: \ListV2LoggingLevelsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listV2LoggingLevels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - targetType: The type of resource for which you are configuring logging. Must be THING_Group.
    ///   - logger: Logger used for logging
    @inlinable
    public func listV2LoggingLevelsPaginator(
        maxResults: Int? = nil,
        targetType: LogTargetType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListV2LoggingLevelsRequest, ListV2LoggingLevelsResponse> {
        let input = ListV2LoggingLevelsRequest(
            maxResults: maxResults, 
            targetType: targetType
        )
        return self.listV2LoggingLevelsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listViolationEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listViolationEventsPaginator(
        _ input: ListViolationEventsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListViolationEventsRequest, ListViolationEventsResponse> {
        return .init(
            input: input,
            command: self.listViolationEvents,
            inputKey: \ListViolationEventsRequest.nextToken,
            outputKey: \ListViolationEventsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listViolationEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - behaviorCriteriaType:  The criteria for a behavior.
    ///   - endTime: The end time for the alerts to be listed.
    ///   - listSuppressedAlerts:  A list of all suppressed alerts.
    ///   - maxResults: The maximum number of results to return at one time.
    ///   - securityProfileName: A filter to limit results to those alerts generated by the specified security profile.
    ///   - startTime: The start time for the alerts to be listed.
    ///   - thingName: A filter to limit results to those alerts caused by the specified thing.
    ///   - verificationState: The verification state of the violation (detect alarm).
    ///   - logger: Logger used for logging
    @inlinable
    public func listViolationEventsPaginator(
        behaviorCriteriaType: BehaviorCriteriaType? = nil,
        endTime: Date,
        listSuppressedAlerts: Bool? = nil,
        maxResults: Int? = nil,
        securityProfileName: String? = nil,
        startTime: Date,
        thingName: String? = nil,
        verificationState: VerificationState? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListViolationEventsRequest, ListViolationEventsResponse> {
        let input = ListViolationEventsRequest(
            behaviorCriteriaType: behaviorCriteriaType, 
            endTime: endTime, 
            listSuppressedAlerts: listSuppressedAlerts, 
            maxResults: maxResults, 
            securityProfileName: securityProfileName, 
            startTime: startTime, 
            thingName: thingName, 
            verificationState: verificationState
        )
        return self.listViolationEventsPaginator(input, logger: logger)
    }
}

extension IoT.GetBehaviorModelTrainingSummariesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.GetBehaviorModelTrainingSummariesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )
    }
}

extension IoT.ListActiveViolationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListActiveViolationsRequest {
        return .init(
            behaviorCriteriaType: self.behaviorCriteriaType,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            thingName: self.thingName,
            verificationState: self.verificationState
        )
    }
}

extension IoT.ListAttachedPoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAttachedPoliciesRequest {
        return .init(
            marker: token,
            pageSize: self.pageSize,
            recursive: self.recursive,
            target: self.target
        )
    }
}

extension IoT.ListAuditFindingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditFindingsRequest {
        return .init(
            checkName: self.checkName,
            endTime: self.endTime,
            listSuppressedFindings: self.listSuppressedFindings,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier,
            startTime: self.startTime,
            taskId: self.taskId
        )
    }
}

extension IoT.ListAuditMitigationActionsExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditMitigationActionsExecutionsRequest {
        return .init(
            actionStatus: self.actionStatus,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId
        )
    }
}

extension IoT.ListAuditMitigationActionsTasksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditMitigationActionsTasksRequest {
        return .init(
            auditTaskId: self.auditTaskId,
            endTime: self.endTime,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus
        )
    }
}

extension IoT.ListAuditSuppressionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditSuppressionsRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            checkName: self.checkName,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier
        )
    }
}

extension IoT.ListAuditTasksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAuditTasksRequest {
        return .init(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus,
            taskType: self.taskType
        )
    }
}

extension IoT.ListAuthorizersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListAuthorizersRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            status: self.status
        )
    }
}

extension IoT.ListBillingGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListBillingGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token
        )
    }
}

extension IoT.ListCACertificatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListCACertificatesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            templateName: self.templateName
        )
    }
}

extension IoT.ListCertificatesByCARequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListCertificatesByCARequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            caCertificateId: self.caCertificateId,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListCertificatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListCertificatesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListCommandExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListCommandExecutionsRequest {
        return .init(
            commandArn: self.commandArn,
            completedTimeFilter: self.completedTimeFilter,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            sortOrder: self.sortOrder,
            startedTimeFilter: self.startedTimeFilter,
            status: self.status,
            targetArn: self.targetArn
        )
    }
}

extension IoT.ListCommandsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListCommandsRequest {
        return .init(
            commandParameterName: self.commandParameterName,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            sortOrder: self.sortOrder
        )
    }
}

extension IoT.ListCustomMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListCustomMetricsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListDetectMitigationActionsExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListDetectMitigationActionsExecutionsRequest {
        return .init(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskId: self.taskId,
            thingName: self.thingName,
            violationId: self.violationId
        )
    }
}

extension IoT.ListDetectMitigationActionsTasksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListDetectMitigationActionsTasksRequest {
        return .init(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )
    }
}

extension IoT.ListDimensionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListDimensionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListDomainConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListDomainConfigurationsRequest {
        return .init(
            marker: token,
            pageSize: self.pageSize,
            serviceType: self.serviceType
        )
    }
}

extension IoT.ListFleetMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListFleetMetricsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListIndicesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListIndicesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListJobExecutionsForJobRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListJobExecutionsForJobRequest {
        return .init(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension IoT.ListJobExecutionsForThingRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListJobExecutionsForThingRequest {
        return .init(
            jobId: self.jobId,
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            thingName: self.thingName
        )
    }
}

extension IoT.ListJobTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListJobTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListJobsRequest {
        return .init(
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            targetSelection: self.targetSelection,
            thingGroupId: self.thingGroupId,
            thingGroupName: self.thingGroupName
        )
    }
}

extension IoT.ListManagedJobTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListManagedJobTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            templateName: self.templateName
        )
    }
}

extension IoT.ListMetricValuesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListMetricValuesRequest {
        return .init(
            dimensionName: self.dimensionName,
            dimensionValueOperator: self.dimensionValueOperator,
            endTime: self.endTime,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token,
            startTime: self.startTime,
            thingName: self.thingName
        )
    }
}

extension IoT.ListMitigationActionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListMitigationActionsRequest {
        return .init(
            actionType: self.actionType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListOTAUpdatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListOTAUpdatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            otaUpdateStatus: self.otaUpdateStatus
        )
    }
}

extension IoT.ListOutgoingCertificatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListOutgoingCertificatesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListPackageVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPackageVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            packageName: self.packageName,
            status: self.status
        )
    }
}

extension IoT.ListPackagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPackagesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListPoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPoliciesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListPolicyPrincipalsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPolicyPrincipalsRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )
    }
}

extension IoT.ListPrincipalPoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPrincipalPoliciesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            principal: self.principal
        )
    }
}

extension IoT.ListPrincipalThingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPrincipalThingsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal
        )
    }
}

extension IoT.ListPrincipalThingsV2Request: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListPrincipalThingsV2Request {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal,
            thingPrincipalType: self.thingPrincipalType
        )
    }
}

extension IoT.ListProvisioningTemplateVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListProvisioningTemplateVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            templateName: self.templateName
        )
    }
}

extension IoT.ListProvisioningTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListProvisioningTemplatesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListRelatedResourcesForAuditFindingRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListRelatedResourcesForAuditFindingRequest {
        return .init(
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListRoleAliasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListRoleAliasesRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )
    }
}

extension IoT.ListSbomValidationResultsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListSbomValidationResultsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            packageName: self.packageName,
            validationResult: self.validationResult,
            versionName: self.versionName
        )
    }
}

extension IoT.ListScheduledAuditsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListScheduledAuditsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListSecurityProfilesForTargetRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListSecurityProfilesForTargetRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            securityProfileTargetArn: self.securityProfileTargetArn
        )
    }
}

extension IoT.ListSecurityProfilesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListSecurityProfilesRequest {
        return .init(
            dimensionName: self.dimensionName,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token
        )
    }
}

extension IoT.ListStreamsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListStreamsRequest {
        return .init(
            ascendingOrder: self.ascendingOrder,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListTagsForResourceRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListTagsForResourceRequest {
        return .init(
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension IoT.ListTargetsForPolicyRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListTargetsForPolicyRequest {
        return .init(
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )
    }
}

extension IoT.ListTargetsForSecurityProfileRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListTargetsForSecurityProfileRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )
    }
}

extension IoT.ListThingGroupsForThingRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingGroupsForThingRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )
    }
}

extension IoT.ListThingGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token,
            parentGroup: self.parentGroup,
            recursive: self.recursive
        )
    }
}

extension IoT.ListThingPrincipalsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingPrincipalsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )
    }
}

extension IoT.ListThingPrincipalsV2Request: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingPrincipalsV2Request {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName,
            thingPrincipalType: self.thingPrincipalType
        )
    }
}

extension IoT.ListThingRegistrationTaskReportsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingRegistrationTaskReportsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            reportType: self.reportType,
            taskId: self.taskId
        )
    }
}

extension IoT.ListThingRegistrationTasksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingRegistrationTasksRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension IoT.ListThingTypesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingTypesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName
        )
    }
}

extension IoT.ListThingsInBillingGroupRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingsInBillingGroupRequest {
        return .init(
            billingGroupName: self.billingGroupName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListThingsInThingGroupRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingsInThingGroupRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            thingGroupName: self.thingGroupName
        )
    }
}

extension IoT.ListThingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListThingsRequest {
        return .init(
            attributeName: self.attributeName,
            attributeValue: self.attributeValue,
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName,
            usePrefixAttributeValue: self.usePrefixAttributeValue
        )
    }
}

extension IoT.ListTopicRuleDestinationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListTopicRuleDestinationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoT.ListTopicRulesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListTopicRulesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            ruleDisabled: self.ruleDisabled,
            topic: self.topic
        )
    }
}

extension IoT.ListV2LoggingLevelsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListV2LoggingLevelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            targetType: self.targetType
        )
    }
}

extension IoT.ListViolationEventsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoT.ListViolationEventsRequest {
        return .init(
            behaviorCriteriaType: self.behaviorCriteriaType,
            endTime: self.endTime,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            startTime: self.startTime,
            thingName: self.thingName,
            verificationState: self.verificationState
        )
    }
}
