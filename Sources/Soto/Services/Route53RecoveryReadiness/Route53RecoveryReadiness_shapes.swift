//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Route53RecoveryReadiness {
    // MARK: Enums

    public enum Readiness: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notAuthorized = "NOT_AUTHORIZED"
        case notReady = "NOT_READY"
        case ready = "READY"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CellOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the cell.
        public let cellArn: String?
        /// The name of the cell.
        public let cellName: String?
        /// A list of cell ARNs.
        public let cells: [String]?
        /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
        public let parentReadinessScopes: [String]?
        /// Tags on the resources.
        public let tags: [String: String]?

        public init(cellArn: String? = nil, cellName: String? = nil, cells: [String]? = nil, parentReadinessScopes: [String]? = nil, tags: [String: String]? = nil) {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cellArn = "cellArn"
            case cellName = "cellName"
            case cells = "cells"
            case parentReadinessScopes = "parentReadinessScopes"
            case tags = "tags"
        }
    }

    public struct CreateCellRequest: AWSEncodableShape {
        /// The name of the cell to create.
        public let cellName: String?
        /// A list of cell Amazon Resource Names (ARNs) contained within this cell, for use in nested cells. For example, Availability Zones within specific Amazon Web Services Regions.
        public let cells: [String]?
        public let tags: [String: String]?

        public init(cellName: String? = nil, cells: [String]? = nil, tags: [String: String]? = nil) {
            self.cellName = cellName
            self.cells = cells
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cellName = "cellName"
            case cells = "cells"
            case tags = "tags"
        }
    }

    public struct CreateCellResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the cell.
        public let cellArn: String?
        /// The name of the cell.
        public let cellName: String?
        /// A list of cell ARNs.
        public let cells: [String]?
        /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
        public let parentReadinessScopes: [String]?
        /// Tags on the resources.
        public let tags: [String: String]?

        public init(cellArn: String? = nil, cellName: String? = nil, cells: [String]? = nil, parentReadinessScopes: [String]? = nil, tags: [String: String]? = nil) {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cellArn = "cellArn"
            case cellName = "cellName"
            case cells = "cells"
            case parentReadinessScopes = "parentReadinessScopes"
            case tags = "tags"
        }
    }

    public struct CreateCrossAccountAuthorizationRequest: AWSEncodableShape {
        /// The cross-account authorization.
        public let crossAccountAuthorization: String?

        public init(crossAccountAuthorization: String? = nil) {
            self.crossAccountAuthorization = crossAccountAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccountAuthorization = "crossAccountAuthorization"
        }
    }

    public struct CreateCrossAccountAuthorizationResponse: AWSDecodableShape {
        /// The cross-account authorization.
        public let crossAccountAuthorization: String?

        public init(crossAccountAuthorization: String? = nil) {
            self.crossAccountAuthorization = crossAccountAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccountAuthorization = "crossAccountAuthorization"
        }
    }

    public struct CreateReadinessCheckRequest: AWSEncodableShape {
        /// The name of the readiness check to create.
        public let readinessCheckName: String?
        /// The name of the resource set to check.
        public let resourceSetName: String?
        public let tags: [String: String]?

        public init(readinessCheckName: String? = nil, resourceSetName: String? = nil, tags: [String: String]? = nil) {
            self.readinessCheckName = readinessCheckName
            self.resourceSetName = resourceSetName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case readinessCheckName = "readinessCheckName"
            case resourceSetName = "resourceSetName"
            case tags = "tags"
        }
    }

    public struct CreateReadinessCheckResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with a readiness check.
        public let readinessCheckArn: String?
        /// Name of a readiness check.
        public let readinessCheckName: String?
        /// Name of the resource set to be checked.
        public let resourceSet: String?
        public let tags: [String: String]?

        public init(readinessCheckArn: String? = nil, readinessCheckName: String? = nil, resourceSet: String? = nil, tags: [String: String]? = nil) {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case readinessCheckArn = "readinessCheckArn"
            case readinessCheckName = "readinessCheckName"
            case resourceSet = "resourceSet"
            case tags = "tags"
        }
    }

    public struct CreateRecoveryGroupRequest: AWSEncodableShape {
        /// A list of the cell Amazon Resource Names (ARNs) in the recovery group.
        public let cells: [String]?
        /// The name of the recovery group to create.
        public let recoveryGroupName: String?
        public let tags: [String: String]?

        public init(cells: [String]? = nil, recoveryGroupName: String? = nil, tags: [String: String]? = nil) {
            self.cells = cells
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
            case recoveryGroupName = "recoveryGroupName"
            case tags = "tags"
        }
    }

    public struct CreateRecoveryGroupResponse: AWSDecodableShape {
        /// A list of a cell's Amazon Resource Names (ARNs).
        public let cells: [String]?
        /// The Amazon Resource Name (ARN) for the recovery group.
        public let recoveryGroupArn: String?
        /// The name of the recovery group.
        public let recoveryGroupName: String?
        /// The tags associated with the recovery group.
        public let tags: [String: String]?

        public init(cells: [String]? = nil, recoveryGroupArn: String? = nil, recoveryGroupName: String? = nil, tags: [String: String]? = nil) {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
            case recoveryGroupArn = "recoveryGroupArn"
            case recoveryGroupName = "recoveryGroupName"
            case tags = "tags"
        }
    }

    public struct CreateResourceSetRequest: AWSEncodableShape {
        /// A list of resource objects in the resource set.
        public let resources: [Resource]?
        /// The name of the resource set to create.
        public let resourceSetName: String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        public let resourceSetType: String?
        /// A tag to associate with the parameters for a resource set.
        public let tags: [String: String]?

        public init(resources: [Resource]? = nil, resourceSetName: String? = nil, resourceSetType: String? = nil, tags: [String: String]? = nil) {
            self.resources = resources
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceSetType, name: "resourceSetType", parent: name, pattern: "^AWS::[A-Za-z0-9]+::[A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "resources"
            case resourceSetName = "resourceSetName"
            case resourceSetType = "resourceSetType"
            case tags = "tags"
        }
    }

    public struct CreateResourceSetResponse: AWSDecodableShape {
        /// A list of resource objects.
        public let resources: [Resource]?
        /// The Amazon Resource Name (ARN) for the resource set.
        public let resourceSetArn: String?
        /// The name of the resource set.
        public let resourceSetName: String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        public let resourceSetType: String?
        public let tags: [String: String]?

        public init(resources: [Resource]? = nil, resourceSetArn: String? = nil, resourceSetName: String? = nil, resourceSetType: String? = nil, tags: [String: String]? = nil) {
            self.resources = resources
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "resources"
            case resourceSetArn = "resourceSetArn"
            case resourceSetName = "resourceSetName"
            case resourceSetType = "resourceSetType"
            case tags = "tags"
        }
    }

    public struct DNSTargetResource: AWSEncodableShape & AWSDecodableShape {
        /// The domain name that acts as an ingress point to a portion of the customer application.
        public let domainName: String?
        /// The hosted zone Amazon Resource Name (ARN) that contains the DNS record with the provided name of the target resource.
        public let hostedZoneArn: String?
        /// The Route 53 record set ID that uniquely identifies a DNS record, given a name and a type.
        public let recordSetId: String?
        /// The type of DNS record of the target resource.
        public let recordType: String?
        /// The target resource of the DNS target resource.
        public let targetResource: TargetResource?

        public init(domainName: String? = nil, hostedZoneArn: String? = nil, recordSetId: String? = nil, recordType: String? = nil, targetResource: TargetResource? = nil) {
            self.domainName = domainName
            self.hostedZoneArn = hostedZoneArn
            self.recordSetId = recordSetId
            self.recordType = recordType
            self.targetResource = targetResource
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case hostedZoneArn = "hostedZoneArn"
            case recordSetId = "recordSetId"
            case recordType = "recordType"
            case targetResource = "targetResource"
        }
    }

    public struct DeleteCellRequest: AWSEncodableShape {
        /// The name of the cell.
        public let cellName: String

        public init(cellName: String) {
            self.cellName = cellName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cellName, key: "CellName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCrossAccountAuthorizationRequest: AWSEncodableShape {
        /// The cross-account authorization.
        public let crossAccountAuthorization: String

        public init(crossAccountAuthorization: String) {
            self.crossAccountAuthorization = crossAccountAuthorization
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.crossAccountAuthorization, key: "CrossAccountAuthorization")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCrossAccountAuthorizationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReadinessCheckRequest: AWSEncodableShape {
        /// Name of a readiness check.
        public let readinessCheckName: String

        public init(readinessCheckName: String) {
            self.readinessCheckName = readinessCheckName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.readinessCheckName, key: "ReadinessCheckName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRecoveryGroupRequest: AWSEncodableShape {
        /// The name of a recovery group.
        public let recoveryGroupName: String

        public init(recoveryGroupName: String) {
            self.recoveryGroupName = recoveryGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.recoveryGroupName, key: "RecoveryGroupName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourceSetRequest: AWSEncodableShape {
        /// Name of a resource set.
        public let resourceSetName: String

        public init(resourceSetName: String) {
            self.resourceSetName = resourceSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceSetName, key: "ResourceSetName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetArchitectureRecommendationsRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The name of a recovery group.
        public let recoveryGroupName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, recoveryGroupName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recoveryGroupName = recoveryGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.recoveryGroupName, key: "RecoveryGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetArchitectureRecommendationsResponse: AWSDecodableShape {
        /// The time that a recovery group was last assessed for recommendations, in UTC ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastAuditTimestamp: Date?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// A list of the recommendations for the customer's application.
        public let recommendations: [Recommendation]?

        public init(lastAuditTimestamp: Date? = nil, nextToken: String? = nil, recommendations: [Recommendation]? = nil) {
            self.lastAuditTimestamp = lastAuditTimestamp
            self.nextToken = nextToken
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case lastAuditTimestamp = "lastAuditTimestamp"
            case nextToken = "nextToken"
            case recommendations = "recommendations"
        }
    }

    public struct GetCellReadinessSummaryRequest: AWSEncodableShape {
        /// The name of the cell.
        public let cellName: String
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(cellName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cellName = cellName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cellName, key: "CellName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCellReadinessSummaryResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The readiness at a cell level.
        public let readiness: Readiness?
        /// Summaries for the readiness checks that make up the cell.
        public let readinessChecks: [ReadinessCheckSummary]?

        public init(nextToken: String? = nil, readiness: Readiness? = nil, readinessChecks: [ReadinessCheckSummary]? = nil) {
            self.nextToken = nextToken
            self.readiness = readiness
            self.readinessChecks = readinessChecks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case readiness = "readiness"
            case readinessChecks = "readinessChecks"
        }
    }

    public struct GetCellRequest: AWSEncodableShape {
        /// The name of the cell.
        public let cellName: String

        public init(cellName: String) {
            self.cellName = cellName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cellName, key: "CellName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCellResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the cell.
        public let cellArn: String?
        /// The name of the cell.
        public let cellName: String?
        /// A list of cell ARNs.
        public let cells: [String]?
        /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
        public let parentReadinessScopes: [String]?
        /// Tags on the resources.
        public let tags: [String: String]?

        public init(cellArn: String? = nil, cellName: String? = nil, cells: [String]? = nil, parentReadinessScopes: [String]? = nil, tags: [String: String]? = nil) {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cellArn = "cellArn"
            case cellName = "cellName"
            case cells = "cells"
            case parentReadinessScopes = "parentReadinessScopes"
            case tags = "tags"
        }
    }

    public struct GetReadinessCheckRequest: AWSEncodableShape {
        /// Name of a readiness check.
        public let readinessCheckName: String

        public init(readinessCheckName: String) {
            self.readinessCheckName = readinessCheckName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.readinessCheckName, key: "ReadinessCheckName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadinessCheckResourceStatusRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// Name of a readiness check.
        public let readinessCheckName: String
        /// The resource identifier, which is the Amazon Resource Name (ARN) or the identifier generated for the resource by Application Recovery Controller (for example, for a DNS target resource).
        public let resourceIdentifier: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, readinessCheckName: String, resourceIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.readinessCheckName = readinessCheckName
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.readinessCheckName, key: "ReadinessCheckName")
            request.encodePath(self.resourceIdentifier, key: "ResourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadinessCheckResourceStatusResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The readiness at a rule level.
        public let readiness: Readiness?
        /// Details of the rule's results.
        public let rules: [RuleResult]?

        public init(nextToken: String? = nil, readiness: Readiness? = nil, rules: [RuleResult]? = nil) {
            self.nextToken = nextToken
            self.readiness = readiness
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case readiness = "readiness"
            case rules = "rules"
        }
    }

    public struct GetReadinessCheckResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with a readiness check.
        public let readinessCheckArn: String?
        /// Name of a readiness check.
        public let readinessCheckName: String?
        /// Name of the resource set to be checked.
        public let resourceSet: String?
        public let tags: [String: String]?

        public init(readinessCheckArn: String? = nil, readinessCheckName: String? = nil, resourceSet: String? = nil, tags: [String: String]? = nil) {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case readinessCheckArn = "readinessCheckArn"
            case readinessCheckName = "readinessCheckName"
            case resourceSet = "resourceSet"
            case tags = "tags"
        }
    }

    public struct GetReadinessCheckStatusRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// Name of a readiness check.
        public let readinessCheckName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, readinessCheckName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.readinessCheckName = readinessCheckName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.readinessCheckName, key: "ReadinessCheckName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReadinessCheckStatusResponse: AWSDecodableShape {
        /// Top level messages for readiness check status
        public let messages: [Message]?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The readiness at rule level.
        public let readiness: Readiness?
        /// Summary of the readiness of resources.
        public let resources: [ResourceResult]?

        public init(messages: [Message]? = nil, nextToken: String? = nil, readiness: Readiness? = nil, resources: [ResourceResult]? = nil) {
            self.messages = messages
            self.nextToken = nextToken
            self.readiness = readiness
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case nextToken = "nextToken"
            case readiness = "readiness"
            case resources = "resources"
        }
    }

    public struct GetRecoveryGroupReadinessSummaryRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The name of a recovery group.
        public let recoveryGroupName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, recoveryGroupName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recoveryGroupName = recoveryGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.recoveryGroupName, key: "RecoveryGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecoveryGroupReadinessSummaryResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The readiness status at a recovery group level.
        public let readiness: Readiness?
        /// Summaries of the readiness checks for the recovery group.
        public let readinessChecks: [ReadinessCheckSummary]?

        public init(nextToken: String? = nil, readiness: Readiness? = nil, readinessChecks: [ReadinessCheckSummary]? = nil) {
            self.nextToken = nextToken
            self.readiness = readiness
            self.readinessChecks = readinessChecks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case readiness = "readiness"
            case readinessChecks = "readinessChecks"
        }
    }

    public struct GetRecoveryGroupRequest: AWSEncodableShape {
        /// The name of a recovery group.
        public let recoveryGroupName: String

        public init(recoveryGroupName: String) {
            self.recoveryGroupName = recoveryGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.recoveryGroupName, key: "RecoveryGroupName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecoveryGroupResponse: AWSDecodableShape {
        /// A list of a cell's Amazon Resource Names (ARNs).
        public let cells: [String]?
        /// The Amazon Resource Name (ARN) for the recovery group.
        public let recoveryGroupArn: String?
        /// The name of the recovery group.
        public let recoveryGroupName: String?
        /// The tags associated with the recovery group.
        public let tags: [String: String]?

        public init(cells: [String]? = nil, recoveryGroupArn: String? = nil, recoveryGroupName: String? = nil, tags: [String: String]? = nil) {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
            case recoveryGroupArn = "recoveryGroupArn"
            case recoveryGroupName = "recoveryGroupName"
            case tags = "tags"
        }
    }

    public struct GetResourceSetRequest: AWSEncodableShape {
        /// Name of a resource set.
        public let resourceSetName: String

        public init(resourceSetName: String) {
            self.resourceSetName = resourceSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceSetName, key: "ResourceSetName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceSetResponse: AWSDecodableShape {
        /// A list of resource objects.
        public let resources: [Resource]?
        /// The Amazon Resource Name (ARN) for the resource set.
        public let resourceSetArn: String?
        /// The name of the resource set.
        public let resourceSetName: String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        public let resourceSetType: String?
        public let tags: [String: String]?

        public init(resources: [Resource]? = nil, resourceSetArn: String? = nil, resourceSetName: String? = nil, resourceSetType: String? = nil, tags: [String: String]? = nil) {
            self.resources = resources
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "resources"
            case resourceSetArn = "resourceSetArn"
            case resourceSetName = "resourceSetName"
            case resourceSetType = "resourceSetType"
            case tags = "tags"
        }
    }

    public struct ListCellsRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCellsResponse: AWSDecodableShape {
        /// A list of cells.
        public let cells: [CellOutput]?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(cells: [CellOutput]? = nil, nextToken: String? = nil) {
            self.cells = cells
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
            case nextToken = "nextToken"
        }
    }

    public struct ListCrossAccountAuthorizationsRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCrossAccountAuthorizationsResponse: AWSDecodableShape {
        /// A list of cross-account authorizations.
        public let crossAccountAuthorizations: [String]?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(crossAccountAuthorizations: [String]? = nil, nextToken: String? = nil) {
            self.crossAccountAuthorizations = crossAccountAuthorizations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crossAccountAuthorizations = "crossAccountAuthorizations"
            case nextToken = "nextToken"
        }
    }

    public struct ListReadinessChecksRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReadinessChecksResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// A list of readiness checks associated with the account.
        public let readinessChecks: [ReadinessCheckOutput]?

        public init(nextToken: String? = nil, readinessChecks: [ReadinessCheckOutput]? = nil) {
            self.nextToken = nextToken
            self.readinessChecks = readinessChecks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case readinessChecks = "readinessChecks"
        }
    }

    public struct ListRecoveryGroupsRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRecoveryGroupsResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// A list of recovery groups.
        public let recoveryGroups: [RecoveryGroupOutput]?

        public init(nextToken: String? = nil, recoveryGroups: [RecoveryGroupOutput]? = nil) {
            self.nextToken = nextToken
            self.recoveryGroups = recoveryGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recoveryGroups = "recoveryGroups"
        }
    }

    public struct ListResourceSetsRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourceSetsResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// A list of resource sets associated with the account.
        public let resourceSets: [ResourceSetOutput]?

        public init(nextToken: String? = nil, resourceSets: [ResourceSetOutput]? = nil) {
            self.nextToken = nextToken
            self.resourceSets = resourceSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceSets = "resourceSets"
        }
    }

    public struct ListRulesOutput: AWSDecodableShape {
        /// The resource type that the readiness rule applies to.
        public let resourceType: String?
        /// The description of a readiness rule.
        public let ruleDescription: String?
        /// The ID for the readiness rule.
        public let ruleId: String?

        public init(resourceType: String? = nil, ruleDescription: String? = nil, ruleId: String? = nil) {
            self.resourceType = resourceType
            self.ruleDescription = ruleDescription
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "resourceType"
            case ruleDescription = "ruleDescription"
            case ruleId = "ruleId"
        }
    }

    public struct ListRulesRequest: AWSEncodableShape {
        /// The number of objects that you want to return with this call.
        public let maxResults: Int?
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// The resource type that a readiness rule applies to.
        public let resourceType: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceType: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesResponse: AWSDecodableShape {
        /// The token that identifies which batch of results you want to see.
        public let nextToken: String?
        /// A list of readiness rules for a specific resource type.
        public let rules: [ListRulesOutput]?

        public init(nextToken: String? = nil, rules: [ListRulesOutput]? = nil) {
            self.nextToken = nextToken
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case rules = "rules"
        }
    }

    public struct ListTagsForResourcesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourcesResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Message: AWSDecodableShape {
        /// The text of a readiness check message.
        public let messageText: String?

        public init(messageText: String? = nil) {
            self.messageText = messageText
        }

        private enum CodingKeys: String, CodingKey {
            case messageText = "messageText"
        }
    }

    public struct NLBResource: AWSEncodableShape & AWSDecodableShape {
        /// The Network Load Balancer resource Amazon Resource Name (ARN).
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct R53ResourceRecord: AWSEncodableShape & AWSDecodableShape {
        /// The DNS target domain name.
        public let domainName: String?
        /// The Route 53 Resource Record Set ID.
        public let recordSetId: String?

        public init(domainName: String? = nil, recordSetId: String? = nil) {
            self.domainName = domainName
            self.recordSetId = recordSetId
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case recordSetId = "recordSetId"
        }
    }

    public struct ReadinessCheckOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with a readiness check.
        public let readinessCheckArn: String?
        /// Name of a readiness check.
        public let readinessCheckName: String?
        /// Name of the resource set to be checked.
        public let resourceSet: String?
        public let tags: [String: String]?

        public init(readinessCheckArn: String? = nil, readinessCheckName: String? = nil, resourceSet: String? = nil, tags: [String: String]? = nil) {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case readinessCheckArn = "readinessCheckArn"
            case readinessCheckName = "readinessCheckName"
            case resourceSet = "resourceSet"
            case tags = "tags"
        }
    }

    public struct ReadinessCheckSummary: AWSDecodableShape {
        /// The readiness status of this readiness check.
        public let readiness: Readiness?
        /// The name of a readiness check.
        public let readinessCheckName: String?

        public init(readiness: Readiness? = nil, readinessCheckName: String? = nil) {
            self.readiness = readiness
            self.readinessCheckName = readinessCheckName
        }

        private enum CodingKeys: String, CodingKey {
            case readiness = "readiness"
            case readinessCheckName = "readinessCheckName"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// Text of the recommendations that are provided to make an application more recovery resilient.
        public let recommendationText: String?

        public init(recommendationText: String? = nil) {
            self.recommendationText = recommendationText
        }

        private enum CodingKeys: String, CodingKey {
            case recommendationText = "recommendationText"
        }
    }

    public struct RecoveryGroupOutput: AWSDecodableShape {
        /// A list of a cell's Amazon Resource Names (ARNs).
        public let cells: [String]?
        /// The Amazon Resource Name (ARN) for the recovery group.
        public let recoveryGroupArn: String?
        /// The name of the recovery group.
        public let recoveryGroupName: String?
        /// The tags associated with the recovery group.
        public let tags: [String: String]?

        public init(cells: [String]? = nil, recoveryGroupArn: String? = nil, recoveryGroupName: String? = nil, tags: [String: String]? = nil) {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
            case recoveryGroupArn = "recoveryGroupArn"
            case recoveryGroupName = "recoveryGroupName"
            case tags = "tags"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// The component identifier of the resource, generated when DNS target resource is used.
        public let componentId: String?
        /// The DNS target resource.
        public let dnsTargetResource: DNSTargetResource?
        /// A list of recovery group Amazon Resource Names (ARNs) and cell ARNs that this resource is contained within.
        public let readinessScopes: [String]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services resource.
        public let resourceArn: String?

        public init(componentId: String? = nil, dnsTargetResource: DNSTargetResource? = nil, readinessScopes: [String]? = nil, resourceArn: String? = nil) {
            self.componentId = componentId
            self.dnsTargetResource = dnsTargetResource
            self.readinessScopes = readinessScopes
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case componentId = "componentId"
            case dnsTargetResource = "dnsTargetResource"
            case readinessScopes = "readinessScopes"
            case resourceArn = "resourceArn"
        }
    }

    public struct ResourceResult: AWSDecodableShape {
        /// The component id of the resource.
        public let componentId: String?
        /// The time (UTC) that the resource was last checked for readiness, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastCheckedTimestamp: Date?
        /// The readiness of a resource.
        public let readiness: Readiness?
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String?

        public init(componentId: String? = nil, lastCheckedTimestamp: Date? = nil, readiness: Readiness? = nil, resourceArn: String? = nil) {
            self.componentId = componentId
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.readiness = readiness
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case componentId = "componentId"
            case lastCheckedTimestamp = "lastCheckedTimestamp"
            case readiness = "readiness"
            case resourceArn = "resourceArn"
        }
    }

    public struct ResourceSetOutput: AWSDecodableShape {
        /// A list of resource objects.
        public let resources: [Resource]?
        /// The Amazon Resource Name (ARN) for the resource set.
        public let resourceSetArn: String?
        /// The name of the resource set.
        public let resourceSetName: String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        public let resourceSetType: String?
        public let tags: [String: String]?

        public init(resources: [Resource]? = nil, resourceSetArn: String? = nil, resourceSetName: String? = nil, resourceSetType: String? = nil, tags: [String: String]? = nil) {
            self.resources = resources
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "resources"
            case resourceSetArn = "resourceSetArn"
            case resourceSetName = "resourceSetName"
            case resourceSetType = "resourceSetType"
            case tags = "tags"
        }
    }

    public struct RuleResult: AWSDecodableShape {
        /// The time the resource was last checked for readiness, in ISO-8601 format, UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastCheckedTimestamp: Date?
        /// Details about the resource's readiness.
        public let messages: [Message]?
        /// The readiness at rule level.
        public let readiness: Readiness?
        /// The identifier of the rule.
        public let ruleId: String?

        public init(lastCheckedTimestamp: Date? = nil, messages: [Message]? = nil, readiness: Readiness? = nil, ruleId: String? = nil) {
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.messages = messages
            self.readiness = readiness
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case lastCheckedTimestamp = "lastCheckedTimestamp"
            case messages = "messages"
            case readiness = "readiness"
            case ruleId = "ruleId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a resource.
        public let resourceArn: String
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetResource: AWSEncodableShape & AWSDecodableShape {
        /// The Network Load Balancer Resource.
        public let nlbResource: NLBResource?
        /// The Route 53 resource.
        public let r53Resource: R53ResourceRecord?

        public init(nlbResource: NLBResource? = nil, r53Resource: R53ResourceRecord? = nil) {
            self.nlbResource = nlbResource
            self.r53Resource = r53Resource
        }

        private enum CodingKeys: String, CodingKey {
            case nlbResource = "nLBResource"
            case r53Resource = "r53Resource"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a resource.
        public let resourceArn: String
        /// The keys for tags you add to resources.
        public let tagKeys: [String]?

        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCellRequest: AWSEncodableShape {
        /// The name of the cell.
        public let cellName: String
        /// A list of cell Amazon Resource Names (ARNs), which completely replaces the previous list.
        public let cells: [String]?

        public init(cellName: String, cells: [String]? = nil) {
            self.cellName = cellName
            self.cells = cells
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cellName, key: "CellName")
            try container.encodeIfPresent(self.cells, forKey: .cells)
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
        }
    }

    public struct UpdateCellResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the cell.
        public let cellArn: String?
        /// The name of the cell.
        public let cellName: String?
        /// A list of cell ARNs.
        public let cells: [String]?
        /// The readiness scope for the cell, which can be a cell Amazon Resource Name (ARN) or a recovery group ARN. This is a list but currently can have only one element.
        public let parentReadinessScopes: [String]?
        /// Tags on the resources.
        public let tags: [String: String]?

        public init(cellArn: String? = nil, cellName: String? = nil, cells: [String]? = nil, parentReadinessScopes: [String]? = nil, tags: [String: String]? = nil) {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cellArn = "cellArn"
            case cellName = "cellName"
            case cells = "cells"
            case parentReadinessScopes = "parentReadinessScopes"
            case tags = "tags"
        }
    }

    public struct UpdateReadinessCheckRequest: AWSEncodableShape {
        /// Name of a readiness check.
        public let readinessCheckName: String
        /// The name of the resource set to be checked.
        public let resourceSetName: String?

        public init(readinessCheckName: String, resourceSetName: String? = nil) {
            self.readinessCheckName = readinessCheckName
            self.resourceSetName = resourceSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.readinessCheckName, key: "ReadinessCheckName")
            try container.encodeIfPresent(self.resourceSetName, forKey: .resourceSetName)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceSetName = "resourceSetName"
        }
    }

    public struct UpdateReadinessCheckResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with a readiness check.
        public let readinessCheckArn: String?
        /// Name of a readiness check.
        public let readinessCheckName: String?
        /// Name of the resource set to be checked.
        public let resourceSet: String?
        public let tags: [String: String]?

        public init(readinessCheckArn: String? = nil, readinessCheckName: String? = nil, resourceSet: String? = nil, tags: [String: String]? = nil) {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case readinessCheckArn = "readinessCheckArn"
            case readinessCheckName = "readinessCheckName"
            case resourceSet = "resourceSet"
            case tags = "tags"
        }
    }

    public struct UpdateRecoveryGroupRequest: AWSEncodableShape {
        /// A list of cell Amazon Resource Names (ARNs). This list completely replaces the previous list.
        public let cells: [String]?
        /// The name of a recovery group.
        public let recoveryGroupName: String

        public init(cells: [String]? = nil, recoveryGroupName: String) {
            self.cells = cells
            self.recoveryGroupName = recoveryGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.cells, forKey: .cells)
            request.encodePath(self.recoveryGroupName, key: "RecoveryGroupName")
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
        }
    }

    public struct UpdateRecoveryGroupResponse: AWSDecodableShape {
        /// A list of a cell's Amazon Resource Names (ARNs).
        public let cells: [String]?
        /// The Amazon Resource Name (ARN) for the recovery group.
        public let recoveryGroupArn: String?
        /// The name of the recovery group.
        public let recoveryGroupName: String?
        /// The tags associated with the recovery group.
        public let tags: [String: String]?

        public init(cells: [String]? = nil, recoveryGroupArn: String? = nil, recoveryGroupName: String? = nil, tags: [String: String]? = nil) {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "cells"
            case recoveryGroupArn = "recoveryGroupArn"
            case recoveryGroupName = "recoveryGroupName"
            case tags = "tags"
        }
    }

    public struct UpdateResourceSetRequest: AWSEncodableShape {
        /// A list of resource objects.
        public let resources: [Resource]?
        /// Name of a resource set.
        public let resourceSetName: String
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        public let resourceSetType: String?

        public init(resources: [Resource]? = nil, resourceSetName: String, resourceSetType: String? = nil) {
            self.resources = resources
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.resources, forKey: .resources)
            request.encodePath(self.resourceSetName, key: "ResourceSetName")
            try container.encodeIfPresent(self.resourceSetType, forKey: .resourceSetType)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceSetType, name: "resourceSetType", parent: name, pattern: "^AWS::[A-Za-z0-9]+::[A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "resources"
            case resourceSetType = "resourceSetType"
        }
    }

    public struct UpdateResourceSetResponse: AWSDecodableShape {
        /// A list of resource objects.
        public let resources: [Resource]?
        /// The Amazon Resource Name (ARN) for the resource set.
        public let resourceSetArn: String?
        /// The name of the resource set.
        public let resourceSetName: String?
        /// The resource type of the resources in the resource set. Enter one of the following values for resource type: AWS::ApiGateway::Stage, AWS::ApiGatewayV2::Stage, AWS::AutoScaling::AutoScalingGroup, AWS::CloudWatch::Alarm, AWS::EC2::CustomerGateway, AWS::DynamoDB::Table, AWS::EC2::Volume, AWS::ElasticLoadBalancing::LoadBalancer, AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::Lambda::Function, AWS::MSK::Cluster, AWS::RDS::DBCluster, AWS::Route53::HealthCheck, AWS::SQS::Queue, AWS::SNS::Topic, AWS::SNS::Subscription, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway, AWS::Route53RecoveryReadiness::DNSTargetResource
        public let resourceSetType: String?
        public let tags: [String: String]?

        public init(resources: [Resource]? = nil, resourceSetArn: String? = nil, resourceSetName: String? = nil, resourceSetType: String? = nil, tags: [String: String]? = nil) {
            self.resources = resources
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "resources"
            case resourceSetArn = "resourceSetArn"
            case resourceSetName = "resourceSetName"
            case resourceSetType = "resourceSetType"
            case tags = "tags"
        }
    }
}

// MARK: - Errors

/// Error enum for Route53RecoveryReadiness
public struct Route53RecoveryReadinessErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Route53RecoveryReadiness
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension Route53RecoveryReadinessErrorType: Equatable {
    public static func == (lhs: Route53RecoveryReadinessErrorType, rhs: Route53RecoveryReadinessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension Route53RecoveryReadinessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
