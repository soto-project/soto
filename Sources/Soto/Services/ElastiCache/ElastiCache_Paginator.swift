//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension ElastiCache {
    ///  Returns information about all provisioned clusters if no cluster identifier is specified, or about a specific cache cluster if a cluster identifier is supplied. By default, abbreviated information about the clusters is returned. You can use the optional ShowCacheNodeInfo flag to retrieve detailed information about the cache nodes associated with the clusters. These details include the DNS address and port for the cache node endpoint. If the cluster is in the creating state, only cluster-level information is displayed until all of the nodes are successfully provisioned. If the cluster is in the deleting state, only cluster-level information is displayed. If cache nodes are currently being added to the cluster, node endpoint information and creation time for the additional nodes are not displayed until they are completely provisioned. When the cluster state is available, the cluster is ready for use. If cache nodes are currently being removed from the cluster, no endpoint information for the removed nodes is displayed.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCacheClustersPaginator<Result>(
        _ input: DescribeCacheClustersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CacheClusterMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCacheClusters,
            inputKey: \DescribeCacheClustersMessage.marker,
            outputKey: \CacheClusterMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCacheClustersPaginator(
        _ input: DescribeCacheClustersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CacheClusterMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCacheClusters,
            inputKey: \DescribeCacheClustersMessage.marker,
            outputKey: \CacheClusterMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of the available cache engines and their versions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCacheEngineVersionsPaginator<Result>(
        _ input: DescribeCacheEngineVersionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CacheEngineVersionMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCacheEngineVersions,
            inputKey: \DescribeCacheEngineVersionsMessage.marker,
            outputKey: \CacheEngineVersionMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCacheEngineVersionsPaginator(
        _ input: DescribeCacheEngineVersionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CacheEngineVersionMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCacheEngineVersions,
            inputKey: \DescribeCacheEngineVersionsMessage.marker,
            outputKey: \CacheEngineVersionMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of cache parameter group descriptions. If a cache parameter group name is specified, the list contains only the descriptions for that group.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCacheParameterGroupsPaginator<Result>(
        _ input: DescribeCacheParameterGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CacheParameterGroupsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCacheParameterGroups,
            inputKey: \DescribeCacheParameterGroupsMessage.marker,
            outputKey: \CacheParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCacheParameterGroupsPaginator(
        _ input: DescribeCacheParameterGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CacheParameterGroupsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCacheParameterGroups,
            inputKey: \DescribeCacheParameterGroupsMessage.marker,
            outputKey: \CacheParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns the detailed parameter list for a particular cache parameter group.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCacheParametersPaginator<Result>(
        _ input: DescribeCacheParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CacheParameterGroupDetails, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCacheParameters,
            inputKey: \DescribeCacheParametersMessage.marker,
            outputKey: \CacheParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCacheParametersPaginator(
        _ input: DescribeCacheParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CacheParameterGroupDetails, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCacheParameters,
            inputKey: \DescribeCacheParametersMessage.marker,
            outputKey: \CacheParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of cache security group descriptions. If a cache security group name is specified, the list contains only the description of that group. This applicable only when you have ElastiCache in Classic setup
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCacheSecurityGroupsPaginator<Result>(
        _ input: DescribeCacheSecurityGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CacheSecurityGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCacheSecurityGroups,
            inputKey: \DescribeCacheSecurityGroupsMessage.marker,
            outputKey: \CacheSecurityGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCacheSecurityGroupsPaginator(
        _ input: DescribeCacheSecurityGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CacheSecurityGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCacheSecurityGroups,
            inputKey: \DescribeCacheSecurityGroupsMessage.marker,
            outputKey: \CacheSecurityGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of cache subnet group descriptions. If a subnet group name is specified, the list contains only the description of that group. This is applicable only when you have ElastiCache in VPC setup. All ElastiCache clusters now launch in VPC by default.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeCacheSubnetGroupsPaginator<Result>(
        _ input: DescribeCacheSubnetGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, CacheSubnetGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeCacheSubnetGroups,
            inputKey: \DescribeCacheSubnetGroupsMessage.marker,
            outputKey: \CacheSubnetGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeCacheSubnetGroupsPaginator(
        _ input: DescribeCacheSubnetGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (CacheSubnetGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeCacheSubnetGroups,
            inputKey: \DescribeCacheSubnetGroupsMessage.marker,
            outputKey: \CacheSubnetGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns the default engine and system parameter information for the specified cache engine.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEngineDefaultParametersPaginator<Result>(
        _ input: DescribeEngineDefaultParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeEngineDefaultParametersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEngineDefaultParameters,
            inputKey: \DescribeEngineDefaultParametersMessage.marker,
            outputKey: \DescribeEngineDefaultParametersResult.engineDefaults?.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEngineDefaultParametersPaginator(
        _ input: DescribeEngineDefaultParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeEngineDefaultParametersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEngineDefaultParameters,
            inputKey: \DescribeEngineDefaultParametersMessage.marker,
            outputKey: \DescribeEngineDefaultParametersResult.engineDefaults?.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns events related to clusters, cache security groups, and cache parameter groups. You can obtain events specific to a particular cluster, cache security group, or cache parameter group by providing the name as a parameter. By default, only the events occurring within the last hour are returned; however, you can retrieve up to 14 days' worth of events if necessary.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEventsPaginator<Result>(
        _ input: DescribeEventsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EventsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \EventsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEventsPaginator(
        _ input: DescribeEventsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EventsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \EventsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about a particular global replication group. If no identifier is specified, returns information about all Global datastores.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeGlobalReplicationGroupsPaginator<Result>(
        _ input: DescribeGlobalReplicationGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeGlobalReplicationGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeGlobalReplicationGroups,
            inputKey: \DescribeGlobalReplicationGroupsMessage.marker,
            outputKey: \DescribeGlobalReplicationGroupsResult.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeGlobalReplicationGroupsPaginator(
        _ input: DescribeGlobalReplicationGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeGlobalReplicationGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeGlobalReplicationGroups,
            inputKey: \DescribeGlobalReplicationGroupsMessage.marker,
            outputKey: \DescribeGlobalReplicationGroupsResult.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about a particular replication group. If no identifier is specified, DescribeReplicationGroups returns information about all replication groups.  This operation is valid for Redis only.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReplicationGroupsPaginator<Result>(
        _ input: DescribeReplicationGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReplicationGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReplicationGroups,
            inputKey: \DescribeReplicationGroupsMessage.marker,
            outputKey: \ReplicationGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReplicationGroupsPaginator(
        _ input: DescribeReplicationGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReplicationGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReplicationGroups,
            inputKey: \DescribeReplicationGroupsMessage.marker,
            outputKey: \ReplicationGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about reserved cache nodes for this account, or about a specified reserved cache node.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedCacheNodesPaginator<Result>(
        _ input: DescribeReservedCacheNodesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReservedCacheNodeMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedCacheNodes,
            inputKey: \DescribeReservedCacheNodesMessage.marker,
            outputKey: \ReservedCacheNodeMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedCacheNodesPaginator(
        _ input: DescribeReservedCacheNodesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReservedCacheNodeMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedCacheNodes,
            inputKey: \DescribeReservedCacheNodesMessage.marker,
            outputKey: \ReservedCacheNodeMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists available reserved cache node offerings.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedCacheNodesOfferingsPaginator<Result>(
        _ input: DescribeReservedCacheNodesOfferingsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReservedCacheNodesOfferingMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedCacheNodesOfferings,
            inputKey: \DescribeReservedCacheNodesOfferingsMessage.marker,
            outputKey: \ReservedCacheNodesOfferingMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedCacheNodesOfferingsPaginator(
        _ input: DescribeReservedCacheNodesOfferingsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReservedCacheNodesOfferingMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedCacheNodesOfferings,
            inputKey: \DescribeReservedCacheNodesOfferingsMessage.marker,
            outputKey: \ReservedCacheNodesOfferingMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns details of the service updates
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeServiceUpdatesPaginator<Result>(
        _ input: DescribeServiceUpdatesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ServiceUpdatesMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeServiceUpdates,
            inputKey: \DescribeServiceUpdatesMessage.marker,
            outputKey: \ServiceUpdatesMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeServiceUpdatesPaginator(
        _ input: DescribeServiceUpdatesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ServiceUpdatesMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeServiceUpdates,
            inputKey: \DescribeServiceUpdatesMessage.marker,
            outputKey: \ServiceUpdatesMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about cluster or replication group snapshots. By default, DescribeSnapshots lists all of your snapshots; it can optionally describe a single snapshot, or just the snapshots associated with a particular cache cluster.  This operation is valid for Redis only.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSnapshotsPaginator<Result>(
        _ input: DescribeSnapshotsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSnapshotsListMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSnapshots,
            inputKey: \DescribeSnapshotsMessage.marker,
            outputKey: \DescribeSnapshotsListMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSnapshotsPaginator(
        _ input: DescribeSnapshotsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSnapshotsListMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSnapshots,
            inputKey: \DescribeSnapshotsMessage.marker,
            outputKey: \DescribeSnapshotsListMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns details of the update actions
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeUpdateActionsPaginator<Result>(
        _ input: DescribeUpdateActionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, UpdateActionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeUpdateActions,
            inputKey: \DescribeUpdateActionsMessage.marker,
            outputKey: \UpdateActionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeUpdateActionsPaginator(
        _ input: DescribeUpdateActionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (UpdateActionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeUpdateActions,
            inputKey: \DescribeUpdateActionsMessage.marker,
            outputKey: \UpdateActionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of user groups.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeUserGroupsPaginator<Result>(
        _ input: DescribeUserGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeUserGroupsResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeUserGroups,
            inputKey: \DescribeUserGroupsMessage.marker,
            outputKey: \DescribeUserGroupsResult.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeUserGroupsPaginator(
        _ input: DescribeUserGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeUserGroupsResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeUserGroups,
            inputKey: \DescribeUserGroupsMessage.marker,
            outputKey: \DescribeUserGroupsResult.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of users.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeUsersPaginator<Result>(
        _ input: DescribeUsersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeUsersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeUsers,
            inputKey: \DescribeUsersMessage.marker,
            outputKey: \DescribeUsersResult.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeUsersPaginator(
        _ input: DescribeUsersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeUsersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeUsers,
            inputKey: \DescribeUsersMessage.marker,
            outputKey: \DescribeUsersResult.marker,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension ElastiCache.DescribeCacheClustersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeCacheClustersMessage {
        return .init(
            cacheClusterId: self.cacheClusterId,
            marker: token,
            maxRecords: self.maxRecords,
            showCacheClustersNotInReplicationGroups: self.showCacheClustersNotInReplicationGroups,
            showCacheNodeInfo: self.showCacheNodeInfo
        )
    }
}

extension ElastiCache.DescribeCacheEngineVersionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeCacheEngineVersionsMessage {
        return .init(
            cacheParameterGroupFamily: self.cacheParameterGroupFamily,
            defaultOnly: self.defaultOnly,
            engine: self.engine,
            engineVersion: self.engineVersion,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension ElastiCache.DescribeCacheParameterGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeCacheParameterGroupsMessage {
        return .init(
            cacheParameterGroupName: self.cacheParameterGroupName,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension ElastiCache.DescribeCacheParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeCacheParametersMessage {
        return .init(
            cacheParameterGroupName: self.cacheParameterGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )
    }
}

extension ElastiCache.DescribeCacheSecurityGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeCacheSecurityGroupsMessage {
        return .init(
            cacheSecurityGroupName: self.cacheSecurityGroupName,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension ElastiCache.DescribeCacheSubnetGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeCacheSubnetGroupsMessage {
        return .init(
            cacheSubnetGroupName: self.cacheSubnetGroupName,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension ElastiCache.DescribeEngineDefaultParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeEngineDefaultParametersMessage {
        return .init(
            cacheParameterGroupFamily: self.cacheParameterGroupFamily,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension ElastiCache.DescribeEventsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeEventsMessage {
        return .init(
            duration: self.duration,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )
    }
}

extension ElastiCache.DescribeGlobalReplicationGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeGlobalReplicationGroupsMessage {
        return .init(
            globalReplicationGroupId: self.globalReplicationGroupId,
            marker: token,
            maxRecords: self.maxRecords,
            showMemberInfo: self.showMemberInfo
        )
    }
}

extension ElastiCache.DescribeReplicationGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeReplicationGroupsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            replicationGroupId: self.replicationGroupId
        )
    }
}

extension ElastiCache.DescribeReservedCacheNodesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeReservedCacheNodesMessage {
        return .init(
            cacheNodeType: self.cacheNodeType,
            duration: self.duration,
            marker: token,
            maxRecords: self.maxRecords,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedCacheNodeId: self.reservedCacheNodeId,
            reservedCacheNodesOfferingId: self.reservedCacheNodesOfferingId
        )
    }
}

extension ElastiCache.DescribeReservedCacheNodesOfferingsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeReservedCacheNodesOfferingsMessage {
        return .init(
            cacheNodeType: self.cacheNodeType,
            duration: self.duration,
            marker: token,
            maxRecords: self.maxRecords,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedCacheNodesOfferingId: self.reservedCacheNodesOfferingId
        )
    }
}

extension ElastiCache.DescribeServiceUpdatesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeServiceUpdatesMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            serviceUpdateName: self.serviceUpdateName,
            serviceUpdateStatus: self.serviceUpdateStatus
        )
    }
}

extension ElastiCache.DescribeSnapshotsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeSnapshotsMessage {
        return .init(
            cacheClusterId: self.cacheClusterId,
            marker: token,
            maxRecords: self.maxRecords,
            replicationGroupId: self.replicationGroupId,
            showNodeGroupConfig: self.showNodeGroupConfig,
            snapshotName: self.snapshotName,
            snapshotSource: self.snapshotSource
        )
    }
}

extension ElastiCache.DescribeUpdateActionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeUpdateActionsMessage {
        return .init(
            cacheClusterIds: self.cacheClusterIds,
            engine: self.engine,
            marker: token,
            maxRecords: self.maxRecords,
            replicationGroupIds: self.replicationGroupIds,
            serviceUpdateName: self.serviceUpdateName,
            serviceUpdateStatus: self.serviceUpdateStatus,
            serviceUpdateTimeRange: self.serviceUpdateTimeRange,
            showNodeLevelUpdateStatus: self.showNodeLevelUpdateStatus,
            updateActionStatus: self.updateActionStatus
        )
    }
}

extension ElastiCache.DescribeUserGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeUserGroupsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            userGroupId: self.userGroupId
        )
    }
}

extension ElastiCache.DescribeUsersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ElastiCache.DescribeUsersMessage {
        return .init(
            engine: self.engine,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            userId: self.userId
        )
    }
}
