//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension OSIS {
    // MARK: Enums

    public enum ChangeProgressStageStatuses: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ChangeProgressStatuses: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum PipelineStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case startFailed = "START_FAILED"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum VpcEndpointServiceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case opensearchServerless = "OPENSEARCH_SERVERLESS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BufferOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether persistent buffering should be enabled.
        public let persistentBufferEnabled: Bool

        public init(persistentBufferEnabled: Bool) {
            self.persistentBufferEnabled = persistentBufferEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case persistentBufferEnabled = "PersistentBufferEnabled"
        }
    }

    public struct ChangeProgressStage: AWSDecodableShape {
        /// A description of the stage.
        public let description: String?
        /// The most recent updated timestamp of the stage.
        public let lastUpdatedAt: Date?
        /// The name of the stage.
        public let name: String?
        /// The current status of the stage that the change is in.
        public let status: ChangeProgressStageStatuses?

        public init(description: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: ChangeProgressStageStatuses? = nil) {
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastUpdatedAt = "LastUpdatedAt"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct ChangeProgressStatus: AWSDecodableShape {
        /// Information about the stages that the pipeline is going through to perform the configuration change.
        public let changeProgressStages: [ChangeProgressStage]?
        /// The time at which the configuration change is made on the pipeline.
        public let startTime: Date?
        /// The overall status of the pipeline configuration change.
        public let status: ChangeProgressStatuses?
        /// The total number of stages required for the pipeline configuration change.
        public let totalNumberOfStages: Int?

        public init(changeProgressStages: [ChangeProgressStage]? = nil, startTime: Date? = nil, status: ChangeProgressStatuses? = nil, totalNumberOfStages: Int? = nil) {
            self.changeProgressStages = changeProgressStages
            self.startTime = startTime
            self.status = status
            self.totalNumberOfStages = totalNumberOfStages
        }

        private enum CodingKeys: String, CodingKey {
            case changeProgressStages = "ChangeProgressStages"
            case startTime = "StartTime"
            case status = "Status"
            case totalNumberOfStages = "TotalNumberOfStages"
        }
    }

    public struct CloudWatchLogDestination: AWSEncodableShape & AWSDecodableShape {
        /// The name of the CloudWatch Logs group to send pipeline logs to. You can specify an existing log group or create a new one. For example, /aws/OpenSearchService/IngestionService/my-pipeline.
        public let logGroup: String

        public init(logGroup: String) {
            self.logGroup = logGroup
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroup, name: "logGroup", parent: name, max: 512)
            try self.validate(self.logGroup, name: "logGroup", parent: name, min: 1)
            try self.validate(self.logGroup, name: "logGroup", parent: name, pattern: "^\\/aws\\/vendedlogs\\/[\\.\\-_/#A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case logGroup = "LogGroup"
        }
    }

    public struct CreatePipelineRequest: AWSEncodableShape {
        /// Key-value pairs to configure persistent buffering for the pipeline.
        public let bufferOptions: BufferOptions?
        /// Key-value pairs to configure encryption for data that is written to a persistent buffer.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// Key-value pairs to configure log publishing.
        public let logPublishingOptions: LogPublishingOptions?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let maxUnits: Int
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let minUnits: Int
        /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
        public let pipelineConfigurationBody: String
        /// The name of the OpenSearch Ingestion pipeline to create. Pipeline names are unique across the pipelines owned by an account within an Amazon Web Services Region.
        public let pipelineName: String
        /// List of tags to add to the pipeline upon creation.
        public let tags: [Tag]?
        /// Container for the values required to configure VPC access for the pipeline. If you don't specify these values, OpenSearch Ingestion creates the pipeline with a public endpoint.
        public let vpcOptions: VpcOptions?

        public init(bufferOptions: BufferOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, logPublishingOptions: LogPublishingOptions? = nil, maxUnits: Int, minUnits: Int, pipelineConfigurationBody: String, pipelineName: String, tags: [Tag]? = nil, vpcOptions: VpcOptions? = nil) {
            self.bufferOptions = bufferOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.logPublishingOptions = logPublishingOptions
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineConfigurationBody = pipelineConfigurationBody
            self.pipelineName = pipelineName
            self.tags = tags
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.logPublishingOptions?.validate(name: "\(name).logPublishingOptions")
            try self.validate(self.maxUnits, name: "maxUnits", parent: name, min: 1)
            try self.validate(self.minUnits, name: "minUnits", parent: name, min: 1)
            try self.validate(self.pipelineConfigurationBody, name: "pipelineConfigurationBody", parent: name, max: 24000)
            try self.validate(self.pipelineConfigurationBody, name: "pipelineConfigurationBody", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.vpcOptions?.validate(name: "\(name).vpcOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case bufferOptions = "BufferOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case logPublishingOptions = "LogPublishingOptions"
            case maxUnits = "MaxUnits"
            case minUnits = "MinUnits"
            case pipelineConfigurationBody = "PipelineConfigurationBody"
            case pipelineName = "PipelineName"
            case tags = "Tags"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct CreatePipelineResponse: AWSDecodableShape {
        /// Container for information about the created pipeline.
        public let pipeline: Pipeline?

        public init(pipeline: Pipeline? = nil) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "Pipeline"
        }
    }

    public struct DeletePipelineRequest: AWSEncodableShape {
        /// The name of the pipeline to delete.
        public let pipelineName: String

        public init(pipelineName: String) {
            self.pipelineName = pipelineName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.pipelineName, key: "PipelineName")
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePipelineResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EncryptionAtRestOptions: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the KMS key used to encrypt data-at-rest in OpenSearch Ingestion. By default, data is encrypted using an AWS owned key.
        public let kmsKeyArn: String

        public init(kmsKeyArn: String) {
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 7)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct GetPipelineBlueprintRequest: AWSEncodableShape {
        /// The name of the blueprint to retrieve.
        public let blueprintName: String

        public init(blueprintName: String) {
            self.blueprintName = blueprintName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.blueprintName, key: "BlueprintName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPipelineBlueprintResponse: AWSDecodableShape {
        /// The requested blueprint in YAML format.
        public let blueprint: PipelineBlueprint?

        public init(blueprint: PipelineBlueprint? = nil) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "Blueprint"
        }
    }

    public struct GetPipelineChangeProgressRequest: AWSEncodableShape {
        /// The name of the pipeline.
        public let pipelineName: String

        public init(pipelineName: String) {
            self.pipelineName = pipelineName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.pipelineName, key: "PipelineName")
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPipelineChangeProgressResponse: AWSDecodableShape {
        /// The current status of the change happening on the pipeline.
        public let changeProgressStatuses: [ChangeProgressStatus]?

        public init(changeProgressStatuses: [ChangeProgressStatus]? = nil) {
            self.changeProgressStatuses = changeProgressStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case changeProgressStatuses = "ChangeProgressStatuses"
        }
    }

    public struct GetPipelineRequest: AWSEncodableShape {
        /// The name of the pipeline to get information about.
        public let pipelineName: String

        public init(pipelineName: String) {
            self.pipelineName = pipelineName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.pipelineName, key: "PipelineName")
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPipelineResponse: AWSDecodableShape {
        /// Detailed information about the requested pipeline.
        public let pipeline: Pipeline?

        public init(pipeline: Pipeline? = nil) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "Pipeline"
        }
    }

    public struct ListPipelineBlueprintsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct ListPipelineBlueprintsResponse: AWSDecodableShape {
        /// A list of available blueprints for Data Prepper.
        public let blueprints: [PipelineBlueprintSummary]?

        public init(blueprints: [PipelineBlueprintSummary]? = nil) {
            self.blueprints = blueprints
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "Blueprints"
        }
    }

    public struct ListPipelinesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListPipelines operation returns a nextToken, you can include the returned nextToken in subsequent ListPipelines operations, which returns results in the next page.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^([\\s\\S]*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPipelinesResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// A list of all existing Data Prepper pipelines.
        public let pipelines: [PipelineSummary]?

        public init(nextToken: String? = nil, pipelines: [PipelineSummary]? = nil) {
            self.nextToken = nextToken
            self.pipelines = pipelines
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pipelines = "Pipelines"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline to retrieve tags for.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 76)
            try self.validate(self.arn, name: "arn", parent: name, min: 46)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws\\-cn|aws\\-us\\-gov|aws\\-iso|aws\\-iso\\-b):osis:.+:pipeline\\/.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the given pipeline.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LogPublishingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The destination for OpenSearch Ingestion logs sent to Amazon CloudWatch Logs. This parameter is required if IsLoggingEnabled is set to true.
        public let cloudWatchLogDestination: CloudWatchLogDestination?
        /// Whether logs should be published.
        public let isLoggingEnabled: Bool?

        public init(cloudWatchLogDestination: CloudWatchLogDestination? = nil, isLoggingEnabled: Bool? = nil) {
            self.cloudWatchLogDestination = cloudWatchLogDestination
            self.isLoggingEnabled = isLoggingEnabled
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogDestination?.validate(name: "\(name).cloudWatchLogDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogDestination = "CloudWatchLogDestination"
            case isLoggingEnabled = "IsLoggingEnabled"
        }
    }

    public struct Pipeline: AWSDecodableShape {
        public let bufferOptions: BufferOptions?
        /// The date and time when the pipeline was created.
        public let createdAt: Date?
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// The ingestion endpoints for the pipeline, which you can send data to.
        public let ingestEndpointUrls: [String]?
        /// The date and time when the pipeline was last updated.
        public let lastUpdatedAt: Date?
        /// Key-value pairs that represent log publishing settings.
        public let logPublishingOptions: LogPublishingOptions?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let maxUnits: Int?
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let minUnits: Int?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public let pipelineArn: String?
        /// The Data Prepper pipeline configuration in YAML format.
        public let pipelineConfigurationBody: String?
        /// The name of the pipeline.
        public let pipelineName: String?
        /// A list of VPC endpoints that OpenSearch Ingestion has created to other AWS services.
        public let serviceVpcEndpoints: [ServiceVpcEndpoint]?
        /// The current status of the pipeline.
        public let status: PipelineStatus?
        /// The reason for the current status of the pipeline.
        public let statusReason: PipelineStatusReason?
        /// A list of tags associated with the given pipeline.
        public let tags: [Tag]?
        /// The VPC interface endpoints that have access to the pipeline.
        public let vpcEndpoints: [VpcEndpoint]?

        public init(bufferOptions: BufferOptions? = nil, createdAt: Date? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, ingestEndpointUrls: [String]? = nil, lastUpdatedAt: Date? = nil, logPublishingOptions: LogPublishingOptions? = nil, maxUnits: Int? = nil, minUnits: Int? = nil, pipelineArn: String? = nil, pipelineConfigurationBody: String? = nil, pipelineName: String? = nil, serviceVpcEndpoints: [ServiceVpcEndpoint]? = nil, status: PipelineStatus? = nil, statusReason: PipelineStatusReason? = nil, tags: [Tag]? = nil, vpcEndpoints: [VpcEndpoint]? = nil) {
            self.bufferOptions = bufferOptions
            self.createdAt = createdAt
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.ingestEndpointUrls = ingestEndpointUrls
            self.lastUpdatedAt = lastUpdatedAt
            self.logPublishingOptions = logPublishingOptions
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineArn = pipelineArn
            self.pipelineConfigurationBody = pipelineConfigurationBody
            self.pipelineName = pipelineName
            self.serviceVpcEndpoints = serviceVpcEndpoints
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.vpcEndpoints = vpcEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case bufferOptions = "BufferOptions"
            case createdAt = "CreatedAt"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case ingestEndpointUrls = "IngestEndpointUrls"
            case lastUpdatedAt = "LastUpdatedAt"
            case logPublishingOptions = "LogPublishingOptions"
            case maxUnits = "MaxUnits"
            case minUnits = "MinUnits"
            case pipelineArn = "PipelineArn"
            case pipelineConfigurationBody = "PipelineConfigurationBody"
            case pipelineName = "PipelineName"
            case serviceVpcEndpoints = "ServiceVpcEndpoints"
            case status = "Status"
            case statusReason = "StatusReason"
            case tags = "Tags"
            case vpcEndpoints = "VpcEndpoints"
        }
    }

    public struct PipelineBlueprint: AWSDecodableShape {
        /// The name of the blueprint.
        public let blueprintName: String?
        /// The YAML configuration of the blueprint.
        public let pipelineConfigurationBody: String?

        public init(blueprintName: String? = nil, pipelineConfigurationBody: String? = nil) {
            self.blueprintName = blueprintName
            self.pipelineConfigurationBody = pipelineConfigurationBody
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
            case pipelineConfigurationBody = "PipelineConfigurationBody"
        }
    }

    public struct PipelineBlueprintSummary: AWSDecodableShape {
        /// The name of the blueprint.
        public let blueprintName: String?

        public init(blueprintName: String? = nil) {
            self.blueprintName = blueprintName
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
        }
    }

    public struct PipelineStatusReason: AWSDecodableShape {
        /// A description of why a pipeline has a certain status.
        public let description: String?

        public init(description: String? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct PipelineSummary: AWSDecodableShape {
        /// The date and time when the pipeline was created.
        public let createdAt: Date?
        /// The date and time when the pipeline was last updated.
        public let lastUpdatedAt: Date?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let maxUnits: Int?
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let minUnits: Int?
        /// The Amazon Resource Name (ARN) of the pipeline.
        public let pipelineArn: String?
        /// The name of the pipeline.
        public let pipelineName: String?
        /// The current status of the pipeline.
        public let status: PipelineStatus?
        public let statusReason: PipelineStatusReason?
        /// A list of tags associated with the given pipeline.
        public let tags: [Tag]?

        public init(createdAt: Date? = nil, lastUpdatedAt: Date? = nil, maxUnits: Int? = nil, minUnits: Int? = nil, pipelineArn: String? = nil, pipelineName: String? = nil, status: PipelineStatus? = nil, statusReason: PipelineStatusReason? = nil, tags: [Tag]? = nil) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineArn = pipelineArn
            self.pipelineName = pipelineName
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case lastUpdatedAt = "LastUpdatedAt"
            case maxUnits = "MaxUnits"
            case minUnits = "MinUnits"
            case pipelineArn = "PipelineArn"
            case pipelineName = "PipelineName"
            case status = "Status"
            case statusReason = "StatusReason"
            case tags = "Tags"
        }
    }

    public struct ServiceVpcEndpoint: AWSDecodableShape {
        /// The name of the service for which a VPC endpoint was created.
        public let serviceName: VpcEndpointServiceName?
        /// The ID of the VPC endpoint that was created.
        public let vpcEndpointId: String?

        public init(serviceName: VpcEndpointServiceName? = nil, vpcEndpointId: String? = nil) {
            self.serviceName = serviceName
            self.vpcEndpointId = vpcEndpointId
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "ServiceName"
            case vpcEndpointId = "VpcEndpointId"
        }
    }

    public struct StartPipelineRequest: AWSEncodableShape {
        /// The name of the pipeline to start.
        public let pipelineName: String

        public init(pipelineName: String) {
            self.pipelineName = pipelineName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.pipelineName, key: "PipelineName")
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartPipelineResponse: AWSDecodableShape {
        public let pipeline: Pipeline?

        public init(pipeline: Pipeline? = nil) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "Pipeline"
        }
    }

    public struct StopPipelineRequest: AWSEncodableShape {
        /// The name of the pipeline to stop.
        public let pipelineName: String

        public init(pipelineName: String) {
            self.pipelineName = pipelineName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.pipelineName, key: "PipelineName")
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopPipelineResponse: AWSDecodableShape {
        public let pipeline: Pipeline?

        public init(pipeline: Pipeline? = nil) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "Pipeline"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key. Tag keys must be unique for the pipeline to which they are attached.
        public let key: String
        /// The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: ".*")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline to tag.
        public let arn: String
        /// The list of key-value tags to add to the pipeline.
        public let tags: [Tag]

        public init(arn: String, tags: [Tag]) {
            self.arn = arn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 76)
            try self.validate(self.arn, name: "arn", parent: name, min: 46)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws\\-cn|aws\\-us\\-gov|aws\\-iso|aws\\-iso\\-b):osis:.+:pipeline\\/.+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the pipeline to remove tags from.
        public let arn: String
        /// The tag keys to remove.
        public let tagKeys: [String]

        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 76)
            try self.validate(self.arn, name: "arn", parent: name, min: 46)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:(aws|aws\\-cn|aws\\-us\\-gov|aws\\-iso|aws\\-iso\\-b):osis:.+:pipeline\\/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePipelineRequest: AWSEncodableShape {
        /// Key-value pairs to configure persistent buffering for the pipeline.
        public let bufferOptions: BufferOptions?
        /// Key-value pairs to configure encryption for data that is written to a persistent buffer.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// Key-value pairs to configure log publishing.
        public let logPublishingOptions: LogPublishingOptions?
        /// The maximum pipeline capacity, in Ingestion Compute Units (ICUs)
        public let maxUnits: Int?
        /// The minimum pipeline capacity, in Ingestion Compute Units (ICUs).
        public let minUnits: Int?
        /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
        public let pipelineConfigurationBody: String?
        /// The name of the pipeline to update.
        public let pipelineName: String

        public init(bufferOptions: BufferOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, logPublishingOptions: LogPublishingOptions? = nil, maxUnits: Int? = nil, minUnits: Int? = nil, pipelineConfigurationBody: String? = nil, pipelineName: String) {
            self.bufferOptions = bufferOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.logPublishingOptions = logPublishingOptions
            self.maxUnits = maxUnits
            self.minUnits = minUnits
            self.pipelineConfigurationBody = pipelineConfigurationBody
            self.pipelineName = pipelineName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.bufferOptions, forKey: .bufferOptions)
            try container.encodeIfPresent(self.encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
            try container.encodeIfPresent(self.logPublishingOptions, forKey: .logPublishingOptions)
            try container.encodeIfPresent(self.maxUnits, forKey: .maxUnits)
            try container.encodeIfPresent(self.minUnits, forKey: .minUnits)
            try container.encodeIfPresent(self.pipelineConfigurationBody, forKey: .pipelineConfigurationBody)
            request.encodePath(self.pipelineName, key: "PipelineName")
        }

        public func validate(name: String) throws {
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.logPublishingOptions?.validate(name: "\(name).logPublishingOptions")
            try self.validate(self.maxUnits, name: "maxUnits", parent: name, min: 1)
            try self.validate(self.minUnits, name: "minUnits", parent: name, min: 1)
            try self.validate(self.pipelineConfigurationBody, name: "pipelineConfigurationBody", parent: name, max: 24000)
            try self.validate(self.pipelineConfigurationBody, name: "pipelineConfigurationBody", parent: name, min: 1)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, max: 28)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, min: 3)
            try self.validate(self.pipelineName, name: "pipelineName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bufferOptions = "BufferOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case logPublishingOptions = "LogPublishingOptions"
            case maxUnits = "MaxUnits"
            case minUnits = "MinUnits"
            case pipelineConfigurationBody = "PipelineConfigurationBody"
        }
    }

    public struct UpdatePipelineResponse: AWSDecodableShape {
        /// Container for information about the updated pipeline.
        public let pipeline: Pipeline?

        public init(pipeline: Pipeline? = nil) {
            self.pipeline = pipeline
        }

        private enum CodingKeys: String, CodingKey {
            case pipeline = "Pipeline"
        }
    }

    public struct ValidatePipelineRequest: AWSEncodableShape {
        /// The pipeline configuration in YAML format. The command accepts the pipeline configuration as a string or within a .yaml file. If you provide the configuration as a string, each new line must be escaped with \n.
        public let pipelineConfigurationBody: String

        public init(pipelineConfigurationBody: String) {
            self.pipelineConfigurationBody = pipelineConfigurationBody
        }

        public func validate(name: String) throws {
            try self.validate(self.pipelineConfigurationBody, name: "pipelineConfigurationBody", parent: name, max: 24000)
            try self.validate(self.pipelineConfigurationBody, name: "pipelineConfigurationBody", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineConfigurationBody = "PipelineConfigurationBody"
        }
    }

    public struct ValidatePipelineResponse: AWSDecodableShape {
        /// A list of errors if the configuration is invalid.
        public let errors: [ValidationMessage]?
        /// A boolean indicating whether or not the pipeline configuration is valid.
        public let isValid: Bool?

        public init(errors: [ValidationMessage]? = nil, isValid: Bool? = nil) {
            self.errors = errors
            self.isValid = isValid
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case isValid = "isValid"
        }
    }

    public struct ValidationMessage: AWSDecodableShape {
        /// The validation message.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct VpcEndpoint: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let vpcEndpointId: String?
        /// The ID for your VPC. Amazon Web Services PrivateLink generates this value when you create a VPC.
        public let vpcId: String?
        /// Information about the VPC, including associated subnets and security groups.
        public let vpcOptions: VpcOptions?

        public init(vpcEndpointId: String? = nil, vpcId: String? = nil, vpcOptions: VpcOptions? = nil) {
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
            self.vpcOptions = vpcOptions
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointId = "VpcEndpointId"
            case vpcId = "VpcId"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct VpcOptions: AWSEncodableShape & AWSDecodableShape {
        /// A list of security groups associated with the VPC endpoint.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs associated with the VPC endpoint.
        public let subnetIds: [String]

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 20)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 11)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-\\w{8}(\\w{9})?$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 12)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 24)
                try validate($0, name: "subnetIds[]", parent: name, min: 15)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-\\w{8}(\\w{9})?$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 12)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }
}

// MARK: - Errors

/// Error enum for OSIS
public struct OSISErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalException = "InternalException"
        case invalidPaginationTokenException = "InvalidPaginationTokenException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize OSIS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permissions to access the resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The client attempted to remove a resource that is currently in use.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request failed because of an unknown error, exception, or failure (the failure is internal to the service).
    public static var internalException: Self { .init(.internalException) }
    /// An invalid pagination token provided in the request.
    public static var invalidPaginationTokenException: Self { .init(.invalidPaginationTokenException) }
    /// You attempted to create more than the allowed number of tags.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// You attempted to create a resource that already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// You attempted to access or delete a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An exception for missing or invalid input fields.
    public static var validationException: Self { .init(.validationException) }
}

extension OSISErrorType: Equatable {
    public static func == (lhs: OSISErrorType, rhs: OSISErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OSISErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
