//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AppConfig {
    // MARK: Enums

    public enum ActionPoint: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDeploymentBaking = "ON_DEPLOYMENT_BAKING"
        case onDeploymentComplete = "ON_DEPLOYMENT_COMPLETE"
        case onDeploymentRolledBack = "ON_DEPLOYMENT_ROLLED_BACK"
        case onDeploymentStart = "ON_DEPLOYMENT_START"
        case onDeploymentStep = "ON_DEPLOYMENT_STEP"
        case preCreateHostedConfigurationVersion = "PRE_CREATE_HOSTED_CONFIGURATION_VERSION"
        case preStartDeployment = "PRE_START_DEPLOYMENT"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bakeTimeStarted = "BAKE_TIME_STARTED"
        case deploymentCompleted = "DEPLOYMENT_COMPLETED"
        case deploymentStarted = "DEPLOYMENT_STARTED"
        case percentageUpdated = "PERCENTAGE_UPDATED"
        case rollbackCompleted = "ROLLBACK_COMPLETED"
        case rollbackStarted = "ROLLBACK_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case baking = "BAKING"
        case complete = "COMPLETE"
        case deploying = "DEPLOYING"
        case rolledBack = "ROLLED_BACK"
        case rollingBack = "ROLLING_BACK"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deploying = "DEPLOYING"
        case readyForDeployment = "READY_FOR_DEPLOYMENT"
        case rolledBack = "ROLLED_BACK"
        case rollingBack = "ROLLING_BACK"
        public var description: String { return self.rawValue }
    }

    public enum GrowthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exponential = "EXPONENTIAL"
        case linear = "LINEAR"
        public var description: String { return self.rawValue }
    }

    public enum ReplicateTo: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case ssmDocument = "SSM_DOCUMENT"
        public var description: String { return self.rawValue }
    }

    public enum TriggeredBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appconfig = "APPCONFIG"
        case cloudwatchAlarm = "CLOUDWATCH_ALARM"
        case internalError = "INTERNAL_ERROR"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ValidatorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jsonSchema = "JSON_SCHEMA"
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// Information about the action.
        public let description: String?
        /// The action name.
        public let name: String?
        /// An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
        public let roleArn: String?
        /// The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
        public let uri: String?

        public init(description: String? = nil, name: String? = nil, roleArn: String? = nil, uri: String? = nil) {
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1})?:(\\d{12})?:[a-zA-Z0-9-_/:.]+$")
            try self.validate(self.uri, name: "uri", parent: name, max: 2048)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
            case uri = "Uri"
        }
    }

    public struct ActionInvocation: AWSDecodableShape {
        /// The name of the action.
        public let actionName: String?
        /// The error code when an extension invocation fails.
        public let errorCode: String?
        /// The error message when an extension invocation fails.
        public let errorMessage: String?
        /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
        public let extensionIdentifier: String?
        /// A system-generated ID for this invocation.
        public let invocationId: String?
        /// An Amazon Resource Name (ARN) for an Identity and Access Management assume role.
        public let roleArn: String?
        /// The extension URI associated to the action point in the extension definition. The URI can be an Amazon Resource Name (ARN) for one of the following: an Lambda function, an Amazon Simple Queue Service queue, an Amazon Simple Notification Service topic, or the Amazon EventBridge default event bus.
        public let uri: String?

        public init(actionName: String? = nil, errorCode: String? = nil, errorMessage: String? = nil, extensionIdentifier: String? = nil, invocationId: String? = nil, roleArn: String? = nil, uri: String? = nil) {
            self.actionName = actionName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.extensionIdentifier = extensionIdentifier
            self.invocationId = invocationId
            self.roleArn = roleArn
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case actionName = "ActionName"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case extensionIdentifier = "ExtensionIdentifier"
            case invocationId = "InvocationId"
            case roleArn = "RoleArn"
            case uri = "Uri"
        }
    }

    public struct Application: AWSDecodableShape {
        /// The description of the application.
        public let description: String?
        /// The application ID.
        public let id: String?
        /// The application name.
        public let name: String?

        public init(description: String? = nil, id: String? = nil, name: String? = nil) {
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct Applications: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Application]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [Application]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct AppliedExtension: AWSDecodableShape {
        /// The system-generated ID for the association.
        public let extensionAssociationId: String?
        /// The system-generated ID of the extension.
        public let extensionId: String?
        /// One or more parameters for the actions called by the extension.
        public let parameters: [String: String]?
        /// The extension version number.
        public let versionNumber: Int?

        public init(extensionAssociationId: String? = nil, extensionId: String? = nil, parameters: [String: String]? = nil, versionNumber: Int? = nil) {
            self.extensionAssociationId = extensionAssociationId
            self.extensionId = extensionId
            self.parameters = parameters
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case extensionAssociationId = "ExtensionAssociationId"
            case extensionId = "ExtensionId"
            case parameters = "Parameters"
            case versionNumber = "VersionNumber"
        }
    }

    public struct Configuration: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The configuration version.
        public let configurationVersion: String?
        /// The content of the configuration or the configuration data.  The Content attribute only contains data if the system finds new or updated configuration data. If there is no new or updated data and ClientConfigurationVersion matches the version of the current configuration, AppConfig returns a 204 No Content HTTP response code and the Content value will be empty.
        public let content: AWSHTTPBody
        /// A standard MIME type describing the format of the configuration content. For more information, see Content-Type.
        public let contentType: String?

        public init(configurationVersion: String? = nil, content: AWSHTTPBody, contentType: String? = nil) {
            self.configurationVersion = configurationVersion
            self.content = content
            self.contentType = contentType
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.configurationVersion = try response.decodeHeaderIfPresent(String.self, key: "Configuration-Version")
            self.content = try container.decode(AWSHTTPBody.self)
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConfigurationProfile: AWSDecodableShape {
        /// The application ID.
        public let applicationId: String?
        /// The configuration profile description.
        public let description: String?
        /// The configuration profile ID.
        public let id: String?
        /// The Amazon Resource Name of the Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
        public let kmsKeyArn: String?
        /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
        public let kmsKeyIdentifier: String?
        /// The URI location of the configuration.
        public let locationUri: String?
        /// The name of the configuration profile.
        public let name: String?
        /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
        public let retrievalRoleArn: String?
        /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type:  AWS.AppConfig.FeatureFlags   AWS.Freeform
        public let type: String?
        /// A list of methods for validating the configuration.
        public let validators: [Validator]?

        public init(applicationId: String? = nil, description: String? = nil, id: String? = nil, kmsKeyArn: String? = nil, kmsKeyIdentifier: String? = nil, locationUri: String? = nil, name: String? = nil, retrievalRoleArn: String? = nil, type: String? = nil, validators: [Validator]? = nil) {
            self.applicationId = applicationId
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.locationUri = locationUri
            self.name = name
            self.retrievalRoleArn = retrievalRoleArn
            self.type = type
            self.validators = validators
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case description = "Description"
            case id = "Id"
            case kmsKeyArn = "KmsKeyArn"
            case kmsKeyIdentifier = "KmsKeyIdentifier"
            case locationUri = "LocationUri"
            case name = "Name"
            case retrievalRoleArn = "RetrievalRoleArn"
            case type = "Type"
            case validators = "Validators"
        }
    }

    public struct ConfigurationProfileSummary: AWSDecodableShape {
        /// The application ID.
        public let applicationId: String?
        /// The ID of the configuration profile.
        public let id: String?
        /// The URI location of the configuration.
        public let locationUri: String?
        /// The name of the configuration profile.
        public let name: String?
        /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type:  AWS.AppConfig.FeatureFlags   AWS.Freeform
        public let type: String?
        /// The types of validators in the configuration profile.
        public let validatorTypes: [ValidatorType]?

        public init(applicationId: String? = nil, id: String? = nil, locationUri: String? = nil, name: String? = nil, type: String? = nil, validatorTypes: [ValidatorType]? = nil) {
            self.applicationId = applicationId
            self.id = id
            self.locationUri = locationUri
            self.name = name
            self.type = type
            self.validatorTypes = validatorTypes
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case id = "Id"
            case locationUri = "LocationUri"
            case name = "Name"
            case type = "Type"
            case validatorTypes = "ValidatorTypes"
        }
    }

    public struct ConfigurationProfiles: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [ConfigurationProfileSummary]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [ConfigurationProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// A description of the application.
        public let description: String?
        /// A name for the application.
        public let name: String
        /// Metadata to assign to the application. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateConfigurationProfileRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// A description of the configuration profile.
        public let description: String?
        /// The identifier for an Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. The identifier can be an KMS key ID, alias, or the Amazon Resource Name (ARN) of the key ID or alias. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
        public let kmsKeyIdentifier: String?
        /// A URI to locate the configuration. You can specify the following:   For the AppConfig hosted configuration store and for feature flags, specify hosted.   For an Amazon Web Services Systems Manager Parameter Store parameter, specify either the parameter name in the format ssm-parameter:// or the ARN.   For an Amazon Web Services CodePipeline pipeline, specify the URI in the following format: codepipeline://.   For an Secrets Manager secret, specify the URI in the following format: secretsmanager://.   For an Amazon S3 object, specify the URI in the following format: s3:/// . Here is an example: s3://my-bucket/my-app/us-east-1/my-config.json    For an SSM document, specify either the document name in the format ssm-document:// or the Amazon Resource Name (ARN).
        public let locationUri: String
        /// A name for the configuration profile.
        public let name: String
        /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.  A retrieval role ARN is not required for configurations stored in the AppConfig hosted configuration store. It is required for all other sources that store your configuration.
        public let retrievalRoleArn: String?
        /// Metadata to assign to the configuration profile. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?
        /// The type of configurations contained in the profile. AppConfig supports feature flags and freeform configurations. We recommend you create feature flag configurations to enable or disable new features and freeform configurations to distribute configurations to an application. When calling this API, enter one of the following values for Type:  AWS.AppConfig.FeatureFlags   AWS.Freeform
        public let type: String?
        /// A list of methods for validating the configuration.
        public let validators: [Validator]?

        public init(applicationId: String, description: String? = nil, kmsKeyIdentifier: String? = nil, locationUri: String, name: String, retrievalRoleArn: String? = nil, tags: [String: String]? = nil, type: String? = nil, validators: [Validator]? = nil) {
            self.applicationId = applicationId
            self.description = description
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.locationUri = locationUri
            self.name = name
            self.retrievalRoleArn = retrievalRoleArn
            self.tags = tags
            self.type = type
            self.validators = validators
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
            try container.encode(self.locationUri, forKey: .locationUri)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.retrievalRoleArn, forKey: .retrievalRoleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
            try container.encodeIfPresent(self.validators, forKey: .validators)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 2048)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.locationUri, name: "locationUri", parent: name, max: 2048)
            try self.validate(self.locationUri, name: "locationUri", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.retrievalRoleArn, name: "retrievalRoleArn", parent: name, max: 2048)
            try self.validate(self.retrievalRoleArn, name: "retrievalRoleArn", parent: name, min: 20)
            try self.validate(self.retrievalRoleArn, name: "retrievalRoleArn", parent: name, pattern: "^((arn):(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):(iam)::\\d{12}:role[/].*)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[a-zA-Z\\.]+$")
            try self.validators?.forEach {
                try $0.validate(name: "\(name).validators[]")
            }
            try self.validate(self.validators, name: "validators", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case kmsKeyIdentifier = "KmsKeyIdentifier"
            case locationUri = "LocationUri"
            case name = "Name"
            case retrievalRoleArn = "RetrievalRoleArn"
            case tags = "Tags"
            case type = "Type"
            case validators = "Validators"
        }
    }

    public struct CreateDeploymentStrategyRequest: AWSEncodableShape {
        /// Total amount of time for a deployment to last.
        public let deploymentDurationInMinutes: Int
        /// A description of the deployment strategy.
        public let description: String?
        /// Specifies the amount of time AppConfig monitors for Amazon CloudWatch alarms after the configuration has been deployed to 100% of its targets, before considering the deployment to be complete. If an alarm is triggered during this time, AppConfig rolls back the deployment. You must configure permissions for AppConfig to roll back based on CloudWatch alarms. For more information, see Configuring permissions for rollback based on Amazon CloudWatch alarms in the AppConfig User Guide.
        public let finalBakeTimeInMinutes: Int?
        /// The percentage of targets to receive a deployed configuration during each interval.
        public let growthFactor: Float
        /// The algorithm used to define how percentage grows over time. AppConfig supports the following growth types:  Linear: For this type, AppConfig processes the deployment by dividing the total number of targets by the value specified for Step percentage. For example, a linear deployment that uses a Step percentage of 10 deploys the configuration to 10 percent of the hosts. After those deployments are complete, the system deploys the configuration to the next 10 percent. This continues until 100% of the targets have successfully received the configuration.  Exponential: For this type, AppConfig processes the deployment exponentially using the following formula: G*(2^N). In this formula, G is the growth factor specified by the user and N is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows:  2*(2^0)   2*(2^1)   2*(2^2)  Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.
        public let growthType: GrowthType?
        /// A name for the deployment strategy.
        public let name: String
        /// Save the deployment strategy to a Systems Manager (SSM) document.
        public let replicateTo: ReplicateTo?
        /// Metadata to assign to the deployment strategy. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(deploymentDurationInMinutes: Int, description: String? = nil, finalBakeTimeInMinutes: Int? = nil, growthFactor: Float, growthType: GrowthType? = nil, name: String, replicateTo: ReplicateTo? = nil, tags: [String: String]? = nil) {
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.description = description
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.name = name
            self.replicateTo = replicateTo
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentDurationInMinutes, name: "deploymentDurationInMinutes", parent: name, max: 1440)
            try self.validate(self.deploymentDurationInMinutes, name: "deploymentDurationInMinutes", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.finalBakeTimeInMinutes, name: "finalBakeTimeInMinutes", parent: name, max: 1440)
            try self.validate(self.finalBakeTimeInMinutes, name: "finalBakeTimeInMinutes", parent: name, min: 0)
            try self.validate(self.growthFactor, name: "growthFactor", parent: name, max: 100.0)
            try self.validate(self.growthFactor, name: "growthFactor", parent: name, min: 1.0)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
            case description = "Description"
            case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
            case growthFactor = "GrowthFactor"
            case growthType = "GrowthType"
            case name = "Name"
            case replicateTo = "ReplicateTo"
            case tags = "Tags"
        }
    }

    public struct CreateEnvironmentRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// A description of the environment.
        public let description: String?
        /// Amazon CloudWatch alarms to monitor during the deployment process.
        public let monitors: [Monitor]?
        /// A name for the environment.
        public let name: String
        /// Metadata to assign to the environment. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(applicationId: String, description: String? = nil, monitors: [Monitor]? = nil, name: String, tags: [String: String]? = nil) {
            self.applicationId = applicationId
            self.description = description
            self.monitors = monitors
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.monitors, forKey: .monitors)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.monitors?.forEach {
                try $0.validate(name: "\(name).monitors[]")
            }
            try self.validate(self.monitors, name: "monitors", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case monitors = "Monitors"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateExtensionAssociationRequest: AWSEncodableShape {
        /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
        public let extensionIdentifier: String
        /// The version number of the extension. If not specified, AppConfig uses the maximum version of the extension.
        public let extensionVersionNumber: Int?
        /// The parameter names and values defined in the extensions. Extension parameters marked Required must be entered for this field.
        public let parameters: [String: String]?
        /// The ARN of an application, configuration profile, or environment.
        public let resourceIdentifier: String
        /// Adds one or more tags for the specified extension association. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(extensionIdentifier: String, extensionVersionNumber: Int? = nil, parameters: [String: String]? = nil, resourceIdentifier: String, tags: [String: String]? = nil) {
            self.extensionIdentifier = extensionIdentifier
            self.extensionVersionNumber = extensionVersionNumber
            self.parameters = parameters
            self.resourceIdentifier = resourceIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, max: 2048)
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, min: 1)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[^\\/#:\\n]{1,64}$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 10)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case extensionIdentifier = "ExtensionIdentifier"
            case extensionVersionNumber = "ExtensionVersionNumber"
            case parameters = "Parameters"
            case resourceIdentifier = "ResourceIdentifier"
            case tags = "Tags"
        }
    }

    public struct CreateExtensionRequest: AWSEncodableShape {
        /// The actions defined in the extension.
        public let actions: [ActionPoint: [Action]]
        /// Information about the extension.
        public let description: String?
        /// You can omit this field when you create an extension. When you create a new version, specify the most recent current version number. For example, you create version 3, enter 2 for this field.
        public let latestVersionNumber: Int?
        /// A name for the extension. Each extension name in your account must be unique. Extension versions use the same name.
        public let name: String
        /// The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object.
        public let parameters: [String: Parameter]?
        /// Adds one or more tags for the specified extension. Tags are metadata that help you categorize resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(actions: [ActionPoint: [Action]], description: String? = nil, latestVersionNumber: Int? = nil, name: String, parameters: [String: Parameter]? = nil, tags: [String: String]? = nil) {
            self.actions = actions
            self.description = description
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.parameters = parameters
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actions, forKey: .actions)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodeHeader(self.latestVersionNumber, key: "Latest-Version-Number")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try validate($0.value, name: "actions[\"\($0.key)\"]", parent: name, max: 1)
                try validate($0.value, name: "actions[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 5)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\/#:\\n]{1,64}$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[^\\/#:\\n]{1,64}$")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 10)
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case name = "Name"
            case parameters = "Parameters"
            case tags = "Tags"
        }
    }

    public struct CreateHostedConfigurationVersionRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The configuration profile ID.
        public let configurationProfileId: String
        /// The content of the configuration or the configuration data.
        public let content: AWSHTTPBody
        /// A standard MIME type describing the format of the configuration content. For more information, see Content-Type.
        public let contentType: String
        /// A description of the configuration.
        public let description: String?
        /// An optional locking token used to prevent race conditions from overwriting configuration updates when creating a new version. To ensure your data is not overwritten when creating multiple hosted configuration versions in rapid succession, specify the version number of the latest hosted configuration version.
        public let latestVersionNumber: Int?
        /// An optional, user-defined label for the AppConfig hosted configuration version. This value must contain at least one non-numeric character. For example, "v2.2.0".
        public let versionLabel: String?

        public init(applicationId: String, configurationProfileId: String, content: AWSHTTPBody, contentType: String, description: String? = nil, latestVersionNumber: Int? = nil, versionLabel: String? = nil) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.content = content
            self.contentType = contentType
            self.description = description
            self.latestVersionNumber = latestVersionNumber
            self.versionLabel = versionLabel
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
            try container.encode(self.content)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.description, key: "Description")
            request.encodeHeader(self.latestVersionNumber, key: "Latest-Version-Number")
            request.encodeHeader(self.versionLabel, key: "VersionLabel")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 255)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, max: 64)
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, min: 1)
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, pattern: "[^0-9]")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The ID of the application to delete.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationProfileRequest: AWSEncodableShape {
        /// The application ID that includes the configuration profile you want to delete.
        public let applicationId: String
        /// The ID of the configuration profile you want to delete.
        public let configurationProfileId: String

        public init(applicationId: String, configurationProfileId: String) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeploymentStrategyRequest: AWSEncodableShape {
        /// The ID of the deployment strategy you want to delete.
        public let deploymentStrategyId: String

        public init(deploymentStrategyId: String) {
            self.deploymentStrategyId = deploymentStrategyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deploymentStrategyId, key: "DeploymentStrategyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentStrategyId, name: "deploymentStrategyId", parent: name, pattern: "^(^[a-z0-9]{4,7}$|^AppConfig\\.[A-Za-z0-9]{9,40}$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentRequest: AWSEncodableShape {
        /// The application ID that includes the environment that you want to delete.
        public let applicationId: String
        /// The ID of the environment that you want to delete.
        public let environmentId: String

        public init(applicationId: String, environmentId: String) {
            self.applicationId = applicationId
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.environmentId, key: "EnvironmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteExtensionAssociationRequest: AWSEncodableShape {
        /// The ID of the extension association to delete.
        public let extensionAssociationId: String

        public init(extensionAssociationId: String) {
            self.extensionAssociationId = extensionAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.extensionAssociationId, key: "ExtensionAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionAssociationId, name: "extensionAssociationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteExtensionRequest: AWSEncodableShape {
        /// The name, ID, or Amazon Resource Name (ARN) of the extension you want to delete.
        public let extensionIdentifier: String
        /// A specific version of an extension to delete. If omitted, the highest version is deleted.
        public let versionNumber: Int?

        public init(extensionIdentifier: String, versionNumber: Int? = nil) {
            self.extensionIdentifier = extensionIdentifier
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.extensionIdentifier, key: "ExtensionIdentifier")
            request.encodeQuery(self.versionNumber, key: "version")
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, max: 2048)
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteHostedConfigurationVersionRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The configuration profile ID.
        public let configurationProfileId: String
        /// The versions number to delete.
        public let versionNumber: Int

        public init(applicationId: String, configurationProfileId: String, versionNumber: Int) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Deployment: AWSDecodableShape {
        /// The ID of the application that was deployed.
        public let applicationId: String?
        /// A list of extensions that were processed as part of the deployment. The extensions that were previously associated to the configuration profile, environment, or the application when StartDeployment was called.
        public let appliedExtensions: [AppliedExtension]?
        /// The time the deployment completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedAt: Date?
        /// Information about the source location of the configuration.
        public let configurationLocationUri: String?
        /// The name of the configuration.
        public let configurationName: String?
        /// The ID of the configuration profile that was deployed.
        public let configurationProfileId: String?
        /// The configuration version that was deployed.
        public let configurationVersion: String?
        /// Total amount of time the deployment lasted.
        public let deploymentDurationInMinutes: Int?
        /// The sequence number of the deployment.
        public let deploymentNumber: Int?
        /// The ID of the deployment strategy that was deployed.
        public let deploymentStrategyId: String?
        /// The description of the deployment.
        public let description: String?
        /// The ID of the environment that was deployed.
        public let environmentId: String?
        /// A list containing all events related to a deployment. The most recent events are displayed first.
        public let eventLog: [DeploymentEvent]?
        /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public let finalBakeTimeInMinutes: Int?
        /// The percentage of targets to receive a deployed configuration during each interval.
        public let growthFactor: Float?
        /// The algorithm used to define how percentage grew over time.
        public let growthType: GrowthType?
        /// The Amazon Resource Name of the Key Management Service key used to encrypt configuration data. You can encrypt secrets stored in Secrets Manager, Amazon Simple Storage Service (Amazon S3) objects encrypted with SSE-KMS, or secure string parameters stored in Amazon Web Services Systems Manager Parameter Store.
        public let kmsKeyArn: String?
        /// The Key Management Service key identifier (key ID, key alias, or key ARN) provided when the resource was created or updated.
        public let kmsKeyIdentifier: String?
        /// The percentage of targets for which the deployment is available.
        public let percentageComplete: Float?
        /// The time the deployment started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The state of the deployment.
        public let state: DeploymentState?
        /// A user-defined label for an AppConfig hosted configuration version.
        public let versionLabel: String?

        public init(applicationId: String? = nil, appliedExtensions: [AppliedExtension]? = nil, completedAt: Date? = nil, configurationLocationUri: String? = nil, configurationName: String? = nil, configurationProfileId: String? = nil, configurationVersion: String? = nil, deploymentDurationInMinutes: Int? = nil, deploymentNumber: Int? = nil, deploymentStrategyId: String? = nil, description: String? = nil, environmentId: String? = nil, eventLog: [DeploymentEvent]? = nil, finalBakeTimeInMinutes: Int? = nil, growthFactor: Float? = nil, growthType: GrowthType? = nil, kmsKeyArn: String? = nil, kmsKeyIdentifier: String? = nil, percentageComplete: Float? = nil, startedAt: Date? = nil, state: DeploymentState? = nil, versionLabel: String? = nil) {
            self.applicationId = applicationId
            self.appliedExtensions = appliedExtensions
            self.completedAt = completedAt
            self.configurationLocationUri = configurationLocationUri
            self.configurationName = configurationName
            self.configurationProfileId = configurationProfileId
            self.configurationVersion = configurationVersion
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.deploymentNumber = deploymentNumber
            self.deploymentStrategyId = deploymentStrategyId
            self.description = description
            self.environmentId = environmentId
            self.eventLog = eventLog
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.kmsKeyArn = kmsKeyArn
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.percentageComplete = percentageComplete
            self.startedAt = startedAt
            self.state = state
            self.versionLabel = versionLabel
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case appliedExtensions = "AppliedExtensions"
            case completedAt = "CompletedAt"
            case configurationLocationUri = "ConfigurationLocationUri"
            case configurationName = "ConfigurationName"
            case configurationProfileId = "ConfigurationProfileId"
            case configurationVersion = "ConfigurationVersion"
            case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
            case deploymentNumber = "DeploymentNumber"
            case deploymentStrategyId = "DeploymentStrategyId"
            case description = "Description"
            case environmentId = "EnvironmentId"
            case eventLog = "EventLog"
            case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
            case growthFactor = "GrowthFactor"
            case growthType = "GrowthType"
            case kmsKeyArn = "KmsKeyArn"
            case kmsKeyIdentifier = "KmsKeyIdentifier"
            case percentageComplete = "PercentageComplete"
            case startedAt = "StartedAt"
            case state = "State"
            case versionLabel = "VersionLabel"
        }
    }

    public struct DeploymentEvent: AWSDecodableShape {
        /// The list of extensions that were invoked as part of the deployment.
        public let actionInvocations: [ActionInvocation]?
        /// A description of the deployment event. Descriptions include, but are not limited to, the following:   The Amazon Web Services account or the Amazon CloudWatch alarm ARN that initiated a rollback.   The percentage of hosts that received the deployment.   A recommendation to attempt a new deployment (in the case of an internal error).
        public let description: String?
        /// The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.
        public let eventType: DeploymentEventType?
        /// The date and time the event occurred.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var occurredAt: Date?
        /// The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.
        public let triggeredBy: TriggeredBy?

        public init(actionInvocations: [ActionInvocation]? = nil, description: String? = nil, eventType: DeploymentEventType? = nil, occurredAt: Date? = nil, triggeredBy: TriggeredBy? = nil) {
            self.actionInvocations = actionInvocations
            self.description = description
            self.eventType = eventType
            self.occurredAt = occurredAt
            self.triggeredBy = triggeredBy
        }

        private enum CodingKeys: String, CodingKey {
            case actionInvocations = "ActionInvocations"
            case description = "Description"
            case eventType = "EventType"
            case occurredAt = "OccurredAt"
            case triggeredBy = "TriggeredBy"
        }
    }

    public struct DeploymentStrategies: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [DeploymentStrategy]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [DeploymentStrategy]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct DeploymentStrategy: AWSDecodableShape {
        /// Total amount of time the deployment lasted.
        public let deploymentDurationInMinutes: Int?
        /// The description of the deployment strategy.
        public let description: String?
        /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public let finalBakeTimeInMinutes: Int?
        /// The percentage of targets that received a deployed configuration during each interval.
        public let growthFactor: Float?
        /// The algorithm used to define how percentage grew over time.
        public let growthType: GrowthType?
        /// The deployment strategy ID.
        public let id: String?
        /// The name of the deployment strategy.
        public let name: String?
        /// Save the deployment strategy to a Systems Manager (SSM) document.
        public let replicateTo: ReplicateTo?

        public init(deploymentDurationInMinutes: Int? = nil, description: String? = nil, finalBakeTimeInMinutes: Int? = nil, growthFactor: Float? = nil, growthType: GrowthType? = nil, id: String? = nil, name: String? = nil, replicateTo: ReplicateTo? = nil) {
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.description = description
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.id = id
            self.name = name
            self.replicateTo = replicateTo
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
            case description = "Description"
            case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
            case growthFactor = "GrowthFactor"
            case growthType = "GrowthType"
            case id = "Id"
            case name = "Name"
            case replicateTo = "ReplicateTo"
        }
    }

    public struct DeploymentSummary: AWSDecodableShape {
        /// Time the deployment completed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedAt: Date?
        /// The name of the configuration.
        public let configurationName: String?
        /// The version of the configuration.
        public let configurationVersion: String?
        /// Total amount of time the deployment lasted.
        public let deploymentDurationInMinutes: Int?
        /// The sequence number of the deployment.
        public let deploymentNumber: Int?
        /// The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public let finalBakeTimeInMinutes: Int?
        /// The percentage of targets to receive a deployed configuration during each interval.
        public let growthFactor: Float?
        /// The algorithm used to define how percentage grows over time.
        public let growthType: GrowthType?
        /// The percentage of targets for which the deployment is available.
        public let percentageComplete: Float?
        /// Time the deployment started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The state of the deployment.
        public let state: DeploymentState?
        /// A user-defined label for an AppConfig hosted configuration version.
        public let versionLabel: String?

        public init(completedAt: Date? = nil, configurationName: String? = nil, configurationVersion: String? = nil, deploymentDurationInMinutes: Int? = nil, deploymentNumber: Int? = nil, finalBakeTimeInMinutes: Int? = nil, growthFactor: Float? = nil, growthType: GrowthType? = nil, percentageComplete: Float? = nil, startedAt: Date? = nil, state: DeploymentState? = nil, versionLabel: String? = nil) {
            self.completedAt = completedAt
            self.configurationName = configurationName
            self.configurationVersion = configurationVersion
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.deploymentNumber = deploymentNumber
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.percentageComplete = percentageComplete
            self.startedAt = startedAt
            self.state = state
            self.versionLabel = versionLabel
        }

        private enum CodingKeys: String, CodingKey {
            case completedAt = "CompletedAt"
            case configurationName = "ConfigurationName"
            case configurationVersion = "ConfigurationVersion"
            case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
            case deploymentNumber = "DeploymentNumber"
            case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
            case growthFactor = "GrowthFactor"
            case growthType = "GrowthType"
            case percentageComplete = "PercentageComplete"
            case startedAt = "StartedAt"
            case state = "State"
            case versionLabel = "VersionLabel"
        }
    }

    public struct Deployments: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [DeploymentSummary]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [DeploymentSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct Environment: AWSDecodableShape {
        /// The application ID.
        public let applicationId: String?
        /// The description of the environment.
        public let description: String?
        /// The environment ID.
        public let id: String?
        /// Amazon CloudWatch alarms monitored during the deployment.
        public let monitors: [Monitor]?
        /// The name of the environment.
        public let name: String?
        /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
        public let state: EnvironmentState?

        public init(applicationId: String? = nil, description: String? = nil, id: String? = nil, monitors: [Monitor]? = nil, name: String? = nil, state: EnvironmentState? = nil) {
            self.applicationId = applicationId
            self.description = description
            self.id = id
            self.monitors = monitors
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case description = "Description"
            case id = "Id"
            case monitors = "Monitors"
            case name = "Name"
            case state = "State"
        }
    }

    public struct Environments: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Environment]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [Environment]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct Extension: AWSDecodableShape {
        /// The actions defined in the extension.
        public let actions: [ActionPoint: [Action]]?
        /// The system-generated Amazon Resource Name (ARN) for the extension.
        public let arn: String?
        /// Information about the extension.
        public let description: String?
        /// The system-generated ID of the extension.
        public let id: String?
        /// The extension name.
        public let name: String?
        /// The parameters accepted by the extension. You specify parameter values when you associate the extension to an AppConfig resource by using the CreateExtensionAssociation API action. For Lambda extension actions, these parameters are included in the Lambda request object.
        public let parameters: [String: Parameter]?
        /// The extension version number.
        public let versionNumber: Int?

        public init(actions: [ActionPoint: [Action]]? = nil, arn: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, parameters: [String: Parameter]? = nil, versionNumber: Int? = nil) {
            self.actions = actions
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.parameters = parameters
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case parameters = "Parameters"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ExtensionAssociation: AWSDecodableShape {
        /// The system-generated Amazon Resource Name (ARN) for the extension.
        public let arn: String?
        /// The ARN of the extension defined in the association.
        public let extensionArn: String?
        /// The version number for the extension defined in the association.
        public let extensionVersionNumber: Int?
        /// The system-generated ID for the association.
        public let id: String?
        /// The parameter names and values defined in the association.
        public let parameters: [String: String]?
        /// The ARNs of applications, configuration profiles, or environments defined in the association.
        public let resourceArn: String?

        public init(arn: String? = nil, extensionArn: String? = nil, extensionVersionNumber: Int? = nil, id: String? = nil, parameters: [String: String]? = nil, resourceArn: String? = nil) {
            self.arn = arn
            self.extensionArn = extensionArn
            self.extensionVersionNumber = extensionVersionNumber
            self.id = id
            self.parameters = parameters
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case extensionArn = "ExtensionArn"
            case extensionVersionNumber = "ExtensionVersionNumber"
            case id = "Id"
            case parameters = "Parameters"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ExtensionAssociationSummary: AWSDecodableShape {
        /// The system-generated Amazon Resource Name (ARN) for the extension.
        public let extensionArn: String?
        /// The extension association ID. This ID is used to call other ExtensionAssociation API actions such as GetExtensionAssociation or DeleteExtensionAssociation.
        public let id: String?
        /// The ARNs of applications, configuration profiles, or environments defined in the association.
        public let resourceArn: String?

        public init(extensionArn: String? = nil, id: String? = nil, resourceArn: String? = nil) {
            self.extensionArn = extensionArn
            self.id = id
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case extensionArn = "ExtensionArn"
            case id = "Id"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ExtensionAssociations: AWSDecodableShape {
        /// The list of extension associations. Each item represents an extension association to an application, environment, or configuration profile.
        public let items: [ExtensionAssociationSummary]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [ExtensionAssociationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ExtensionSummary: AWSDecodableShape {
        /// The system-generated Amazon Resource Name (ARN) for the extension.
        public let arn: String?
        /// Information about the extension.
        public let description: String?
        /// The system-generated ID of the extension.
        public let id: String?
        /// The extension name.
        public let name: String?
        /// The extension version number.
        public let versionNumber: Int?

        public init(arn: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, versionNumber: Int? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case versionNumber = "VersionNumber"
        }
    }

    public struct Extensions: AWSDecodableShape {
        /// The list of available extensions. The list includes Amazon Web Services authored and user-created extensions.
        public let items: [ExtensionSummary]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [ExtensionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        /// The ID of the application you want to get.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigurationProfileRequest: AWSEncodableShape {
        /// The ID of the application that includes the configuration profile you want to get.
        public let applicationId: String
        /// The ID of the configuration profile that you want to get.
        public let configurationProfileId: String

        public init(applicationId: String, configurationProfileId: String) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigurationRequest: AWSEncodableShape {
        /// The application to get. Specify either the application name or the application ID.
        public let application: String
        /// The configuration version returned in the most recent GetConfiguration response.  AppConfig uses the value of the ClientConfigurationVersion parameter to identify the configuration version on your clients. If you don’t send ClientConfigurationVersion with each call to GetConfiguration, your clients receive the current configuration. You are charged each time your clients receive a configuration. To avoid excess charges, we recommend you use the StartConfigurationSession and GetLatestConfiguration APIs, which track the client configuration version on your behalf. If you choose to continue using GetConfiguration, we recommend that you include the ClientConfigurationVersion value with every call to GetConfiguration. The value to use for ClientConfigurationVersion comes from the ConfigurationVersion attribute returned by GetConfiguration when there is new or updated data, and should be saved for subsequent calls to GetConfiguration.  For more information about working with configurations, see Retrieving the Configuration in the AppConfig User Guide.
        public let clientConfigurationVersion: String?
        /// The clientId parameter in the following command is a unique, user-specified ID to identify the client for the configuration. This ID enables AppConfig to deploy the configuration in intervals, as defined in the deployment strategy.
        public let clientId: String
        /// The configuration to get. Specify either the configuration name or the configuration ID.
        public let configuration: String
        /// The environment to get. Specify either the environment name or the environment ID.
        public let environment: String

        public init(application: String, clientConfigurationVersion: String? = nil, clientId: String, configuration: String, environment: String) {
            self.application = application
            self.clientConfigurationVersion = clientConfigurationVersion
            self.clientId = clientId
            self.configuration = configuration
            self.environment = environment
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.application, key: "Application")
            request.encodeQuery(self.clientConfigurationVersion, key: "client_configuration_version")
            request.encodeQuery(self.clientId, key: "client_id")
            request.encodePath(self.configuration, key: "Configuration")
            request.encodePath(self.environment, key: "Environment")
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 64)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.clientConfigurationVersion, name: "clientConfigurationVersion", parent: name, max: 1024)
            try self.validate(self.clientConfigurationVersion, name: "clientConfigurationVersion", parent: name, min: 1)
            try self.validate(self.clientId, name: "clientId", parent: name, max: 64)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.configuration, name: "configuration", parent: name, max: 64)
            try self.validate(self.configuration, name: "configuration", parent: name, min: 1)
            try self.validate(self.environment, name: "environment", parent: name, max: 64)
            try self.validate(self.environment, name: "environment", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentRequest: AWSEncodableShape {
        /// The ID of the application that includes the deployment you want to get.
        public let applicationId: String
        /// The sequence number of the deployment.
        public let deploymentNumber: Int
        /// The ID of the environment that includes the deployment you want to get.
        public let environmentId: String

        public init(applicationId: String, deploymentNumber: Int, environmentId: String) {
            self.applicationId = applicationId
            self.deploymentNumber = deploymentNumber
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.deploymentNumber, key: "DeploymentNumber")
            request.encodePath(self.environmentId, key: "EnvironmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentStrategyRequest: AWSEncodableShape {
        /// The ID of the deployment strategy to get.
        public let deploymentStrategyId: String

        public init(deploymentStrategyId: String) {
            self.deploymentStrategyId = deploymentStrategyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deploymentStrategyId, key: "DeploymentStrategyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentStrategyId, name: "deploymentStrategyId", parent: name, pattern: "^(^[a-z0-9]{4,7}$|^AppConfig\\.[A-Za-z0-9]{9,40}$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentRequest: AWSEncodableShape {
        /// The ID of the application that includes the environment you want to get.
        public let applicationId: String
        /// The ID of the environment that you want to get.
        public let environmentId: String

        public init(applicationId: String, environmentId: String) {
            self.applicationId = applicationId
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.environmentId, key: "EnvironmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExtensionAssociationRequest: AWSEncodableShape {
        /// The extension association ID to get.
        public let extensionAssociationId: String

        public init(extensionAssociationId: String) {
            self.extensionAssociationId = extensionAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.extensionAssociationId, key: "ExtensionAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionAssociationId, name: "extensionAssociationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExtensionRequest: AWSEncodableShape {
        /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
        public let extensionIdentifier: String
        /// The extension version number. If no version number was defined, AppConfig uses the highest version.
        public let versionNumber: Int?

        public init(extensionIdentifier: String, versionNumber: Int? = nil) {
            self.extensionIdentifier = extensionIdentifier
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.extensionIdentifier, key: "ExtensionIdentifier")
            request.encodeQuery(self.versionNumber, key: "version_number")
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, max: 2048)
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetHostedConfigurationVersionRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The configuration profile ID.
        public let configurationProfileId: String
        /// The version.
        public let versionNumber: Int

        public init(applicationId: String, configurationProfileId: String, versionNumber: Int) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct HostedConfigurationVersion: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The application ID.
        public let applicationId: String?
        /// The configuration profile ID.
        public let configurationProfileId: String?
        /// The content of the configuration or the configuration data.
        public let content: AWSHTTPBody
        /// A standard MIME type describing the format of the configuration content. For more information, see Content-Type.
        public let contentType: String?
        /// A description of the configuration.
        public let description: String?
        /// The Amazon Resource Name of the Key Management Service key that was used to encrypt this specific version of the configuration data in the AppConfig hosted configuration store.
        public let kmsKeyArn: String?
        /// A user-defined label for an AppConfig hosted configuration version.
        public let versionLabel: String?
        /// The configuration version.
        public let versionNumber: Int?

        public init(applicationId: String? = nil, configurationProfileId: String? = nil, content: AWSHTTPBody, contentType: String? = nil, description: String? = nil, kmsKeyArn: String? = nil, versionLabel: String? = nil, versionNumber: Int? = nil) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.content = content
            self.contentType = contentType
            self.description = description
            self.kmsKeyArn = kmsKeyArn
            self.versionLabel = versionLabel
            self.versionNumber = versionNumber
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.applicationId = try response.decodeHeaderIfPresent(String.self, key: "Application-Id")
            self.configurationProfileId = try response.decodeHeaderIfPresent(String.self, key: "Configuration-Profile-Id")
            self.content = try container.decode(AWSHTTPBody.self)
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.description = try response.decodeHeaderIfPresent(String.self, key: "Description")
            self.kmsKeyArn = try response.decodeHeaderIfPresent(String.self, key: "KmsKeyArn")
            self.versionLabel = try response.decodeHeaderIfPresent(String.self, key: "VersionLabel")
            self.versionNumber = try response.decodeHeaderIfPresent(Int.self, key: "Version-Number")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct HostedConfigurationVersionSummary: AWSDecodableShape {
        /// The application ID.
        public let applicationId: String?
        /// The configuration profile ID.
        public let configurationProfileId: String?
        /// A standard MIME type describing the format of the configuration content. For more information, see Content-Type.
        public let contentType: String?
        /// A description of the configuration.
        public let description: String?
        /// The Amazon Resource Name of the Key Management Service key that was used to encrypt this specific version of the configuration data in the AppConfig hosted configuration store.
        public let kmsKeyArn: String?
        /// A user-defined label for an AppConfig hosted configuration version.
        public let versionLabel: String?
        /// The configuration version.
        public let versionNumber: Int?

        public init(applicationId: String? = nil, configurationProfileId: String? = nil, contentType: String? = nil, description: String? = nil, kmsKeyArn: String? = nil, versionLabel: String? = nil, versionNumber: Int? = nil) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.contentType = contentType
            self.description = description
            self.kmsKeyArn = kmsKeyArn
            self.versionLabel = versionLabel
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case configurationProfileId = "ConfigurationProfileId"
            case contentType = "ContentType"
            case description = "Description"
            case kmsKeyArn = "KmsKeyArn"
            case versionLabel = "VersionLabel"
            case versionNumber = "VersionNumber"
        }
    }

    public struct HostedConfigurationVersions: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [HostedConfigurationVersionSummary]?
        /// The token for the next set of items to return. Use this token to get the next set of results.
        public let nextToken: String?

        public init(items: [HostedConfigurationVersionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// A token to start the list. Next token is a pagination token generated by AppConfig to describe what page the previous List call ended on. For the first List request, the nextToken should not be set. On subsequent calls, the nextToken parameter should be set to the previous responses nextToken value. Use this token to get the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationProfilesRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?
        /// A filter based on the type of configurations that the configuration profile contains. A configuration can be a feature flag or a freeform configuration.
        public let type: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, type: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[a-zA-Z\\.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeploymentStrategiesRequest: AWSEncodableShape {
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeploymentsRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The environment ID.
        public let environmentId: String
        /// The maximum number of items that may be returned for this call. If there are items that have not yet been returned, the response will include a non-null NextToken that you can provide in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// The token returned by a prior call to this operation indicating the next set of results to be returned. If not specified, the operation will return the first set of results.
        public let nextToken: String?

        public init(applicationId: String, environmentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.environmentId, key: "EnvironmentId")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExtensionAssociationsRequest: AWSEncodableShape {
        /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
        public let extensionIdentifier: String?
        /// The version number for the extension defined in the association.
        public let extensionVersionNumber: Int?
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// A token to start the list. Use this token to get the next set of results or pass null to get the first set of results.
        public let nextToken: String?
        /// The ARN of an application, configuration profile, or environment.
        public let resourceIdentifier: String?

        public init(extensionIdentifier: String? = nil, extensionVersionNumber: Int? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceIdentifier: String? = nil) {
            self.extensionIdentifier = extensionIdentifier
            self.extensionVersionNumber = extensionVersionNumber
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.extensionIdentifier, key: "extension_identifier")
            request.encodeQuery(self.extensionVersionNumber, key: "extension_version_number")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
            request.encodeQuery(self.resourceIdentifier, key: "resource_identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, max: 2048)
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 20)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1})?:(\\d{12})?:[a-zA-Z0-9-_/:.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExtensionsRequest: AWSEncodableShape {
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// The extension name.
        public let name: String?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "next_token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHostedConfigurationVersionsRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The configuration profile ID.
        public let configurationProfileId: String
        /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
        public let maxResults: Int?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?
        /// An optional filter that can be used to specify the version label of an AppConfig hosted configuration version. This parameter supports filtering by prefix using a wildcard, for example "v2*". If you don't specify an asterisk at the end of the value, only an exact match is returned.
        public let versionLabel: String?

        public init(applicationId: String, configurationProfileId: String, maxResults: Int? = nil, nextToken: String? = nil, versionLabel: String? = nil) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.versionLabel = versionLabel
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
            request.encodeQuery(self.maxResults, key: "max_results")
            request.encodeQuery(self.nextToken, key: "next_token")
            request.encodeQuery(self.versionLabel, key: "version_label")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, max: 64)
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1})?:(\\d{12})?:[a-zA-Z0-9-_/:.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Monitor: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.
        public let alarmArn: String
        /// ARN of an Identity and Access Management (IAM) role for AppConfig to monitor AlarmArn.
        public let alarmRoleArn: String?

        public init(alarmArn: String, alarmRoleArn: String? = nil) {
            self.alarmArn = alarmArn
            self.alarmRoleArn = alarmRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.alarmArn, name: "alarmArn", parent: name, max: 2048)
            try self.validate(self.alarmArn, name: "alarmArn", parent: name, min: 1)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, max: 2048)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, min: 20)
            try self.validate(self.alarmRoleArn, name: "alarmRoleArn", parent: name, pattern: "^((arn):(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):(iam)::\\d{12}:role[/].*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case alarmArn = "AlarmArn"
            case alarmRoleArn = "AlarmRoleArn"
        }
    }

    public struct Parameter: AWSEncodableShape & AWSDecodableShape {
        /// Information about the parameter.
        public let description: String?
        /// Indicates whether this parameter's value can be supplied at the extension's action point instead of during extension association. Dynamic parameters can't be marked Required.
        public let dynamic: Bool?
        /// A parameter value must be specified in the extension association.
        public let required: Bool?

        public init(description: String? = nil, dynamic: Bool? = nil, required: Bool? = nil) {
            self.description = description
            self.dynamic = dynamic
            self.required = required
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case dynamic = "Dynamic"
            case required = "Required"
        }
    }

    public struct ResourceTags: AWSDecodableShape {
        /// Metadata to assign to AppConfig resources. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct StartDeploymentRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The configuration profile ID.
        public let configurationProfileId: String
        /// The configuration version to deploy. If deploying an AppConfig hosted configuration version, you can specify either the version number or version label. For all other configurations, you must specify the version number.
        public let configurationVersion: String
        /// The deployment strategy ID.
        public let deploymentStrategyId: String
        /// A description of the deployment.
        public let description: String?
        /// A map of dynamic extension parameter names to values to pass to associated extensions with PRE_START_DEPLOYMENT actions.
        public let dynamicExtensionParameters: [String: String]?
        /// The environment ID.
        public let environmentId: String
        /// The KMS key identifier (key ID, key alias, or key ARN). AppConfig uses this ID to encrypt the configuration data using a customer managed key.
        public let kmsKeyIdentifier: String?
        /// Metadata to assign to the deployment. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
        public let tags: [String: String]?

        public init(applicationId: String, configurationProfileId: String, configurationVersion: String, deploymentStrategyId: String, description: String? = nil, dynamicExtensionParameters: [String: String]? = nil, environmentId: String, kmsKeyIdentifier: String? = nil, tags: [String: String]? = nil) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.configurationVersion = configurationVersion
            self.deploymentStrategyId = deploymentStrategyId
            self.description = description
            self.dynamicExtensionParameters = dynamicExtensionParameters
            self.environmentId = environmentId
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encode(self.configurationProfileId, forKey: .configurationProfileId)
            try container.encode(self.configurationVersion, forKey: .configurationVersion)
            try container.encode(self.deploymentStrategyId, forKey: .deploymentStrategyId)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dynamicExtensionParameters, forKey: .dynamicExtensionParameters)
            request.encodePath(self.environmentId, key: "EnvironmentId")
            try container.encodeIfPresent(self.kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationVersion, name: "configurationVersion", parent: name, max: 1024)
            try self.validate(self.configurationVersion, name: "configurationVersion", parent: name, min: 1)
            try self.validate(self.deploymentStrategyId, name: "deploymentStrategyId", parent: name, pattern: "^(^[a-z0-9]{4,7}$|^AppConfig\\.[A-Za-z0-9]{9,40}$)$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.dynamicExtensionParameters?.forEach {
                try validate($0.key, name: "dynamicExtensionParameters.key", parent: name, pattern: "^([^#\\n]{1,96})#([^\\/#\\n]{1,64})$")
                try validate($0.value, name: "dynamicExtensionParameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "dynamicExtensionParameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.dynamicExtensionParameters, name: "dynamicExtensionParameters", parent: name, max: 10)
            try self.validate(self.dynamicExtensionParameters, name: "dynamicExtensionParameters", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 2048)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationProfileId = "ConfigurationProfileId"
            case configurationVersion = "ConfigurationVersion"
            case deploymentStrategyId = "DeploymentStrategyId"
            case description = "Description"
            case dynamicExtensionParameters = "DynamicExtensionParameters"
            case kmsKeyIdentifier = "KmsKeyIdentifier"
            case tags = "Tags"
        }
    }

    public struct StopDeploymentRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The sequence number of the deployment.
        public let deploymentNumber: Int
        /// The environment ID.
        public let environmentId: String

        public init(applicationId: String, deploymentNumber: Int, environmentId: String) {
            self.applicationId = applicationId
            self.deploymentNumber = deploymentNumber
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.deploymentNumber, key: "DeploymentNumber")
            request.encodePath(self.environmentId, key: "EnvironmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource for which to retrieve tags.
        public let resourceArn: String
        /// The key-value string map. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1})?:(\\d{12})?:[a-zA-Z0-9-_/:.]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource for which to remove tags.
        public let resourceArn: String
        /// The tag keys to delete.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1})?:(\\d{12})?:[a-zA-Z0-9-_/:.]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// A description of the application.
        public let description: String?
        /// The name of the application.
        public let name: String?

        public init(applicationId: String, description: String? = nil, name: String? = nil) {
            self.applicationId = applicationId
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateConfigurationProfileRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The ID of the configuration profile.
        public let configurationProfileId: String
        /// A description of the configuration profile.
        public let description: String?
        /// The identifier for a Key Management Service key to encrypt new configuration data versions in the AppConfig hosted configuration store. This attribute is only used for hosted configuration types. The identifier can be an KMS key ID, alias, or the Amazon Resource Name (ARN) of the key ID or alias. To encrypt data managed in other configuration stores, see the documentation for how to specify an KMS key for that particular service.
        public let kmsKeyIdentifier: String?
        /// The name of the configuration profile.
        public let name: String?
        /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
        public let retrievalRoleArn: String?
        /// A list of methods for validating the configuration.
        public let validators: [Validator]?

        public init(applicationId: String, configurationProfileId: String, description: String? = nil, kmsKeyIdentifier: String? = nil, name: String? = nil, retrievalRoleArn: String? = nil, validators: [Validator]? = nil) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.description = description
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.retrievalRoleArn = retrievalRoleArn
            self.validators = validators
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.retrievalRoleArn, forKey: .retrievalRoleArn)
            try container.encodeIfPresent(self.validators, forKey: .validators)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.retrievalRoleArn, name: "retrievalRoleArn", parent: name, max: 2048)
            try self.validate(self.retrievalRoleArn, name: "retrievalRoleArn", parent: name, min: 20)
            try self.validate(self.retrievalRoleArn, name: "retrievalRoleArn", parent: name, pattern: "^((arn):(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):(iam)::\\d{12}:role[/].*)$")
            try self.validators?.forEach {
                try $0.validate(name: "\(name).validators[]")
            }
            try self.validate(self.validators, name: "validators", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case kmsKeyIdentifier = "KmsKeyIdentifier"
            case name = "Name"
            case retrievalRoleArn = "RetrievalRoleArn"
            case validators = "Validators"
        }
    }

    public struct UpdateDeploymentStrategyRequest: AWSEncodableShape {
        /// Total amount of time for a deployment to last.
        public let deploymentDurationInMinutes: Int?
        /// The deployment strategy ID.
        public let deploymentStrategyId: String
        /// A description of the deployment strategy.
        public let description: String?
        /// The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public let finalBakeTimeInMinutes: Int?
        /// The percentage of targets to receive a deployed configuration during each interval.
        public let growthFactor: Float?
        /// The algorithm used to define how percentage grows over time. AppConfig supports the following growth types:  Linear: For this type, AppConfig processes the deployment by increments of the growth factor evenly distributed over the deployment time. For example, a linear deployment that uses a growth factor of 20 initially makes the configuration available to 20 percent of the targets. After 1/5th of the deployment time has passed, the system updates the percentage to 40 percent. This continues until 100% of the targets are set to receive the deployed configuration.  Exponential: For this type, AppConfig processes the deployment exponentially using the following formula: G*(2^N). In this formula, G is the growth factor specified by the user and N is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows:  2*(2^0)   2*(2^1)   2*(2^2)  Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.
        public let growthType: GrowthType?

        public init(deploymentDurationInMinutes: Int? = nil, deploymentStrategyId: String, description: String? = nil, finalBakeTimeInMinutes: Int? = nil, growthFactor: Float? = nil, growthType: GrowthType? = nil) {
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.deploymentStrategyId = deploymentStrategyId
            self.description = description
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
            request.encodePath(self.deploymentStrategyId, key: "DeploymentStrategyId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
            try container.encodeIfPresent(self.growthFactor, forKey: .growthFactor)
            try container.encodeIfPresent(self.growthType, forKey: .growthType)
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentDurationInMinutes, name: "deploymentDurationInMinutes", parent: name, max: 1440)
            try self.validate(self.deploymentDurationInMinutes, name: "deploymentDurationInMinutes", parent: name, min: 0)
            try self.validate(self.deploymentStrategyId, name: "deploymentStrategyId", parent: name, pattern: "^(^[a-z0-9]{4,7}$|^AppConfig\\.[A-Za-z0-9]{9,40}$)$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.finalBakeTimeInMinutes, name: "finalBakeTimeInMinutes", parent: name, max: 1440)
            try self.validate(self.finalBakeTimeInMinutes, name: "finalBakeTimeInMinutes", parent: name, min: 0)
            try self.validate(self.growthFactor, name: "growthFactor", parent: name, max: 100.0)
            try self.validate(self.growthFactor, name: "growthFactor", parent: name, min: 1.0)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
            case description = "Description"
            case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
            case growthFactor = "GrowthFactor"
            case growthType = "GrowthType"
        }
    }

    public struct UpdateEnvironmentRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// A description of the environment.
        public let description: String?
        /// The environment ID.
        public let environmentId: String
        /// Amazon CloudWatch alarms to monitor during the deployment process.
        public let monitors: [Monitor]?
        /// The name of the environment.
        public let name: String?

        public init(applicationId: String, description: String? = nil, environmentId: String, monitors: [Monitor]? = nil, name: String? = nil) {
            self.applicationId = applicationId
            self.description = description
            self.environmentId = environmentId
            self.monitors = monitors
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.environmentId, key: "EnvironmentId")
            try container.encodeIfPresent(self.monitors, forKey: .monitors)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.monitors?.forEach {
                try $0.validate(name: "\(name).monitors[]")
            }
            try self.validate(self.monitors, name: "monitors", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case monitors = "Monitors"
            case name = "Name"
        }
    }

    public struct UpdateExtensionAssociationRequest: AWSEncodableShape {
        /// The system-generated ID for the association.
        public let extensionAssociationId: String
        /// The parameter names and values defined in the extension.
        public let parameters: [String: String]?

        public init(extensionAssociationId: String, parameters: [String: String]? = nil) {
            self.extensionAssociationId = extensionAssociationId
            self.parameters = parameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.extensionAssociationId, key: "ExtensionAssociationId")
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionAssociationId, name: "extensionAssociationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[^\\/#:\\n]{1,64}$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
        }
    }

    public struct UpdateExtensionRequest: AWSEncodableShape {
        /// The actions defined in the extension.
        public let actions: [ActionPoint: [Action]]?
        /// Information about the extension.
        public let description: String?
        /// The name, the ID, or the Amazon Resource Name (ARN) of the extension.
        public let extensionIdentifier: String
        /// One or more parameters for the actions called by the extension.
        public let parameters: [String: Parameter]?
        /// The extension version number.
        public let versionNumber: Int?

        public init(actions: [ActionPoint: [Action]]? = nil, description: String? = nil, extensionIdentifier: String, parameters: [String: Parameter]? = nil, versionNumber: Int? = nil) {
            self.actions = actions
            self.description = description
            self.extensionIdentifier = extensionIdentifier
            self.parameters = parameters
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actions, forKey: .actions)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.extensionIdentifier, key: "ExtensionIdentifier")
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.versionNumber, forKey: .versionNumber)
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try validate($0.value, name: "actions[\"\($0.key)\"]", parent: name, max: 1)
                try validate($0.value, name: "actions[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 5)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, max: 2048)
            try self.validate(self.extensionIdentifier, name: "extensionIdentifier", parent: name, min: 1)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[^\\/#:\\n]{1,64}$")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 10)
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case parameters = "Parameters"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ValidateConfigurationRequest: AWSEncodableShape {
        /// The application ID.
        public let applicationId: String
        /// The configuration profile ID.
        public let configurationProfileId: String
        /// The version of the configuration to validate.
        public let configurationVersion: String

        public init(applicationId: String, configurationProfileId: String, configurationVersion: String) {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.configurationVersion = configurationVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "ApplicationId")
            request.encodePath(self.configurationProfileId, key: "ConfigurationProfileId")
            request.encodeQuery(self.configurationVersion, key: "configuration_version")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationProfileId, name: "configurationProfileId", parent: name, pattern: "^[a-z0-9]{4,7}$")
            try self.validate(self.configurationVersion, name: "configurationVersion", parent: name, max: 1024)
            try self.validate(self.configurationVersion, name: "configurationVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Validator: AWSEncodableShape & AWSDecodableShape {
        /// Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.
        public let content: String
        /// AppConfig supports validators of type JSON_SCHEMA and LAMBDA
        public let type: ValidatorType

        public init(content: String, type: ValidatorType) {
            self.content = content
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 32768)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case type = "Type"
        }
    }
}

// MARK: - Errors

/// Error enum for AppConfig
public struct AppConfigErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case payloadTooLargeException = "PayloadTooLargeException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppConfig
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The request could not be processed because of conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// There was an internal failure in the AppConfig service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The configuration size is too large.
    public static var payloadTooLargeException: Self { .init(.payloadTooLargeException) }
    /// The requested resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of one more AppConfig resources exceeds the maximum allowed. Verify that your environment doesn't exceed the following service quotas: Applications: 100 max Deployment strategies: 20 max Configuration profiles: 100 max per application Environments: 20 max per application To resolve this issue, you can delete one or more resources and try again. Or, you can request a quota increase. For more information about quotas and to request an increase, see Service quotas for AppConfig in the Amazon Web Services General Reference.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
}

extension AppConfigErrorType: Equatable {
    public static func == (lhs: AppConfigErrorType, rhs: AppConfigErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppConfigErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
