//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS DSQL service.
///
/// This is an interface reference for Amazon Aurora DSQL. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Aurora DSQL. Amazon Aurora DSQL is a serverless, distributed SQL database suitable for workloads of any size. Aurora DSQL is available in both single-Region and multi-Region configurations, so your clusters and databases are always available even if an Availability Zone or an Amazon Web Services Region are unavailable. Aurora DSQL lets you focus on using your data to acquire new insights for your business and customers.
public struct DSQL: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the DSQL client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "DSQL",
            serviceIdentifier: "dsql",
            serviceProtocol: .restjson,
            apiVersion: "2018-05-10",
            endpoint: endpoint,
            errorType: DSQLErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates a cluster in Amazon Aurora DSQL.
    @Sendable
    @inlinable
    public func createCluster(_ input: CreateClusterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateClusterOutput {
        try await self.client.execute(
            operation: "CreateCluster", 
            path: "/cluster", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a cluster in Amazon Aurora DSQL.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the  idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes  successfully, the subsequent retries with the same client token return the  result from the original successful request and they  have no additional effect. If you don't specify a client token, the Amazon Web Services SDK  automatically generates one.
    ///   - deletionProtectionEnabled: If enabled, you can't delete your cluster. You must first disable this property before you can delete your cluster.
    ///   - tags: A map of key and value pairs to use to tag your cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCluster(
        clientToken: String? = CreateClusterInput.idempotencyToken(),
        deletionProtectionEnabled: Bool? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateClusterOutput {
        let input = CreateClusterInput(
            clientToken: clientToken, 
            deletionProtectionEnabled: deletionProtectionEnabled, 
            tags: tags
        )
        return try await self.createCluster(input, logger: logger)
    }

    /// Creates multi-Region clusters in Amazon Aurora DSQL.  Multi-Region clusters require a linked Region list, which is an array of the Regions in which you want to create linked clusters. Multi-Region clusters require a witness Region, which participates in quorum in failure scenarios.
    @Sendable
    @inlinable
    public func createMultiRegionClusters(_ input: CreateMultiRegionClustersInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMultiRegionClustersOutput {
        try await self.client.execute(
            operation: "CreateMultiRegionClusters", 
            path: "/multi-region-clusters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates multi-Region clusters in Amazon Aurora DSQL.  Multi-Region clusters require a linked Region list, which is an array of the Regions in which you want to create linked clusters. Multi-Region clusters require a witness Region, which participates in quorum in failure scenarios.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the  idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes  successfully. The subsequent retries with the same client token return the  result from the original successful request and they  have no additional effect. If you don't specify a client token, the Amazon Web Services SDK  automatically generates one.
    ///   - clusterProperties: A mapping of properties to use when creating linked clusters.
    ///   - linkedRegionList: An array of the Regions in which you want to create additional clusters.
    ///   - witnessRegion: The witness Region of multi-Region clusters.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMultiRegionClusters(
        clientToken: String? = CreateMultiRegionClustersInput.idempotencyToken(),
        clusterProperties: [String: LinkedClusterProperties]? = nil,
        linkedRegionList: [String],
        witnessRegion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMultiRegionClustersOutput {
        let input = CreateMultiRegionClustersInput(
            clientToken: clientToken, 
            clusterProperties: clusterProperties, 
            linkedRegionList: linkedRegionList, 
            witnessRegion: witnessRegion
        )
        return try await self.createMultiRegionClusters(input, logger: logger)
    }

    /// Deletes a cluster in Amazon Aurora DSQL.
    @Sendable
    @inlinable
    public func deleteCluster(_ input: DeleteClusterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteClusterOutput {
        try await self.client.execute(
            operation: "DeleteCluster", 
            path: "/cluster/{identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a cluster in Amazon Aurora DSQL.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the  idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes  successfully. The subsequent retries with the same client token return the  result from the original successful request and they  have no additional effect. If you don't specify a client token, the Amazon Web Services SDK  automatically generates one.
    ///   - identifier: The ID of the cluster to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCluster(
        clientToken: String? = DeleteClusterInput.idempotencyToken(),
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteClusterOutput {
        let input = DeleteClusterInput(
            clientToken: clientToken, 
            identifier: identifier
        )
        return try await self.deleteCluster(input, logger: logger)
    }

    /// Deletes a multi-Region cluster in Amazon Aurora DSQL.
    @Sendable
    @inlinable
    public func deleteMultiRegionClusters(_ input: DeleteMultiRegionClustersInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteMultiRegionClusters", 
            path: "/multi-region-clusters", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a multi-Region cluster in Amazon Aurora DSQL.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the  idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes  successfully. The subsequent retries with the same client token return the  result from the original successful request and they  have no additional effect. If you don't specify a client token, the Amazon Web Services SDK  automatically generates one.
    ///   - linkedClusterArns: The ARNs of the clusters linked to the cluster you want to delete.  also deletes these clusters as part of the operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMultiRegionClusters(
        clientToken: String? = DeleteMultiRegionClustersInput.idempotencyToken(),
        linkedClusterArns: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteMultiRegionClustersInput(
            clientToken: clientToken, 
            linkedClusterArns: linkedClusterArns
        )
        return try await self.deleteMultiRegionClusters(input, logger: logger)
    }

    /// Retrieves information about a cluster.
    @Sendable
    @inlinable
    public func getCluster(_ input: GetClusterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetClusterOutput {
        try await self.client.execute(
            operation: "GetCluster", 
            path: "/cluster/{identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a cluster.
    ///
    /// Parameters:
    ///   - identifier: The ID of the cluster to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCluster(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetClusterOutput {
        let input = GetClusterInput(
            identifier: identifier
        )
        return try await self.getCluster(input, logger: logger)
    }

    /// Retrieves information about a list of clusters.
    @Sendable
    @inlinable
    public func listClusters(_ input: ListClustersInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClustersOutput {
        try await self.client.execute(
            operation: "ListClusters", 
            path: "/cluster", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a list of clusters.
    ///
    /// Parameters:
    ///   - maxResults: An optional parameter that specifies the maximum number of results to return.  You can use nextToken to display the next page of results.
    ///   - nextToken: If your initial ListClusters operation returns a nextToken, you can include the returned nextToken in following ListClusters operations,  which returns results in the next page.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClusters(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClustersOutput {
        let input = ListClustersInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClusters(input, logger: logger)
    }

    /// Lists all of the tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource for which you want to list the tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Tags a resource with a map of key and value pairs.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Tags a resource with a map of key and value pairs.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource that you want to tag.
    ///   - tags: A map of key and value pairs to use to tag your resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a tag from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource from which to remove tags.
    ///   - tagKeys: The array of keys of the tags that you want to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a cluster.
    @Sendable
    @inlinable
    public func updateCluster(_ input: UpdateClusterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateClusterOutput {
        try await self.client.execute(
            operation: "UpdateCluster", 
            path: "/cluster/{identifier}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a cluster.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the  idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes  successfully. The subsequent retries with the same client token return the  result from the original successful request and they  have no additional effect. If you don't specify a client token, the Amazon Web Services SDK  automatically generates one.
    ///   - deletionProtectionEnabled: Specifies whether to enable deletion protection in your cluster.
    ///   - identifier: The ID of the cluster you want to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCluster(
        clientToken: String? = UpdateClusterInput.idempotencyToken(),
        deletionProtectionEnabled: Bool? = nil,
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateClusterOutput {
        let input = UpdateClusterInput(
            clientToken: clientToken, 
            deletionProtectionEnabled: deletionProtectionEnabled, 
            identifier: identifier
        )
        return try await self.updateCluster(input, logger: logger)
    }
}

extension DSQL {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: DSQL, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DSQL {
    /// Return PaginatorSequence for operation ``listClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersPaginator(
        _ input: ListClustersInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClustersInput, ListClustersOutput> {
        return .init(
            input: input,
            command: self.listClusters,
            inputKey: \ListClustersInput.nextToken,
            outputKey: \ListClustersOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: An optional parameter that specifies the maximum number of results to return.  You can use nextToken to display the next page of results.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClustersInput, ListClustersOutput> {
        let input = ListClustersInput(
            maxResults: maxResults
        )
        return self.listClustersPaginator(input, logger: logger)
    }
}

extension DSQL.ListClustersInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> DSQL.ListClustersInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DSQL {
    /// Waiter for operation ``getCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterActive(
        _ input: GetClusterInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetClusterInput, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
            ],
            command: self.getCluster
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - identifier: The ID of the cluster to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterActive(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetClusterInput(
            identifier: identifier
        )
        try await self.waitUntilClusterActive(input, logger: logger)
    }

    /// Waiter for operation ``getCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterNotExists(
        _ input: GetClusterInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetClusterInput, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
            ],
            command: self.getCluster
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - identifier: The ID of the cluster to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterNotExists(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetClusterInput(
            identifier: identifier
        )
        try await self.waitUntilClusterNotExists(input, logger: logger)
    }
}
