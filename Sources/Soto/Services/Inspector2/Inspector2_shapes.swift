//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Inspector2 {
    // MARK: Enums

    public enum AccountSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum AggregationFindingType: String, CustomStringConvertible, Codable, _SotoSendable {
        case networkReachability = "NETWORK_REACHABILITY"
        case packageVulnerability = "PACKAGE_VULNERABILITY"
        public var description: String { return self.rawValue }
    }

    public enum AggregationResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainerImage = "AWS_ECR_CONTAINER_IMAGE"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        public var description: String { return self.rawValue }
    }

    public enum AggregationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case account = "ACCOUNT"
        case ami = "AMI"
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainer = "AWS_ECR_CONTAINER"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        case findingType = "FINDING_TYPE"
        case imageLayer = "IMAGE_LAYER"
        case lambdaLayer = "LAMBDA_LAYER"
        case package = "PACKAGE"
        case repository = "REPOSITORY"
        case title = "TITLE"
        public var description: String { return self.rawValue }
    }

    public enum AmiSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case affectedInstances = "AFFECTED_INSTANCES"
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum Architecture: String, CustomStringConvertible, Codable, _SotoSendable {
        case arm64 = "ARM64"
        case x8664 = "X86_64"
        public var description: String { return self.rawValue }
    }

    public enum AwsEcrContainerSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum CoverageMapComparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CoverageResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainerImage = "AWS_ECR_CONTAINER_IMAGE"
        case awsEcrRepository = "AWS_ECR_REPOSITORY"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        public var description: String { return self.rawValue }
    }

    public enum CoverageStringComparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum Currency: String, CustomStringConvertible, Codable, _SotoSendable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum DelegatedAdminStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Ec2InstanceSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        case networkFindings = "NETWORK_FINDINGS"
        public var description: String { return self.rawValue }
    }

    public enum Ec2Platform: String, CustomStringConvertible, Codable, _SotoSendable {
        case linux = "LINUX"
        case unknown = "UNKNOWN"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum EcrRescanDuration: String, CustomStringConvertible, Codable, _SotoSendable {
        case days180 = "DAYS_180"
        case days30 = "DAYS_30"
        case lifetime = "LIFETIME"
        public var description: String { return self.rawValue }
    }

    public enum EcrRescanDurationStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum EcrScanFrequency: String, CustomStringConvertible, Codable, _SotoSendable {
        case continuousScan = "CONTINUOUS_SCAN"
        case manual = "MANUAL"
        case scanOnPush = "SCAN_ON_PUSH"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case accountIsIsolated = "ACCOUNT_IS_ISOLATED"
        case alreadyEnabled = "ALREADY_ENABLED"
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case disassociateAllMembers = "DISASSOCIATE_ALL_MEMBERS"
        case enableInProgress = "ENABLE_IN_PROGRESS"
        case eventbridgeThrottled = "EVENTBRIDGE_THROTTLED"
        case eventbridgeUnavailable = "EVENTBRIDGE_UNAVAILABLE"
        case internalError = "INTERNAL_ERROR"
        case resourceNotFound = "RESOURCE_NOT_FOUND"
        case resourceScanNotDisabled = "RESOURCE_SCAN_NOT_DISABLED"
        case ssmThrottled = "SSM_THROTTLED"
        case ssmUnavailable = "SSM_UNAVAILABLE"
        case suspendInProgress = "SUSPEND_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ExploitAvailable: String, CustomStringConvertible, Codable, _SotoSendable {
        case no = "NO"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum ExternalReportStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum FilterAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case none = "NONE"
        case suppress = "SUPPRESS"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        case suppressed = "SUPPRESSED"
        public var description: String { return self.rawValue }
    }

    public enum FindingType: String, CustomStringConvertible, Codable, _SotoSendable {
        case networkReachability = "NETWORK_REACHABILITY"
        case packageVulnerability = "PACKAGE_VULNERABILITY"
        public var description: String { return self.rawValue }
    }

    public enum FindingTypeSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum FixAvailable: String, CustomStringConvertible, Codable, _SotoSendable {
        case no = "NO"
        case partial = "PARTIAL"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialInfoErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case internalError = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ec2 = "EC2"
        case ecr = "ECR"
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum GroupKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case accountId = "ACCOUNT_ID"
        case ecrRepositoryName = "ECR_REPOSITORY_NAME"
        case resourceType = "RESOURCE_TYPE"
        case scanStatusCode = "SCAN_STATUS_CODE"
        case scanStatusReason = "SCAN_STATUS_REASON"
        public var description: String { return self.rawValue }
    }

    public enum ImageLayerSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum LambdaFunctionSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum LambdaLayerSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum MapComparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NetworkProtocol: String, CustomStringConvertible, Codable, _SotoSendable {
        case tcp = "TCP"
        case udp = "UDP"
        public var description: String { return self.rawValue }
    }

    public enum Operation: String, CustomStringConvertible, Codable, _SotoSendable {
        case disableRepository = "DISABLE_REPOSITORY"
        case disableScanning = "DISABLE_SCANNING"
        case enableRepository = "ENABLE_REPOSITORY"
        case enableScanning = "ENABLE_SCANNING"
        public var description: String { return self.rawValue }
    }

    public enum PackageManager: String, CustomStringConvertible, Codable, _SotoSendable {
        case bundler = "BUNDLER"
        case cargo = "CARGO"
        case composer = "COMPOSER"
        case gobinary = "GOBINARY"
        case gomod = "GOMOD"
        case jar = "JAR"
        case nodepkg = "NODEPKG"
        case npm = "NPM"
        case nuget = "NUGET"
        case os = "OS"
        case pip = "PIP"
        case pipenv = "PIPENV"
        case poetry = "POETRY"
        case pom = "POM"
        case pythonpkg = "PYTHONPKG"
        case yarn = "YARN"
        public var description: String { return self.rawValue }
    }

    public enum PackageSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum PackageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case image = "IMAGE"
        case zip = "ZIP"
        public var description: String { return self.rawValue }
    }

    public enum RelationshipStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case accountSuspended = "ACCOUNT_SUSPENDED"
        case cannotCreateDetectorInOrgMaster = "CANNOT_CREATE_DETECTOR_IN_ORG_MASTER"
        case created = "CREATED"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case emailVerificationFailed = "EMAIL_VERIFICATION_FAILED"
        case emailVerificationInProgress = "EMAIL_VERIFICATION_IN_PROGRESS"
        case enabled = "ENABLED"
        case invited = "INVITED"
        case regionDisabled = "REGION_DISABLED"
        case removed = "REMOVED"
        case resigned = "RESIGNED"
        public var description: String { return self.rawValue }
    }

    public enum ReportFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum ReportingErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case bucketNotFound = "BUCKET_NOT_FOUND"
        case incompatibleBucketRegion = "INCOMPATIBLE_BUCKET_REGION"
        case internalError = "INTERNAL_ERROR"
        case invalidPermissions = "INVALID_PERMISSIONS"
        case malformedKmsKey = "MALFORMED_KMS_KEY"
        case noFindingsFound = "NO_FINDINGS_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum RepositorySortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case affectedImages = "AFFECTED_IMAGES"
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum ResourceScanType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ec2 = "EC2"
        case ecr = "ECR"
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainerImage = "AWS_ECR_CONTAINER_IMAGE"
        case awsEcrRepository = "AWS_ECR_REPOSITORY"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        public var description: String { return self.rawValue }
    }

    public enum Runtime: String, CustomStringConvertible, Codable, _SotoSendable {
        case go1X = "GO_1_X"
        case java11 = "JAVA_11"
        case java8 = "JAVA_8"
        case java8Al2 = "JAVA_8_AL2"
        case nodejs = "NODEJS"
        case nodejs12X = "NODEJS_12_X"
        case nodejs14X = "NODEJS_14_X"
        case nodejs16X = "NODEJS_16_X"
        case nodejs18X = "NODEJS_18_X"
        case python37 = "PYTHON_3_7"
        case python38 = "PYTHON_3_8"
        case python39 = "PYTHON_3_9"
        case unsupported = "UNSUPPORTED"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatusReason: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case ec2InstanceStopped = "EC2_INSTANCE_STOPPED"
        case excludedByTag = "EXCLUDED_BY_TAG"
        case imageSizeExceeded = "IMAGE_SIZE_EXCEEDED"
        case internalError = "INTERNAL_ERROR"
        case noInventory = "NO_INVENTORY"
        case noResourcesFound = "NO_RESOURCES_FOUND"
        case pendingDisable = "PENDING_DISABLE"
        case pendingInitialScan = "PENDING_INITIAL_SCAN"
        case resourceTerminated = "RESOURCE_TERMINATED"
        case scanEligibilityExpired = "SCAN_ELIGIBILITY_EXPIRED"
        case scanFrequencyManual = "SCAN_FREQUENCY_MANUAL"
        case scanFrequencyScanOnPush = "SCAN_FREQUENCY_SCAN_ON_PUSH"
        case staleInventory = "STALE_INVENTORY"
        case successful = "SUCCESSFUL"
        case unmanagedEc2Instance = "UNMANAGED_EC2_INSTANCE"
        case unsupportedOs = "UNSUPPORTED_OS"
        case unsupportedRuntime = "UNSUPPORTED_RUNTIME"
        public var description: String { return self.rawValue }
    }

    public enum ScanType: String, CustomStringConvertible, Codable, _SotoSendable {
        case network = "NETWORK"
        case package = "PACKAGE"
        public var description: String { return self.rawValue }
    }

    public enum Service: String, CustomStringConvertible, Codable, _SotoSendable {
        case ec2 = "EC2"
        case ecr = "ECR"
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible, Codable, _SotoSendable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        case untriaged = "UNTRIAGED"
        public var description: String { return self.rawValue }
    }

    public enum SortField: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsAccountId = "AWS_ACCOUNT_ID"
        case componentType = "COMPONENT_TYPE"
        case ecrImagePushedAt = "ECR_IMAGE_PUSHED_AT"
        case ecrImageRegistry = "ECR_IMAGE_REGISTRY"
        case ecrImageRepositoryName = "ECR_IMAGE_REPOSITORY_NAME"
        case findingStatus = "FINDING_STATUS"
        case findingType = "FINDING_TYPE"
        case firstObservedAt = "FIRST_OBSERVED_AT"
        case inspectorScore = "INSPECTOR_SCORE"
        case lastObservedAt = "LAST_OBSERVED_AT"
        case networkProtocol = "NETWORK_PROTOCOL"
        case resourceType = "RESOURCE_TYPE"
        case severity = "SEVERITY"
        case vendorSeverity = "VENDOR_SEVERITY"
        case vulnerabilityId = "VULNERABILITY_ID"
        case vulnerabilitySource = "VULNERABILITY_SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case disabling = "DISABLING"
        case enabled = "ENABLED"
        case enabling = "ENABLING"
        case suspended = "SUSPENDED"
        case suspending = "SUSPENDING"
        public var description: String { return self.rawValue }
    }

    public enum StringComparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum TitleSortBy: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum UsageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ec2InstanceHours = "EC2_INSTANCE_HOURS"
        case ecrInitialScan = "ECR_INITIAL_SCAN"
        case ecrRescan = "ECR_RESCAN"
        case lambdaFunctionHours = "LAMBDA_FUNCTION_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum AggregationRequest: AWSEncodableShape, _SotoSendable {
        /// An object that contains details about an aggregation request based on Amazon Web Services account IDs.
        case accountAggregation(AccountAggregation)
        /// An object that contains details about an aggregation request based on Amazon Machine Images (AMIs).
        case amiAggregation(AmiAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR container images.
        case awsEcrContainerAggregation(AwsEcrContainerAggregation)
        /// An object that contains details about an aggregation request based on Amazon EC2 instances.
        case ec2InstanceAggregation(Ec2InstanceAggregation)
        /// An object that contains details about an aggregation request based on finding types.
        case findingTypeAggregation(FindingTypeAggregation)
        /// An object that contains details about an aggregation request based on container image layers.
        case imageLayerAggregation(ImageLayerAggregation)
        /// Returns an object with findings aggregated by AWS Lambda function.
        case lambdaFunctionAggregation(LambdaFunctionAggregation)
        /// Returns an object with findings aggregated by AWS Lambda layer.
        case lambdaLayerAggregation(LambdaLayerAggregation)
        /// An object that contains details about an aggregation request based on operating system package type.
        case packageAggregation(PackageAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR repositories.
        case repositoryAggregation(RepositoryAggregation)
        /// An object that contains details about an aggregation request based on finding title.
        case titleAggregation(TitleAggregation)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .accountAggregation(let value):
                try container.encode(value, forKey: .accountAggregation)
            case .amiAggregation(let value):
                try container.encode(value, forKey: .amiAggregation)
            case .awsEcrContainerAggregation(let value):
                try container.encode(value, forKey: .awsEcrContainerAggregation)
            case .ec2InstanceAggregation(let value):
                try container.encode(value, forKey: .ec2InstanceAggregation)
            case .findingTypeAggregation(let value):
                try container.encode(value, forKey: .findingTypeAggregation)
            case .imageLayerAggregation(let value):
                try container.encode(value, forKey: .imageLayerAggregation)
            case .lambdaFunctionAggregation(let value):
                try container.encode(value, forKey: .lambdaFunctionAggregation)
            case .lambdaLayerAggregation(let value):
                try container.encode(value, forKey: .lambdaLayerAggregation)
            case .packageAggregation(let value):
                try container.encode(value, forKey: .packageAggregation)
            case .repositoryAggregation(let value):
                try container.encode(value, forKey: .repositoryAggregation)
            case .titleAggregation(let value):
                try container.encode(value, forKey: .titleAggregation)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amiAggregation(let value):
                try value.validate(name: "\(name).amiAggregation")
            case .awsEcrContainerAggregation(let value):
                try value.validate(name: "\(name).awsEcrContainerAggregation")
            case .ec2InstanceAggregation(let value):
                try value.validate(name: "\(name).ec2InstanceAggregation")
            case .imageLayerAggregation(let value):
                try value.validate(name: "\(name).imageLayerAggregation")
            case .lambdaFunctionAggregation(let value):
                try value.validate(name: "\(name).lambdaFunctionAggregation")
            case .lambdaLayerAggregation(let value):
                try value.validate(name: "\(name).lambdaLayerAggregation")
            case .packageAggregation(let value):
                try value.validate(name: "\(name).packageAggregation")
            case .repositoryAggregation(let value):
                try value.validate(name: "\(name).repositoryAggregation")
            case .titleAggregation(let value):
                try value.validate(name: "\(name).titleAggregation")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregation
            case amiAggregation
            case awsEcrContainerAggregation
            case ec2InstanceAggregation
            case findingTypeAggregation
            case imageLayerAggregation
            case lambdaFunctionAggregation
            case lambdaLayerAggregation
            case packageAggregation
            case repositoryAggregation
            case titleAggregation
        }
    }

    public enum AggregationResponse: AWSDecodableShape, _SotoSendable {
        /// An object that contains details about an aggregation response based on Amazon Web Services account IDs.
        case accountAggregation(AccountAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon Machine Images (AMIs).
        case amiAggregation(AmiAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR container images.
        case awsEcrContainerAggregation(AwsEcrContainerAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon EC2 instances.
        case ec2InstanceAggregation(Ec2InstanceAggregationResponse)
        /// An object that contains details about an aggregation response based on finding types.
        case findingTypeAggregation(FindingTypeAggregationResponse)
        /// An object that contains details about an aggregation response based on container image layers.
        case imageLayerAggregation(ImageLayerAggregationResponse)
        /// An aggregation of findings by AWS Lambda function.
        case lambdaFunctionAggregation(LambdaFunctionAggregationResponse)
        /// An aggregation of findings by AWS Lambda layer.
        case lambdaLayerAggregation(LambdaLayerAggregationResponse)
        /// An object that contains details about an aggregation response based on operating system package type.
        case packageAggregation(PackageAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR repositories.
        case repositoryAggregation(RepositoryAggregationResponse)
        /// An object that contains details about an aggregation response based on finding title.
        case titleAggregation(TitleAggregationResponse)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accountAggregation:
                let value = try container.decode(AccountAggregationResponse.self, forKey: .accountAggregation)
                self = .accountAggregation(value)
            case .amiAggregation:
                let value = try container.decode(AmiAggregationResponse.self, forKey: .amiAggregation)
                self = .amiAggregation(value)
            case .awsEcrContainerAggregation:
                let value = try container.decode(AwsEcrContainerAggregationResponse.self, forKey: .awsEcrContainerAggregation)
                self = .awsEcrContainerAggregation(value)
            case .ec2InstanceAggregation:
                let value = try container.decode(Ec2InstanceAggregationResponse.self, forKey: .ec2InstanceAggregation)
                self = .ec2InstanceAggregation(value)
            case .findingTypeAggregation:
                let value = try container.decode(FindingTypeAggregationResponse.self, forKey: .findingTypeAggregation)
                self = .findingTypeAggregation(value)
            case .imageLayerAggregation:
                let value = try container.decode(ImageLayerAggregationResponse.self, forKey: .imageLayerAggregation)
                self = .imageLayerAggregation(value)
            case .lambdaFunctionAggregation:
                let value = try container.decode(LambdaFunctionAggregationResponse.self, forKey: .lambdaFunctionAggregation)
                self = .lambdaFunctionAggregation(value)
            case .lambdaLayerAggregation:
                let value = try container.decode(LambdaLayerAggregationResponse.self, forKey: .lambdaLayerAggregation)
                self = .lambdaLayerAggregation(value)
            case .packageAggregation:
                let value = try container.decode(PackageAggregationResponse.self, forKey: .packageAggregation)
                self = .packageAggregation(value)
            case .repositoryAggregation:
                let value = try container.decode(RepositoryAggregationResponse.self, forKey: .repositoryAggregation)
                self = .repositoryAggregation(value)
            case .titleAggregation:
                let value = try container.decode(TitleAggregationResponse.self, forKey: .titleAggregation)
                self = .titleAggregation(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregation
            case amiAggregation
            case awsEcrContainerAggregation
            case ec2InstanceAggregation
            case findingTypeAggregation
            case imageLayerAggregation
            case lambdaFunctionAggregation
            case lambdaLayerAggregation
            case packageAggregation
            case repositoryAggregation
            case titleAggregation
        }
    }

    // MARK: Shapes

    public struct Account: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String
        /// Details of the status of Amazon Inspector scans by resource type.
        public let resourceStatus: ResourceStatus
        /// The status of Amazon Inspector for the account.
        public let status: Status

        public init(accountId: String, resourceStatus: ResourceStatus, status: Status) {
            self.accountId = accountId
            self.resourceStatus = resourceStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case resourceStatus
            case status
        }
    }

    public struct AccountAggregation: AWSEncodableShape {
        /// The type of finding.
        public let findingType: AggregationFindingType?
        /// The type of resource.
        public let resourceType: AggregationResourceType?
        /// The value to sort by.
        public let sortBy: AccountSortBy?
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder?

        public init(findingType: AggregationFindingType? = nil, resourceType: AggregationResourceType? = nil, sortBy: AccountSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case findingType
            case resourceType
            case sortBy
            case sortOrder
        }
    }

    public struct AccountAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The number of findings by severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case severityCounts
        }
    }

    public struct AccountState: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public let resourceState: ResourceState
        /// An object detailing the status of Amazon Inspector for the account.
        public let state: State

        public init(accountId: String, resourceState: ResourceState, state: State) {
            self.accountId = accountId
            self.resourceState = resourceState
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case resourceState
            case state
        }
    }

    public struct AmiAggregation: AWSEncodableShape {
        /// The IDs of AMIs to aggregate findings for.
        public let amis: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: AmiSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        public init(amis: [StringFilter]? = nil, sortBy: AmiSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.amis = amis
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.amis?.forEach {
                try $0.validate(name: "\(name).amis[]")
            }
            try self.validate(self.amis, name: "amis", parent: name, max: 10)
            try self.validate(self.amis, name: "amis", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amis
            case sortBy
            case sortOrder
        }
    }

    public struct AmiAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID for the AMI.
        public let accountId: String?
        /// The IDs of Amazon EC2 instances using this AMI.
        public let affectedInstances: Int64?
        /// The ID of the AMI that findings were aggregated for.
        public let ami: String
        /// An object that contains the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, affectedInstances: Int64? = nil, ami: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.affectedInstances = affectedInstances
            self.ami = ami
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case affectedInstances
            case ami
            case severityCounts
        }
    }

    public struct AssociateMemberRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the member account to be associated.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
        }
    }

    public struct AssociateMemberResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully associated member account.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
        }
    }

    public struct AutoEnable: AWSEncodableShape & AWSDecodableShape {
        /// Represents whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
        public let ec2: Bool
        /// Represents whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
        public let ecr: Bool
        /// Represents whether AWS Lambda scans are automatically enabled for new members of your Amazon Inspector organization.
        public let lambda: Bool?

        public init(ec2: Bool, ecr: Bool, lambda: Bool? = nil) {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
        }

        private enum CodingKeys: String, CodingKey {
            case ec2
            case ecr
            case lambda
        }
    }

    public struct AwsEc2InstanceDetails: AWSDecodableShape {
        /// The IAM instance profile ARN of the Amazon EC2 instance.
        public let iamInstanceProfileArn: String?
        /// The image ID of the Amazon EC2 instance.
        public let imageId: String?
        /// The IPv4 addresses of the Amazon EC2 instance.
        public let ipV4Addresses: [String]?
        /// The IPv6 addresses of the Amazon EC2 instance.
        public let ipV6Addresses: [String]?
        /// The name of the key pair used to launch the Amazon EC2 instance.
        public let keyName: String?
        /// The date and time the Amazon EC2 instance was launched at.
        public let launchedAt: Date?
        /// The platform of the Amazon EC2 instance.
        public let platform: String?
        /// The subnet ID of the Amazon EC2 instance.
        public let subnetId: String?
        /// The type of the Amazon EC2 instance.
        public let type: String?
        /// The VPC ID of the Amazon EC2 instance.
        public let vpcId: String?

        public init(iamInstanceProfileArn: String? = nil, imageId: String? = nil, ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil, keyName: String? = nil, launchedAt: Date? = nil, platform: String? = nil, subnetId: String? = nil, type: String? = nil, vpcId: String? = nil) {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.platform = platform
            self.subnetId = subnetId
            self.type = type
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case iamInstanceProfileArn
            case imageId
            case ipV4Addresses
            case ipV6Addresses
            case keyName
            case launchedAt
            case platform
            case subnetId
            case type
            case vpcId
        }
    }

    public struct AwsEcrContainerAggregation: AWSEncodableShape {
        /// The architecture of the containers.
        public let architectures: [StringFilter]?
        /// The image SHA values.
        public let imageShas: [StringFilter]?
        /// The image tags.
        public let imageTags: [StringFilter]?
        /// The container repositories.
        public let repositories: [StringFilter]?
        /// The container resource IDs.
        public let resourceIds: [StringFilter]?
        /// The value to sort by.
        public let sortBy: AwsEcrContainerSortBy?
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder?

        public init(architectures: [StringFilter]? = nil, imageShas: [StringFilter]? = nil, imageTags: [StringFilter]? = nil, repositories: [StringFilter]? = nil, resourceIds: [StringFilter]? = nil, sortBy: AwsEcrContainerSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.architectures = architectures
            self.imageShas = imageShas
            self.imageTags = imageTags
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.architectures?.forEach {
                try $0.validate(name: "\(name).architectures[]")
            }
            try self.validate(self.architectures, name: "architectures", parent: name, max: 10)
            try self.validate(self.architectures, name: "architectures", parent: name, min: 1)
            try self.imageShas?.forEach {
                try $0.validate(name: "\(name).imageShas[]")
            }
            try self.validate(self.imageShas, name: "imageShas", parent: name, max: 10)
            try self.validate(self.imageShas, name: "imageShas", parent: name, min: 1)
            try self.imageTags?.forEach {
                try $0.validate(name: "\(name).imageTags[]")
            }
            try self.validate(self.imageTags, name: "imageTags", parent: name, max: 10)
            try self.validate(self.imageTags, name: "imageTags", parent: name, min: 1)
            try self.repositories?.forEach {
                try $0.validate(name: "\(name).repositories[]")
            }
            try self.validate(self.repositories, name: "repositories", parent: name, max: 10)
            try self.validate(self.repositories, name: "repositories", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case architectures
            case imageShas
            case imageTags
            case repositories
            case resourceIds
            case sortBy
            case sortOrder
        }
    }

    public struct AwsEcrContainerAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the account that owns the container.
        public let accountId: String?
        /// The architecture of the container.
        public let architecture: String?
        /// The SHA value of the container image.
        public let imageSha: String?
        /// The container image stags.
        public let imageTags: [String]?
        /// The container repository.
        public let repository: String?
        /// The resource ID of the container.
        public let resourceId: String
        /// The number of finding by severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, architecture: String? = nil, imageSha: String? = nil, imageTags: [String]? = nil, repository: String? = nil, resourceId: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.architecture = architecture
            self.imageSha = imageSha
            self.imageTags = imageTags
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case architecture
            case imageSha
            case imageTags
            case repository
            case resourceId
            case severityCounts
        }
    }

    public struct AwsEcrContainerImageDetails: AWSDecodableShape {
        /// The architecture of the Amazon ECR container image.
        public let architecture: String?
        /// The image author of the Amazon ECR container image.
        public let author: String?
        /// The image hash of the Amazon ECR container image.
        public let imageHash: String
        /// The image tags attached to the Amazon ECR container image.
        public let imageTags: [String]?
        /// The platform of the Amazon ECR container image.
        public let platform: String?
        /// The date and time the Amazon ECR container image was pushed.
        public let pushedAt: Date?
        /// The registry for the Amazon ECR container image.
        public let registry: String
        /// The name of the repository the Amazon ECR container image resides in.
        public let repositoryName: String

        public init(architecture: String? = nil, author: String? = nil, imageHash: String, imageTags: [String]? = nil, platform: String? = nil, pushedAt: Date? = nil, registry: String, repositoryName: String) {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case architecture
            case author
            case imageHash
            case imageTags
            case platform
            case pushedAt
            case registry
            case repositoryName
        }
    }

    public struct AwsLambdaFunctionDetails: AWSDecodableShape {
        /// The instruction set architecture that the AWS Lambda function supports. Architecture is a string array with one of the  valid values. The default architecture value is x86_64.
        public let architectures: [Architecture]?
        /// The SHA256 hash of the AWS Lambda function's deployment package.
        public let codeSha256: String
        /// The AWS Lambda function's execution role.
        public let executionRoleArn: String
        /// The name of the AWS Lambda function.
        public let functionName: String
        /// The date and time that a user last updated the configuration, in ISO 8601 format
        public let lastModifiedAt: Date?
        /// The AWS Lambda function's  layers. A Lambda function can have up to five layers.
        public let layers: [String]?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public let packageType: PackageType?
        /// The runtime environment for the AWS Lambda function.
        public let runtime: Runtime
        /// The version of the AWS Lambda function.
        public let version: String
        /// The AWS Lambda function's networking configuration.
        public let vpcConfig: LambdaVpcConfig?

        public init(architectures: [Architecture]? = nil, codeSha256: String, executionRoleArn: String, functionName: String, lastModifiedAt: Date? = nil, layers: [String]? = nil, packageType: PackageType? = nil, runtime: Runtime, version: String, vpcConfig: LambdaVpcConfig? = nil) {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.executionRoleArn = executionRoleArn
            self.functionName = functionName
            self.lastModifiedAt = lastModifiedAt
            self.layers = layers
            self.packageType = packageType
            self.runtime = runtime
            self.version = version
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case architectures
            case codeSha256
            case executionRoleArn
            case functionName
            case lastModifiedAt
            case layers
            case packageType
            case runtime
            case version
            case vpcConfig
        }
    }

    public struct BatchGetAccountStatusRequest: AWSEncodableShape {
        /// The 12-digit Amazon Web Services account IDs of the accounts to retrieve Amazon Inspector status for.
        public let accountIds: [String]?

        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct BatchGetAccountStatusResponse: AWSDecodableShape {
        /// An array of objects that provide details on the status of Amazon Inspector for each of the requested accounts.
        public let accounts: [AccountState]
        /// An array of objects detailing any accounts that failed to enable Amazon Inspector and why.
        public let failedAccounts: [FailedAccount]?

        public init(accounts: [AccountState], failedAccounts: [FailedAccount]? = nil) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts
            case failedAccounts
        }
    }

    public struct BatchGetFreeTrialInfoRequest: AWSEncodableShape {
        /// The account IDs to get free trial status for.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "[0-9]{12}")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct BatchGetFreeTrialInfoResponse: AWSDecodableShape {
        /// An array of objects that provide Amazon Inspector free trial details for each of the requested accounts.
        public let accounts: [FreeTrialAccountInfo]
        /// An array of objects detailing any accounts that free trial data could not be returned for.
        public let failedAccounts: [FreeTrialInfoError]

        public init(accounts: [FreeTrialAccountInfo], failedAccounts: [FreeTrialInfoError]) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts
            case failedAccounts
        }
    }

    public struct CancelFindingsReportRequest: AWSEncodableShape {
        /// The ID of the report to be canceled.
        public let reportId: String

        public init(reportId: String) {
            self.reportId = reportId
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "\\b[a-f0-9]{8}\\b-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-\\b[a-f0-9]{12}\\b")
        }

        private enum CodingKeys: String, CodingKey {
            case reportId
        }
    }

    public struct CancelFindingsReportResponse: AWSDecodableShape {
        /// The ID of the canceled report.
        public let reportId: String

        public init(reportId: String) {
            self.reportId = reportId
        }

        private enum CodingKeys: String, CodingKey {
            case reportId
        }
    }

    public struct Counts: AWSDecodableShape {
        /// The number of resources.
        public let count: Int64?
        /// The key associated with this group
        public let groupKey: GroupKey?

        public init(count: Int64? = nil, groupKey: GroupKey? = nil) {
            self.count = count
            self.groupKey = groupKey
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case groupKey
        }
    }

    public struct CoverageFilterCriteria: AWSEncodableShape {
        /// An array of Amazon Web Services account IDs to return coverage statistics for.
        public let accountId: [CoverageStringFilter]?
        /// The Amazon EC2 instance tags to filter on.
        public let ec2InstanceTags: [CoverageMapFilter]?
        /// The Amazon ECR image tags to filter on.
        public let ecrImageTags: [CoverageStringFilter]?
        /// The Amazon ECR repository name to filter on.
        public let ecrRepositoryName: [CoverageStringFilter]?
        /// Returns coverage statistics for AWS Lambda functions filtered by function names.
        public let lambdaFunctionName: [CoverageStringFilter]?
        /// Returns coverage statistics for AWS Lambda functions filtered by runtime.
        public let lambdaFunctionRuntime: [CoverageStringFilter]?
        /// Returns coverage statistics for AWS Lambda functions filtered by tag.
        public let lambdaFunctionTags: [CoverageMapFilter]?
        /// An array of Amazon Web Services resource IDs to return coverage statistics for.
        public let resourceId: [CoverageStringFilter]?
        /// An array of Amazon Web Services resource types to return coverage statistics for. The values can be AWS_EC2_INSTANCE or AWS_ECR_REPOSITORY.
        public let resourceType: [CoverageStringFilter]?
        /// The scan status code to filter on.
        public let scanStatusCode: [CoverageStringFilter]?
        /// The scan status reason to filter on.
        public let scanStatusReason: [CoverageStringFilter]?
        /// An array of Amazon Inspector scan types to return coverage statistics for.
        public let scanType: [CoverageStringFilter]?

        public init(accountId: [CoverageStringFilter]? = nil, ec2InstanceTags: [CoverageMapFilter]? = nil, ecrImageTags: [CoverageStringFilter]? = nil, ecrRepositoryName: [CoverageStringFilter]? = nil, lambdaFunctionName: [CoverageStringFilter]? = nil, lambdaFunctionRuntime: [CoverageStringFilter]? = nil, lambdaFunctionTags: [CoverageMapFilter]? = nil, resourceId: [CoverageStringFilter]? = nil, resourceType: [CoverageStringFilter]? = nil, scanStatusCode: [CoverageStringFilter]? = nil, scanStatusReason: [CoverageStringFilter]? = nil, scanType: [CoverageStringFilter]? = nil) {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lambdaFunctionTags = lambdaFunctionTags
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.scanStatusCode = scanStatusCode
            self.scanStatusReason = scanStatusReason
            self.scanType = scanType
        }

        public func validate(name: String) throws {
            try self.accountId?.forEach {
                try $0.validate(name: "\(name).accountId[]")
            }
            try self.validate(self.accountId, name: "accountId", parent: name, max: 10)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 1)
            try self.ec2InstanceTags?.forEach {
                try $0.validate(name: "\(name).ec2InstanceTags[]")
            }
            try self.validate(self.ec2InstanceTags, name: "ec2InstanceTags", parent: name, max: 10)
            try self.validate(self.ec2InstanceTags, name: "ec2InstanceTags", parent: name, min: 1)
            try self.ecrImageTags?.forEach {
                try $0.validate(name: "\(name).ecrImageTags[]")
            }
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, max: 10)
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, min: 1)
            try self.ecrRepositoryName?.forEach {
                try $0.validate(name: "\(name).ecrRepositoryName[]")
            }
            try self.validate(self.ecrRepositoryName, name: "ecrRepositoryName", parent: name, max: 10)
            try self.validate(self.ecrRepositoryName, name: "ecrRepositoryName", parent: name, min: 1)
            try self.lambdaFunctionName?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionName[]")
            }
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, max: 10)
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, min: 1)
            try self.lambdaFunctionRuntime?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionRuntime[]")
            }
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, max: 10)
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, min: 1)
            try self.lambdaFunctionTags?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionTags[]")
            }
            try self.validate(self.lambdaFunctionTags, name: "lambdaFunctionTags", parent: name, max: 10)
            try self.validate(self.lambdaFunctionTags, name: "lambdaFunctionTags", parent: name, min: 1)
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 10)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 10)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
            try self.scanStatusCode?.forEach {
                try $0.validate(name: "\(name).scanStatusCode[]")
            }
            try self.validate(self.scanStatusCode, name: "scanStatusCode", parent: name, max: 10)
            try self.validate(self.scanStatusCode, name: "scanStatusCode", parent: name, min: 1)
            try self.scanStatusReason?.forEach {
                try $0.validate(name: "\(name).scanStatusReason[]")
            }
            try self.validate(self.scanStatusReason, name: "scanStatusReason", parent: name, max: 10)
            try self.validate(self.scanStatusReason, name: "scanStatusReason", parent: name, min: 1)
            try self.scanType?.forEach {
                try $0.validate(name: "\(name).scanType[]")
            }
            try self.validate(self.scanType, name: "scanType", parent: name, max: 10)
            try self.validate(self.scanType, name: "scanType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case ec2InstanceTags
            case ecrImageTags
            case ecrRepositoryName
            case lambdaFunctionName
            case lambdaFunctionRuntime
            case lambdaFunctionTags
            case resourceId
            case resourceType
            case scanStatusCode
            case scanStatusReason
            case scanType
        }
    }

    public struct CoverageMapFilter: AWSEncodableShape {
        /// The operator to compare coverage on.
        public let comparison: CoverageMapComparison
        /// The tag key associated with the coverage map filter.
        public let key: String
        /// The tag value associated with the coverage map filter.
        public let value: String?

        public init(comparison: CoverageMapComparison, key: String, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison
            case key
            case value
        }
    }

    public struct CoverageStringFilter: AWSEncodableShape {
        /// The operator to compare strings on.
        public let comparison: CoverageStringComparison
        /// The value to compare strings on.
        public let value: String

        public init(comparison: CoverageStringComparison, value: String) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison
            case value
        }
    }

    public struct CoveredResource: AWSDecodableShape {
        /// The Amazon Web Services account ID of the covered resource.
        public let accountId: String
        /// The ID of the covered resource.
        public let resourceId: String
        /// An object that contains details about the metadata.
        public let resourceMetadata: ResourceScanMetadata?
        /// The type of the covered resource.
        public let resourceType: CoverageResourceType
        /// The status of the scan covering the resource.
        public let scanStatus: ScanStatus?
        /// The Amazon Inspector scan type covering the resource.
        public let scanType: ScanType

        public init(accountId: String, resourceId: String, resourceMetadata: ResourceScanMetadata? = nil, resourceType: CoverageResourceType, scanStatus: ScanStatus? = nil, scanType: ScanType) {
            self.accountId = accountId
            self.resourceId = resourceId
            self.resourceMetadata = resourceMetadata
            self.resourceType = resourceType
            self.scanStatus = scanStatus
            self.scanType = scanType
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case resourceId
            case resourceMetadata
            case resourceType
            case scanStatus
            case scanType
        }
    }

    public struct CreateFilterRequest: AWSEncodableShape {
        /// Defines the action that is to be applied to the findings that match the filter.
        public let action: FilterAction
        /// A description of the filter.
        public let description: String?
        /// Defines the criteria to be used in the filter for querying findings.
        public let filterCriteria: FilterCriteria
        /// The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.
        public let name: String
        /// The reason for creating the filter.
        public let reason: String?
        /// A list of tags for the filter.
        public let tags: [String: String]?

        public init(action: FilterAction, description: String? = nil, filterCriteria: FilterCriteria, name: String, reason: String? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.description = description
            self.filterCriteria = filterCriteria
            self.name = name
            self.reason = reason
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.filterCriteria.validate(name: "\(name).filterCriteria")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.reason, name: "reason", parent: name, max: 512)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case description
            case filterCriteria
            case name
            case reason
            case tags
        }
    }

    public struct CreateFilterResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the successfully created filter.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct CreateFindingsReportRequest: AWSEncodableShape {
        /// The filter criteria to apply to the results of the finding report.
        public let filterCriteria: FilterCriteria?
        /// The format to generate the report in.
        public let reportFormat: ReportFormat
        /// The Amazon S3 export destination for the report.
        public let s3Destination: Destination

        public init(filterCriteria: FilterCriteria? = nil, reportFormat: ReportFormat, s3Destination: Destination) {
            self.filterCriteria = filterCriteria
            self.reportFormat = reportFormat
            self.s3Destination = s3Destination
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria
            case reportFormat
            case s3Destination
        }
    }

    public struct CreateFindingsReportResponse: AWSDecodableShape {
        /// The ID of the report.
        public let reportId: String?

        public init(reportId: String? = nil) {
            self.reportId = reportId
        }

        private enum CodingKeys: String, CodingKey {
            case reportId
        }
    }

    public struct CvssScore: AWSDecodableShape {
        /// The base CVSS score used for the finding.
        public let baseScore: Double
        /// The vector string of the CVSS score.
        public let scoringVector: String
        /// The source of the CVSS score.
        public let source: String
        /// The version of CVSS used for the score.
        public let version: String

        public init(baseScore: Double, scoringVector: String, source: String, version: String) {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case baseScore
            case scoringVector
            case source
            case version
        }
    }

    public struct CvssScoreAdjustment: AWSDecodableShape {
        /// The metric used to adjust the CVSS score.
        public let metric: String
        /// The reason the CVSS score has been adjustment.
        public let reason: String

        public init(metric: String, reason: String) {
            self.metric = metric
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case metric
            case reason
        }
    }

    public struct CvssScoreDetails: AWSDecodableShape {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public let adjustments: [CvssScoreAdjustment]?
        /// The source of the CVSS data.
        public let cvssSource: String?
        /// The CVSS score.
        public let score: Double
        /// The source for the CVSS score.
        public let scoreSource: String
        /// The vector for the CVSS score.
        public let scoringVector: String
        /// The CVSS version used in scoring.
        public let version: String

        public init(adjustments: [CvssScoreAdjustment]? = nil, cvssSource: String? = nil, score: Double, scoreSource: String, scoringVector: String, version: String) {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case adjustments
            case cvssSource
            case score
            case scoreSource
            case scoringVector
            case version
        }
    }

    public struct DateFilter: AWSEncodableShape & AWSDecodableShape {
        /// A timestamp representing the end of the time period filtered on.
        public let endInclusive: Date?
        /// A timestamp representing the start of the time period filtered on.
        public let startInclusive: Date?

        public init(endInclusive: Date? = nil, startInclusive: Date? = nil) {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case endInclusive
            case startInclusive
        }
    }

    public struct DelegatedAdmin: AWSDecodableShape {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public let accountId: String?
        /// The status of the Amazon Inspector delegated administrator.
        public let relationshipStatus: RelationshipStatus?

        public init(accountId: String? = nil, relationshipStatus: RelationshipStatus? = nil) {
            self.accountId = accountId
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case relationshipStatus
        }
    }

    public struct DelegatedAdminAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public let accountId: String?
        /// The status of the Amazon Inspector delegated administrator.
        public let status: DelegatedAdminStatus?

        public init(accountId: String? = nil, status: DelegatedAdminStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case status
        }
    }

    public struct DeleteFilterRequest: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) of the filter to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteFilterResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the filter that has been deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        /// The scan types are automatically enabled for new members of your organization.
        public let autoEnable: AutoEnable?
        /// Represents whether your organization has reached the maximum Amazon Web Services account limit for Amazon Inspector.
        public let maxAccountLimitReached: Bool?

        public init(autoEnable: AutoEnable? = nil, maxAccountLimitReached: Bool? = nil) {
            self.autoEnable = autoEnable
            self.maxAccountLimitReached = maxAccountLimitReached
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
            case maxAccountLimitReached
        }
    }

    public struct Destination: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket to export findings to.
        public let bucketName: String
        /// The prefix of the KMS key used to export findings.
        public let keyPrefix: String?
        /// The ARN of the KMS key used to encrypt data when exporting findings.
        public let kmsKeyArn: String

        public init(bucketName: String, keyPrefix: String? = nil, kmsKeyArn: String) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case keyPrefix
            case kmsKeyArn
        }
    }

    public struct DisableDelegatedAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the current Amazon Inspector delegated administrator.
        public let delegatedAdminAccountId: String

        public init(delegatedAdminAccountId: String) {
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, max: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, min: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccountId
        }
    }

    public struct DisableDelegatedAdminAccountResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully disabled delegated administrator.
        public let delegatedAdminAccountId: String

        public init(delegatedAdminAccountId: String) {
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccountId
        }
    }

    public struct DisableRequest: AWSEncodableShape {
        /// An array of account IDs you want to disable Amazon Inspector scans for.
        public let accountIds: [String]?
        /// The resource scan types you want to disable.
        public let resourceTypes: [ResourceScanType]?

        public init(accountIds: [String]? = nil, resourceTypes: [ResourceScanType]? = nil) {
            self.accountIds = accountIds
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case resourceTypes
        }
    }

    public struct DisableResponse: AWSDecodableShape {
        /// Information on the accounts that have had Amazon Inspector scans successfully disabled. Details are provided for each account.
        public let accounts: [Account]
        /// Information on any accounts for which Amazon Inspector scans could not be disabled. Details are provided for each account.
        public let failedAccounts: [FailedAccount]?

        public init(accounts: [Account], failedAccounts: [FailedAccount]? = nil) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts
            case failedAccounts
        }
    }

    public struct DisassociateMemberRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the member account to disassociate.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
        }
    }

    public struct DisassociateMemberResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully disassociated member.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
        }
    }

    public struct Ec2InstanceAggregation: AWSEncodableShape {
        /// The AMI IDs associated with the Amazon EC2 instances to aggregate findings for.
        public let amis: [StringFilter]?
        /// The Amazon EC2 instance IDs to aggregate findings for.
        public let instanceIds: [StringFilter]?
        /// The Amazon EC2 instance tags to aggregate findings for.
        public let instanceTags: [MapFilter]?
        /// The operating system types to aggregate findings for. Valid values must be uppercase and underscore separated, examples are ORACLE_LINUX_7 and ALPINE_LINUX_3_8.
        public let operatingSystems: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: Ec2InstanceSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        public init(amis: [StringFilter]? = nil, instanceIds: [StringFilter]? = nil, instanceTags: [MapFilter]? = nil, operatingSystems: [StringFilter]? = nil, sortBy: Ec2InstanceSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.amis = amis
            self.instanceIds = instanceIds
            self.instanceTags = instanceTags
            self.operatingSystems = operatingSystems
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.amis?.forEach {
                try $0.validate(name: "\(name).amis[]")
            }
            try self.validate(self.amis, name: "amis", parent: name, max: 10)
            try self.validate(self.amis, name: "amis", parent: name, min: 1)
            try self.instanceIds?.forEach {
                try $0.validate(name: "\(name).instanceIds[]")
            }
            try self.validate(self.instanceIds, name: "instanceIds", parent: name, max: 10)
            try self.validate(self.instanceIds, name: "instanceIds", parent: name, min: 1)
            try self.instanceTags?.forEach {
                try $0.validate(name: "\(name).instanceTags[]")
            }
            try self.validate(self.instanceTags, name: "instanceTags", parent: name, max: 10)
            try self.validate(self.instanceTags, name: "instanceTags", parent: name, min: 1)
            try self.operatingSystems?.forEach {
                try $0.validate(name: "\(name).operatingSystems[]")
            }
            try self.validate(self.operatingSystems, name: "operatingSystems", parent: name, max: 10)
            try self.validate(self.operatingSystems, name: "operatingSystems", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amis
            case instanceIds
            case instanceTags
            case operatingSystems
            case sortBy
            case sortOrder
        }
    }

    public struct Ec2InstanceAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account for the Amazon EC2 instance.
        public let accountId: String?
        /// The Amazon Machine Image (AMI) of the Amazon EC2 instance.
        public let ami: String?
        /// The Amazon EC2 instance ID.
        public let instanceId: String
        /// The tags attached to the instance.
        public let instanceTags: [String: String]?
        /// The number of network findings for the Amazon EC2 instance.
        public let networkFindings: Int64?
        /// The operating system of the Amazon EC2 instance.
        public let operatingSystem: String?
        /// An object that contains the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, ami: String? = nil, instanceId: String, instanceTags: [String: String]? = nil, networkFindings: Int64? = nil, operatingSystem: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.ami = ami
            self.instanceId = instanceId
            self.instanceTags = instanceTags
            self.networkFindings = networkFindings
            self.operatingSystem = operatingSystem
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case ami
            case instanceId
            case instanceTags
            case networkFindings
            case operatingSystem
            case severityCounts
        }
    }

    public struct Ec2Metadata: AWSDecodableShape {
        /// The ID of the Amazon Machine Image (AMI) used to launch the instance.
        public let amiId: String?
        /// The platform of the instance.
        public let platform: Ec2Platform?
        /// The tags attached to the instance.
        public let tags: [String: String]?

        public init(amiId: String? = nil, platform: Ec2Platform? = nil, tags: [String: String]? = nil) {
            self.amiId = amiId
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case amiId
            case platform
            case tags
        }
    }

    public struct EcrConfiguration: AWSEncodableShape {
        /// The ECR automated re-scan duration defines how long an ECR image will be actively scanned by Amazon Inspector. When the number of days since an image was last pushed exceeds the automated re-scan duration the monitoring state of that image becomes inactive and all associated findings are scheduled for closure.
        public let rescanDuration: EcrRescanDuration

        public init(rescanDuration: EcrRescanDuration) {
            self.rescanDuration = rescanDuration
        }

        private enum CodingKeys: String, CodingKey {
            case rescanDuration
        }
    }

    public struct EcrConfigurationState: AWSDecodableShape {
        /// An object that contains details about the state of the ECR automated re-scan setting.
        public let rescanDurationState: EcrRescanDurationState?

        public init(rescanDurationState: EcrRescanDurationState? = nil) {
            self.rescanDurationState = rescanDurationState
        }

        private enum CodingKeys: String, CodingKey {
            case rescanDurationState
        }
    }

    public struct EcrContainerImageMetadata: AWSDecodableShape {
        /// Tags associated with the Amazon ECR image metadata.
        public let tags: [String]?

        public init(tags: [String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct EcrRepositoryMetadata: AWSDecodableShape {
        /// The name of the Amazon ECR repository.
        public let name: String?
        /// The frequency of scans.
        public let scanFrequency: EcrScanFrequency?

        public init(name: String? = nil, scanFrequency: EcrScanFrequency? = nil) {
            self.name = name
            self.scanFrequency = scanFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case scanFrequency
        }
    }

    public struct EcrRescanDurationState: AWSDecodableShape {
        /// The ECR automated re-scan duration defines how long an ECR image will be actively scanned by Amazon Inspector. When the number of days since an image was last pushed exceeds the automated re-scan duration the monitoring state of that image becomes inactive and all associated findings are scheduled for closure.
        public let rescanDuration: EcrRescanDuration?
        /// The status of changes to the ECR automated re-scan duration.
        public let status: EcrRescanDurationStatus?
        /// A timestamp representing when the last time the ECR scan duration setting was changed.
        public let updatedAt: Date?

        public init(rescanDuration: EcrRescanDuration? = nil, status: EcrRescanDurationStatus? = nil, updatedAt: Date? = nil) {
            self.rescanDuration = rescanDuration
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case rescanDuration
            case status
            case updatedAt
        }
    }

    public struct EnableDelegatedAdminAccountRequest: AWSEncodableShape {
        /// The idempotency token for the request.
        public let clientToken: String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
        public let delegatedAdminAccountId: String

        public init(clientToken: String? = EnableDelegatedAdminAccountRequest.idempotencyToken(), delegatedAdminAccountId: String) {
            self.clientToken = clientToken
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, max: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, min: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case delegatedAdminAccountId
        }
    }

    public struct EnableDelegatedAdminAccountResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully Amazon Inspector delegated administrator.
        public let delegatedAdminAccountId: String

        public init(delegatedAdminAccountId: String) {
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccountId
        }
    }

    public struct EnableRequest: AWSEncodableShape {
        /// A list of account IDs you want to enable Amazon Inspector scans for.
        public let accountIds: [String]?
        /// The idempotency token for the request.
        public let clientToken: String?
        /// The resource scan types you want to enable.
        public let resourceTypes: [ResourceScanType]

        public init(accountIds: [String]? = nil, clientToken: String? = EnableRequest.idempotencyToken(), resourceTypes: [ResourceScanType]) {
            self.accountIds = accountIds
            self.clientToken = clientToken
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 3)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case clientToken
            case resourceTypes
        }
    }

    public struct EnableResponse: AWSDecodableShape {
        /// Information on the accounts that have had Amazon Inspector scans successfully enabled. Details are provided for each account.
        public let accounts: [Account]
        /// Information on any accounts for which Amazon Inspector scans could not be enabled. Details are provided for each account.
        public let failedAccounts: [FailedAccount]?

        public init(accounts: [Account], failedAccounts: [FailedAccount]? = nil) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts
            case failedAccounts
        }
    }

    public struct ExploitabilityDetails: AWSDecodableShape {
        /// The date and time of the last exploit associated with a finding discovered in your environment.
        public let lastKnownExploitAt: Date?

        public init(lastKnownExploitAt: Date? = nil) {
            self.lastKnownExploitAt = lastKnownExploitAt
        }

        private enum CodingKeys: String, CodingKey {
            case lastKnownExploitAt
        }
    }

    public struct FailedAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String
        /// The error code explaining why the account failed to enable Amazon Inspector.
        public let errorCode: ErrorCode
        /// The error message received when the account failed to enable Amazon Inspector.
        public let errorMessage: String
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public let resourceStatus: ResourceStatus?
        /// The status of Amazon Inspector for the account.
        public let status: Status?

        public init(accountId: String, errorCode: ErrorCode, errorMessage: String, resourceStatus: ResourceStatus? = nil, status: Status? = nil) {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resourceStatus = resourceStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case errorCode
            case errorMessage
            case resourceStatus
            case status
        }
    }

    public struct Filter: AWSDecodableShape {
        /// The action that is to be applied to the findings that match the filter.
        public let action: FilterAction
        /// The Amazon Resource Number (ARN) associated with this filter.
        public let arn: String
        /// The date and time this filter was created at.
        public let createdAt: Date
        /// Details on the filter criteria associated with this filter.
        public let criteria: FilterCriteria
        /// A description of the filter.
        public let description: String?
        /// The name of the filter.
        public let name: String
        /// The Amazon Web Services account ID of the account that created the filter.
        public let ownerId: String
        /// The reason for the filter.
        public let reason: String?
        /// The tags attached to the filter.
        public let tags: [String: String]?
        /// The date and time the filter was last updated at.
        public let updatedAt: Date

        public init(action: FilterAction, arn: String, createdAt: Date, criteria: FilterCriteria, description: String? = nil, name: String, ownerId: String, reason: String? = nil, tags: [String: String]? = nil, updatedAt: Date) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.criteria = criteria
            self.description = description
            self.name = name
            self.ownerId = ownerId
            self.reason = reason
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case arn
            case createdAt
            case criteria
            case description
            case name
            case ownerId
            case reason
            case tags
            case updatedAt
        }
    }

    public struct FilterCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Details of the Amazon Web Services account IDs used to filter findings.
        public let awsAccountId: [StringFilter]?
        /// Details of the component IDs used to filter findings.
        public let componentId: [StringFilter]?
        /// Details of the component types used to filter findings.
        public let componentType: [StringFilter]?
        /// Details of the Amazon EC2 instance image IDs used to filter findings.
        public let ec2InstanceImageId: [StringFilter]?
        /// Details of the Amazon EC2 instance subnet IDs used to filter findings.
        public let ec2InstanceSubnetId: [StringFilter]?
        /// Details of the Amazon EC2 instance VPC IDs used to filter findings.
        public let ec2InstanceVpcId: [StringFilter]?
        /// Details of the Amazon ECR image architecture types used to filter findings.
        public let ecrImageArchitecture: [StringFilter]?
        /// Details of the Amazon ECR image hashes used to filter findings.
        public let ecrImageHash: [StringFilter]?
        /// Details on the Amazon ECR image push date and time used to filter findings.
        public let ecrImagePushedAt: [DateFilter]?
        /// Details on the Amazon ECR registry used to filter findings.
        public let ecrImageRegistry: [StringFilter]?
        /// Details on the name of the Amazon ECR repository used to filter findings.
        public let ecrImageRepositoryName: [StringFilter]?
        /// The tags attached to the Amazon ECR container image.
        public let ecrImageTags: [StringFilter]?
        /// Filters the list of AWS Lambda findings by the availability of exploits.
        public let exploitAvailable: [StringFilter]?
        /// Details on the finding ARNs used to filter findings.
        public let findingArn: [StringFilter]?
        /// Details on the finding status types used to filter findings.
        public let findingStatus: [StringFilter]?
        /// Details on the finding types used to filter findings.
        public let findingType: [StringFilter]?
        /// Details on the date and time a finding was first seen used to filter findings.
        public let firstObservedAt: [DateFilter]?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL.  A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public let fixAvailable: [StringFilter]?
        /// The Amazon Inspector score to filter on.
        public let inspectorScore: [NumberFilter]?
        /// Filters the list of AWS Lambda functions by execution role.
        public let lambdaFunctionExecutionRoleArn: [StringFilter]?
        /// Filters the list of AWS Lambda functions by the date and time that a user last updated the configuration, in ISO 8601 format
        public let lambdaFunctionLastModifiedAt: [DateFilter]?
        /// Filters the list of AWS Lambda functions by the function's  layers. A Lambda function can have up to five layers.
        public let lambdaFunctionLayers: [StringFilter]?
        /// Filters the list of AWS Lambda functions by the name of the function.
        public let lambdaFunctionName: [StringFilter]?
        /// Filters the list of AWS Lambda functions by the runtime environment for the Lambda function.
        public let lambdaFunctionRuntime: [StringFilter]?
        /// Details on the date and time a finding was last seen used to filter findings.
        public let lastObservedAt: [DateFilter]?
        /// Details on the ingress source addresses used to filter findings.
        public let networkProtocol: [StringFilter]?
        /// Details on the port ranges used to filter findings.
        public let portRange: [PortRangeFilter]?
        /// Details on the related vulnerabilities used to filter findings.
        public let relatedVulnerabilities: [StringFilter]?
        /// Details on the resource IDs used to filter findings.
        public let resourceId: [StringFilter]?
        /// Details on the resource tags used to filter findings.
        public let resourceTags: [MapFilter]?
        /// Details on the resource types used to filter findings.
        public let resourceType: [StringFilter]?
        /// Details on the severity used to filter findings.
        public let severity: [StringFilter]?
        /// Details on the finding title used to filter findings.
        public let title: [StringFilter]?
        /// Details on the date and time a finding was last updated at used to filter findings.
        public let updatedAt: [DateFilter]?
        /// Details on the vendor severity used to filter findings.
        public let vendorSeverity: [StringFilter]?
        /// Details on the vulnerability ID used to filter findings.
        public let vulnerabilityId: [StringFilter]?
        /// Details on the vulnerability type used to filter findings.
        public let vulnerabilitySource: [StringFilter]?
        /// Details on the vulnerable packages used to filter findings.
        public let vulnerablePackages: [PackageFilter]?

        public init(awsAccountId: [StringFilter]? = nil, componentId: [StringFilter]? = nil, componentType: [StringFilter]? = nil, ec2InstanceImageId: [StringFilter]? = nil, ec2InstanceSubnetId: [StringFilter]? = nil, ec2InstanceVpcId: [StringFilter]? = nil, ecrImageArchitecture: [StringFilter]? = nil, ecrImageHash: [StringFilter]? = nil, ecrImagePushedAt: [DateFilter]? = nil, ecrImageRegistry: [StringFilter]? = nil, ecrImageRepositoryName: [StringFilter]? = nil, ecrImageTags: [StringFilter]? = nil, exploitAvailable: [StringFilter]? = nil, findingArn: [StringFilter]? = nil, findingStatus: [StringFilter]? = nil, findingType: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, fixAvailable: [StringFilter]? = nil, inspectorScore: [NumberFilter]? = nil, lambdaFunctionExecutionRoleArn: [StringFilter]? = nil, lambdaFunctionLastModifiedAt: [DateFilter]? = nil, lambdaFunctionLayers: [StringFilter]? = nil, lambdaFunctionName: [StringFilter]? = nil, lambdaFunctionRuntime: [StringFilter]? = nil, lastObservedAt: [DateFilter]? = nil, networkProtocol: [StringFilter]? = nil, portRange: [PortRangeFilter]? = nil, relatedVulnerabilities: [StringFilter]? = nil, resourceId: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, severity: [StringFilter]? = nil, title: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, vendorSeverity: [StringFilter]? = nil, vulnerabilityId: [StringFilter]? = nil, vulnerabilitySource: [StringFilter]? = nil, vulnerablePackages: [PackageFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.componentId = componentId
            self.componentType = componentType
            self.ec2InstanceImageId = ec2InstanceImageId
            self.ec2InstanceSubnetId = ec2InstanceSubnetId
            self.ec2InstanceVpcId = ec2InstanceVpcId
            self.ecrImageArchitecture = ecrImageArchitecture
            self.ecrImageHash = ecrImageHash
            self.ecrImagePushedAt = ecrImagePushedAt
            self.ecrImageRegistry = ecrImageRegistry
            self.ecrImageRepositoryName = ecrImageRepositoryName
            self.ecrImageTags = ecrImageTags
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.findingStatus = findingStatus
            self.findingType = findingType
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.lambdaFunctionExecutionRoleArn = lambdaFunctionExecutionRoleArn
            self.lambdaFunctionLastModifiedAt = lambdaFunctionLastModifiedAt
            self.lambdaFunctionLayers = lambdaFunctionLayers
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lastObservedAt = lastObservedAt
            self.networkProtocol = networkProtocol
            self.portRange = portRange
            self.relatedVulnerabilities = relatedVulnerabilities
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.vendorSeverity = vendorSeverity
            self.vulnerabilityId = vulnerabilityId
            self.vulnerabilitySource = vulnerabilitySource
            self.vulnerablePackages = vulnerablePackages
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 10)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 1)
            try self.componentId?.forEach {
                try $0.validate(name: "\(name).componentId[]")
            }
            try self.validate(self.componentId, name: "componentId", parent: name, max: 10)
            try self.validate(self.componentId, name: "componentId", parent: name, min: 1)
            try self.componentType?.forEach {
                try $0.validate(name: "\(name).componentType[]")
            }
            try self.validate(self.componentType, name: "componentType", parent: name, max: 10)
            try self.validate(self.componentType, name: "componentType", parent: name, min: 1)
            try self.ec2InstanceImageId?.forEach {
                try $0.validate(name: "\(name).ec2InstanceImageId[]")
            }
            try self.validate(self.ec2InstanceImageId, name: "ec2InstanceImageId", parent: name, max: 10)
            try self.validate(self.ec2InstanceImageId, name: "ec2InstanceImageId", parent: name, min: 1)
            try self.ec2InstanceSubnetId?.forEach {
                try $0.validate(name: "\(name).ec2InstanceSubnetId[]")
            }
            try self.validate(self.ec2InstanceSubnetId, name: "ec2InstanceSubnetId", parent: name, max: 10)
            try self.validate(self.ec2InstanceSubnetId, name: "ec2InstanceSubnetId", parent: name, min: 1)
            try self.ec2InstanceVpcId?.forEach {
                try $0.validate(name: "\(name).ec2InstanceVpcId[]")
            }
            try self.validate(self.ec2InstanceVpcId, name: "ec2InstanceVpcId", parent: name, max: 10)
            try self.validate(self.ec2InstanceVpcId, name: "ec2InstanceVpcId", parent: name, min: 1)
            try self.ecrImageArchitecture?.forEach {
                try $0.validate(name: "\(name).ecrImageArchitecture[]")
            }
            try self.validate(self.ecrImageArchitecture, name: "ecrImageArchitecture", parent: name, max: 10)
            try self.validate(self.ecrImageArchitecture, name: "ecrImageArchitecture", parent: name, min: 1)
            try self.ecrImageHash?.forEach {
                try $0.validate(name: "\(name).ecrImageHash[]")
            }
            try self.validate(self.ecrImageHash, name: "ecrImageHash", parent: name, max: 10)
            try self.validate(self.ecrImageHash, name: "ecrImageHash", parent: name, min: 1)
            try self.validate(self.ecrImagePushedAt, name: "ecrImagePushedAt", parent: name, max: 10)
            try self.validate(self.ecrImagePushedAt, name: "ecrImagePushedAt", parent: name, min: 1)
            try self.ecrImageRegistry?.forEach {
                try $0.validate(name: "\(name).ecrImageRegistry[]")
            }
            try self.validate(self.ecrImageRegistry, name: "ecrImageRegistry", parent: name, max: 10)
            try self.validate(self.ecrImageRegistry, name: "ecrImageRegistry", parent: name, min: 1)
            try self.ecrImageRepositoryName?.forEach {
                try $0.validate(name: "\(name).ecrImageRepositoryName[]")
            }
            try self.validate(self.ecrImageRepositoryName, name: "ecrImageRepositoryName", parent: name, max: 10)
            try self.validate(self.ecrImageRepositoryName, name: "ecrImageRepositoryName", parent: name, min: 1)
            try self.ecrImageTags?.forEach {
                try $0.validate(name: "\(name).ecrImageTags[]")
            }
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, max: 10)
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, min: 1)
            try self.exploitAvailable?.forEach {
                try $0.validate(name: "\(name).exploitAvailable[]")
            }
            try self.validate(self.exploitAvailable, name: "exploitAvailable", parent: name, max: 10)
            try self.validate(self.exploitAvailable, name: "exploitAvailable", parent: name, min: 1)
            try self.findingArn?.forEach {
                try $0.validate(name: "\(name).findingArn[]")
            }
            try self.validate(self.findingArn, name: "findingArn", parent: name, max: 10)
            try self.validate(self.findingArn, name: "findingArn", parent: name, min: 1)
            try self.findingStatus?.forEach {
                try $0.validate(name: "\(name).findingStatus[]")
            }
            try self.validate(self.findingStatus, name: "findingStatus", parent: name, max: 10)
            try self.validate(self.findingStatus, name: "findingStatus", parent: name, min: 1)
            try self.findingType?.forEach {
                try $0.validate(name: "\(name).findingType[]")
            }
            try self.validate(self.findingType, name: "findingType", parent: name, max: 10)
            try self.validate(self.findingType, name: "findingType", parent: name, min: 1)
            try self.validate(self.firstObservedAt, name: "firstObservedAt", parent: name, max: 10)
            try self.validate(self.firstObservedAt, name: "firstObservedAt", parent: name, min: 1)
            try self.fixAvailable?.forEach {
                try $0.validate(name: "\(name).fixAvailable[]")
            }
            try self.validate(self.fixAvailable, name: "fixAvailable", parent: name, max: 10)
            try self.validate(self.fixAvailable, name: "fixAvailable", parent: name, min: 1)
            try self.validate(self.inspectorScore, name: "inspectorScore", parent: name, max: 10)
            try self.validate(self.inspectorScore, name: "inspectorScore", parent: name, min: 1)
            try self.lambdaFunctionExecutionRoleArn?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionExecutionRoleArn[]")
            }
            try self.validate(self.lambdaFunctionExecutionRoleArn, name: "lambdaFunctionExecutionRoleArn", parent: name, max: 10)
            try self.validate(self.lambdaFunctionExecutionRoleArn, name: "lambdaFunctionExecutionRoleArn", parent: name, min: 1)
            try self.validate(self.lambdaFunctionLastModifiedAt, name: "lambdaFunctionLastModifiedAt", parent: name, max: 10)
            try self.validate(self.lambdaFunctionLastModifiedAt, name: "lambdaFunctionLastModifiedAt", parent: name, min: 1)
            try self.lambdaFunctionLayers?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionLayers[]")
            }
            try self.validate(self.lambdaFunctionLayers, name: "lambdaFunctionLayers", parent: name, max: 10)
            try self.validate(self.lambdaFunctionLayers, name: "lambdaFunctionLayers", parent: name, min: 1)
            try self.lambdaFunctionName?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionName[]")
            }
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, max: 10)
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, min: 1)
            try self.lambdaFunctionRuntime?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionRuntime[]")
            }
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, max: 10)
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, min: 1)
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, max: 10)
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, min: 1)
            try self.networkProtocol?.forEach {
                try $0.validate(name: "\(name).networkProtocol[]")
            }
            try self.validate(self.networkProtocol, name: "networkProtocol", parent: name, max: 10)
            try self.validate(self.networkProtocol, name: "networkProtocol", parent: name, min: 1)
            try self.portRange?.forEach {
                try $0.validate(name: "\(name).portRange[]")
            }
            try self.validate(self.portRange, name: "portRange", parent: name, max: 10)
            try self.validate(self.portRange, name: "portRange", parent: name, min: 1)
            try self.relatedVulnerabilities?.forEach {
                try $0.validate(name: "\(name).relatedVulnerabilities[]")
            }
            try self.validate(self.relatedVulnerabilities, name: "relatedVulnerabilities", parent: name, max: 10)
            try self.validate(self.relatedVulnerabilities, name: "relatedVulnerabilities", parent: name, min: 1)
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 10)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 10)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 10)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
            try self.severity?.forEach {
                try $0.validate(name: "\(name).severity[]")
            }
            try self.validate(self.severity, name: "severity", parent: name, max: 10)
            try self.validate(self.severity, name: "severity", parent: name, min: 1)
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.validate(self.title, name: "title", parent: name, max: 10)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, max: 10)
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, min: 1)
            try self.vendorSeverity?.forEach {
                try $0.validate(name: "\(name).vendorSeverity[]")
            }
            try self.validate(self.vendorSeverity, name: "vendorSeverity", parent: name, max: 10)
            try self.validate(self.vendorSeverity, name: "vendorSeverity", parent: name, min: 1)
            try self.vulnerabilityId?.forEach {
                try $0.validate(name: "\(name).vulnerabilityId[]")
            }
            try self.validate(self.vulnerabilityId, name: "vulnerabilityId", parent: name, max: 10)
            try self.validate(self.vulnerabilityId, name: "vulnerabilityId", parent: name, min: 1)
            try self.vulnerabilitySource?.forEach {
                try $0.validate(name: "\(name).vulnerabilitySource[]")
            }
            try self.validate(self.vulnerabilitySource, name: "vulnerabilitySource", parent: name, max: 10)
            try self.validate(self.vulnerabilitySource, name: "vulnerabilitySource", parent: name, min: 1)
            try self.vulnerablePackages?.forEach {
                try $0.validate(name: "\(name).vulnerablePackages[]")
            }
            try self.validate(self.vulnerablePackages, name: "vulnerablePackages", parent: name, max: 10)
            try self.validate(self.vulnerablePackages, name: "vulnerablePackages", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId
            case componentId
            case componentType
            case ec2InstanceImageId
            case ec2InstanceSubnetId
            case ec2InstanceVpcId
            case ecrImageArchitecture
            case ecrImageHash
            case ecrImagePushedAt
            case ecrImageRegistry
            case ecrImageRepositoryName
            case ecrImageTags
            case exploitAvailable
            case findingArn
            case findingStatus
            case findingType
            case firstObservedAt
            case fixAvailable
            case inspectorScore
            case lambdaFunctionExecutionRoleArn
            case lambdaFunctionLastModifiedAt
            case lambdaFunctionLayers
            case lambdaFunctionName
            case lambdaFunctionRuntime
            case lastObservedAt
            case networkProtocol
            case portRange
            case relatedVulnerabilities
            case resourceId
            case resourceTags
            case resourceType
            case severity
            case title
            case updatedAt
            case vendorSeverity
            case vulnerabilityId
            case vulnerabilitySource
            case vulnerablePackages
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The Amazon Web Services account ID associated with the finding.
        public let awsAccountId: String
        /// The description of the finding.
        public let description: String
        /// The details of an exploit available for a finding discovered in your environment.
        public let exploitabilityDetails: ExploitabilityDetails?
        /// If a finding discovered in your environment has an exploit available.
        public let exploitAvailable: ExploitAvailable?
        /// The Amazon Resource Number (ARN) of the finding.
        public let findingArn: String
        /// The date and time that the finding was first observed.
        public let firstObservedAt: Date
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL.  A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public let fixAvailable: FixAvailable?
        /// The Amazon Inspector score given to the finding.
        public let inspectorScore: Double?
        /// An object that contains details of the Amazon Inspector score.
        public let inspectorScoreDetails: InspectorScoreDetails?
        /// The date and time that the finding was last observed.
        public let lastObservedAt: Date
        /// An object that contains the details of a network reachability finding.
        public let networkReachabilityDetails: NetworkReachabilityDetails?
        /// An object that contains the details of a package vulnerability finding.
        public let packageVulnerabilityDetails: PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        public let remediation: Remediation
        /// Contains information on the resources involved in a finding.
        public let resources: [Resource]
        /// The severity of the finding.
        public let severity: Severity
        /// The status of the finding.
        public let status: FindingStatus
        /// The title of the finding.
        public let title: String?
        /// The type of the finding.
        public let type: FindingType
        /// The date and time the finding was last updated at.
        public let updatedAt: Date?

        public init(awsAccountId: String, description: String, exploitabilityDetails: ExploitabilityDetails? = nil, exploitAvailable: ExploitAvailable? = nil, findingArn: String, firstObservedAt: Date, fixAvailable: FixAvailable? = nil, inspectorScore: Double? = nil, inspectorScoreDetails: InspectorScoreDetails? = nil, lastObservedAt: Date, networkReachabilityDetails: NetworkReachabilityDetails? = nil, packageVulnerabilityDetails: PackageVulnerabilityDetails? = nil, remediation: Remediation, resources: [Resource], severity: Severity, status: FindingStatus, title: String? = nil, type: FindingType, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.exploitabilityDetails = exploitabilityDetails
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.lastObservedAt = lastObservedAt
            self.networkReachabilityDetails = networkReachabilityDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId
            case description
            case exploitabilityDetails
            case exploitAvailable
            case findingArn
            case firstObservedAt
            case fixAvailable
            case inspectorScore
            case inspectorScoreDetails
            case lastObservedAt
            case networkReachabilityDetails
            case packageVulnerabilityDetails
            case remediation
            case resources
            case severity
            case status
            case title
            case type
            case updatedAt
        }
    }

    public struct FindingTypeAggregation: AWSEncodableShape {
        /// The finding type to aggregate.
        public let findingType: AggregationFindingType?
        /// The resource type to aggregate.
        public let resourceType: AggregationResourceType?
        /// The value to sort results by.
        public let sortBy: FindingTypeSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        public init(findingType: AggregationFindingType? = nil, resourceType: AggregationResourceType? = nil, sortBy: FindingTypeSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case findingType
            case resourceType
            case sortBy
            case sortOrder
        }
    }

    public struct FindingTypeAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// The value to sort results by.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case severityCounts
        }
    }

    public struct FreeTrialAccountInfo: AWSDecodableShape {
        /// The account associated with the Amazon Inspector free trial information.
        public let accountId: String
        /// Contains information about the Amazon Inspector free trial for an account.
        public let freeTrialInfo: [FreeTrialInfo]

        public init(accountId: String, freeTrialInfo: [FreeTrialInfo]) {
            self.accountId = accountId
            self.freeTrialInfo = freeTrialInfo
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case freeTrialInfo
        }
    }

    public struct FreeTrialInfo: AWSDecodableShape {
        /// The date and time that the Amazon Inspector free trail ends for a given account.
        public let end: Date
        /// The date and time that the Amazon Inspector free trail started for a given account.
        public let start: Date
        /// The order to sort results by.
        public let status: FreeTrialStatus
        /// The type of scan covered by the Amazon Inspector free trail.
        public let type: FreeTrialType

        public init(end: Date, start: Date, status: FreeTrialStatus, type: FreeTrialType) {
            self.end = end
            self.start = start
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case end
            case start
            case status
            case type
        }
    }

    public struct FreeTrialInfoError: AWSDecodableShape {
        /// The account associated with the Amazon Inspector free trial information.
        public let accountId: String
        /// The error code.
        public let code: FreeTrialInfoErrorCode
        /// The error message returned.
        public let message: String

        public init(accountId: String, code: FreeTrialInfoErrorCode, message: String) {
            self.accountId = accountId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case code
            case message
        }
    }

    public struct GetConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetConfigurationResponse: AWSDecodableShape {
        /// Specifies how the ECR automated re-scan duration is currently configured for your environment.
        public let ecrConfiguration: EcrConfigurationState?

        public init(ecrConfiguration: EcrConfigurationState? = nil) {
            self.ecrConfiguration = ecrConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ecrConfiguration
        }
    }

    public struct GetDelegatedAdminAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDelegatedAdminAccountResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
        public let delegatedAdmin: DelegatedAdmin?

        public init(delegatedAdmin: DelegatedAdmin? = nil) {
            self.delegatedAdmin = delegatedAdmin
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdmin
        }
    }

    public struct GetFindingsReportStatusRequest: AWSEncodableShape {
        /// The ID of the report to retrieve the status of.
        public let reportId: String?

        public init(reportId: String? = nil) {
            self.reportId = reportId
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "\\b[a-f0-9]{8}\\b-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-\\b[a-f0-9]{12}\\b")
        }

        private enum CodingKeys: String, CodingKey {
            case reportId
        }
    }

    public struct GetFindingsReportStatusResponse: AWSDecodableShape {
        /// The destination of the report.
        public let destination: Destination?
        /// The error code of the report.
        public let errorCode: ReportingErrorCode?
        /// The error message of the report.
        public let errorMessage: String?
        /// The filter criteria associated with the report.
        public let filterCriteria: FilterCriteria?
        /// The ID of the report.
        public let reportId: String?
        /// The status of the report.
        public let status: ExternalReportStatus?

        public init(destination: Destination? = nil, errorCode: ReportingErrorCode? = nil, errorMessage: String? = nil, filterCriteria: FilterCriteria? = nil, reportId: String? = nil, status: ExternalReportStatus? = nil) {
            self.destination = destination
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.filterCriteria = filterCriteria
            self.reportId = reportId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destination
            case errorCode
            case errorMessage
            case filterCriteria
            case reportId
            case status
        }
    }

    public struct GetMemberRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the member account to retrieve information on.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
        }
    }

    public struct GetMemberResponse: AWSDecodableShape {
        /// Details of the retrieved member account.
        public let member: Member?

        public init(member: Member? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct ImageLayerAggregation: AWSEncodableShape {
        /// The hashes associated with the layers.
        public let layerHashes: [StringFilter]?
        /// The repository associated with the container image hosting the layers.
        public let repositories: [StringFilter]?
        /// The ID of the container image layer.
        public let resourceIds: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: ImageLayerSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        public init(layerHashes: [StringFilter]? = nil, repositories: [StringFilter]? = nil, resourceIds: [StringFilter]? = nil, sortBy: ImageLayerSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.layerHashes = layerHashes
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.layerHashes?.forEach {
                try $0.validate(name: "\(name).layerHashes[]")
            }
            try self.validate(self.layerHashes, name: "layerHashes", parent: name, max: 10)
            try self.validate(self.layerHashes, name: "layerHashes", parent: name, min: 1)
            try self.repositories?.forEach {
                try $0.validate(name: "\(name).repositories[]")
            }
            try self.validate(self.repositories, name: "repositories", parent: name, max: 10)
            try self.validate(self.repositories, name: "repositories", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case layerHashes
            case repositories
            case resourceIds
            case sortBy
            case sortOrder
        }
    }

    public struct ImageLayerAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the container image hosting the layer image.
        public let accountId: String
        /// The layer hash.
        public let layerHash: String
        /// The repository the layer resides in.
        public let repository: String
        /// The resource ID of the container image layer.
        public let resourceId: String
        /// An object that represents the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String, layerHash: String, repository: String, resourceId: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.layerHash = layerHash
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case layerHash
            case repository
            case resourceId
            case severityCounts
        }
    }

    public struct InspectorScoreDetails: AWSDecodableShape {
        /// An object that contains details about the CVSS score given to a finding.
        public let adjustedCvss: CvssScoreDetails?

        public init(adjustedCvss: CvssScoreDetails? = nil) {
            self.adjustedCvss = adjustedCvss
        }

        private enum CodingKeys: String, CodingKey {
            case adjustedCvss
        }
    }

    public struct LambdaFunctionAggregation: AWSEncodableShape {
        /// The AWS Lambda function names to include in the aggregation results.
        public let functionNames: [StringFilter]?
        /// The tags to include in the aggregation results.
        public let functionTags: [MapFilter]?
        /// The resource IDs to include in the aggregation results.
        public let resourceIds: [StringFilter]?
        /// Returns findings aggregated by AWS Lambda function runtime environments.
        public let runtimes: [StringFilter]?
        /// The finding severity to use for sorting the results.
        public let sortBy: LambdaFunctionSortBy?
        /// The order to use for sorting the results.
        public let sortOrder: SortOrder?

        public init(functionNames: [StringFilter]? = nil, functionTags: [MapFilter]? = nil, resourceIds: [StringFilter]? = nil, runtimes: [StringFilter]? = nil, sortBy: LambdaFunctionSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.functionNames = functionNames
            self.functionTags = functionTags
            self.resourceIds = resourceIds
            self.runtimes = runtimes
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.functionNames?.forEach {
                try $0.validate(name: "\(name).functionNames[]")
            }
            try self.validate(self.functionNames, name: "functionNames", parent: name, max: 10)
            try self.validate(self.functionNames, name: "functionNames", parent: name, min: 1)
            try self.functionTags?.forEach {
                try $0.validate(name: "\(name).functionTags[]")
            }
            try self.validate(self.functionTags, name: "functionTags", parent: name, max: 10)
            try self.validate(self.functionTags, name: "functionTags", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
            try self.runtimes?.forEach {
                try $0.validate(name: "\(name).runtimes[]")
            }
            try self.validate(self.runtimes, name: "runtimes", parent: name, max: 10)
            try self.validate(self.runtimes, name: "runtimes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case functionNames
            case functionTags
            case resourceIds
            case runtimes
            case sortBy
            case sortOrder
        }
    }

    public struct LambdaFunctionAggregationResponse: AWSDecodableShape {
        /// The ID of the AWS account that owns the AWS Lambda function.
        public let accountId: String?
        /// The AWS Lambda function names included in the aggregation results.
        public let functionName: String?
        /// The tags included in the aggregation results.
        public let lambdaTags: [String: String]?
        /// The date that the AWS Lambda function included in the aggregation results was last changed.
        public let lastModifiedAt: Date?
        /// The resource IDs included in the aggregation results.
        public let resourceId: String
        /// The runtimes included in the aggregation results.
        public let runtime: String?
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, functionName: String? = nil, lambdaTags: [String: String]? = nil, lastModifiedAt: Date? = nil, resourceId: String, runtime: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.functionName = functionName
            self.lambdaTags = lambdaTags
            self.lastModifiedAt = lastModifiedAt
            self.resourceId = resourceId
            self.runtime = runtime
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case functionName
            case lambdaTags
            case lastModifiedAt
            case resourceId
            case runtime
            case severityCounts
        }
    }

    public struct LambdaFunctionMetadata: AWSDecodableShape {
        /// The name of a function.
        public let functionName: String?
        /// The resource tags on an AWS Lambda function.
        public let functionTags: [String: String]?
        /// The layers for an AWS Lambda function. A Lambda function can have up to five layers.
        public let layers: [String]?
        /// An AWS Lambda function's runtime.
        public let runtime: Runtime?

        public init(functionName: String? = nil, functionTags: [String: String]? = nil, layers: [String]? = nil, runtime: Runtime? = nil) {
            self.functionName = functionName
            self.functionTags = functionTags
            self.layers = layers
            self.runtime = runtime
        }

        private enum CodingKeys: String, CodingKey {
            case functionName
            case functionTags
            case layers
            case runtime
        }
    }

    public struct LambdaLayerAggregation: AWSEncodableShape {
        /// The names of the AWS Lambda functions associated with the layers.
        public let functionNames: [StringFilter]?
        /// The Amazon Resource Name (ARN) of the AWS Lambda function layer.
        public let layerArns: [StringFilter]?
        /// The resource IDs for the AWS Lambda function layers.
        public let resourceIds: [StringFilter]?
        /// The finding severity to use for sorting the results.
        public let sortBy: LambdaLayerSortBy?
        /// The order to use for sorting the results.
        public let sortOrder: SortOrder?

        public init(functionNames: [StringFilter]? = nil, layerArns: [StringFilter]? = nil, resourceIds: [StringFilter]? = nil, sortBy: LambdaLayerSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.functionNames = functionNames
            self.layerArns = layerArns
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.functionNames?.forEach {
                try $0.validate(name: "\(name).functionNames[]")
            }
            try self.validate(self.functionNames, name: "functionNames", parent: name, max: 10)
            try self.validate(self.functionNames, name: "functionNames", parent: name, min: 1)
            try self.layerArns?.forEach {
                try $0.validate(name: "\(name).layerArns[]")
            }
            try self.validate(self.layerArns, name: "layerArns", parent: name, max: 10)
            try self.validate(self.layerArns, name: "layerArns", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case functionNames
            case layerArns
            case resourceIds
            case sortBy
            case sortOrder
        }
    }

    public struct LambdaLayerAggregationResponse: AWSDecodableShape {
        /// The account ID of the AWS Lambda function layer.
        public let accountId: String
        /// The names of the AWS Lambda functions associated with the layers.
        public let functionName: String
        /// The Amazon Resource Name (ARN) of the AWS Lambda function layer.
        public let layerArn: String
        /// The Resource ID of the AWS Lambda function layer.
        public let resourceId: String
        public let severityCounts: SeverityCounts?

        public init(accountId: String, functionName: String, layerArn: String, resourceId: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.functionName = functionName
            self.layerArn = layerArn
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case functionName
            case layerArn
            case resourceId
            case severityCounts
        }
    }

    public struct LambdaVpcConfig: AWSDecodableShape {
        /// The VPC security groups and subnets that are attached to an AWS Lambda function. For more information, see VPC Settings.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds
            case subnetIds
            case vpcId
        }
    }

    public struct ListAccountPermissionsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The service scan type to check permissions for.
        public let service: Service?

        public init(maxResults: Int? = nil, nextToken: String? = nil, service: Service? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.service = service
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1024)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case service
        }
    }

    public struct ListAccountPermissionsResponse: AWSDecodableShape {
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Contains details on the permissions an account has to configure Amazon Inspector.
        public let permissions: [Permission]

        public init(nextToken: String? = nil, permissions: [Permission]) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case permissions
        }
    }

    public struct ListCoverageRequest: AWSEncodableShape {
        /// An object that contains details on the filters to apply to the coverage data for your environment.
        public let filterCriteria: CoverageFilterCriteria?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(filterCriteria: CoverageFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria
            case maxResults
            case nextToken
        }
    }

    public struct ListCoverageResponse: AWSDecodableShape {
        /// An object that contains details on the covered resources in your environment.
        public let coveredResources: [CoveredResource]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(coveredResources: [CoveredResource]? = nil, nextToken: String? = nil) {
            self.coveredResources = coveredResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coveredResources
            case nextToken
        }
    }

    public struct ListCoverageStatisticsRequest: AWSEncodableShape {
        /// An object that contains details on the filters to apply to the coverage data for your environment.
        public let filterCriteria: CoverageFilterCriteria?
        /// The value to group the results by.
        public let groupBy: GroupKey?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(filterCriteria: CoverageFilterCriteria? = nil, groupBy: GroupKey? = nil, nextToken: String? = nil) {
            self.filterCriteria = filterCriteria
            self.groupBy = groupBy
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria
            case groupBy
            case nextToken
        }
    }

    public struct ListCoverageStatisticsResponse: AWSDecodableShape {
        /// An array with the number for each group.
        public let countsByGroup: [Counts]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The total number for all groups.
        public let totalCounts: Int64

        public init(countsByGroup: [Counts]? = nil, nextToken: String? = nil, totalCounts: Int64) {
            self.countsByGroup = countsByGroup
            self.nextToken = nextToken
            self.totalCounts = totalCounts
        }

        private enum CodingKeys: String, CodingKey {
            case countsByGroup
            case nextToken
            case totalCounts
        }
    }

    public struct ListDelegatedAdminAccountsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListDelegatedAdminAccountsResponse: AWSDecodableShape {
        /// Details of the Amazon Inspector delegated administrator of your organization.
        public let delegatedAdminAccounts: [DelegatedAdminAccount]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(delegatedAdminAccounts: [DelegatedAdminAccount]? = nil, nextToken: String? = nil) {
            self.delegatedAdminAccounts = delegatedAdminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccounts
            case nextToken
        }
    }

    public struct ListFiltersRequest: AWSEncodableShape {
        /// The action the filter applies to matched findings.
        public let action: FilterAction?
        /// The Amazon resource number (ARN) of the filter.
        public let arns: [String]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(action: FilterAction? = nil, arns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.action = action
            self.arns = arns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.arns?.forEach {
                try validate($0, name: "arns[]", parent: name, max: 128)
                try validate($0, name: "arns[]", parent: name, min: 1)
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case arns
            case maxResults
            case nextToken
        }
    }

    public struct ListFiltersResponse: AWSDecodableShape {
        /// Contains details on the filters associated with your account.
        public let filters: [Filter]
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(filters: [Filter], nextToken: String? = nil) {
            self.filters = filters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case nextToken
        }
    }

    public struct ListFindingAggregationsRequest: AWSEncodableShape {
        /// The Amazon Web Services account IDs to retrieve finding aggregation data for.
        public let accountIds: [StringFilter]?
        /// Details of the aggregation request that is used to filter your aggregation results.
        public let aggregationRequest: AggregationRequest?
        /// The type of the aggregation request.
        public let aggregationType: AggregationType
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(accountIds: [StringFilter]? = nil, aggregationRequest: AggregationRequest? = nil, aggregationType: AggregationType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountIds = accountIds
            self.aggregationRequest = aggregationRequest
            self.aggregationType = aggregationType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try $0.validate(name: "\(name).accountIds[]")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 10)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.aggregationRequest?.validate(name: "\(name).aggregationRequest")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case aggregationRequest
            case aggregationType
            case maxResults
            case nextToken
        }
    }

    public struct ListFindingAggregationsResponse: AWSDecodableShape {
        /// The type of aggregation to perform.
        public let aggregationType: AggregationType
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Objects that contain the results of an aggregation operation.
        public let responses: [AggregationResponse]?

        public init(aggregationType: AggregationType, nextToken: String? = nil, responses: [AggregationResponse]? = nil) {
            self.aggregationType = aggregationType
            self.nextToken = nextToken
            self.responses = responses
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationType
            case nextToken
            case responses
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        /// Details on the filters to apply to your finding results.
        public let filterCriteria: FilterCriteria?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Details on the sort criteria to apply to your finding results.
        public let sortCriteria: SortCriteria?

        public init(filterCriteria: FilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        /// Contains details on the findings in your environment.
        public let findings: [Finding]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(findings: [Finding]? = nil, nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings
            case nextToken
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Specifies whether to list only currently associated members if True or to list all members within the organization if False.
        public let onlyAssociated: Bool?

        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: Bool? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1_000_000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case onlyAssociated
        }
    }

    public struct ListMembersResponse: AWSDecodableShape {
        /// An object that contains details for each member account.
        public let members: [Member]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon resource number (ARN) of the resource to list tags of.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListUsageTotalsRequest: AWSEncodableShape {
        /// The Amazon Web Services account IDs to retrieve usage totals for.
        public let accountIds: [String]?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        public init(accountIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountIds = accountIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "[0-9]{12}")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 7000)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case maxResults
            case nextToken
        }
    }

    public struct ListUsageTotalsResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// An object with details on the total usage for the requested account.
        public let totals: [UsageTotal]?

        public init(nextToken: String? = nil, totals: [UsageTotal]? = nil) {
            self.nextToken = nextToken
            self.totals = totals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case totals
        }
    }

    public struct MapFilter: AWSEncodableShape & AWSDecodableShape {
        /// The operator to use when comparing values in the filter.
        public let comparison: MapComparison
        /// The tag key used in the filter.
        public let key: String
        /// The tag value used in the filter.
        public let value: String?

        public init(comparison: MapComparison, key: String, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison
            case key
            case value
        }
    }

    public struct Member: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member account.
        public let accountId: String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for this member account.
        public let delegatedAdminAccountId: String?
        /// The status of the member account.
        public let relationshipStatus: RelationshipStatus?
        /// A timestamp showing when the status of this member was last updated.
        public let updatedAt: Date?

        public init(accountId: String? = nil, delegatedAdminAccountId: String? = nil, relationshipStatus: RelationshipStatus? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.delegatedAdminAccountId = delegatedAdminAccountId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case delegatedAdminAccountId
            case relationshipStatus
            case updatedAt
        }
    }

    public struct NetworkPath: AWSDecodableShape {
        /// The details on the steps in the network path.
        public let steps: [Step]?

        public init(steps: [Step]? = nil) {
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case steps
        }
    }

    public struct NetworkReachabilityDetails: AWSDecodableShape {
        /// An object that contains details about a network path associated with a finding.
        public let networkPath: NetworkPath
        /// An object that contains details about the open port range associated with a finding.
        public let openPortRange: PortRange
        /// The protocol associated with a finding.
        public let `protocol`: NetworkProtocol

        public init(networkPath: NetworkPath, openPortRange: PortRange, protocol: NetworkProtocol) {
            self.networkPath = networkPath
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case networkPath
            case openPortRange
            case `protocol`
        }
    }

    public struct NumberFilter: AWSEncodableShape & AWSDecodableShape {
        /// The lowest number to be included in the filter.
        public let lowerInclusive: Double?
        /// The highest number to be included in the filter.
        public let upperInclusive: Double?

        public init(lowerInclusive: Double? = nil, upperInclusive: Double? = nil) {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case lowerInclusive
            case upperInclusive
        }
    }

    public struct PackageAggregation: AWSEncodableShape {
        /// The names of packages to aggregate findings on.
        public let packageNames: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: PackageSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        public init(packageNames: [StringFilter]? = nil, sortBy: PackageSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.packageNames = packageNames
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.packageNames?.forEach {
                try $0.validate(name: "\(name).packageNames[]")
            }
            try self.validate(self.packageNames, name: "packageNames", parent: name, max: 10)
            try self.validate(self.packageNames, name: "packageNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case packageNames
            case sortBy
            case sortOrder
        }
    }

    public struct PackageAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// The name of the operating system package.
        public let packageName: String
        /// An object that contains the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, packageName: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.packageName = packageName
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case packageName
            case severityCounts
        }
    }

    public struct PackageFilter: AWSEncodableShape & AWSDecodableShape {
        /// An object that contains details on the package architecture type to filter on.
        public let architecture: StringFilter?
        /// An object that contains details on the package epoch to filter on.
        public let epoch: NumberFilter?
        /// An object that contains details on the name of the package to filter on.
        public let name: StringFilter?
        /// An object that contains details on the package release to filter on.
        public let release: StringFilter?
        public let sourceLambdaLayerArn: StringFilter?
        /// An object that contains details on the source layer hash to filter on.
        public let sourceLayerHash: StringFilter?
        /// The package version to filter on.
        public let version: StringFilter?

        public init(architecture: StringFilter? = nil, epoch: NumberFilter? = nil, name: StringFilter? = nil, release: StringFilter? = nil, sourceLambdaLayerArn: StringFilter? = nil, sourceLayerHash: StringFilter? = nil, version: StringFilter? = nil) {
            self.architecture = architecture
            self.epoch = epoch
            self.name = name
            self.release = release
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        public func validate(name: String) throws {
            try self.architecture?.validate(name: "\(name).architecture")
            try self.name?.validate(name: "\(name).name")
            try self.release?.validate(name: "\(name).release")
            try self.sourceLambdaLayerArn?.validate(name: "\(name).sourceLambdaLayerArn")
            try self.sourceLayerHash?.validate(name: "\(name).sourceLayerHash")
            try self.version?.validate(name: "\(name).version")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture
            case epoch
            case name
            case release
            case sourceLambdaLayerArn
            case sourceLayerHash
            case version
        }
    }

    public struct PackageVulnerabilityDetails: AWSDecodableShape {
        /// An object that contains details about the CVSS score of a finding.
        public let cvss: [CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public let referenceUrls: [String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public let relatedVulnerabilities: [String]?
        /// The source of the vulnerability information.
        public let source: String
        /// A URL to the source of the vulnerability information.
        public let sourceUrl: String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public let vendorCreatedAt: Date?
        /// The severity the vendor has given to this vulnerability type.
        public let vendorSeverity: String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public let vendorUpdatedAt: Date?
        /// The ID given to this vulnerability.
        public let vulnerabilityId: String
        /// The packages impacted by this vulnerability.
        public let vulnerablePackages: [VulnerablePackage]?

        public init(cvss: [CvssScore]? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, source: String, sourceUrl: String? = nil, vendorCreatedAt: Date? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: Date? = nil, vulnerabilityId: String, vulnerablePackages: [VulnerablePackage]? = nil) {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }

        private enum CodingKeys: String, CodingKey {
            case cvss
            case referenceUrls
            case relatedVulnerabilities
            case source
            case sourceUrl
            case vendorCreatedAt
            case vendorSeverity
            case vendorUpdatedAt
            case vulnerabilityId
            case vulnerablePackages
        }
    }

    public struct Permission: AWSDecodableShape {
        /// The operations that can be performed with the given permissions.
        public let operation: Operation
        /// The services that the permissions allow an account to perform the given operations for.
        public let service: Service

        public init(operation: Operation, service: Service) {
            self.operation = operation
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operation
            case service
        }
    }

    public struct PortRange: AWSDecodableShape {
        /// The beginning port in a port range.
        public let begin: Int
        /// The ending port in a port range.
        public let end: Int

        public init(begin: Int, end: Int) {
            self.begin = begin
            self.end = end
        }

        private enum CodingKeys: String, CodingKey {
            case begin
            case end
        }
    }

    public struct PortRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The port number the port range begins at.
        public let beginInclusive: Int?
        /// The port number the port range ends at.
        public let endInclusive: Int?

        public init(beginInclusive: Int? = nil, endInclusive: Int? = nil) {
            self.beginInclusive = beginInclusive
            self.endInclusive = endInclusive
        }

        public func validate(name: String) throws {
            try self.validate(self.beginInclusive, name: "beginInclusive", parent: name, max: 65535)
            try self.validate(self.beginInclusive, name: "beginInclusive", parent: name, min: 0)
            try self.validate(self.endInclusive, name: "endInclusive", parent: name, max: 65535)
            try self.validate(self.endInclusive, name: "endInclusive", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case beginInclusive
            case endInclusive
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The recommended course of action to remediate the finding.
        public let text: String?
        /// The URL address to the CVE remediation recommendations.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text
            case url = "Url"
        }
    }

    public struct Remediation: AWSDecodableShape {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public let recommendation: Recommendation?

        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation
        }
    }

    public struct RepositoryAggregation: AWSEncodableShape {
        /// The names of repositories to aggregate findings on.
        public let repositories: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: RepositorySortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        public init(repositories: [StringFilter]? = nil, sortBy: RepositorySortBy? = nil, sortOrder: SortOrder? = nil) {
            self.repositories = repositories
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.repositories?.forEach {
                try $0.validate(name: "\(name).repositories[]")
            }
            try self.validate(self.repositories, name: "repositories", parent: name, max: 10)
            try self.validate(self.repositories, name: "repositories", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case repositories
            case sortBy
            case sortOrder
        }
    }

    public struct RepositoryAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// The number of container images impacted by the findings.
        public let affectedImages: Int64?
        /// The name of the repository associated with the findings.
        public let repository: String
        /// An object that represent the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        public init(accountId: String? = nil, affectedImages: Int64? = nil, repository: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.affectedImages = affectedImages
            self.repository = repository
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case affectedImages
            case repository
            case severityCounts
        }
    }

    public struct Resource: AWSDecodableShape {
        /// An object that contains details about the resource involved in a finding.
        public let details: ResourceDetails?
        /// The ID of the resource.
        public let id: String
        /// The partition of the resource.
        public let partition: String?
        /// The Amazon Web Services Region the impacted resource is located in.
        public let region: String?
        /// The tags attached to the resource.
        public let tags: [String: String]?
        /// The type of resource.
        public let type: ResourceType

        public init(details: ResourceDetails? = nil, id: String, partition: String? = nil, region: String? = nil, tags: [String: String]? = nil, type: ResourceType) {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details
            case id
            case partition
            case region
            case tags
            case type
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// An object that contains details about the Amazon EC2 instance involved in the finding.
        public let awsEc2Instance: AwsEc2InstanceDetails?
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public let awsEcrContainerImage: AwsEcrContainerImageDetails?
        /// A summary of the information about an AWS Lambda function affected by a finding.
        public let awsLambdaFunction: AwsLambdaFunctionDetails?

        public init(awsEc2Instance: AwsEc2InstanceDetails? = nil, awsEcrContainerImage: AwsEcrContainerImageDetails? = nil, awsLambdaFunction: AwsLambdaFunctionDetails? = nil) {
            self.awsEc2Instance = awsEc2Instance
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsLambdaFunction = awsLambdaFunction
        }

        private enum CodingKeys: String, CodingKey {
            case awsEc2Instance
            case awsEcrContainerImage
            case awsLambdaFunction
        }
    }

    public struct ResourceScanMetadata: AWSDecodableShape {
        /// An object that contains metadata details for an Amazon EC2 instance.
        public let ec2: Ec2Metadata?
        /// An object that contains details about the container metadata for an Amazon ECR image.
        public let ecrImage: EcrContainerImageMetadata?
        /// An object that contains details about the repository an Amazon ECR image resides in.
        public let ecrRepository: EcrRepositoryMetadata?
        /// An object that contains metadata details for an AWS Lambda function.
        public let lambdaFunction: LambdaFunctionMetadata?

        public init(ec2: Ec2Metadata? = nil, ecrImage: EcrContainerImageMetadata? = nil, ecrRepository: EcrRepositoryMetadata? = nil, lambdaFunction: LambdaFunctionMetadata? = nil) {
            self.ec2 = ec2
            self.ecrImage = ecrImage
            self.ecrRepository = ecrRepository
            self.lambdaFunction = lambdaFunction
        }

        private enum CodingKeys: String, CodingKey {
            case ec2
            case ecrImage
            case ecrRepository
            case lambdaFunction
        }
    }

    public struct ResourceState: AWSDecodableShape {
        /// An object detailing the state of Amazon Inspector scanning for Amazon EC2 resources.
        public let ec2: State
        /// An object detailing the state of Amazon Inspector scanning for Amazon ECR resources.
        public let ecr: State
        public let lambda: State?

        public init(ec2: State, ecr: State, lambda: State? = nil) {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
        }

        private enum CodingKeys: String, CodingKey {
            case ec2
            case ecr
            case lambda
        }
    }

    public struct ResourceStatus: AWSDecodableShape {
        /// The status of Amazon Inspector scanning for Amazon EC2 resources.
        public let ec2: Status
        /// The status of Amazon Inspector scanning for Amazon ECR resources.
        public let ecr: Status
        /// The status of Amazon Inspector scanning for AWS Lambda function resources.
        public let lambda: Status?

        public init(ec2: Status, ecr: Status, lambda: Status? = nil) {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
        }

        private enum CodingKeys: String, CodingKey {
            case ec2
            case ecr
            case lambda
        }
    }

    public struct ScanStatus: AWSDecodableShape {
        /// The reason for the scan.
        public let reason: ScanStatusReason
        /// The status code of the scan.
        public let statusCode: ScanStatusCode

        public init(reason: ScanStatusReason, statusCode: ScanStatusCode) {
            self.reason = reason
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case reason
            case statusCode
        }
    }

    public struct SeverityCounts: AWSDecodableShape {
        /// The total count of findings from all severities.
        public let all: Int64?
        /// The total count of critical severity findings.
        public let critical: Int64?
        /// The total count of high severity findings.
        public let high: Int64?
        /// The total count of medium severity findings.
        public let medium: Int64?

        public init(all: Int64? = nil, critical: Int64? = nil, high: Int64? = nil, medium: Int64? = nil) {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }

        private enum CodingKeys: String, CodingKey {
            case all
            case critical
            case high
            case medium
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        /// The finding detail field by which results are sorted.
        public let field: SortField
        /// The order by which findings are sorted.
        public let sortOrder: SortOrder

        public init(field: SortField, sortOrder: SortOrder) {
            self.field = field
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case field
            case sortOrder
        }
    }

    public struct State: AWSDecodableShape {
        /// The error code explaining why the account failed to enable Amazon Inspector.
        public let errorCode: ErrorCode
        /// The error message received when the account failed to enable Amazon Inspector.
        public let errorMessage: String
        /// The status of Amazon Inspector for the account.
        public let status: Status

        public init(errorCode: ErrorCode, errorMessage: String, status: Status) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case status
        }
    }

    public struct Step: AWSDecodableShape {
        /// The component ID.
        public let componentId: String
        /// The component type.
        public let componentType: String

        public init(componentId: String, componentType: String) {
            self.componentId = componentId
            self.componentType = componentType
        }

        private enum CodingKeys: String, CodingKey {
            case componentId
            case componentType
        }
    }

    public struct StringFilter: AWSEncodableShape & AWSDecodableShape {
        /// The operator to use when comparing values in the filter.
        public let comparison: StringComparison
        /// The value to filter on.
        public let value: String

        public init(comparison: StringComparison, value: String) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison
            case value
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to apply a tag to.
        public let resourceArn: String
        /// The tags to be added to a resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TitleAggregation: AWSEncodableShape {
        /// The resource type to aggregate on.
        public let resourceType: AggregationResourceType?
        /// The value to sort results by.
        public let sortBy: TitleSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?
        /// The finding titles to aggregate on.
        public let titles: [StringFilter]?
        /// The vulnerability IDs of the findings.
        public let vulnerabilityIds: [StringFilter]?

        public init(resourceType: AggregationResourceType? = nil, sortBy: TitleSortBy? = nil, sortOrder: SortOrder? = nil, titles: [StringFilter]? = nil, vulnerabilityIds: [StringFilter]? = nil) {
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.titles = titles
            self.vulnerabilityIds = vulnerabilityIds
        }

        public func validate(name: String) throws {
            try self.titles?.forEach {
                try $0.validate(name: "\(name).titles[]")
            }
            try self.validate(self.titles, name: "titles", parent: name, max: 10)
            try self.validate(self.titles, name: "titles", parent: name, min: 1)
            try self.vulnerabilityIds?.forEach {
                try $0.validate(name: "\(name).vulnerabilityIds[]")
            }
            try self.validate(self.vulnerabilityIds, name: "vulnerabilityIds", parent: name, max: 10)
            try self.validate(self.vulnerabilityIds, name: "vulnerabilityIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType
            case sortBy
            case sortOrder
            case titles
            case vulnerabilityIds
        }
    }

    public struct TitleAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// An object that represent the count of matched findings per severity.
        public let severityCounts: SeverityCounts?
        /// The title that the findings were aggregated on.
        public let title: String
        /// The vulnerability ID of the finding.
        public let vulnerabilityId: String?

        public init(accountId: String? = nil, severityCounts: SeverityCounts? = nil, title: String, vulnerabilityId: String? = nil) {
            self.accountId = accountId
            self.severityCounts = severityCounts
            self.title = title
            self.vulnerabilityId = vulnerabilityId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case severityCounts
            case title
            case vulnerabilityId
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) for the resource to remove tags from.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        /// Specifies how the ECR automated re-scan will be updated for your environment.
        public let ecrConfiguration: EcrConfiguration

        public init(ecrConfiguration: EcrConfiguration) {
            self.ecrConfiguration = ecrConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ecrConfiguration
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFilterRequest: AWSEncodableShape {
        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// A description of the filter.
        public let description: String?
        /// The Amazon Resource Number (ARN) of the filter to update.
        public let filterArn: String
        /// Defines the criteria to be update in the filter.
        public let filterCriteria: FilterCriteria?
        /// The name of the filter.
        public let name: String?
        /// The reason the filter was updated.
        public let reason: String?

        public init(action: FilterAction? = nil, description: String? = nil, filterArn: String, filterCriteria: FilterCriteria? = nil, name: String? = nil, reason: String? = nil) {
            self.action = action
            self.description = description
            self.filterArn = filterArn
            self.filterCriteria = filterCriteria
            self.name = name
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 128)
            try self.validate(self.filterArn, name: "filterArn", parent: name, min: 1)
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.reason, name: "reason", parent: name, max: 512)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case description
            case filterArn
            case filterCriteria
            case name
            case reason
        }
    }

    public struct UpdateFilterResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the successfully updated filter.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        /// Defines which scan types are enabled automatically for new members of your Amazon Inspector organization.
        public let autoEnable: AutoEnable

        public init(autoEnable: AutoEnable) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        /// The updated status of scan types automatically enabled for new members of your Amazon Inspector organization.
        public let autoEnable: AutoEnable

        public init(autoEnable: AutoEnable) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct Usage: AWSDecodableShape {
        /// The currency type used when calculating usage data.
        public let currency: Currency?
        /// The estimated monthly cost of Amazon Inspector.
        public let estimatedMonthlyCost: Double?
        /// The total of usage.
        public let total: Double?
        /// The type scan.
        public let type: UsageType?

        public init(currency: Currency? = nil, estimatedMonthlyCost: Double? = nil, total: Double? = nil, type: UsageType? = nil) {
            self.currency = currency
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.total = total
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currency
            case estimatedMonthlyCost
            case total
            case type
        }
    }

    public struct UsageTotal: AWSDecodableShape {
        /// The account ID of the account that usage data was retrieved for.
        public let accountId: String?
        /// An object representing the total usage for an account.
        public let usage: [Usage]?

        public init(accountId: String? = nil, usage: [Usage]? = nil) {
            self.accountId = accountId
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case usage
        }
    }

    public struct VulnerablePackage: AWSDecodableShape {
        /// The architecture of the vulnerable package.
        public let arch: String?
        /// The epoch of the vulnerable package.
        public let epoch: Int?
        /// The file path of the vulnerable package.
        public let filePath: String?
        /// The version of the package that contains the vulnerability fix.
        public let fixedInVersion: String?
        /// The name of the vulnerable package.
        public let name: String
        /// The package manager of the vulnerable package.
        public let packageManager: PackageManager?
        /// The release of the vulnerable package.
        public let release: String?
        /// The code to run in your environment to update packages with a fix available.
        public let remediation: String?
        /// The Amazon Resource Number (ARN) of the AWS Lambda function affected by a finding.
        public let sourceLambdaLayerArn: String?
        /// The source layer hash of the vulnerable package.
        public let sourceLayerHash: String?
        /// The version of the vulnerable package.
        public let version: String

        public init(arch: String? = nil, epoch: Int? = nil, filePath: String? = nil, fixedInVersion: String? = nil, name: String, packageManager: PackageManager? = nil, release: String? = nil, remediation: String? = nil, sourceLambdaLayerArn: String? = nil, sourceLayerHash: String? = nil, version: String) {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arch
            case epoch
            case filePath
            case fixedInVersion
            case name
            case packageManager
            case release
            case remediation
            case sourceLambdaLayerArn
            case sourceLayerHash
            case version
        }
    }
}

// MARK: - Errors

/// Error enum for Inspector2
public struct Inspector2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Inspector2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// One or more tags submitted as part of the request is not valid.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// A conflict occurred.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request has failed due to an internal failure of the Amazon Inspector service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The operation tried to access an invalid resource. Make sure the resource is specified correctly.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The limit on the number of requests per second was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request has failed validation due to missing required fields or having invalid inputs.
    public static var validationException: Self { .init(.validationException) }
}

extension Inspector2ErrorType: Equatable {
    public static func == (lhs: Inspector2ErrorType, rhs: Inspector2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension Inspector2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
