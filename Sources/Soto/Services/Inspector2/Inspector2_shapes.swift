//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Inspector2 {
    // MARK: Enums

    public enum AccountSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum AggregationFindingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case codeVulnerability = "CODE_VULNERABILITY"
        case networkReachability = "NETWORK_REACHABILITY"
        case packageVulnerability = "PACKAGE_VULNERABILITY"
        public var description: String { return self.rawValue }
    }

    public enum AggregationResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainerImage = "AWS_ECR_CONTAINER_IMAGE"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        public var description: String { return self.rawValue }
    }

    public enum AggregationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case ami = "AMI"
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainer = "AWS_ECR_CONTAINER"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        case findingType = "FINDING_TYPE"
        case imageLayer = "IMAGE_LAYER"
        case lambdaLayer = "LAMBDA_LAYER"
        case package = "PACKAGE"
        case repository = "REPOSITORY"
        case title = "TITLE"
        public var description: String { return self.rawValue }
    }

    public enum AmiSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case affectedInstances = "AFFECTED_INSTANCES"
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum Architecture: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arm64 = "ARM64"
        case x8664 = "X86_64"
        public var description: String { return self.rawValue }
    }

    public enum AwsEcrContainerSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum CisFindingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case passed = "PASSED"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum CisFindingStatusComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CisReportFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case pdf = "PDF"
        public var description: String { return self.rawValue }
    }

    public enum CisReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum CisResultStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case passed = "PASSED"
        case skipped = "SKIPPED"
        public var description: String { return self.rawValue }
    }

    public enum CisResultStatusComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CisRuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case failed = "FAILED"
        case informational = "INFORMATIONAL"
        case notApplicable = "NOT_APPLICABLE"
        case notEvaluated = "NOT_EVALUATED"
        case passed = "PASSED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum CisScanConfigurationsSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case scanConfigurationArn = "SCAN_CONFIGURATION_ARN"
        case scanName = "SCAN_NAME"
        public var description: String { return self.rawValue }
    }

    public enum CisScanResultDetailsSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case checkId = "CHECK_ID"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum CisScanResultsAggregatedByChecksSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case checkId = "CHECK_ID"
        case failedCounts = "FAILED_COUNTS"
        case platform = "PLATFORM"
        case securityLevel = "SECURITY_LEVEL"
        case title = "TITLE"
        public var description: String { return self.rawValue }
    }

    public enum CisScanResultsAggregatedByTargetResourceSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case failedCounts = "FAILED_COUNTS"
        case platform = "PLATFORM"
        case resourceId = "RESOURCE_ID"
        case targetStatus = "TARGET_STATUS"
        case targetStatusReason = "TARGET_STATUS_REASON"
        public var description: String { return self.rawValue }
    }

    public enum CisScanStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum CisScanStatusComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CisSecurityLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case level1 = "LEVEL_1"
        case level2 = "LEVEL_2"
        public var description: String { return self.rawValue }
    }

    public enum CisSecurityLevelComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CisSortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum CisStringComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum CisTargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum CisTargetStatusComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CisTargetStatusReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case scanInProgress = "SCAN_IN_PROGRESS"
        case ssmUnmanaged = "SSM_UNMANAGED"
        case unsupportedOs = "UNSUPPORTED_OS"
        public var description: String { return self.rawValue }
    }

    public enum CodeSnippetErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case codeSnippetNotFound = "CODE_SNIPPET_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case invalidInput = "INVALID_INPUT"
        public var description: String { return self.rawValue }
    }

    public enum CoverageMapComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum CoverageResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainerImage = "AWS_ECR_CONTAINER_IMAGE"
        case awsEcrRepository = "AWS_ECR_REPOSITORY"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        public var description: String { return self.rawValue }
    }

    public enum CoverageStringComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum Currency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum Day: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fri = "FRI"
        case mon = "MON"
        case sat = "SAT"
        case sun = "SUN"
        case thu = "THU"
        case tue = "TUE"
        case wed = "WED"
        public var description: String { return self.rawValue }
    }

    public enum DelegatedAdminStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Ec2DeepInspectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case deactivated = "DEACTIVATED"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum Ec2InstanceSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        case networkFindings = "NETWORK_FINDINGS"
        public var description: String { return self.rawValue }
    }

    public enum Ec2Platform: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case macos = "MACOS"
        case unknown = "UNKNOWN"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum Ec2ScanMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2Hybrid = "EC2_HYBRID"
        case ec2SsmAgentBased = "EC2_SSM_AGENT_BASED"
        public var description: String { return self.rawValue }
    }

    public enum Ec2ScanModeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum EcrPullDateRescanDuration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days14 = "DAYS_14"
        case days180 = "DAYS_180"
        case days30 = "DAYS_30"
        case days60 = "DAYS_60"
        case days90 = "DAYS_90"
        public var description: String { return self.rawValue }
    }

    public enum EcrRescanDuration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days14 = "DAYS_14"
        case days180 = "DAYS_180"
        case days30 = "DAYS_30"
        case days60 = "DAYS_60"
        case days90 = "DAYS_90"
        case lifetime = "LIFETIME"
        public var description: String { return self.rawValue }
    }

    public enum EcrRescanDurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum EcrScanFrequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuousScan = "CONTINUOUS_SCAN"
        case manual = "MANUAL"
        case scanOnPush = "SCAN_ON_PUSH"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case accountIsIsolated = "ACCOUNT_IS_ISOLATED"
        case alreadyEnabled = "ALREADY_ENABLED"
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case disassociateAllMembers = "DISASSOCIATE_ALL_MEMBERS"
        case ec2SsmAssociationVersionLimitExceeded = "EC2_SSM_ASSOCIATION_VERSION_LIMIT_EXCEEDED"
        case ec2SsmResourceDataSyncLimitExceeded = "EC2_SSM_RESOURCE_DATA_SYNC_LIMIT_EXCEEDED"
        case enableInProgress = "ENABLE_IN_PROGRESS"
        case eventbridgeThrottled = "EVENTBRIDGE_THROTTLED"
        case eventbridgeUnavailable = "EVENTBRIDGE_UNAVAILABLE"
        case internalError = "INTERNAL_ERROR"
        case resourceNotFound = "RESOURCE_NOT_FOUND"
        case resourceScanNotDisabled = "RESOURCE_SCAN_NOT_DISABLED"
        case ssmThrottled = "SSM_THROTTLED"
        case ssmUnavailable = "SSM_UNAVAILABLE"
        case suspendInProgress = "SUSPEND_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ExploitAvailable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case no = "NO"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum ExternalReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum FilterAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case suppress = "SUPPRESS"
        public var description: String { return self.rawValue }
    }

    public enum FindingDetailsErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case findingDetailsNotFound = "FINDING_DETAILS_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case invalidInput = "INVALID_INPUT"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        case suppressed = "SUPPRESSED"
        public var description: String { return self.rawValue }
    }

    public enum FindingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case codeVulnerability = "CODE_VULNERABILITY"
        case networkReachability = "NETWORK_REACHABILITY"
        case packageVulnerability = "PACKAGE_VULNERABILITY"
        public var description: String { return self.rawValue }
    }

    public enum FindingTypeSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum FixAvailable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case no = "NO"
        case partial = "PARTIAL"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialInfoErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case internalError = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum FreeTrialType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2 = "EC2"
        case ecr = "ECR"
        case lambda = "LAMBDA"
        case lambdaCode = "LAMBDA_CODE"
        public var description: String { return self.rawValue }
    }

    public enum GroupKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case ecrRepositoryName = "ECR_REPOSITORY_NAME"
        case resourceType = "RESOURCE_TYPE"
        case scanStatusCode = "SCAN_STATUS_CODE"
        case scanStatusReason = "SCAN_STATUS_REASON"
        public var description: String { return self.rawValue }
    }

    public enum ImageLayerSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum LambdaFunctionSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum LambdaLayerSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum ListCisScansDetailLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case member = "MEMBER"
        case organization = "ORGANIZATION"
        public var description: String { return self.rawValue }
    }

    public enum ListCisScansSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failedChecks = "FAILED_CHECKS"
        case scanStartDate = "SCAN_START_DATE"
        case scheduledBy = "SCHEDULED_BY"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum MapComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NetworkProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tcp = "TCP"
        case udp = "UDP"
        public var description: String { return self.rawValue }
    }

    public enum Operation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableRepository = "DISABLE_REPOSITORY"
        case disableScanning = "DISABLE_SCANNING"
        case enableRepository = "ENABLE_REPOSITORY"
        case enableScanning = "ENABLE_SCANNING"
        public var description: String { return self.rawValue }
    }

    public enum PackageManager: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bundler = "BUNDLER"
        case cargo = "CARGO"
        case composer = "COMPOSER"
        case dotnetCore = "DOTNET_CORE"
        case gemspec = "GEMSPEC"
        case gobinary = "GOBINARY"
        case gomod = "GOMOD"
        case jar = "JAR"
        case nodepkg = "NODEPKG"
        case npm = "NPM"
        case nuget = "NUGET"
        case os = "OS"
        case pip = "PIP"
        case pipenv = "PIPENV"
        case poetry = "POETRY"
        case pom = "POM"
        case pythonpkg = "PYTHONPKG"
        case yarn = "YARN"
        public var description: String { return self.rawValue }
    }

    public enum PackageSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum PackageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "IMAGE"
        case zip = "ZIP"
        public var description: String { return self.rawValue }
    }

    public enum RelationshipStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountSuspended = "ACCOUNT_SUSPENDED"
        case cannotCreateDetectorInOrgMaster = "CANNOT_CREATE_DETECTOR_IN_ORG_MASTER"
        case created = "CREATED"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case emailVerificationFailed = "EMAIL_VERIFICATION_FAILED"
        case emailVerificationInProgress = "EMAIL_VERIFICATION_IN_PROGRESS"
        case enabled = "ENABLED"
        case invited = "INVITED"
        case regionDisabled = "REGION_DISABLED"
        case removed = "REMOVED"
        case resigned = "RESIGNED"
        public var description: String { return self.rawValue }
    }

    public enum ReportFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum ReportingErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bucketNotFound = "BUCKET_NOT_FOUND"
        case incompatibleBucketRegion = "INCOMPATIBLE_BUCKET_REGION"
        case internalError = "INTERNAL_ERROR"
        case invalidPermissions = "INVALID_PERMISSIONS"
        case malformedKmsKey = "MALFORMED_KMS_KEY"
        case noFindingsFound = "NO_FINDINGS_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum RepositorySortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case affectedImages = "AFFECTED_IMAGES"
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum ResourceMapComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceScanType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2 = "EC2"
        case ecr = "ECR"
        case lambda = "LAMBDA"
        case lambdaCode = "LAMBDA_CODE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStringComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsEc2Instance = "AWS_EC2_INSTANCE"
        case awsEcrContainerImage = "AWS_ECR_CONTAINER_IMAGE"
        case awsEcrRepository = "AWS_ECR_REPOSITORY"
        case awsLambdaFunction = "AWS_LAMBDA_FUNCTION"
        public var description: String { return self.rawValue }
    }

    public enum Runtime: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dotnetcore31 = "DOTNETCORE_3_1"
        case dotnet6 = "DOTNET_6"
        case dotnet7 = "DOTNET_7"
        case go1X = "GO_1_X"
        case java11 = "JAVA_11"
        case java17 = "JAVA_17"
        case java8 = "JAVA_8"
        case java8Al2 = "JAVA_8_AL2"
        case nodejs = "NODEJS"
        case nodejs12X = "NODEJS_12_X"
        case nodejs14X = "NODEJS_14_X"
        case nodejs16X = "NODEJS_16_X"
        case nodejs18X = "NODEJS_18_X"
        case python310 = "PYTHON_3_10"
        case python311 = "PYTHON_3_11"
        case python37 = "PYTHON_3_7"
        case python38 = "PYTHON_3_8"
        case python39 = "PYTHON_3_9"
        case ruby27 = "RUBY_2_7"
        case ruby32 = "RUBY_3_2"
        case unsupported = "UNSUPPORTED"
        public var description: String { return self.rawValue }
    }

    public enum SbomReportFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cyclonedx14 = "CYCLONEDX_1_4"
        case spdx23 = "SPDX_2_3"
        public var description: String { return self.rawValue }
    }

    public enum ScanMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2Agentless = "EC2_AGENTLESS"
        case ec2SsmAgentBased = "EC2_SSM_AGENT_BASED"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatusReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case agentlessInstanceCollectionTimeLimitExceeded = "AGENTLESS_INSTANCE_COLLECTION_TIME_LIMIT_EXCEEDED"
        case agentlessInstanceStorageLimitExceeded = "AGENTLESS_INSTANCE_STORAGE_LIMIT_EXCEEDED"
        case deepInspectionCollectionTimeLimitExceeded = "DEEP_INSPECTION_COLLECTION_TIME_LIMIT_EXCEEDED"
        case deepInspectionDailySsmInventoryLimitExceeded = "DEEP_INSPECTION_DAILY_SSM_INVENTORY_LIMIT_EXCEEDED"
        case deepInspectionNoInventory = "DEEP_INSPECTION_NO_INVENTORY"
        case deepInspectionPackageCollectionLimitExceeded = "DEEP_INSPECTION_PACKAGE_COLLECTION_LIMIT_EXCEEDED"
        case ec2InstanceStopped = "EC2_INSTANCE_STOPPED"
        case excludedByTag = "EXCLUDED_BY_TAG"
        case imageSizeExceeded = "IMAGE_SIZE_EXCEEDED"
        case internalError = "INTERNAL_ERROR"
        case noInventory = "NO_INVENTORY"
        case noResourcesFound = "NO_RESOURCES_FOUND"
        case pendingDisable = "PENDING_DISABLE"
        case pendingInitialScan = "PENDING_INITIAL_SCAN"
        case resourceTerminated = "RESOURCE_TERMINATED"
        case scanEligibilityExpired = "SCAN_ELIGIBILITY_EXPIRED"
        case scanFrequencyManual = "SCAN_FREQUENCY_MANUAL"
        case scanFrequencyScanOnPush = "SCAN_FREQUENCY_SCAN_ON_PUSH"
        case staleInventory = "STALE_INVENTORY"
        case successful = "SUCCESSFUL"
        case unmanagedEc2Instance = "UNMANAGED_EC2_INSTANCE"
        case unsupportedConfigFile = "UNSUPPORTED_CONFIG_FILE"
        case unsupportedMediaType = "UNSUPPORTED_MEDIA_TYPE"
        case unsupportedOs = "UNSUPPORTED_OS"
        case unsupportedRuntime = "UNSUPPORTED_RUNTIME"
        public var description: String { return self.rawValue }
    }

    public enum ScanType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case code = "CODE"
        case network = "NETWORK"
        case package = "PACKAGE"
        public var description: String { return self.rawValue }
    }

    public enum Service: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2 = "EC2"
        case ecr = "ECR"
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        case untriaged = "UNTRIAGED"
        public var description: String { return self.rawValue }
    }

    public enum SortField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAccountId = "AWS_ACCOUNT_ID"
        case componentType = "COMPONENT_TYPE"
        case ecrImagePushedAt = "ECR_IMAGE_PUSHED_AT"
        case ecrImageRegistry = "ECR_IMAGE_REGISTRY"
        case ecrImageRepositoryName = "ECR_IMAGE_REPOSITORY_NAME"
        case epssScore = "EPSS_SCORE"
        case findingStatus = "FINDING_STATUS"
        case findingType = "FINDING_TYPE"
        case firstObservedAt = "FIRST_OBSERVED_AT"
        case inspectorScore = "INSPECTOR_SCORE"
        case lastObservedAt = "LAST_OBSERVED_AT"
        case networkProtocol = "NETWORK_PROTOCOL"
        case resourceType = "RESOURCE_TYPE"
        case severity = "SEVERITY"
        case vendorSeverity = "VENDOR_SEVERITY"
        case vulnerabilityId = "VULNERABILITY_ID"
        case vulnerabilitySource = "VULNERABILITY_SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case disabling = "DISABLING"
        case enabled = "ENABLED"
        case enabling = "ENABLING"
        case suspended = "SUSPENDED"
        case suspending = "SUSPENDING"
        public var description: String { return self.rawValue }
    }

    public enum StopCisSessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case interrupted = "INTERRUPTED"
        case success = "SUCCESS"
        case unsupportedOs = "UNSUPPORTED_OS"
        public var description: String { return self.rawValue }
    }

    public enum StringComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum TagComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum TitleSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case critical = "CRITICAL"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum UsageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ec2InstanceHours = "EC2_INSTANCE_HOURS"
        case ecrInitialScan = "ECR_INITIAL_SCAN"
        case ecrRescan = "ECR_RESCAN"
        case lambdaFunctionCodeHours = "LAMBDA_FUNCTION_CODE_HOURS"
        case lambdaFunctionHours = "LAMBDA_FUNCTION_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        public var description: String { return self.rawValue }
    }

    public enum VulnerabilitySource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nvd = "NVD"
        public var description: String { return self.rawValue }
    }

    public enum AggregationRequest: AWSEncodableShape, Sendable {
        /// An object that contains details about an aggregation request based on Amazon Web Services account IDs.
        case accountAggregation(AccountAggregation)
        /// An object that contains details about an aggregation request based on Amazon Machine Images (AMIs).
        case amiAggregation(AmiAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR container images.
        case awsEcrContainerAggregation(AwsEcrContainerAggregation)
        /// An object that contains details about an aggregation request based on Amazon EC2 instances.
        case ec2InstanceAggregation(Ec2InstanceAggregation)
        /// An object that contains details about an aggregation request based on finding types.
        case findingTypeAggregation(FindingTypeAggregation)
        /// An object that contains details about an aggregation request based on container image layers.
        case imageLayerAggregation(ImageLayerAggregation)
        /// Returns an object with findings aggregated by Amazon Web Services Lambda function.
        case lambdaFunctionAggregation(LambdaFunctionAggregation)
        /// Returns an object with findings aggregated by Amazon Web Services Lambda layer.
        case lambdaLayerAggregation(LambdaLayerAggregation)
        /// An object that contains details about an aggregation request based on operating system package type.
        case packageAggregation(PackageAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR repositories.
        case repositoryAggregation(RepositoryAggregation)
        /// An object that contains details about an aggregation request based on finding title.
        case titleAggregation(TitleAggregation)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .accountAggregation(let value):
                try container.encode(value, forKey: .accountAggregation)
            case .amiAggregation(let value):
                try container.encode(value, forKey: .amiAggregation)
            case .awsEcrContainerAggregation(let value):
                try container.encode(value, forKey: .awsEcrContainerAggregation)
            case .ec2InstanceAggregation(let value):
                try container.encode(value, forKey: .ec2InstanceAggregation)
            case .findingTypeAggregation(let value):
                try container.encode(value, forKey: .findingTypeAggregation)
            case .imageLayerAggregation(let value):
                try container.encode(value, forKey: .imageLayerAggregation)
            case .lambdaFunctionAggregation(let value):
                try container.encode(value, forKey: .lambdaFunctionAggregation)
            case .lambdaLayerAggregation(let value):
                try container.encode(value, forKey: .lambdaLayerAggregation)
            case .packageAggregation(let value):
                try container.encode(value, forKey: .packageAggregation)
            case .repositoryAggregation(let value):
                try container.encode(value, forKey: .repositoryAggregation)
            case .titleAggregation(let value):
                try container.encode(value, forKey: .titleAggregation)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amiAggregation(let value):
                try value.validate(name: "\(name).amiAggregation")
            case .awsEcrContainerAggregation(let value):
                try value.validate(name: "\(name).awsEcrContainerAggregation")
            case .ec2InstanceAggregation(let value):
                try value.validate(name: "\(name).ec2InstanceAggregation")
            case .imageLayerAggregation(let value):
                try value.validate(name: "\(name).imageLayerAggregation")
            case .lambdaFunctionAggregation(let value):
                try value.validate(name: "\(name).lambdaFunctionAggregation")
            case .lambdaLayerAggregation(let value):
                try value.validate(name: "\(name).lambdaLayerAggregation")
            case .packageAggregation(let value):
                try value.validate(name: "\(name).packageAggregation")
            case .repositoryAggregation(let value):
                try value.validate(name: "\(name).repositoryAggregation")
            case .titleAggregation(let value):
                try value.validate(name: "\(name).titleAggregation")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregation = "accountAggregation"
            case amiAggregation = "amiAggregation"
            case awsEcrContainerAggregation = "awsEcrContainerAggregation"
            case ec2InstanceAggregation = "ec2InstanceAggregation"
            case findingTypeAggregation = "findingTypeAggregation"
            case imageLayerAggregation = "imageLayerAggregation"
            case lambdaFunctionAggregation = "lambdaFunctionAggregation"
            case lambdaLayerAggregation = "lambdaLayerAggregation"
            case packageAggregation = "packageAggregation"
            case repositoryAggregation = "repositoryAggregation"
            case titleAggregation = "titleAggregation"
        }
    }

    public enum AggregationResponse: AWSDecodableShape, Sendable {
        /// An object that contains details about an aggregation response based on Amazon Web Services account IDs.
        case accountAggregation(AccountAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon Machine Images (AMIs).
        case amiAggregation(AmiAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR container images.
        case awsEcrContainerAggregation(AwsEcrContainerAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon EC2 instances.
        case ec2InstanceAggregation(Ec2InstanceAggregationResponse)
        /// An object that contains details about an aggregation response based on finding types.
        case findingTypeAggregation(FindingTypeAggregationResponse)
        /// An object that contains details about an aggregation response based on container image layers.
        case imageLayerAggregation(ImageLayerAggregationResponse)
        /// An aggregation of findings by Amazon Web Services Lambda function.
        case lambdaFunctionAggregation(LambdaFunctionAggregationResponse)
        /// An aggregation of findings by Amazon Web Services Lambda layer.
        case lambdaLayerAggregation(LambdaLayerAggregationResponse)
        /// An object that contains details about an aggregation response based on operating system package type.
        case packageAggregation(PackageAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR repositories.
        case repositoryAggregation(RepositoryAggregationResponse)
        /// An object that contains details about an aggregation response based on finding title.
        case titleAggregation(TitleAggregationResponse)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accountAggregation:
                let value = try container.decode(AccountAggregationResponse.self, forKey: .accountAggregation)
                self = .accountAggregation(value)
            case .amiAggregation:
                let value = try container.decode(AmiAggregationResponse.self, forKey: .amiAggregation)
                self = .amiAggregation(value)
            case .awsEcrContainerAggregation:
                let value = try container.decode(AwsEcrContainerAggregationResponse.self, forKey: .awsEcrContainerAggregation)
                self = .awsEcrContainerAggregation(value)
            case .ec2InstanceAggregation:
                let value = try container.decode(Ec2InstanceAggregationResponse.self, forKey: .ec2InstanceAggregation)
                self = .ec2InstanceAggregation(value)
            case .findingTypeAggregation:
                let value = try container.decode(FindingTypeAggregationResponse.self, forKey: .findingTypeAggregation)
                self = .findingTypeAggregation(value)
            case .imageLayerAggregation:
                let value = try container.decode(ImageLayerAggregationResponse.self, forKey: .imageLayerAggregation)
                self = .imageLayerAggregation(value)
            case .lambdaFunctionAggregation:
                let value = try container.decode(LambdaFunctionAggregationResponse.self, forKey: .lambdaFunctionAggregation)
                self = .lambdaFunctionAggregation(value)
            case .lambdaLayerAggregation:
                let value = try container.decode(LambdaLayerAggregationResponse.self, forKey: .lambdaLayerAggregation)
                self = .lambdaLayerAggregation(value)
            case .packageAggregation:
                let value = try container.decode(PackageAggregationResponse.self, forKey: .packageAggregation)
                self = .packageAggregation(value)
            case .repositoryAggregation:
                let value = try container.decode(RepositoryAggregationResponse.self, forKey: .repositoryAggregation)
                self = .repositoryAggregation(value)
            case .titleAggregation:
                let value = try container.decode(TitleAggregationResponse.self, forKey: .titleAggregation)
                self = .titleAggregation(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountAggregation = "accountAggregation"
            case amiAggregation = "amiAggregation"
            case awsEcrContainerAggregation = "awsEcrContainerAggregation"
            case ec2InstanceAggregation = "ec2InstanceAggregation"
            case findingTypeAggregation = "findingTypeAggregation"
            case imageLayerAggregation = "imageLayerAggregation"
            case lambdaFunctionAggregation = "lambdaFunctionAggregation"
            case lambdaLayerAggregation = "lambdaLayerAggregation"
            case packageAggregation = "packageAggregation"
            case repositoryAggregation = "repositoryAggregation"
            case titleAggregation = "titleAggregation"
        }
    }

    public enum Schedule: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The schedule's daily.
        case daily(DailySchedule)
        /// The schedule's monthly.
        case monthly(MonthlySchedule)
        /// The schedule's one time.
        case oneTime(OneTimeSchedule)
        /// The schedule's weekly.
        case weekly(WeeklySchedule)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .daily:
                let value = try container.decode(DailySchedule.self, forKey: .daily)
                self = .daily(value)
            case .monthly:
                let value = try container.decode(MonthlySchedule.self, forKey: .monthly)
                self = .monthly(value)
            case .oneTime:
                let value = try container.decode(OneTimeSchedule.self, forKey: .oneTime)
                self = .oneTime(value)
            case .weekly:
                let value = try container.decode(WeeklySchedule.self, forKey: .weekly)
                self = .weekly(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .daily(let value):
                try container.encode(value, forKey: .daily)
            case .monthly(let value):
                try container.encode(value, forKey: .monthly)
            case .oneTime(let value):
                try container.encode(value, forKey: .oneTime)
            case .weekly(let value):
                try container.encode(value, forKey: .weekly)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .daily(let value):
                try value.validate(name: "\(name).daily")
            case .monthly(let value):
                try value.validate(name: "\(name).monthly")
            case .weekly(let value):
                try value.validate(name: "\(name).weekly")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case daily = "daily"
            case monthly = "monthly"
            case oneTime = "oneTime"
            case weekly = "weekly"
        }
    }

    // MARK: Shapes

    public struct Account: AWSDecodableShape {
        /// The ID of the Amazon Web Services account.
        public let accountId: String
        /// Details of the status of Amazon Inspector scans by resource type.
        public let resourceStatus: ResourceStatus
        /// The status of Amazon Inspector for the account.
        public let status: Status

        @inlinable
        public init(accountId: String, resourceStatus: ResourceStatus, status: Status) {
            self.accountId = accountId
            self.resourceStatus = resourceStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case resourceStatus = "resourceStatus"
            case status = "status"
        }
    }

    public struct AccountAggregation: AWSEncodableShape {
        /// The type of finding.
        public let findingType: AggregationFindingType?
        /// The type of resource.
        public let resourceType: AggregationResourceType?
        /// The value to sort by.
        public let sortBy: AccountSortBy?
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder?

        @inlinable
        public init(findingType: AggregationFindingType? = nil, resourceType: AggregationResourceType? = nil, sortBy: AccountSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case findingType = "findingType"
            case resourceType = "resourceType"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct AccountAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        ///  The number of findings that have an exploit available.
        public let exploitAvailableCount: Int64?
        ///  Details about the number of fixes.
        public let fixAvailableCount: Int64?
        /// The number of findings by severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, exploitAvailableCount: Int64? = nil, fixAvailableCount: Int64? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.exploitAvailableCount = exploitAvailableCount
            self.fixAvailableCount = fixAvailableCount
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case exploitAvailableCount = "exploitAvailableCount"
            case fixAvailableCount = "fixAvailableCount"
            case severityCounts = "severityCounts"
        }
    }

    public struct AccountState: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public let resourceState: ResourceState
        /// An object detailing the status of Amazon Inspector for the account.
        public let state: State

        @inlinable
        public init(accountId: String, resourceState: ResourceState, state: State) {
            self.accountId = accountId
            self.resourceState = resourceState
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case resourceState = "resourceState"
            case state = "state"
        }
    }

    public struct AmiAggregation: AWSEncodableShape {
        /// The IDs of AMIs to aggregate findings for.
        public let amis: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: AmiSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        @inlinable
        public init(amis: [StringFilter]? = nil, sortBy: AmiSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.amis = amis
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.amis?.forEach {
                try $0.validate(name: "\(name).amis[]")
            }
            try self.validate(self.amis, name: "amis", parent: name, max: 10)
            try self.validate(self.amis, name: "amis", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct AmiAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID for the AMI.
        public let accountId: String?
        /// The IDs of Amazon EC2 instances using this AMI.
        public let affectedInstances: Int64?
        /// The ID of the AMI that findings were aggregated for.
        public let ami: String
        /// An object that contains the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, affectedInstances: Int64? = nil, ami: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.affectedInstances = affectedInstances
            self.ami = ami
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case affectedInstances = "affectedInstances"
            case ami = "ami"
            case severityCounts = "severityCounts"
        }
    }

    public struct AssociateMemberRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the member account to be associated.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct AssociateMemberResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully associated member account.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct AtigData: AWSDecodableShape {
        /// The date and time this vulnerability was first observed.
        public let firstSeen: Date?
        /// The date and time this vulnerability was last observed.
        public let lastSeen: Date?
        /// The commercial sectors this vulnerability targets.
        public let targets: [String]?
        /// The MITRE ATT&amp;CK tactics, techniques, and procedures (TTPs) associated with vulnerability.
        public let ttps: [String]?

        @inlinable
        public init(firstSeen: Date? = nil, lastSeen: Date? = nil, targets: [String]? = nil, ttps: [String]? = nil) {
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.targets = targets
            self.ttps = ttps
        }

        private enum CodingKeys: String, CodingKey {
            case firstSeen = "firstSeen"
            case lastSeen = "lastSeen"
            case targets = "targets"
            case ttps = "ttps"
        }
    }

    public struct AutoEnable: AWSEncodableShape & AWSDecodableShape {
        /// Represents whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
        public let ec2: Bool
        /// Represents whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
        public let ecr: Bool
        /// Represents whether Amazon Web Services Lambda standard scans are automatically enabled for new members of your Amazon Inspector organization.
        public let lambda: Bool?
        /// Represents whether Lambda code scans are automatically enabled for new members of your Amazon Inspector organization.
        public let lambdaCode: Bool?

        @inlinable
        public init(ec2: Bool, ecr: Bool, lambda: Bool? = nil, lambdaCode: Bool? = nil) {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }

        private enum CodingKeys: String, CodingKey {
            case ec2 = "ec2"
            case ecr = "ecr"
            case lambda = "lambda"
            case lambdaCode = "lambdaCode"
        }
    }

    public struct AwsEc2InstanceDetails: AWSDecodableShape {
        /// The IAM instance profile ARN of the Amazon EC2 instance.
        public let iamInstanceProfileArn: String?
        /// The image ID of the Amazon EC2 instance.
        public let imageId: String?
        /// The IPv4 addresses of the Amazon EC2 instance.
        public let ipV4Addresses: [String]?
        /// The IPv6 addresses of the Amazon EC2 instance.
        public let ipV6Addresses: [String]?
        /// The name of the key pair used to launch the Amazon EC2 instance.
        public let keyName: String?
        /// The date and time the Amazon EC2 instance was launched at.
        public let launchedAt: Date?
        /// The platform of the Amazon EC2 instance.
        public let platform: String?
        /// The subnet ID of the Amazon EC2 instance.
        public let subnetId: String?
        /// The type of the Amazon EC2 instance.
        public let type: String?
        /// The VPC ID of the Amazon EC2 instance.
        public let vpcId: String?

        @inlinable
        public init(iamInstanceProfileArn: String? = nil, imageId: String? = nil, ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil, keyName: String? = nil, launchedAt: Date? = nil, platform: String? = nil, subnetId: String? = nil, type: String? = nil, vpcId: String? = nil) {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.platform = platform
            self.subnetId = subnetId
            self.type = type
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case iamInstanceProfileArn = "iamInstanceProfileArn"
            case imageId = "imageId"
            case ipV4Addresses = "ipV4Addresses"
            case ipV6Addresses = "ipV6Addresses"
            case keyName = "keyName"
            case launchedAt = "launchedAt"
            case platform = "platform"
            case subnetId = "subnetId"
            case type = "type"
            case vpcId = "vpcId"
        }
    }

    public struct AwsEcrContainerAggregation: AWSEncodableShape {
        /// The architecture of the containers.
        public let architectures: [StringFilter]?
        /// The image SHA values.
        public let imageShas: [StringFilter]?
        /// The image tags.
        public let imageTags: [StringFilter]?
        /// The container repositories.
        public let repositories: [StringFilter]?
        /// The container resource IDs.
        public let resourceIds: [StringFilter]?
        /// The value to sort by.
        public let sortBy: AwsEcrContainerSortBy?
        /// The sort order (ascending or descending).
        public let sortOrder: SortOrder?

        @inlinable
        public init(architectures: [StringFilter]? = nil, imageShas: [StringFilter]? = nil, imageTags: [StringFilter]? = nil, repositories: [StringFilter]? = nil, resourceIds: [StringFilter]? = nil, sortBy: AwsEcrContainerSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.architectures = architectures
            self.imageShas = imageShas
            self.imageTags = imageTags
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.architectures?.forEach {
                try $0.validate(name: "\(name).architectures[]")
            }
            try self.validate(self.architectures, name: "architectures", parent: name, max: 10)
            try self.validate(self.architectures, name: "architectures", parent: name, min: 1)
            try self.imageShas?.forEach {
                try $0.validate(name: "\(name).imageShas[]")
            }
            try self.validate(self.imageShas, name: "imageShas", parent: name, max: 10)
            try self.validate(self.imageShas, name: "imageShas", parent: name, min: 1)
            try self.imageTags?.forEach {
                try $0.validate(name: "\(name).imageTags[]")
            }
            try self.validate(self.imageTags, name: "imageTags", parent: name, max: 10)
            try self.validate(self.imageTags, name: "imageTags", parent: name, min: 1)
            try self.repositories?.forEach {
                try $0.validate(name: "\(name).repositories[]")
            }
            try self.validate(self.repositories, name: "repositories", parent: name, max: 10)
            try self.validate(self.repositories, name: "repositories", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "architectures"
            case imageShas = "imageShas"
            case imageTags = "imageTags"
            case repositories = "repositories"
            case resourceIds = "resourceIds"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct AwsEcrContainerAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the account that owns the container.
        public let accountId: String?
        /// The architecture of the container.
        public let architecture: String?
        /// The SHA value of the container image.
        public let imageSha: String?
        /// The container image stags.
        public let imageTags: [String]?
        /// The container repository.
        public let repository: String?
        /// The resource ID of the container.
        public let resourceId: String
        /// The number of finding by severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, architecture: String? = nil, imageSha: String? = nil, imageTags: [String]? = nil, repository: String? = nil, resourceId: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.architecture = architecture
            self.imageSha = imageSha
            self.imageTags = imageTags
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case architecture = "architecture"
            case imageSha = "imageSha"
            case imageTags = "imageTags"
            case repository = "repository"
            case resourceId = "resourceId"
            case severityCounts = "severityCounts"
        }
    }

    public struct AwsEcrContainerImageDetails: AWSDecodableShape {
        /// The architecture of the Amazon ECR container image.
        public let architecture: String?
        /// The image author of the Amazon ECR container image.
        public let author: String?
        /// The image hash of the Amazon ECR container image.
        public let imageHash: String
        /// The image tags attached to the Amazon ECR container image.
        public let imageTags: [String]?
        /// The platform of the Amazon ECR container image.
        public let platform: String?
        /// The date and time the Amazon ECR container image was pushed.
        public let pushedAt: Date?
        /// The registry for the Amazon ECR container image.
        public let registry: String
        /// The name of the repository the Amazon ECR container image resides in.
        public let repositoryName: String

        @inlinable
        public init(architecture: String? = nil, author: String? = nil, imageHash: String, imageTags: [String]? = nil, platform: String? = nil, pushedAt: Date? = nil, registry: String, repositoryName: String) {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case author = "author"
            case imageHash = "imageHash"
            case imageTags = "imageTags"
            case platform = "platform"
            case pushedAt = "pushedAt"
            case registry = "registry"
            case repositoryName = "repositoryName"
        }
    }

    public struct AwsLambdaFunctionDetails: AWSDecodableShape {
        /// The instruction set architecture that the Amazon Web Services Lambda function supports. Architecture is a string array with one of the  valid values. The default architecture value is x86_64.
        public let architectures: [Architecture]?
        /// The SHA256 hash of the Amazon Web Services Lambda function's deployment package.
        public let codeSha256: String
        /// The Amazon Web Services Lambda function's execution role.
        public let executionRoleArn: String
        /// The name of the Amazon Web Services Lambda function.
        public let functionName: String
        /// The date and time that a user last updated the configuration, in ISO 8601 format
        public let lastModifiedAt: Date?
        /// The Amazon Web Services Lambda function's  layers. A Lambda function can have up to five layers.
        public let layers: [String]?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public let packageType: PackageType?
        /// The runtime environment for the Amazon Web Services Lambda function.
        public let runtime: Runtime
        /// The version of the Amazon Web Services Lambda function.
        public let version: String
        /// The Amazon Web Services Lambda function's networking configuration.
        public let vpcConfig: LambdaVpcConfig?

        @inlinable
        public init(architectures: [Architecture]? = nil, codeSha256: String, executionRoleArn: String, functionName: String, lastModifiedAt: Date? = nil, layers: [String]? = nil, packageType: PackageType? = nil, runtime: Runtime, version: String, vpcConfig: LambdaVpcConfig? = nil) {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.executionRoleArn = executionRoleArn
            self.functionName = functionName
            self.lastModifiedAt = lastModifiedAt
            self.layers = layers
            self.packageType = packageType
            self.runtime = runtime
            self.version = version
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "architectures"
            case codeSha256 = "codeSha256"
            case executionRoleArn = "executionRoleArn"
            case functionName = "functionName"
            case lastModifiedAt = "lastModifiedAt"
            case layers = "layers"
            case packageType = "packageType"
            case runtime = "runtime"
            case version = "version"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct BatchGetAccountStatusRequest: AWSEncodableShape {
        /// The 12-digit Amazon Web Services account IDs of the accounts to retrieve Amazon Inspector status for.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct BatchGetAccountStatusResponse: AWSDecodableShape {
        /// An array of objects that provide details on the status of Amazon Inspector for each of the requested accounts.
        public let accounts: [AccountState]
        /// An array of objects detailing any accounts that failed to enable Amazon Inspector and why.
        public let failedAccounts: [FailedAccount]?

        @inlinable
        public init(accounts: [AccountState], failedAccounts: [FailedAccount]? = nil) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case failedAccounts = "failedAccounts"
        }
    }

    public struct BatchGetCodeSnippetRequest: AWSEncodableShape {
        /// An array of finding ARNs for the findings you want to retrieve code snippets from.
        public let findingArns: [String]

        @inlinable
        public init(findingArns: [String]) {
            self.findingArns = findingArns
        }

        public func validate(name: String) throws {
            try self.findingArns.forEach {
                try validate($0, name: "findingArns[]", parent: name, max: 100)
                try validate($0, name: "findingArns[]", parent: name, min: 1)
                try validate($0, name: "findingArns[]", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:inspector2:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:finding/[a-f0-9]{32}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case findingArns = "findingArns"
        }
    }

    public struct BatchGetCodeSnippetResponse: AWSDecodableShape {
        /// The retrieved code snippets associated with the provided finding ARNs.
        public let codeSnippetResults: [CodeSnippetResult]?
        /// Any errors Amazon Inspector encountered while trying to retrieve the requested code snippets.
        public let errors: [CodeSnippetError]?

        @inlinable
        public init(codeSnippetResults: [CodeSnippetResult]? = nil, errors: [CodeSnippetError]? = nil) {
            self.codeSnippetResults = codeSnippetResults
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case codeSnippetResults = "codeSnippetResults"
            case errors = "errors"
        }
    }

    public struct BatchGetFindingDetailsRequest: AWSEncodableShape {
        /// A list of finding ARNs.
        public let findingArns: [String]

        @inlinable
        public init(findingArns: [String]) {
            self.findingArns = findingArns
        }

        public func validate(name: String) throws {
            try self.findingArns.forEach {
                try validate($0, name: "findingArns[]", parent: name, max: 100)
                try validate($0, name: "findingArns[]", parent: name, min: 1)
                try validate($0, name: "findingArns[]", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:inspector2:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:finding/[a-f0-9]{32}$")
            }
            try self.validate(self.findingArns, name: "findingArns", parent: name, max: 10)
            try self.validate(self.findingArns, name: "findingArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingArns = "findingArns"
        }
    }

    public struct BatchGetFindingDetailsResponse: AWSDecodableShape {
        /// Error information for findings that details could not be returned for.
        public let errors: [FindingDetailsError]?
        /// A finding's vulnerability details.
        public let findingDetails: [FindingDetail]?

        @inlinable
        public init(errors: [FindingDetailsError]? = nil, findingDetails: [FindingDetail]? = nil) {
            self.errors = errors
            self.findingDetails = findingDetails
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case findingDetails = "findingDetails"
        }
    }

    public struct BatchGetFreeTrialInfoRequest: AWSEncodableShape {
        /// The account IDs to get free trial status for.
        public let accountIds: [String]

        @inlinable
        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "[0-9]{12}")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct BatchGetFreeTrialInfoResponse: AWSDecodableShape {
        /// An array of objects that provide Amazon Inspector free trial details for each of the requested accounts.
        public let accounts: [FreeTrialAccountInfo]
        /// An array of objects detailing any accounts that free trial data could not be returned for.
        public let failedAccounts: [FreeTrialInfoError]

        @inlinable
        public init(accounts: [FreeTrialAccountInfo], failedAccounts: [FreeTrialInfoError]) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case failedAccounts = "failedAccounts"
        }
    }

    public struct BatchGetMemberEc2DeepInspectionStatusRequest: AWSEncodableShape {
        /// The unique identifiers for the Amazon Web Services accounts to retrieve Amazon Inspector deep inspection activation status for.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct BatchGetMemberEc2DeepInspectionStatusResponse: AWSDecodableShape {
        /// An array of objects that provide details on the activation status of Amazon Inspector deep inspection for each of the requested accounts.
        public let accountIds: [MemberAccountEc2DeepInspectionStatusState]?
        /// An array of objects that provide details on any accounts that failed to activate Amazon Inspector deep inspection and why.
        public let failedAccountIds: [FailedMemberAccountEc2DeepInspectionStatusState]?

        @inlinable
        public init(accountIds: [MemberAccountEc2DeepInspectionStatusState]? = nil, failedAccountIds: [FailedMemberAccountEc2DeepInspectionStatusState]? = nil) {
            self.accountIds = accountIds
            self.failedAccountIds = failedAccountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case failedAccountIds = "failedAccountIds"
        }
    }

    public struct BatchUpdateMemberEc2DeepInspectionStatusRequest: AWSEncodableShape {
        /// The unique identifiers for the Amazon Web Services accounts to change Amazon Inspector deep inspection status for.
        public let accountIds: [MemberAccountEc2DeepInspectionStatus]

        @inlinable
        public init(accountIds: [MemberAccountEc2DeepInspectionStatus]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try $0.validate(name: "\(name).accountIds[]")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
        }
    }

    public struct BatchUpdateMemberEc2DeepInspectionStatusResponse: AWSDecodableShape {
        /// An array of objects that provide details for each of the accounts that Amazon Inspector deep inspection status was successfully changed for.
        public let accountIds: [MemberAccountEc2DeepInspectionStatusState]?
        /// An array of objects that provide details for each of the accounts that Amazon Inspector deep inspection status could not be successfully changed for.
        public let failedAccountIds: [FailedMemberAccountEc2DeepInspectionStatusState]?

        @inlinable
        public init(accountIds: [MemberAccountEc2DeepInspectionStatusState]? = nil, failedAccountIds: [FailedMemberAccountEc2DeepInspectionStatusState]? = nil) {
            self.accountIds = accountIds
            self.failedAccountIds = failedAccountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case failedAccountIds = "failedAccountIds"
        }
    }

    public struct CancelFindingsReportRequest: AWSEncodableShape {
        /// The ID of the report to be canceled.
        public let reportId: String

        @inlinable
        public init(reportId: String) {
            self.reportId = reportId
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "\\b[a-f0-9]{8}\\b-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-\\b[a-f0-9]{12}\\b")
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct CancelFindingsReportResponse: AWSDecodableShape {
        /// The ID of the canceled report.
        public let reportId: String

        @inlinable
        public init(reportId: String) {
            self.reportId = reportId
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct CancelSbomExportRequest: AWSEncodableShape {
        /// The report ID of the SBOM export to cancel.
        public let reportId: String

        @inlinable
        public init(reportId: String) {
            self.reportId = reportId
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "\\b[a-f0-9]{8}\\b-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-\\b[a-f0-9]{12}\\b")
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct CancelSbomExportResponse: AWSDecodableShape {
        /// The report ID of the canceled SBOM export.
        public let reportId: String?

        @inlinable
        public init(reportId: String? = nil) {
            self.reportId = reportId
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct CisCheckAggregation: AWSDecodableShape {
        /// The account ID for the CIS check.
        public let accountId: String?
        /// The description for the CIS check.
        public let checkDescription: String?
        /// The check ID for the CIS check.
        public let checkId: String?
        /// The CIS check level.
        public let level: CisSecurityLevel?
        /// The CIS check platform.
        public let platform: String?
        /// The scan ARN for the CIS check scan ARN.
        public let scanArn: String
        /// The CIS check status counts.
        public let statusCounts: StatusCounts?
        /// The CIS check title.
        public let title: String?

        @inlinable
        public init(accountId: String? = nil, checkDescription: String? = nil, checkId: String? = nil, level: CisSecurityLevel? = nil, platform: String? = nil, scanArn: String, statusCounts: StatusCounts? = nil, title: String? = nil) {
            self.accountId = accountId
            self.checkDescription = checkDescription
            self.checkId = checkId
            self.level = level
            self.platform = platform
            self.scanArn = scanArn
            self.statusCounts = statusCounts
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case checkDescription = "checkDescription"
            case checkId = "checkId"
            case level = "level"
            case platform = "platform"
            case scanArn = "scanArn"
            case statusCounts = "statusCounts"
            case title = "title"
        }
    }

    public struct CisDateFilter: AWSEncodableShape {
        /// The CIS date filter's earliest scan start time.
        public let earliestScanStartTime: Date?
        /// The CIS date filter's latest scan start time.
        public let latestScanStartTime: Date?

        @inlinable
        public init(earliestScanStartTime: Date? = nil, latestScanStartTime: Date? = nil) {
            self.earliestScanStartTime = earliestScanStartTime
            self.latestScanStartTime = latestScanStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case earliestScanStartTime = "earliestScanStartTime"
            case latestScanStartTime = "latestScanStartTime"
        }
    }

    public struct CisFindingStatusFilter: AWSEncodableShape {
        /// The comparison value of the CIS finding status filter.
        public let comparison: CisFindingStatusComparison
        /// The value of the CIS finding status filter.
        public let value: CisFindingStatus

        @inlinable
        public init(comparison: CisFindingStatusComparison, value: CisFindingStatus) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisNumberFilter: AWSEncodableShape {
        /// The CIS number filter's lower inclusive.
        public let lowerInclusive: Int?
        /// The CIS number filter's upper inclusive.
        public let upperInclusive: Int?

        @inlinable
        public init(lowerInclusive: Int? = nil, upperInclusive: Int? = nil) {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case lowerInclusive = "lowerInclusive"
            case upperInclusive = "upperInclusive"
        }
    }

    public struct CisResultStatusFilter: AWSEncodableShape {
        /// The comparison value of the CIS result status filter.
        public let comparison: CisResultStatusComparison
        /// The value of the CIS result status filter.
        public let value: CisResultStatus

        @inlinable
        public init(comparison: CisResultStatusComparison, value: CisResultStatus) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisScan: AWSDecodableShape {
        /// The CIS scan's failed checks.
        public let failedChecks: Int?
        /// The CIS scan's ARN.
        public let scanArn: String
        /// The CIS scan's configuration ARN.
        public let scanConfigurationArn: String
        /// The CIS scan's date.
        public let scanDate: Date?
        /// The the name of the scan configuration that's associated with this scan.
        public let scanName: String?
        /// The account or organization that schedules the CIS scan.
        public let scheduledBy: String?
        ///  The security level for the CIS scan.  Security level refers to the Benchmark levels that CIS assigns to a profile.
        public let securityLevel: CisSecurityLevel?
        /// The CIS scan's status.
        public let status: CisScanStatus?
        /// The CIS scan's targets.
        public let targets: CisTargets?
        /// The CIS scan's total checks.
        public let totalChecks: Int?

        @inlinable
        public init(failedChecks: Int? = nil, scanArn: String, scanConfigurationArn: String, scanDate: Date? = nil, scanName: String? = nil, scheduledBy: String? = nil, securityLevel: CisSecurityLevel? = nil, status: CisScanStatus? = nil, targets: CisTargets? = nil, totalChecks: Int? = nil) {
            self.failedChecks = failedChecks
            self.scanArn = scanArn
            self.scanConfigurationArn = scanConfigurationArn
            self.scanDate = scanDate
            self.scanName = scanName
            self.scheduledBy = scheduledBy
            self.securityLevel = securityLevel
            self.status = status
            self.targets = targets
            self.totalChecks = totalChecks
        }

        private enum CodingKeys: String, CodingKey {
            case failedChecks = "failedChecks"
            case scanArn = "scanArn"
            case scanConfigurationArn = "scanConfigurationArn"
            case scanDate = "scanDate"
            case scanName = "scanName"
            case scheduledBy = "scheduledBy"
            case securityLevel = "securityLevel"
            case status = "status"
            case targets = "targets"
            case totalChecks = "totalChecks"
        }
    }

    public struct CisScanConfiguration: AWSDecodableShape {
        /// The CIS scan configuration's owner ID.
        public let ownerId: String?
        /// The CIS scan configuration's scan configuration ARN.
        public let scanConfigurationArn: String
        /// The name of the CIS scan configuration.
        public let scanName: String?
        /// The CIS scan configuration's schedule.
        public let schedule: Schedule?
        /// The CIS scan configuration's security level.
        public let securityLevel: CisSecurityLevel?
        /// The CIS scan configuration's tags.
        public let tags: [String: String]?
        /// The CIS scan configuration's targets.
        public let targets: CisTargets?

        @inlinable
        public init(ownerId: String? = nil, scanConfigurationArn: String, scanName: String? = nil, schedule: Schedule? = nil, securityLevel: CisSecurityLevel? = nil, tags: [String: String]? = nil, targets: CisTargets? = nil) {
            self.ownerId = ownerId
            self.scanConfigurationArn = scanConfigurationArn
            self.scanName = scanName
            self.schedule = schedule
            self.securityLevel = securityLevel
            self.tags = tags
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case ownerId = "ownerId"
            case scanConfigurationArn = "scanConfigurationArn"
            case scanName = "scanName"
            case schedule = "schedule"
            case securityLevel = "securityLevel"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct CisScanResultDetails: AWSDecodableShape {
        /// The CIS scan result details' account ID.
        public let accountId: String?
        /// The account ID that's associated with the CIS scan result details.
        public let checkDescription: String?
        /// The CIS scan result details' check ID.
        public let checkId: String?
        /// The CIS scan result details' finding ARN.
        public let findingArn: String?
        /// The CIS scan result details' level.
        public let level: CisSecurityLevel?
        /// The CIS scan result details' platform.
        public let platform: String?
        /// The CIS scan result details' remediation.
        public let remediation: String?
        /// The CIS scan result details' scan ARN.
        public let scanArn: String
        /// The CIS scan result details' status.
        public let status: CisFindingStatus?
        /// The CIS scan result details' status reason.
        public let statusReason: String?
        /// The CIS scan result details' target resource ID.
        public let targetResourceId: String?
        /// The CIS scan result details' title.
        public let title: String?

        @inlinable
        public init(accountId: String? = nil, checkDescription: String? = nil, checkId: String? = nil, findingArn: String? = nil, level: CisSecurityLevel? = nil, platform: String? = nil, remediation: String? = nil, scanArn: String, status: CisFindingStatus? = nil, statusReason: String? = nil, targetResourceId: String? = nil, title: String? = nil) {
            self.accountId = accountId
            self.checkDescription = checkDescription
            self.checkId = checkId
            self.findingArn = findingArn
            self.level = level
            self.platform = platform
            self.remediation = remediation
            self.scanArn = scanArn
            self.status = status
            self.statusReason = statusReason
            self.targetResourceId = targetResourceId
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case checkDescription = "checkDescription"
            case checkId = "checkId"
            case findingArn = "findingArn"
            case level = "level"
            case platform = "platform"
            case remediation = "remediation"
            case scanArn = "scanArn"
            case status = "status"
            case statusReason = "statusReason"
            case targetResourceId = "targetResourceId"
            case title = "title"
        }
    }

    public struct CisScanResultDetailsFilterCriteria: AWSEncodableShape {
        /// The criteria's check ID filters.
        public let checkIdFilters: [CisStringFilter]?
        /// The criteria's finding ARN filters.
        public let findingArnFilters: [CisStringFilter]?
        /// The criteria's finding status filters.
        public let findingStatusFilters: [CisFindingStatusFilter]?
        ///  The criteria's security level filters. .  Security level refers to the Benchmark levels that CIS assigns to a profile.
        public let securityLevelFilters: [CisSecurityLevelFilter]?
        /// The criteria's title filters.
        public let titleFilters: [CisStringFilter]?

        @inlinable
        public init(checkIdFilters: [CisStringFilter]? = nil, findingArnFilters: [CisStringFilter]? = nil, findingStatusFilters: [CisFindingStatusFilter]? = nil, securityLevelFilters: [CisSecurityLevelFilter]? = nil, titleFilters: [CisStringFilter]? = nil) {
            self.checkIdFilters = checkIdFilters
            self.findingArnFilters = findingArnFilters
            self.findingStatusFilters = findingStatusFilters
            self.securityLevelFilters = securityLevelFilters
            self.titleFilters = titleFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.checkIdFilters, name: "checkIdFilters", parent: name, max: 10)
            try self.validate(self.checkIdFilters, name: "checkIdFilters", parent: name, min: 1)
            try self.validate(self.findingArnFilters, name: "findingArnFilters", parent: name, max: 10)
            try self.validate(self.findingArnFilters, name: "findingArnFilters", parent: name, min: 1)
            try self.validate(self.findingStatusFilters, name: "findingStatusFilters", parent: name, max: 10)
            try self.validate(self.findingStatusFilters, name: "findingStatusFilters", parent: name, min: 1)
            try self.validate(self.securityLevelFilters, name: "securityLevelFilters", parent: name, max: 10)
            try self.validate(self.securityLevelFilters, name: "securityLevelFilters", parent: name, min: 1)
            try self.validate(self.titleFilters, name: "titleFilters", parent: name, max: 10)
            try self.validate(self.titleFilters, name: "titleFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case checkIdFilters = "checkIdFilters"
            case findingArnFilters = "findingArnFilters"
            case findingStatusFilters = "findingStatusFilters"
            case securityLevelFilters = "securityLevelFilters"
            case titleFilters = "titleFilters"
        }
    }

    public struct CisScanResultsAggregatedByChecksFilterCriteria: AWSEncodableShape {
        /// The criteria's account ID filters.
        public let accountIdFilters: [CisStringFilter]?
        /// The criteria's check ID filters.
        public let checkIdFilters: [CisStringFilter]?
        /// The criteria's failed resources filters.
        public let failedResourcesFilters: [CisNumberFilter]?
        /// The criteria's platform filters.
        public let platformFilters: [CisStringFilter]?
        /// The criteria's security level filters.
        public let securityLevelFilters: [CisSecurityLevelFilter]?
        /// The criteria's title filters.
        public let titleFilters: [CisStringFilter]?

        @inlinable
        public init(accountIdFilters: [CisStringFilter]? = nil, checkIdFilters: [CisStringFilter]? = nil, failedResourcesFilters: [CisNumberFilter]? = nil, platformFilters: [CisStringFilter]? = nil, securityLevelFilters: [CisSecurityLevelFilter]? = nil, titleFilters: [CisStringFilter]? = nil) {
            self.accountIdFilters = accountIdFilters
            self.checkIdFilters = checkIdFilters
            self.failedResourcesFilters = failedResourcesFilters
            self.platformFilters = platformFilters
            self.securityLevelFilters = securityLevelFilters
            self.titleFilters = titleFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.accountIdFilters, name: "accountIdFilters", parent: name, max: 1)
            try self.validate(self.accountIdFilters, name: "accountIdFilters", parent: name, min: 1)
            try self.validate(self.checkIdFilters, name: "checkIdFilters", parent: name, max: 10)
            try self.validate(self.checkIdFilters, name: "checkIdFilters", parent: name, min: 1)
            try self.validate(self.failedResourcesFilters, name: "failedResourcesFilters", parent: name, max: 10)
            try self.validate(self.failedResourcesFilters, name: "failedResourcesFilters", parent: name, min: 1)
            try self.validate(self.platformFilters, name: "platformFilters", parent: name, max: 10)
            try self.validate(self.platformFilters, name: "platformFilters", parent: name, min: 1)
            try self.validate(self.securityLevelFilters, name: "securityLevelFilters", parent: name, max: 10)
            try self.validate(self.securityLevelFilters, name: "securityLevelFilters", parent: name, min: 1)
            try self.validate(self.titleFilters, name: "titleFilters", parent: name, max: 10)
            try self.validate(self.titleFilters, name: "titleFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIdFilters = "accountIdFilters"
            case checkIdFilters = "checkIdFilters"
            case failedResourcesFilters = "failedResourcesFilters"
            case platformFilters = "platformFilters"
            case securityLevelFilters = "securityLevelFilters"
            case titleFilters = "titleFilters"
        }
    }

    public struct CisScanResultsAggregatedByTargetResourceFilterCriteria: AWSEncodableShape {
        /// The criteria's account ID filters.
        public let accountIdFilters: [CisStringFilter]?
        /// The criteria's check ID filters.
        public let checkIdFilters: [CisStringFilter]?
        /// The criteria's failed checks filters.
        public let failedChecksFilters: [CisNumberFilter]?
        /// The criteria's platform filters.
        public let platformFilters: [CisStringFilter]?
        /// The criteria's status filter.
        public let statusFilters: [CisResultStatusFilter]?
        /// The criteria's target resource ID filters.
        public let targetResourceIdFilters: [CisStringFilter]?
        /// The criteria's target resource tag filters.
        public let targetResourceTagFilters: [TagFilter]?
        /// The criteria's target status filters.
        public let targetStatusFilters: [CisTargetStatusFilter]?
        /// The criteria's target status reason filters.
        public let targetStatusReasonFilters: [CisTargetStatusReasonFilter]?

        @inlinable
        public init(accountIdFilters: [CisStringFilter]? = nil, checkIdFilters: [CisStringFilter]? = nil, failedChecksFilters: [CisNumberFilter]? = nil, platformFilters: [CisStringFilter]? = nil, statusFilters: [CisResultStatusFilter]? = nil, targetResourceIdFilters: [CisStringFilter]? = nil, targetResourceTagFilters: [TagFilter]? = nil, targetStatusFilters: [CisTargetStatusFilter]? = nil, targetStatusReasonFilters: [CisTargetStatusReasonFilter]? = nil) {
            self.accountIdFilters = accountIdFilters
            self.checkIdFilters = checkIdFilters
            self.failedChecksFilters = failedChecksFilters
            self.platformFilters = platformFilters
            self.statusFilters = statusFilters
            self.targetResourceIdFilters = targetResourceIdFilters
            self.targetResourceTagFilters = targetResourceTagFilters
            self.targetStatusFilters = targetStatusFilters
            self.targetStatusReasonFilters = targetStatusReasonFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.accountIdFilters, name: "accountIdFilters", parent: name, max: 10)
            try self.validate(self.accountIdFilters, name: "accountIdFilters", parent: name, min: 1)
            try self.validate(self.checkIdFilters, name: "checkIdFilters", parent: name, max: 10)
            try self.validate(self.checkIdFilters, name: "checkIdFilters", parent: name, min: 1)
            try self.validate(self.failedChecksFilters, name: "failedChecksFilters", parent: name, max: 10)
            try self.validate(self.failedChecksFilters, name: "failedChecksFilters", parent: name, min: 1)
            try self.validate(self.platformFilters, name: "platformFilters", parent: name, max: 10)
            try self.validate(self.platformFilters, name: "platformFilters", parent: name, min: 1)
            try self.validate(self.statusFilters, name: "statusFilters", parent: name, max: 10)
            try self.validate(self.statusFilters, name: "statusFilters", parent: name, min: 1)
            try self.validate(self.targetResourceIdFilters, name: "targetResourceIdFilters", parent: name, max: 10)
            try self.validate(self.targetResourceIdFilters, name: "targetResourceIdFilters", parent: name, min: 1)
            try self.targetResourceTagFilters?.forEach {
                try $0.validate(name: "\(name).targetResourceTagFilters[]")
            }
            try self.validate(self.targetResourceTagFilters, name: "targetResourceTagFilters", parent: name, max: 10)
            try self.validate(self.targetResourceTagFilters, name: "targetResourceTagFilters", parent: name, min: 1)
            try self.validate(self.targetStatusFilters, name: "targetStatusFilters", parent: name, max: 10)
            try self.validate(self.targetStatusFilters, name: "targetStatusFilters", parent: name, min: 1)
            try self.validate(self.targetStatusReasonFilters, name: "targetStatusReasonFilters", parent: name, max: 10)
            try self.validate(self.targetStatusReasonFilters, name: "targetStatusReasonFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIdFilters = "accountIdFilters"
            case checkIdFilters = "checkIdFilters"
            case failedChecksFilters = "failedChecksFilters"
            case platformFilters = "platformFilters"
            case statusFilters = "statusFilters"
            case targetResourceIdFilters = "targetResourceIdFilters"
            case targetResourceTagFilters = "targetResourceTagFilters"
            case targetStatusFilters = "targetStatusFilters"
            case targetStatusReasonFilters = "targetStatusReasonFilters"
        }
    }

    public struct CisScanStatusFilter: AWSEncodableShape {
        /// The filter comparison value.
        public let comparison: CisScanStatusComparison
        /// The filter value.
        public let value: CisScanStatus

        @inlinable
        public init(comparison: CisScanStatusComparison, value: CisScanStatus) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisSecurityLevelFilter: AWSEncodableShape {
        /// The CIS security filter comparison value.
        public let comparison: CisSecurityLevelComparison
        /// The CIS security filter value.
        public let value: CisSecurityLevel

        @inlinable
        public init(comparison: CisSecurityLevelComparison, value: CisSecurityLevel) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisSessionMessage: AWSEncodableShape {
        /// The CIS rule details for the CIS session message.
        public let cisRuleDetails: AWSBase64Data
        /// The rule ID for the CIS session message.
        public let ruleId: String
        /// The status of the CIS session message.
        public let status: CisRuleStatus

        @inlinable
        public init(cisRuleDetails: AWSBase64Data, ruleId: String, status: CisRuleStatus) {
            self.cisRuleDetails = cisRuleDetails
            self.ruleId = ruleId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.cisRuleDetails, name: "cisRuleDetails", parent: name, max: 1000)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 500)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cisRuleDetails = "cisRuleDetails"
            case ruleId = "ruleId"
            case status = "status"
        }
    }

    public struct CisStringFilter: AWSEncodableShape {
        /// The comparison value of the CIS string filter.
        public let comparison: CisStringComparison
        /// The value of the CIS string filter.
        public let value: String

        @inlinable
        public init(comparison: CisStringComparison, value: String) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisTargetResourceAggregation: AWSDecodableShape {
        /// The account ID for the CIS target resource.
        public let accountId: String?
        /// The platform for the CIS target resource.
        public let platform: String?
        /// The scan ARN for the CIS target resource.
        public let scanArn: String
        /// The target resource status counts.
        public let statusCounts: StatusCounts?
        /// The ID of the target resource.
        public let targetResourceId: String?
        /// The tag for the target resource.
        public let targetResourceTags: [String: [String]]?
        /// The status of the target resource.
        public let targetStatus: CisTargetStatus?
        /// The reason for the target resource.
        public let targetStatusReason: CisTargetStatusReason?

        @inlinable
        public init(accountId: String? = nil, platform: String? = nil, scanArn: String, statusCounts: StatusCounts? = nil, targetResourceId: String? = nil, targetResourceTags: [String: [String]]? = nil, targetStatus: CisTargetStatus? = nil, targetStatusReason: CisTargetStatusReason? = nil) {
            self.accountId = accountId
            self.platform = platform
            self.scanArn = scanArn
            self.statusCounts = statusCounts
            self.targetResourceId = targetResourceId
            self.targetResourceTags = targetResourceTags
            self.targetStatus = targetStatus
            self.targetStatusReason = targetStatusReason
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case platform = "platform"
            case scanArn = "scanArn"
            case statusCounts = "statusCounts"
            case targetResourceId = "targetResourceId"
            case targetResourceTags = "targetResourceTags"
            case targetStatus = "targetStatus"
            case targetStatusReason = "targetStatusReason"
        }
    }

    public struct CisTargetStatusFilter: AWSEncodableShape {
        /// The comparison value of the CIS target status filter.
        public let comparison: CisTargetStatusComparison
        /// The value of the CIS target status filter.
        public let value: CisTargetStatus

        @inlinable
        public init(comparison: CisTargetStatusComparison, value: CisTargetStatus) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisTargetStatusReasonFilter: AWSEncodableShape {
        /// The comparison value of the CIS target status reason filter.
        public let comparison: CisTargetStatusComparison
        /// The value of the CIS target status reason filter.
        public let value: CisTargetStatusReason

        @inlinable
        public init(comparison: CisTargetStatusComparison, value: CisTargetStatusReason) {
            self.comparison = comparison
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CisTargets: AWSDecodableShape {
        /// The CIS target account ids.
        public let accountIds: [String]?
        /// The CIS target resource tags.
        public let targetResourceTags: [String: [String]]?

        @inlinable
        public init(accountIds: [String]? = nil, targetResourceTags: [String: [String]]? = nil) {
            self.accountIds = accountIds
            self.targetResourceTags = targetResourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case targetResourceTags = "targetResourceTags"
        }
    }

    public struct CisaData: AWSDecodableShape {
        /// The remediation action recommended by CISA for this vulnerability.
        public let action: String?
        /// The date and time CISA added this vulnerability to their catalogue.
        public let dateAdded: Date?
        /// The date and time CISA expects a fix to have been provided vulnerability.
        public let dateDue: Date?

        @inlinable
        public init(action: String? = nil, dateAdded: Date? = nil, dateDue: Date? = nil) {
            self.action = action
            self.dateAdded = dateAdded
            self.dateDue = dateDue
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case dateAdded = "dateAdded"
            case dateDue = "dateDue"
        }
    }

    public struct CodeFilePath: AWSDecodableShape {
        /// The line number of the last line of code that a vulnerability was found in.
        public let endLine: Int
        /// The name of the file the code vulnerability was found in.
        public let fileName: String
        /// The file path to the code that a vulnerability was found in.
        public let filePath: String
        /// The line number of the first line of code that a vulnerability was found in.
        public let startLine: Int

        @inlinable
        public init(endLine: Int, fileName: String, filePath: String, startLine: Int) {
            self.endLine = endLine
            self.fileName = fileName
            self.filePath = filePath
            self.startLine = startLine
        }

        private enum CodingKeys: String, CodingKey {
            case endLine = "endLine"
            case fileName = "fileName"
            case filePath = "filePath"
            case startLine = "startLine"
        }
    }

    public struct CodeLine: AWSDecodableShape {
        /// The content of a line of code
        public let content: String
        /// The line number that a section of code is located at.
        public let lineNumber: Int

        @inlinable
        public init(content: String, lineNumber: Int) {
            self.content = content
            self.lineNumber = lineNumber
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case lineNumber = "lineNumber"
        }
    }

    public struct CodeSnippetError: AWSDecodableShape {
        /// The error code for the error that prevented a code snippet from being retrieved.
        public let errorCode: CodeSnippetErrorCode
        /// The error message received when Amazon Inspector failed to retrieve a code snippet.
        public let errorMessage: String
        /// The ARN of the finding that a code snippet couldn't be retrieved for.
        public let findingArn: String

        @inlinable
        public init(errorCode: CodeSnippetErrorCode, errorMessage: String, findingArn: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingArn = findingArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case findingArn = "findingArn"
        }
    }

    public struct CodeSnippetResult: AWSDecodableShape {
        /// Contains information on the retrieved code snippet.
        public let codeSnippet: [CodeLine]?
        /// The line number of the last line of a code snippet.
        public let endLine: Int?
        /// The ARN of a finding that the code snippet is associated with.
        public let findingArn: String?
        /// The line number of the first line of a code snippet.
        public let startLine: Int?
        /// Details of a suggested code fix.
        public let suggestedFixes: [SuggestedFix]?

        @inlinable
        public init(codeSnippet: [CodeLine]? = nil, endLine: Int? = nil, findingArn: String? = nil, startLine: Int? = nil, suggestedFixes: [SuggestedFix]? = nil) {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.findingArn = findingArn
            self.startLine = startLine
            self.suggestedFixes = suggestedFixes
        }

        private enum CodingKeys: String, CodingKey {
            case codeSnippet = "codeSnippet"
            case endLine = "endLine"
            case findingArn = "findingArn"
            case startLine = "startLine"
            case suggestedFixes = "suggestedFixes"
        }
    }

    public struct CodeVulnerabilityDetails: AWSDecodableShape {
        /// The Common Weakness Enumeration (CWE) item associated with the detected vulnerability.
        public let cwes: [String]
        /// The ID for the Amazon CodeGuru detector associated with the finding. For more information on detectors see Amazon CodeGuru Detector Library.
        public let detectorId: String
        /// The name of the detector used to identify the code vulnerability. For more information on detectors see CodeGuru Detector Library.
        public let detectorName: String
        /// The detector tag associated with the vulnerability. Detector tags group related vulnerabilities by common themes or tactics. For a list of available tags by programming language, see Java tags, or Python tags.
        public let detectorTags: [String]?
        /// Contains information on where the code vulnerability is located in your code.
        public let filePath: CodeFilePath
        /// A URL containing supporting documentation about the code vulnerability detected.
        public let referenceUrls: [String]?
        /// The identifier for a rule that was used to detect the code vulnerability.
        public let ruleId: String?
        /// The Amazon Resource Name (ARN) of the Lambda layer that the code vulnerability was detected in.
        public let sourceLambdaLayerArn: String?

        @inlinable
        public init(cwes: [String], detectorId: String, detectorName: String, detectorTags: [String]? = nil, filePath: CodeFilePath, referenceUrls: [String]? = nil, ruleId: String? = nil, sourceLambdaLayerArn: String? = nil) {
            self.cwes = cwes
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.filePath = filePath
            self.referenceUrls = referenceUrls
            self.ruleId = ruleId
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
        }

        private enum CodingKeys: String, CodingKey {
            case cwes = "cwes"
            case detectorId = "detectorId"
            case detectorName = "detectorName"
            case detectorTags = "detectorTags"
            case filePath = "filePath"
            case referenceUrls = "referenceUrls"
            case ruleId = "ruleId"
            case sourceLambdaLayerArn = "sourceLambdaLayerArn"
        }
    }

    public struct ComputePlatform: AWSEncodableShape {
        /// The compute platform product.
        public let product: String?
        /// The compute platform vendor.
        public let vendor: String?
        /// The compute platform version.
        public let version: String?

        @inlinable
        public init(product: String? = nil, vendor: String? = nil, version: String? = nil) {
            self.product = product
            self.vendor = vendor
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.product, name: "product", parent: name, max: 32)
            try self.validate(self.vendor, name: "vendor", parent: name, max: 16)
            try self.validate(self.version, name: "version", parent: name, max: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case product = "product"
            case vendor = "vendor"
            case version = "version"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The ID of the conflicting resource.
        public let resourceId: String
        /// The type of the conflicting resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct Counts: AWSDecodableShape {
        /// The number of resources.
        public let count: Int64?
        /// The key associated with this group
        public let groupKey: GroupKey?

        @inlinable
        public init(count: Int64? = nil, groupKey: GroupKey? = nil) {
            self.count = count
            self.groupKey = groupKey
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case groupKey = "groupKey"
        }
    }

    public struct CoverageDateFilter: AWSEncodableShape {
        /// A timestamp representing the end of the time period to filter results by.
        public let endInclusive: Date?
        /// A timestamp representing the start of the time period to filter results by.
        public let startInclusive: Date?

        @inlinable
        public init(endInclusive: Date? = nil, startInclusive: Date? = nil) {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case endInclusive = "endInclusive"
            case startInclusive = "startInclusive"
        }
    }

    public struct CoverageFilterCriteria: AWSEncodableShape {
        /// An array of Amazon Web Services account IDs to return coverage statistics for.
        public let accountId: [CoverageStringFilter]?
        /// The Amazon EC2 instance tags to filter on.
        public let ec2InstanceTags: [CoverageMapFilter]?
        /// The Amazon ECR image tags to filter on.
        public let ecrImageTags: [CoverageStringFilter]?
        /// The Amazon ECR repository name to filter on.
        public let ecrRepositoryName: [CoverageStringFilter]?
        /// The date an image was last pulled at.
        public let imagePulledAt: [CoverageDateFilter]?
        /// Returns coverage statistics for Amazon Web Services Lambda functions filtered by function names.
        public let lambdaFunctionName: [CoverageStringFilter]?
        /// Returns coverage statistics for Amazon Web Services Lambda functions filtered by runtime.
        public let lambdaFunctionRuntime: [CoverageStringFilter]?
        /// Returns coverage statistics for Amazon Web Services Lambda functions filtered by tag.
        public let lambdaFunctionTags: [CoverageMapFilter]?
        /// Filters Amazon Web Services resources based on whether Amazon Inspector has checked them for vulnerabilities within the specified time range.
        public let lastScannedAt: [CoverageDateFilter]?
        /// An array of Amazon Web Services resource IDs to return coverage statistics for.
        public let resourceId: [CoverageStringFilter]?
        /// An array of Amazon Web Services resource types to return coverage statistics for. The values can be AWS_EC2_INSTANCE, AWS_LAMBDA_FUNCTION, AWS_ECR_CONTAINER_IMAGE,  AWS_ECR_REPOSITORY or AWS_ACCOUNT.
        public let resourceType: [CoverageStringFilter]?
        /// The filter to search for Amazon EC2 instance coverage by scan mode. Valid values are EC2_SSM_AGENT_BASED and EC2_AGENTLESS.
        public let scanMode: [CoverageStringFilter]?
        /// The scan status code to filter on. Valid values are: ValidationException, InternalServerException, ResourceNotFoundException, BadRequestException, and ThrottlingException.
        public let scanStatusCode: [CoverageStringFilter]?
        /// The scan status reason to filter on.
        public let scanStatusReason: [CoverageStringFilter]?
        /// An array of Amazon Inspector scan types to return coverage statistics for.
        public let scanType: [CoverageStringFilter]?

        @inlinable
        public init(accountId: [CoverageStringFilter]? = nil, ec2InstanceTags: [CoverageMapFilter]? = nil, ecrImageTags: [CoverageStringFilter]? = nil, ecrRepositoryName: [CoverageStringFilter]? = nil, imagePulledAt: [CoverageDateFilter]? = nil, lambdaFunctionName: [CoverageStringFilter]? = nil, lambdaFunctionRuntime: [CoverageStringFilter]? = nil, lambdaFunctionTags: [CoverageMapFilter]? = nil, lastScannedAt: [CoverageDateFilter]? = nil, resourceId: [CoverageStringFilter]? = nil, resourceType: [CoverageStringFilter]? = nil, scanMode: [CoverageStringFilter]? = nil, scanStatusCode: [CoverageStringFilter]? = nil, scanStatusReason: [CoverageStringFilter]? = nil, scanType: [CoverageStringFilter]? = nil) {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.imagePulledAt = imagePulledAt
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lambdaFunctionTags = lambdaFunctionTags
            self.lastScannedAt = lastScannedAt
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.scanMode = scanMode
            self.scanStatusCode = scanStatusCode
            self.scanStatusReason = scanStatusReason
            self.scanType = scanType
        }

        public func validate(name: String) throws {
            try self.accountId?.forEach {
                try $0.validate(name: "\(name).accountId[]")
            }
            try self.validate(self.accountId, name: "accountId", parent: name, max: 10)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 1)
            try self.ec2InstanceTags?.forEach {
                try $0.validate(name: "\(name).ec2InstanceTags[]")
            }
            try self.validate(self.ec2InstanceTags, name: "ec2InstanceTags", parent: name, max: 10)
            try self.validate(self.ec2InstanceTags, name: "ec2InstanceTags", parent: name, min: 1)
            try self.ecrImageTags?.forEach {
                try $0.validate(name: "\(name).ecrImageTags[]")
            }
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, max: 10)
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, min: 1)
            try self.ecrRepositoryName?.forEach {
                try $0.validate(name: "\(name).ecrRepositoryName[]")
            }
            try self.validate(self.ecrRepositoryName, name: "ecrRepositoryName", parent: name, max: 10)
            try self.validate(self.ecrRepositoryName, name: "ecrRepositoryName", parent: name, min: 1)
            try self.validate(self.imagePulledAt, name: "imagePulledAt", parent: name, max: 10)
            try self.validate(self.imagePulledAt, name: "imagePulledAt", parent: name, min: 1)
            try self.lambdaFunctionName?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionName[]")
            }
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, max: 10)
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, min: 1)
            try self.lambdaFunctionRuntime?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionRuntime[]")
            }
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, max: 10)
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, min: 1)
            try self.lambdaFunctionTags?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionTags[]")
            }
            try self.validate(self.lambdaFunctionTags, name: "lambdaFunctionTags", parent: name, max: 10)
            try self.validate(self.lambdaFunctionTags, name: "lambdaFunctionTags", parent: name, min: 1)
            try self.validate(self.lastScannedAt, name: "lastScannedAt", parent: name, max: 10)
            try self.validate(self.lastScannedAt, name: "lastScannedAt", parent: name, min: 1)
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 10)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 10)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
            try self.scanMode?.forEach {
                try $0.validate(name: "\(name).scanMode[]")
            }
            try self.validate(self.scanMode, name: "scanMode", parent: name, max: 10)
            try self.validate(self.scanMode, name: "scanMode", parent: name, min: 1)
            try self.scanStatusCode?.forEach {
                try $0.validate(name: "\(name).scanStatusCode[]")
            }
            try self.validate(self.scanStatusCode, name: "scanStatusCode", parent: name, max: 10)
            try self.validate(self.scanStatusCode, name: "scanStatusCode", parent: name, min: 1)
            try self.scanStatusReason?.forEach {
                try $0.validate(name: "\(name).scanStatusReason[]")
            }
            try self.validate(self.scanStatusReason, name: "scanStatusReason", parent: name, max: 10)
            try self.validate(self.scanStatusReason, name: "scanStatusReason", parent: name, min: 1)
            try self.scanType?.forEach {
                try $0.validate(name: "\(name).scanType[]")
            }
            try self.validate(self.scanType, name: "scanType", parent: name, max: 10)
            try self.validate(self.scanType, name: "scanType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case ec2InstanceTags = "ec2InstanceTags"
            case ecrImageTags = "ecrImageTags"
            case ecrRepositoryName = "ecrRepositoryName"
            case imagePulledAt = "imagePulledAt"
            case lambdaFunctionName = "lambdaFunctionName"
            case lambdaFunctionRuntime = "lambdaFunctionRuntime"
            case lambdaFunctionTags = "lambdaFunctionTags"
            case lastScannedAt = "lastScannedAt"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case scanMode = "scanMode"
            case scanStatusCode = "scanStatusCode"
            case scanStatusReason = "scanStatusReason"
            case scanType = "scanType"
        }
    }

    public struct CoverageMapFilter: AWSEncodableShape {
        /// The operator to compare coverage on.
        public let comparison: CoverageMapComparison
        /// The tag key associated with the coverage map filter.
        public let key: String
        /// The tag value associated with the coverage map filter.
        public let value: String?

        @inlinable
        public init(comparison: CoverageMapComparison, key: String, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case key = "key"
            case value = "value"
        }
    }

    public struct CoverageStringFilter: AWSEncodableShape {
        /// The operator to compare strings on.
        public let comparison: CoverageStringComparison
        /// The value to compare strings on.
        public let value: String

        @inlinable
        public init(comparison: CoverageStringComparison, value: String) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct CoveredResource: AWSDecodableShape {
        /// The Amazon Web Services account ID of the covered resource.
        public let accountId: String
        /// The date and time the resource was last checked for vulnerabilities.
        public let lastScannedAt: Date?
        /// The ID of the covered resource.
        public let resourceId: String
        /// An object that contains details about the metadata.
        public let resourceMetadata: ResourceScanMetadata?
        /// The type of the covered resource.
        public let resourceType: CoverageResourceType
        /// The scan method that is applied to the instance.
        public let scanMode: ScanMode?
        /// The status of the scan covering the resource.
        public let scanStatus: ScanStatus?
        /// The Amazon Inspector scan type covering the resource.
        public let scanType: ScanType

        @inlinable
        public init(accountId: String, lastScannedAt: Date? = nil, resourceId: String, resourceMetadata: ResourceScanMetadata? = nil, resourceType: CoverageResourceType, scanMode: ScanMode? = nil, scanStatus: ScanStatus? = nil, scanType: ScanType) {
            self.accountId = accountId
            self.lastScannedAt = lastScannedAt
            self.resourceId = resourceId
            self.resourceMetadata = resourceMetadata
            self.resourceType = resourceType
            self.scanMode = scanMode
            self.scanStatus = scanStatus
            self.scanType = scanType
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case lastScannedAt = "lastScannedAt"
            case resourceId = "resourceId"
            case resourceMetadata = "resourceMetadata"
            case resourceType = "resourceType"
            case scanMode = "scanMode"
            case scanStatus = "scanStatus"
            case scanType = "scanType"
        }
    }

    public struct CreateCisScanConfigurationRequest: AWSEncodableShape {
        /// The scan name for the CIS scan configuration.
        public let scanName: String
        /// The schedule for the CIS scan configuration.
        public let schedule: Schedule
        ///  The security level for the CIS scan configuration.  Security level refers to the Benchmark levels that CIS assigns to a profile.
        public let securityLevel: CisSecurityLevel
        /// The tags for the CIS scan configuration.
        public let tags: [String: String]?
        /// The targets for the CIS scan configuration.
        public let targets: CreateCisTargets

        @inlinable
        public init(scanName: String, schedule: Schedule, securityLevel: CisSecurityLevel, tags: [String: String]? = nil, targets: CreateCisTargets) {
            self.scanName = scanName
            self.schedule = schedule
            self.securityLevel = securityLevel
            self.tags = tags
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.validate(self.scanName, name: "scanName", parent: name, max: 128)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.schedule.validate(name: "\(name).schedule")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.targets.validate(name: "\(name).targets")
        }

        private enum CodingKeys: String, CodingKey {
            case scanName = "scanName"
            case schedule = "schedule"
            case securityLevel = "securityLevel"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct CreateCisScanConfigurationResponse: AWSDecodableShape {
        /// The scan configuration ARN for the CIS scan configuration.
        public let scanConfigurationArn: String?

        @inlinable
        public init(scanConfigurationArn: String? = nil) {
            self.scanConfigurationArn = scanConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case scanConfigurationArn = "scanConfigurationArn"
        }
    }

    public struct CreateCisTargets: AWSEncodableShape {
        /// The CIS target account ids.
        public let accountIds: [String]
        /// The CIS target resource tags.
        public let targetResourceTags: [String: [String]]

        @inlinable
        public init(accountIds: [String], targetResourceTags: [String: [String]]) {
            self.accountIds = accountIds
            self.targetResourceTags = targetResourceTags
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}|ALL_ACCOUNTS|SELF$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 10000)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.targetResourceTags.forEach {
                try validate($0.key, name: "targetResourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "targetResourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "targetResourceTags.key", parent: name, pattern: "^[\\p{L}\\p{Z}\\p{N}_.:/=\\-@]*$")
                try validate($0.value, name: "targetResourceTags[\"\($0.key)\"]", parent: name, max: 5)
                try validate($0.value, name: "targetResourceTags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.targetResourceTags, name: "targetResourceTags", parent: name, max: 5)
            try self.validate(self.targetResourceTags, name: "targetResourceTags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case targetResourceTags = "targetResourceTags"
        }
    }

    public struct CreateFilterRequest: AWSEncodableShape {
        /// Defines the action that is to be applied to the findings that match the filter.
        public let action: FilterAction
        /// A description of the filter.
        public let description: String?
        /// Defines the criteria to be used in the filter for querying findings.
        public let filterCriteria: FilterCriteria
        /// The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.
        public let name: String
        /// The reason for creating the filter.
        public let reason: String?
        /// A list of tags for the filter.
        public let tags: [String: String]?

        @inlinable
        public init(action: FilterAction, description: String? = nil, filterCriteria: FilterCriteria, name: String, reason: String? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.description = description
            self.filterCriteria = filterCriteria
            self.name = name
            self.reason = reason
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.filterCriteria.validate(name: "\(name).filterCriteria")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.reason, name: "reason", parent: name, max: 512)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case filterCriteria = "filterCriteria"
            case name = "name"
            case reason = "reason"
            case tags = "tags"
        }
    }

    public struct CreateFilterResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the successfully created filter.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateFindingsReportRequest: AWSEncodableShape {
        /// The filter criteria to apply to the results of the finding report.
        public let filterCriteria: FilterCriteria?
        /// The format to generate the report in.
        public let reportFormat: ReportFormat
        /// The Amazon S3 export destination for the report.
        public let s3Destination: Destination

        @inlinable
        public init(filterCriteria: FilterCriteria? = nil, reportFormat: ReportFormat, s3Destination: Destination) {
            self.filterCriteria = filterCriteria
            self.reportFormat = reportFormat
            self.s3Destination = s3Destination
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case reportFormat = "reportFormat"
            case s3Destination = "s3Destination"
        }
    }

    public struct CreateFindingsReportResponse: AWSDecodableShape {
        /// The ID of the report.
        public let reportId: String?

        @inlinable
        public init(reportId: String? = nil) {
            self.reportId = reportId
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct CreateSbomExportRequest: AWSEncodableShape {
        /// The output format for the software bill of materials (SBOM) report.
        public let reportFormat: SbomReportFormat
        /// The resource filter criteria for the software bill of materials (SBOM) report.
        public let resourceFilterCriteria: ResourceFilterCriteria?
        /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
        public let s3Destination: Destination

        @inlinable
        public init(reportFormat: SbomReportFormat, resourceFilterCriteria: ResourceFilterCriteria? = nil, s3Destination: Destination) {
            self.reportFormat = reportFormat
            self.resourceFilterCriteria = resourceFilterCriteria
            self.s3Destination = s3Destination
        }

        public func validate(name: String) throws {
            try self.resourceFilterCriteria?.validate(name: "\(name).resourceFilterCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case reportFormat = "reportFormat"
            case resourceFilterCriteria = "resourceFilterCriteria"
            case s3Destination = "s3Destination"
        }
    }

    public struct CreateSbomExportResponse: AWSDecodableShape {
        /// The report ID for the software bill of materials (SBOM) report.
        public let reportId: String?

        @inlinable
        public init(reportId: String? = nil) {
            self.reportId = reportId
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct Cvss2: AWSDecodableShape {
        /// The CVSS v2 base score for the vulnerability.
        public let baseScore: Double?
        /// The scoring vector associated with the CVSS v2 score.
        public let scoringVector: String?

        @inlinable
        public init(baseScore: Double? = nil, scoringVector: String? = nil) {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
        }

        private enum CodingKeys: String, CodingKey {
            case baseScore = "baseScore"
            case scoringVector = "scoringVector"
        }
    }

    public struct Cvss3: AWSDecodableShape {
        /// The CVSS v3 base score for the vulnerability.
        public let baseScore: Double?
        /// The scoring vector associated with the CVSS v3 score.
        public let scoringVector: String?

        @inlinable
        public init(baseScore: Double? = nil, scoringVector: String? = nil) {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
        }

        private enum CodingKeys: String, CodingKey {
            case baseScore = "baseScore"
            case scoringVector = "scoringVector"
        }
    }

    public struct CvssScore: AWSDecodableShape {
        /// The base CVSS score used for the finding.
        public let baseScore: Double
        /// The vector string of the CVSS score.
        public let scoringVector: String
        /// The source of the CVSS score.
        public let source: String
        /// The version of CVSS used for the score.
        public let version: String

        @inlinable
        public init(baseScore: Double, scoringVector: String, source: String, version: String) {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case baseScore = "baseScore"
            case scoringVector = "scoringVector"
            case source = "source"
            case version = "version"
        }
    }

    public struct CvssScoreAdjustment: AWSDecodableShape {
        /// The metric used to adjust the CVSS score.
        public let metric: String
        /// The reason the CVSS score has been adjustment.
        public let reason: String

        @inlinable
        public init(metric: String, reason: String) {
            self.metric = metric
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "metric"
            case reason = "reason"
        }
    }

    public struct CvssScoreDetails: AWSDecodableShape {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public let adjustments: [CvssScoreAdjustment]?
        /// The source of the CVSS data.
        public let cvssSource: String?
        /// The CVSS score.
        public let score: Double
        /// The source for the CVSS score.
        public let scoreSource: String
        /// The vector for the CVSS score.
        public let scoringVector: String
        /// The CVSS version used in scoring.
        public let version: String

        @inlinable
        public init(adjustments: [CvssScoreAdjustment]? = nil, cvssSource: String? = nil, score: Double, scoreSource: String, scoringVector: String, version: String) {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case adjustments = "adjustments"
            case cvssSource = "cvssSource"
            case score = "score"
            case scoreSource = "scoreSource"
            case scoringVector = "scoringVector"
            case version = "version"
        }
    }

    public struct DailySchedule: AWSEncodableShape & AWSDecodableShape {
        /// The schedule start time.
        public let startTime: Time

        @inlinable
        public init(startTime: Time) {
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.startTime.validate(name: "\(name).startTime")
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "startTime"
        }
    }

    public struct DateFilter: AWSEncodableShape & AWSDecodableShape {
        /// A timestamp representing the end of the time period filtered on.
        public let endInclusive: Date?
        /// A timestamp representing the start of the time period filtered on.
        public let startInclusive: Date?

        @inlinable
        public init(endInclusive: Date? = nil, startInclusive: Date? = nil) {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case endInclusive = "endInclusive"
            case startInclusive = "startInclusive"
        }
    }

    public struct DelegatedAdmin: AWSDecodableShape {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public let accountId: String?
        /// The status of the Amazon Inspector delegated administrator.
        public let relationshipStatus: RelationshipStatus?

        @inlinable
        public init(accountId: String? = nil, relationshipStatus: RelationshipStatus? = nil) {
            self.accountId = accountId
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case relationshipStatus = "relationshipStatus"
        }
    }

    public struct DelegatedAdminAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public let accountId: String?
        /// The status of the Amazon Inspector delegated administrator.
        public let status: DelegatedAdminStatus?

        @inlinable
        public init(accountId: String? = nil, status: DelegatedAdminStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case status = "status"
        }
    }

    public struct DeleteCisScanConfigurationRequest: AWSEncodableShape {
        /// The ARN of the CIS scan configuration.
        public let scanConfigurationArn: String

        @inlinable
        public init(scanConfigurationArn: String) {
            self.scanConfigurationArn = scanConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.scanConfigurationArn, name: "scanConfigurationArn", parent: name, pattern: "^arn:aws(-us-gov|-cn)?:inspector2:[a-z]{2}(-gov)?-[a-z]+-[0-9]{1}:[0-9]{12}:owner/(o-[a-z0-9]+|[0-9]{12})/cis-configuration/[0-9a-fA-F-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case scanConfigurationArn = "scanConfigurationArn"
        }
    }

    public struct DeleteCisScanConfigurationResponse: AWSDecodableShape {
        /// The ARN of the CIS scan configuration.
        public let scanConfigurationArn: String

        @inlinable
        public init(scanConfigurationArn: String) {
            self.scanConfigurationArn = scanConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case scanConfigurationArn = "scanConfigurationArn"
        }
    }

    public struct DeleteFilterRequest: AWSEncodableShape {
        /// The Amazon Resource Number (ARN) of the filter to be deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteFilterResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the filter that has been deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        /// The scan types are automatically enabled for new members of your organization.
        public let autoEnable: AutoEnable?
        /// Represents whether your organization has reached the maximum Amazon Web Services account limit for Amazon Inspector.
        public let maxAccountLimitReached: Bool?

        @inlinable
        public init(autoEnable: AutoEnable? = nil, maxAccountLimitReached: Bool? = nil) {
            self.autoEnable = autoEnable
            self.maxAccountLimitReached = maxAccountLimitReached
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
            case maxAccountLimitReached = "maxAccountLimitReached"
        }
    }

    public struct Destination: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket to export findings to.
        public let bucketName: String
        /// The prefix that the findings will be written under.
        public let keyPrefix: String?
        /// The ARN of the KMS key used to encrypt data when exporting findings.
        public let kmsKeyArn: String

        @inlinable
        public init(bucketName: String, keyPrefix: String? = nil, kmsKeyArn: String) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case keyPrefix = "keyPrefix"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct DisableDelegatedAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the current Amazon Inspector delegated administrator.
        public let delegatedAdminAccountId: String

        @inlinable
        public init(delegatedAdminAccountId: String) {
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, max: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, min: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccountId = "delegatedAdminAccountId"
        }
    }

    public struct DisableDelegatedAdminAccountResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully disabled delegated administrator.
        public let delegatedAdminAccountId: String

        @inlinable
        public init(delegatedAdminAccountId: String) {
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccountId = "delegatedAdminAccountId"
        }
    }

    public struct DisableRequest: AWSEncodableShape {
        /// An array of account IDs you want to disable Amazon Inspector scans for.
        public let accountIds: [String]?
        /// The resource scan types you want to disable.
        public let resourceTypes: [ResourceScanType]?

        @inlinable
        public init(accountIds: [String]? = nil, resourceTypes: [ResourceScanType]? = nil) {
            self.accountIds = accountIds
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case resourceTypes = "resourceTypes"
        }
    }

    public struct DisableResponse: AWSDecodableShape {
        /// Information on the accounts that have had Amazon Inspector scans successfully disabled. Details are provided for each account.
        public let accounts: [Account]
        /// Information on any accounts for which Amazon Inspector scans could not be disabled. Details are provided for each account.
        public let failedAccounts: [FailedAccount]?

        @inlinable
        public init(accounts: [Account], failedAccounts: [FailedAccount]? = nil) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case failedAccounts = "failedAccounts"
        }
    }

    public struct DisassociateMemberRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the member account to disassociate.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct DisassociateMemberResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully disassociated member.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct Ec2Configuration: AWSEncodableShape {
        /// The scan method that is applied to the instance.
        public let scanMode: Ec2ScanMode

        @inlinable
        public init(scanMode: Ec2ScanMode) {
            self.scanMode = scanMode
        }

        private enum CodingKeys: String, CodingKey {
            case scanMode = "scanMode"
        }
    }

    public struct Ec2ConfigurationState: AWSDecodableShape {
        /// An object that contains details about the state of the Amazon EC2 scan mode.
        public let scanModeState: Ec2ScanModeState?

        @inlinable
        public init(scanModeState: Ec2ScanModeState? = nil) {
            self.scanModeState = scanModeState
        }

        private enum CodingKeys: String, CodingKey {
            case scanModeState = "scanModeState"
        }
    }

    public struct Ec2InstanceAggregation: AWSEncodableShape {
        /// The AMI IDs associated with the Amazon EC2 instances to aggregate findings for.
        public let amis: [StringFilter]?
        /// The Amazon EC2 instance IDs to aggregate findings for.
        public let instanceIds: [StringFilter]?
        /// The Amazon EC2 instance tags to aggregate findings for.
        public let instanceTags: [MapFilter]?
        /// The operating system types to aggregate findings for. Valid values must be uppercase and underscore separated, examples are ORACLE_LINUX_7 and ALPINE_LINUX_3_8.
        public let operatingSystems: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: Ec2InstanceSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        @inlinable
        public init(amis: [StringFilter]? = nil, instanceIds: [StringFilter]? = nil, instanceTags: [MapFilter]? = nil, operatingSystems: [StringFilter]? = nil, sortBy: Ec2InstanceSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.amis = amis
            self.instanceIds = instanceIds
            self.instanceTags = instanceTags
            self.operatingSystems = operatingSystems
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.amis?.forEach {
                try $0.validate(name: "\(name).amis[]")
            }
            try self.validate(self.amis, name: "amis", parent: name, max: 10)
            try self.validate(self.amis, name: "amis", parent: name, min: 1)
            try self.instanceIds?.forEach {
                try $0.validate(name: "\(name).instanceIds[]")
            }
            try self.validate(self.instanceIds, name: "instanceIds", parent: name, max: 10)
            try self.validate(self.instanceIds, name: "instanceIds", parent: name, min: 1)
            try self.instanceTags?.forEach {
                try $0.validate(name: "\(name).instanceTags[]")
            }
            try self.validate(self.instanceTags, name: "instanceTags", parent: name, max: 10)
            try self.validate(self.instanceTags, name: "instanceTags", parent: name, min: 1)
            try self.operatingSystems?.forEach {
                try $0.validate(name: "\(name).operatingSystems[]")
            }
            try self.validate(self.operatingSystems, name: "operatingSystems", parent: name, max: 10)
            try self.validate(self.operatingSystems, name: "operatingSystems", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amis = "amis"
            case instanceIds = "instanceIds"
            case instanceTags = "instanceTags"
            case operatingSystems = "operatingSystems"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct Ec2InstanceAggregationResponse: AWSDecodableShape {
        /// The Amazon Web Services account for the Amazon EC2 instance.
        public let accountId: String?
        /// The Amazon Machine Image (AMI) of the Amazon EC2 instance.
        public let ami: String?
        /// The Amazon EC2 instance ID.
        public let instanceId: String
        /// The tags attached to the instance.
        public let instanceTags: [String: String]?
        /// The number of network findings for the Amazon EC2 instance.
        public let networkFindings: Int64?
        /// The operating system of the Amazon EC2 instance.
        public let operatingSystem: String?
        /// An object that contains the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, ami: String? = nil, instanceId: String, instanceTags: [String: String]? = nil, networkFindings: Int64? = nil, operatingSystem: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.ami = ami
            self.instanceId = instanceId
            self.instanceTags = instanceTags
            self.networkFindings = networkFindings
            self.operatingSystem = operatingSystem
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case ami = "ami"
            case instanceId = "instanceId"
            case instanceTags = "instanceTags"
            case networkFindings = "networkFindings"
            case operatingSystem = "operatingSystem"
            case severityCounts = "severityCounts"
        }
    }

    public struct Ec2Metadata: AWSDecodableShape {
        /// The ID of the Amazon Machine Image (AMI) used to launch the instance.
        public let amiId: String?
        /// The platform of the instance.
        public let platform: Ec2Platform?
        /// The tags attached to the instance.
        public let tags: [String: String]?

        @inlinable
        public init(amiId: String? = nil, platform: Ec2Platform? = nil, tags: [String: String]? = nil) {
            self.amiId = amiId
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "amiId"
            case platform = "platform"
            case tags = "tags"
        }
    }

    public struct Ec2ScanModeState: AWSDecodableShape {
        /// The scan method that is applied to the instance.
        public let scanMode: Ec2ScanMode?
        /// The status of the Amazon EC2 scan mode setting.
        public let scanModeStatus: Ec2ScanModeStatus?

        @inlinable
        public init(scanMode: Ec2ScanMode? = nil, scanModeStatus: Ec2ScanModeStatus? = nil) {
            self.scanMode = scanMode
            self.scanModeStatus = scanModeStatus
        }

        private enum CodingKeys: String, CodingKey {
            case scanMode = "scanMode"
            case scanModeStatus = "scanModeStatus"
        }
    }

    public struct EcrConfiguration: AWSEncodableShape {
        /// The rescan duration configured for image pull date.
        public let pullDateRescanDuration: EcrPullDateRescanDuration?
        /// The rescan duration configured for image push date.
        public let rescanDuration: EcrRescanDuration

        @inlinable
        public init(pullDateRescanDuration: EcrPullDateRescanDuration? = nil, rescanDuration: EcrRescanDuration) {
            self.pullDateRescanDuration = pullDateRescanDuration
            self.rescanDuration = rescanDuration
        }

        private enum CodingKeys: String, CodingKey {
            case pullDateRescanDuration = "pullDateRescanDuration"
            case rescanDuration = "rescanDuration"
        }
    }

    public struct EcrConfigurationState: AWSDecodableShape {
        /// An object that contains details about the state of the ECR re-scan settings.
        public let rescanDurationState: EcrRescanDurationState?

        @inlinable
        public init(rescanDurationState: EcrRescanDurationState? = nil) {
            self.rescanDurationState = rescanDurationState
        }

        private enum CodingKeys: String, CodingKey {
            case rescanDurationState = "rescanDurationState"
        }
    }

    public struct EcrContainerImageMetadata: AWSDecodableShape {
        /// The date an image was last pulled at.
        public let imagePulledAt: Date?
        /// Tags associated with the Amazon ECR image metadata.
        public let tags: [String]?

        @inlinable
        public init(imagePulledAt: Date? = nil, tags: [String]? = nil) {
            self.imagePulledAt = imagePulledAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case imagePulledAt = "imagePulledAt"
            case tags = "tags"
        }
    }

    public struct EcrRepositoryMetadata: AWSDecodableShape {
        /// The name of the Amazon ECR repository.
        public let name: String?
        /// The frequency of scans.
        public let scanFrequency: EcrScanFrequency?

        @inlinable
        public init(name: String? = nil, scanFrequency: EcrScanFrequency? = nil) {
            self.name = name
            self.scanFrequency = scanFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case scanFrequency = "scanFrequency"
        }
    }

    public struct EcrRescanDurationState: AWSDecodableShape {
        /// The rescan duration configured for image pull date.
        public let pullDateRescanDuration: EcrPullDateRescanDuration?
        /// The rescan duration configured for image push date.
        public let rescanDuration: EcrRescanDuration?
        /// The status of changes to the ECR automated re-scan duration.
        public let status: EcrRescanDurationStatus?
        /// A timestamp representing when the last time the ECR scan duration setting was changed.
        public let updatedAt: Date?

        @inlinable
        public init(pullDateRescanDuration: EcrPullDateRescanDuration? = nil, rescanDuration: EcrRescanDuration? = nil, status: EcrRescanDurationStatus? = nil, updatedAt: Date? = nil) {
            self.pullDateRescanDuration = pullDateRescanDuration
            self.rescanDuration = rescanDuration
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case pullDateRescanDuration = "pullDateRescanDuration"
            case rescanDuration = "rescanDuration"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnableDelegatedAdminAccountRequest: AWSEncodableShape {
        /// The idempotency token for the request.
        public let clientToken: String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
        public let delegatedAdminAccountId: String

        @inlinable
        public init(clientToken: String? = EnableDelegatedAdminAccountRequest.idempotencyToken(), delegatedAdminAccountId: String) {
            self.clientToken = clientToken
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, max: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, min: 12)
            try self.validate(self.delegatedAdminAccountId, name: "delegatedAdminAccountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case delegatedAdminAccountId = "delegatedAdminAccountId"
        }
    }

    public struct EnableDelegatedAdminAccountResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the successfully Amazon Inspector delegated administrator.
        public let delegatedAdminAccountId: String

        @inlinable
        public init(delegatedAdminAccountId: String) {
            self.delegatedAdminAccountId = delegatedAdminAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccountId = "delegatedAdminAccountId"
        }
    }

    public struct EnableRequest: AWSEncodableShape {
        /// A list of account IDs you want to enable Amazon Inspector scans for.
        public let accountIds: [String]?
        /// The idempotency token for the request.
        public let clientToken: String?
        /// The resource scan types you want to enable.
        public let resourceTypes: [ResourceScanType]

        @inlinable
        public init(accountIds: [String]? = nil, clientToken: String? = EnableRequest.idempotencyToken(), resourceTypes: [ResourceScanType]) {
            self.accountIds = accountIds
            self.clientToken = clientToken
            self.resourceTypes = resourceTypes
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, max: 3)
            try self.validate(self.resourceTypes, name: "resourceTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case clientToken = "clientToken"
            case resourceTypes = "resourceTypes"
        }
    }

    public struct EnableResponse: AWSDecodableShape {
        /// Information on the accounts that have had Amazon Inspector scans successfully enabled. Details are provided for each account.
        public let accounts: [Account]
        /// Information on any accounts for which Amazon Inspector scans could not be enabled. Details are provided for each account.
        public let failedAccounts: [FailedAccount]?

        @inlinable
        public init(accounts: [Account], failedAccounts: [FailedAccount]? = nil) {
            self.accounts = accounts
            self.failedAccounts = failedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case failedAccounts = "failedAccounts"
        }
    }

    public struct Epss: AWSDecodableShape {
        /// The Exploit Prediction Scoring System (EPSS) score.
        public let score: Double?

        @inlinable
        public init(score: Double? = nil) {
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case score = "score"
        }
    }

    public struct EpssDetails: AWSDecodableShape {
        /// The EPSS score.
        public let score: Double?

        @inlinable
        public init(score: Double? = nil) {
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case score = "score"
        }
    }

    public struct Evidence: AWSDecodableShape {
        /// The evidence details.
        public let evidenceDetail: String?
        /// The evidence rule.
        public let evidenceRule: String?
        /// The evidence severity.
        public let severity: String?

        @inlinable
        public init(evidenceDetail: String? = nil, evidenceRule: String? = nil, severity: String? = nil) {
            self.evidenceDetail = evidenceDetail
            self.evidenceRule = evidenceRule
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case evidenceDetail = "evidenceDetail"
            case evidenceRule = "evidenceRule"
            case severity = "severity"
        }
    }

    public struct ExploitObserved: AWSDecodableShape {
        /// The date an time when the exploit was first seen.
        public let firstSeen: Date?
        /// The date an time when the exploit was last seen.
        public let lastSeen: Date?

        @inlinable
        public init(firstSeen: Date? = nil, lastSeen: Date? = nil) {
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
        }

        private enum CodingKeys: String, CodingKey {
            case firstSeen = "firstSeen"
            case lastSeen = "lastSeen"
        }
    }

    public struct ExploitabilityDetails: AWSDecodableShape {
        /// The date and time of the last exploit associated with a finding discovered in your environment.
        public let lastKnownExploitAt: Date?

        @inlinable
        public init(lastKnownExploitAt: Date? = nil) {
            self.lastKnownExploitAt = lastKnownExploitAt
        }

        private enum CodingKeys: String, CodingKey {
            case lastKnownExploitAt = "lastKnownExploitAt"
        }
    }

    public struct FailedAccount: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String
        /// The error code explaining why the account failed to enable Amazon Inspector.
        public let errorCode: ErrorCode
        /// The error message received when the account failed to enable Amazon Inspector.
        public let errorMessage: String
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public let resourceStatus: ResourceStatus?
        /// The status of Amazon Inspector for the account.
        public let status: Status?

        @inlinable
        public init(accountId: String, errorCode: ErrorCode, errorMessage: String, resourceStatus: ResourceStatus? = nil, status: Status? = nil) {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resourceStatus = resourceStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case resourceStatus = "resourceStatus"
            case status = "status"
        }
    }

    public struct FailedMemberAccountEc2DeepInspectionStatusState: AWSDecodableShape {
        /// The unique identifier for the Amazon Web Services account of the organization member that failed to activate Amazon Inspector deep inspection.
        public let accountId: String
        /// The status of EC2 scanning in the account that failed to activate Amazon Inspector deep inspection.
        public let ec2ScanStatus: Status?
        /// The error message explaining why the account failed to activate Amazon Inspector deep inspection.
        public let errorMessage: String?

        @inlinable
        public init(accountId: String, ec2ScanStatus: Status? = nil, errorMessage: String? = nil) {
            self.accountId = accountId
            self.ec2ScanStatus = ec2ScanStatus
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case ec2ScanStatus = "ec2ScanStatus"
            case errorMessage = "errorMessage"
        }
    }

    public struct Filter: AWSDecodableShape {
        /// The action that is to be applied to the findings that match the filter.
        public let action: FilterAction
        /// The Amazon Resource Number (ARN) associated with this filter.
        public let arn: String
        /// The date and time this filter was created at.
        public let createdAt: Date
        /// Details on the filter criteria associated with this filter.
        public let criteria: FilterCriteria
        /// A description of the filter.
        public let description: String?
        /// The name of the filter.
        public let name: String
        /// The Amazon Web Services account ID of the account that created the filter.
        public let ownerId: String
        /// The reason for the filter.
        public let reason: String?
        /// The tags attached to the filter.
        public let tags: [String: String]?
        /// The date and time the filter was last updated at.
        public let updatedAt: Date

        @inlinable
        public init(action: FilterAction, arn: String, createdAt: Date, criteria: FilterCriteria, description: String? = nil, name: String, ownerId: String, reason: String? = nil, tags: [String: String]? = nil, updatedAt: Date) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.criteria = criteria
            self.description = description
            self.name = name
            self.ownerId = ownerId
            self.reason = reason
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case createdAt = "createdAt"
            case criteria = "criteria"
            case description = "description"
            case name = "name"
            case ownerId = "ownerId"
            case reason = "reason"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct FilterCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Details of the Amazon Web Services account IDs used to filter findings.
        public let awsAccountId: [StringFilter]?
        /// The name of the detector used to identify a code vulnerability in a Lambda function used to filter findings.
        public let codeVulnerabilityDetectorName: [StringFilter]?
        /// The detector type tag associated with the vulnerability used to filter findings. Detector tags group related vulnerabilities by common themes or tactics. For a list of available tags by programming language, see Java tags, or Python tags.
        public let codeVulnerabilityDetectorTags: [StringFilter]?
        /// The file path to the file in a Lambda function that contains a code vulnerability used to filter findings.
        public let codeVulnerabilityFilePath: [StringFilter]?
        /// Details of the component IDs used to filter findings.
        public let componentId: [StringFilter]?
        /// Details of the component types used to filter findings.
        public let componentType: [StringFilter]?
        /// Details of the Amazon EC2 instance image IDs used to filter findings.
        public let ec2InstanceImageId: [StringFilter]?
        /// Details of the Amazon EC2 instance subnet IDs used to filter findings.
        public let ec2InstanceSubnetId: [StringFilter]?
        /// Details of the Amazon EC2 instance VPC IDs used to filter findings.
        public let ec2InstanceVpcId: [StringFilter]?
        /// Details of the Amazon ECR image architecture types used to filter findings.
        public let ecrImageArchitecture: [StringFilter]?
        /// Details of the Amazon ECR image hashes used to filter findings.
        public let ecrImageHash: [StringFilter]?
        /// Details on the Amazon ECR image push date and time used to filter findings.
        public let ecrImagePushedAt: [DateFilter]?
        /// Details on the Amazon ECR registry used to filter findings.
        public let ecrImageRegistry: [StringFilter]?
        /// Details on the name of the Amazon ECR repository used to filter findings.
        public let ecrImageRepositoryName: [StringFilter]?
        /// The tags attached to the Amazon ECR container image.
        public let ecrImageTags: [StringFilter]?
        /// The EPSS score used to filter findings.
        public let epssScore: [NumberFilter]?
        /// Filters the list of Amazon Web Services Lambda findings by the availability of exploits.
        public let exploitAvailable: [StringFilter]?
        /// Details on the finding ARNs used to filter findings.
        public let findingArn: [StringFilter]?
        /// Details on the finding status types used to filter findings.
        public let findingStatus: [StringFilter]?
        /// Details on the finding types used to filter findings.
        public let findingType: [StringFilter]?
        /// Details on the date and time a finding was first seen used to filter findings.
        public let firstObservedAt: [DateFilter]?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL.  A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public let fixAvailable: [StringFilter]?
        /// The Amazon Inspector score to filter on.
        public let inspectorScore: [NumberFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by execution role.
        public let lambdaFunctionExecutionRoleArn: [StringFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the date and time that a user last updated the configuration, in ISO 8601 format
        public let lambdaFunctionLastModifiedAt: [DateFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the function's  layers. A Lambda function can have up to five layers.
        public let lambdaFunctionLayers: [StringFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the name of the function.
        public let lambdaFunctionName: [StringFilter]?
        /// Filters the list of Amazon Web Services Lambda functions by the runtime environment for the Lambda function.
        public let lambdaFunctionRuntime: [StringFilter]?
        /// Details on the date and time a finding was last seen used to filter findings.
        public let lastObservedAt: [DateFilter]?
        /// Details on network protocol used to filter findings.
        public let networkProtocol: [StringFilter]?
        /// Details on the port ranges used to filter findings.
        public let portRange: [PortRangeFilter]?
        /// Details on the related vulnerabilities used to filter findings.
        public let relatedVulnerabilities: [StringFilter]?
        /// Details on the resource IDs used to filter findings.
        public let resourceId: [StringFilter]?
        /// Details on the resource tags used to filter findings.
        public let resourceTags: [MapFilter]?
        /// Details on the resource types used to filter findings.
        public let resourceType: [StringFilter]?
        /// Details on the severity used to filter findings.
        public let severity: [StringFilter]?
        /// Details on the finding title used to filter findings.
        public let title: [StringFilter]?
        /// Details on the date and time a finding was last updated at used to filter findings.
        public let updatedAt: [DateFilter]?
        /// Details on the vendor severity used to filter findings.
        public let vendorSeverity: [StringFilter]?
        /// Details on the vulnerability ID used to filter findings.
        public let vulnerabilityId: [StringFilter]?
        /// Details on the vulnerability type used to filter findings.
        public let vulnerabilitySource: [StringFilter]?
        /// Details on the vulnerable packages used to filter findings.
        public let vulnerablePackages: [PackageFilter]?

        @inlinable
        public init(awsAccountId: [StringFilter]? = nil, codeVulnerabilityDetectorName: [StringFilter]? = nil, codeVulnerabilityDetectorTags: [StringFilter]? = nil, codeVulnerabilityFilePath: [StringFilter]? = nil, componentId: [StringFilter]? = nil, componentType: [StringFilter]? = nil, ec2InstanceImageId: [StringFilter]? = nil, ec2InstanceSubnetId: [StringFilter]? = nil, ec2InstanceVpcId: [StringFilter]? = nil, ecrImageArchitecture: [StringFilter]? = nil, ecrImageHash: [StringFilter]? = nil, ecrImagePushedAt: [DateFilter]? = nil, ecrImageRegistry: [StringFilter]? = nil, ecrImageRepositoryName: [StringFilter]? = nil, ecrImageTags: [StringFilter]? = nil, epssScore: [NumberFilter]? = nil, exploitAvailable: [StringFilter]? = nil, findingArn: [StringFilter]? = nil, findingStatus: [StringFilter]? = nil, findingType: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, fixAvailable: [StringFilter]? = nil, inspectorScore: [NumberFilter]? = nil, lambdaFunctionExecutionRoleArn: [StringFilter]? = nil, lambdaFunctionLastModifiedAt: [DateFilter]? = nil, lambdaFunctionLayers: [StringFilter]? = nil, lambdaFunctionName: [StringFilter]? = nil, lambdaFunctionRuntime: [StringFilter]? = nil, lastObservedAt: [DateFilter]? = nil, networkProtocol: [StringFilter]? = nil, portRange: [PortRangeFilter]? = nil, relatedVulnerabilities: [StringFilter]? = nil, resourceId: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, severity: [StringFilter]? = nil, title: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, vendorSeverity: [StringFilter]? = nil, vulnerabilityId: [StringFilter]? = nil, vulnerabilitySource: [StringFilter]? = nil, vulnerablePackages: [PackageFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.codeVulnerabilityDetectorName = codeVulnerabilityDetectorName
            self.codeVulnerabilityDetectorTags = codeVulnerabilityDetectorTags
            self.codeVulnerabilityFilePath = codeVulnerabilityFilePath
            self.componentId = componentId
            self.componentType = componentType
            self.ec2InstanceImageId = ec2InstanceImageId
            self.ec2InstanceSubnetId = ec2InstanceSubnetId
            self.ec2InstanceVpcId = ec2InstanceVpcId
            self.ecrImageArchitecture = ecrImageArchitecture
            self.ecrImageHash = ecrImageHash
            self.ecrImagePushedAt = ecrImagePushedAt
            self.ecrImageRegistry = ecrImageRegistry
            self.ecrImageRepositoryName = ecrImageRepositoryName
            self.ecrImageTags = ecrImageTags
            self.epssScore = epssScore
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.findingStatus = findingStatus
            self.findingType = findingType
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.lambdaFunctionExecutionRoleArn = lambdaFunctionExecutionRoleArn
            self.lambdaFunctionLastModifiedAt = lambdaFunctionLastModifiedAt
            self.lambdaFunctionLayers = lambdaFunctionLayers
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionRuntime = lambdaFunctionRuntime
            self.lastObservedAt = lastObservedAt
            self.networkProtocol = networkProtocol
            self.portRange = portRange
            self.relatedVulnerabilities = relatedVulnerabilities
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.vendorSeverity = vendorSeverity
            self.vulnerabilityId = vulnerabilityId
            self.vulnerabilitySource = vulnerabilitySource
            self.vulnerablePackages = vulnerablePackages
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 10)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 1)
            try self.codeVulnerabilityDetectorName?.forEach {
                try $0.validate(name: "\(name).codeVulnerabilityDetectorName[]")
            }
            try self.validate(self.codeVulnerabilityDetectorName, name: "codeVulnerabilityDetectorName", parent: name, max: 10)
            try self.validate(self.codeVulnerabilityDetectorName, name: "codeVulnerabilityDetectorName", parent: name, min: 1)
            try self.codeVulnerabilityDetectorTags?.forEach {
                try $0.validate(name: "\(name).codeVulnerabilityDetectorTags[]")
            }
            try self.validate(self.codeVulnerabilityDetectorTags, name: "codeVulnerabilityDetectorTags", parent: name, max: 10)
            try self.validate(self.codeVulnerabilityDetectorTags, name: "codeVulnerabilityDetectorTags", parent: name, min: 1)
            try self.codeVulnerabilityFilePath?.forEach {
                try $0.validate(name: "\(name).codeVulnerabilityFilePath[]")
            }
            try self.validate(self.codeVulnerabilityFilePath, name: "codeVulnerabilityFilePath", parent: name, max: 10)
            try self.validate(self.codeVulnerabilityFilePath, name: "codeVulnerabilityFilePath", parent: name, min: 1)
            try self.componentId?.forEach {
                try $0.validate(name: "\(name).componentId[]")
            }
            try self.validate(self.componentId, name: "componentId", parent: name, max: 10)
            try self.validate(self.componentId, name: "componentId", parent: name, min: 1)
            try self.componentType?.forEach {
                try $0.validate(name: "\(name).componentType[]")
            }
            try self.validate(self.componentType, name: "componentType", parent: name, max: 10)
            try self.validate(self.componentType, name: "componentType", parent: name, min: 1)
            try self.ec2InstanceImageId?.forEach {
                try $0.validate(name: "\(name).ec2InstanceImageId[]")
            }
            try self.validate(self.ec2InstanceImageId, name: "ec2InstanceImageId", parent: name, max: 10)
            try self.validate(self.ec2InstanceImageId, name: "ec2InstanceImageId", parent: name, min: 1)
            try self.ec2InstanceSubnetId?.forEach {
                try $0.validate(name: "\(name).ec2InstanceSubnetId[]")
            }
            try self.validate(self.ec2InstanceSubnetId, name: "ec2InstanceSubnetId", parent: name, max: 10)
            try self.validate(self.ec2InstanceSubnetId, name: "ec2InstanceSubnetId", parent: name, min: 1)
            try self.ec2InstanceVpcId?.forEach {
                try $0.validate(name: "\(name).ec2InstanceVpcId[]")
            }
            try self.validate(self.ec2InstanceVpcId, name: "ec2InstanceVpcId", parent: name, max: 10)
            try self.validate(self.ec2InstanceVpcId, name: "ec2InstanceVpcId", parent: name, min: 1)
            try self.ecrImageArchitecture?.forEach {
                try $0.validate(name: "\(name).ecrImageArchitecture[]")
            }
            try self.validate(self.ecrImageArchitecture, name: "ecrImageArchitecture", parent: name, max: 10)
            try self.validate(self.ecrImageArchitecture, name: "ecrImageArchitecture", parent: name, min: 1)
            try self.ecrImageHash?.forEach {
                try $0.validate(name: "\(name).ecrImageHash[]")
            }
            try self.validate(self.ecrImageHash, name: "ecrImageHash", parent: name, max: 10)
            try self.validate(self.ecrImageHash, name: "ecrImageHash", parent: name, min: 1)
            try self.validate(self.ecrImagePushedAt, name: "ecrImagePushedAt", parent: name, max: 10)
            try self.validate(self.ecrImagePushedAt, name: "ecrImagePushedAt", parent: name, min: 1)
            try self.ecrImageRegistry?.forEach {
                try $0.validate(name: "\(name).ecrImageRegistry[]")
            }
            try self.validate(self.ecrImageRegistry, name: "ecrImageRegistry", parent: name, max: 10)
            try self.validate(self.ecrImageRegistry, name: "ecrImageRegistry", parent: name, min: 1)
            try self.ecrImageRepositoryName?.forEach {
                try $0.validate(name: "\(name).ecrImageRepositoryName[]")
            }
            try self.validate(self.ecrImageRepositoryName, name: "ecrImageRepositoryName", parent: name, max: 10)
            try self.validate(self.ecrImageRepositoryName, name: "ecrImageRepositoryName", parent: name, min: 1)
            try self.ecrImageTags?.forEach {
                try $0.validate(name: "\(name).ecrImageTags[]")
            }
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, max: 10)
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, min: 1)
            try self.validate(self.epssScore, name: "epssScore", parent: name, max: 10)
            try self.validate(self.epssScore, name: "epssScore", parent: name, min: 1)
            try self.exploitAvailable?.forEach {
                try $0.validate(name: "\(name).exploitAvailable[]")
            }
            try self.validate(self.exploitAvailable, name: "exploitAvailable", parent: name, max: 10)
            try self.validate(self.exploitAvailable, name: "exploitAvailable", parent: name, min: 1)
            try self.findingArn?.forEach {
                try $0.validate(name: "\(name).findingArn[]")
            }
            try self.validate(self.findingArn, name: "findingArn", parent: name, max: 10)
            try self.validate(self.findingArn, name: "findingArn", parent: name, min: 1)
            try self.findingStatus?.forEach {
                try $0.validate(name: "\(name).findingStatus[]")
            }
            try self.validate(self.findingStatus, name: "findingStatus", parent: name, max: 10)
            try self.validate(self.findingStatus, name: "findingStatus", parent: name, min: 1)
            try self.findingType?.forEach {
                try $0.validate(name: "\(name).findingType[]")
            }
            try self.validate(self.findingType, name: "findingType", parent: name, max: 10)
            try self.validate(self.findingType, name: "findingType", parent: name, min: 1)
            try self.validate(self.firstObservedAt, name: "firstObservedAt", parent: name, max: 10)
            try self.validate(self.firstObservedAt, name: "firstObservedAt", parent: name, min: 1)
            try self.fixAvailable?.forEach {
                try $0.validate(name: "\(name).fixAvailable[]")
            }
            try self.validate(self.fixAvailable, name: "fixAvailable", parent: name, max: 10)
            try self.validate(self.fixAvailable, name: "fixAvailable", parent: name, min: 1)
            try self.validate(self.inspectorScore, name: "inspectorScore", parent: name, max: 10)
            try self.validate(self.inspectorScore, name: "inspectorScore", parent: name, min: 1)
            try self.lambdaFunctionExecutionRoleArn?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionExecutionRoleArn[]")
            }
            try self.validate(self.lambdaFunctionExecutionRoleArn, name: "lambdaFunctionExecutionRoleArn", parent: name, max: 10)
            try self.validate(self.lambdaFunctionExecutionRoleArn, name: "lambdaFunctionExecutionRoleArn", parent: name, min: 1)
            try self.validate(self.lambdaFunctionLastModifiedAt, name: "lambdaFunctionLastModifiedAt", parent: name, max: 10)
            try self.validate(self.lambdaFunctionLastModifiedAt, name: "lambdaFunctionLastModifiedAt", parent: name, min: 1)
            try self.lambdaFunctionLayers?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionLayers[]")
            }
            try self.validate(self.lambdaFunctionLayers, name: "lambdaFunctionLayers", parent: name, max: 10)
            try self.validate(self.lambdaFunctionLayers, name: "lambdaFunctionLayers", parent: name, min: 1)
            try self.lambdaFunctionName?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionName[]")
            }
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, max: 10)
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, min: 1)
            try self.lambdaFunctionRuntime?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionRuntime[]")
            }
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, max: 10)
            try self.validate(self.lambdaFunctionRuntime, name: "lambdaFunctionRuntime", parent: name, min: 1)
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, max: 10)
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, min: 1)
            try self.networkProtocol?.forEach {
                try $0.validate(name: "\(name).networkProtocol[]")
            }
            try self.validate(self.networkProtocol, name: "networkProtocol", parent: name, max: 10)
            try self.validate(self.networkProtocol, name: "networkProtocol", parent: name, min: 1)
            try self.portRange?.forEach {
                try $0.validate(name: "\(name).portRange[]")
            }
            try self.validate(self.portRange, name: "portRange", parent: name, max: 10)
            try self.validate(self.portRange, name: "portRange", parent: name, min: 1)
            try self.relatedVulnerabilities?.forEach {
                try $0.validate(name: "\(name).relatedVulnerabilities[]")
            }
            try self.validate(self.relatedVulnerabilities, name: "relatedVulnerabilities", parent: name, max: 10)
            try self.validate(self.relatedVulnerabilities, name: "relatedVulnerabilities", parent: name, min: 1)
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 10)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 10)
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, min: 1)
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 10)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
            try self.severity?.forEach {
                try $0.validate(name: "\(name).severity[]")
            }
            try self.validate(self.severity, name: "severity", parent: name, max: 10)
            try self.validate(self.severity, name: "severity", parent: name, min: 1)
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.validate(self.title, name: "title", parent: name, max: 10)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, max: 10)
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, min: 1)
            try self.vendorSeverity?.forEach {
                try $0.validate(name: "\(name).vendorSeverity[]")
            }
            try self.validate(self.vendorSeverity, name: "vendorSeverity", parent: name, max: 10)
            try self.validate(self.vendorSeverity, name: "vendorSeverity", parent: name, min: 1)
            try self.vulnerabilityId?.forEach {
                try $0.validate(name: "\(name).vulnerabilityId[]")
            }
            try self.validate(self.vulnerabilityId, name: "vulnerabilityId", parent: name, max: 10)
            try self.validate(self.vulnerabilityId, name: "vulnerabilityId", parent: name, min: 1)
            try self.vulnerabilitySource?.forEach {
                try $0.validate(name: "\(name).vulnerabilitySource[]")
            }
            try self.validate(self.vulnerabilitySource, name: "vulnerabilitySource", parent: name, max: 10)
            try self.validate(self.vulnerabilitySource, name: "vulnerabilitySource", parent: name, min: 1)
            try self.vulnerablePackages?.forEach {
                try $0.validate(name: "\(name).vulnerablePackages[]")
            }
            try self.validate(self.vulnerablePackages, name: "vulnerablePackages", parent: name, max: 10)
            try self.validate(self.vulnerablePackages, name: "vulnerablePackages", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case codeVulnerabilityDetectorName = "codeVulnerabilityDetectorName"
            case codeVulnerabilityDetectorTags = "codeVulnerabilityDetectorTags"
            case codeVulnerabilityFilePath = "codeVulnerabilityFilePath"
            case componentId = "componentId"
            case componentType = "componentType"
            case ec2InstanceImageId = "ec2InstanceImageId"
            case ec2InstanceSubnetId = "ec2InstanceSubnetId"
            case ec2InstanceVpcId = "ec2InstanceVpcId"
            case ecrImageArchitecture = "ecrImageArchitecture"
            case ecrImageHash = "ecrImageHash"
            case ecrImagePushedAt = "ecrImagePushedAt"
            case ecrImageRegistry = "ecrImageRegistry"
            case ecrImageRepositoryName = "ecrImageRepositoryName"
            case ecrImageTags = "ecrImageTags"
            case epssScore = "epssScore"
            case exploitAvailable = "exploitAvailable"
            case findingArn = "findingArn"
            case findingStatus = "findingStatus"
            case findingType = "findingType"
            case firstObservedAt = "firstObservedAt"
            case fixAvailable = "fixAvailable"
            case inspectorScore = "inspectorScore"
            case lambdaFunctionExecutionRoleArn = "lambdaFunctionExecutionRoleArn"
            case lambdaFunctionLastModifiedAt = "lambdaFunctionLastModifiedAt"
            case lambdaFunctionLayers = "lambdaFunctionLayers"
            case lambdaFunctionName = "lambdaFunctionName"
            case lambdaFunctionRuntime = "lambdaFunctionRuntime"
            case lastObservedAt = "lastObservedAt"
            case networkProtocol = "networkProtocol"
            case portRange = "portRange"
            case relatedVulnerabilities = "relatedVulnerabilities"
            case resourceId = "resourceId"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case severity = "severity"
            case title = "title"
            case updatedAt = "updatedAt"
            case vendorSeverity = "vendorSeverity"
            case vulnerabilityId = "vulnerabilityId"
            case vulnerabilitySource = "vulnerabilitySource"
            case vulnerablePackages = "vulnerablePackages"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The Amazon Web Services account ID associated with the finding.
        public let awsAccountId: String
        /// Details about the code vulnerability identified in a Lambda function used to filter findings.
        public let codeVulnerabilityDetails: CodeVulnerabilityDetails?
        /// The description of the finding.
        public let description: String
        /// The finding's EPSS score.
        public let epss: EpssDetails?
        /// The details of an exploit available for a finding discovered in your environment.
        public let exploitabilityDetails: ExploitabilityDetails?
        /// If a finding discovered in your environment has an exploit available.
        public let exploitAvailable: ExploitAvailable?
        /// The Amazon Resource Number (ARN) of the finding.
        public let findingArn: String
        /// The date and time that the finding was first observed.
        public let firstObservedAt: Date
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL.  A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public let fixAvailable: FixAvailable?
        /// The Amazon Inspector score given to the finding.
        public let inspectorScore: Double?
        /// An object that contains details of the Amazon Inspector score.
        public let inspectorScoreDetails: InspectorScoreDetails?
        ///  The date and time the finding was last observed.  This timestamp for this field remains unchanged until a finding is updated.
        public let lastObservedAt: Date
        /// An object that contains the details of a network reachability finding.
        public let networkReachabilityDetails: NetworkReachabilityDetails?
        /// An object that contains the details of a package vulnerability finding.
        public let packageVulnerabilityDetails: PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        public let remediation: Remediation
        /// Contains information on the resources involved in a finding. The resource value determines the valid values for type in your request. For more information, see Finding types in the Amazon Inspector user guide.
        public let resources: [Resource]
        /// The severity of the finding. UNTRIAGED applies to PACKAGE_VULNERABILITY type findings that the vendor has not assigned a severity yet. For more information, see Severity levels for findings in the Amazon Inspector user guide.
        public let severity: Severity
        /// The status of the finding.
        public let status: FindingStatus
        /// The title of the finding.
        public let title: String?
        /// The type of the finding. The type value determines the valid values for resource in your request. For more information, see Finding types in the Amazon Inspector user guide.
        public let type: FindingType
        /// The date and time the finding was last updated at.
        public let updatedAt: Date?

        @inlinable
        public init(awsAccountId: String, codeVulnerabilityDetails: CodeVulnerabilityDetails? = nil, description: String, epss: EpssDetails? = nil, exploitabilityDetails: ExploitabilityDetails? = nil, exploitAvailable: ExploitAvailable? = nil, findingArn: String, firstObservedAt: Date, fixAvailable: FixAvailable? = nil, inspectorScore: Double? = nil, inspectorScoreDetails: InspectorScoreDetails? = nil, lastObservedAt: Date, networkReachabilityDetails: NetworkReachabilityDetails? = nil, packageVulnerabilityDetails: PackageVulnerabilityDetails? = nil, remediation: Remediation, resources: [Resource], severity: Severity, status: FindingStatus, title: String? = nil, type: FindingType, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.codeVulnerabilityDetails = codeVulnerabilityDetails
            self.description = description
            self.epss = epss
            self.exploitabilityDetails = exploitabilityDetails
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.lastObservedAt = lastObservedAt
            self.networkReachabilityDetails = networkReachabilityDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case codeVulnerabilityDetails = "codeVulnerabilityDetails"
            case description = "description"
            case epss = "epss"
            case exploitabilityDetails = "exploitabilityDetails"
            case exploitAvailable = "exploitAvailable"
            case findingArn = "findingArn"
            case firstObservedAt = "firstObservedAt"
            case fixAvailable = "fixAvailable"
            case inspectorScore = "inspectorScore"
            case inspectorScoreDetails = "inspectorScoreDetails"
            case lastObservedAt = "lastObservedAt"
            case networkReachabilityDetails = "networkReachabilityDetails"
            case packageVulnerabilityDetails = "packageVulnerabilityDetails"
            case remediation = "remediation"
            case resources = "resources"
            case severity = "severity"
            case status = "status"
            case title = "title"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct FindingDetail: AWSDecodableShape {
        /// The Cybersecurity and Infrastructure Security Agency (CISA) details for a specific vulnerability.
        public let cisaData: CisaData?
        /// The Common Weakness Enumerations (CWEs) associated with the vulnerability.
        public let cwes: [String]?
        /// The Exploit Prediction Scoring System (EPSS) score of the vulnerability.
        public let epssScore: Double?
        /// Information on the evidence of the vulnerability.
        public let evidences: [Evidence]?
        /// Contains information on when this exploit was observed.
        public let exploitObserved: ExploitObserved?
        /// The finding ARN that the vulnerability details are associated with.
        public let findingArn: String?
        /// The reference URLs for the vulnerability data.
        public let referenceUrls: [String]?
        /// The risk score of the vulnerability.
        public let riskScore: Int?
        /// The known malware tools or kits that can exploit the vulnerability.
        public let tools: [String]?
        /// The MITRE adversary tactics, techniques, or procedures (TTPs) associated with the vulnerability.
        public let ttps: [String]?

        @inlinable
        public init(cisaData: CisaData? = nil, cwes: [String]? = nil, epssScore: Double? = nil, evidences: [Evidence]? = nil, exploitObserved: ExploitObserved? = nil, findingArn: String? = nil, referenceUrls: [String]? = nil, riskScore: Int? = nil, tools: [String]? = nil, ttps: [String]? = nil) {
            self.cisaData = cisaData
            self.cwes = cwes
            self.epssScore = epssScore
            self.evidences = evidences
            self.exploitObserved = exploitObserved
            self.findingArn = findingArn
            self.referenceUrls = referenceUrls
            self.riskScore = riskScore
            self.tools = tools
            self.ttps = ttps
        }

        private enum CodingKeys: String, CodingKey {
            case cisaData = "cisaData"
            case cwes = "cwes"
            case epssScore = "epssScore"
            case evidences = "evidences"
            case exploitObserved = "exploitObserved"
            case findingArn = "findingArn"
            case referenceUrls = "referenceUrls"
            case riskScore = "riskScore"
            case tools = "tools"
            case ttps = "ttps"
        }
    }

    public struct FindingDetailsError: AWSDecodableShape {
        /// The error code.
        public let errorCode: FindingDetailsErrorCode
        /// The error message.
        public let errorMessage: String
        /// The finding ARN that returned an error.
        public let findingArn: String

        @inlinable
        public init(errorCode: FindingDetailsErrorCode, errorMessage: String, findingArn: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingArn = findingArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case findingArn = "findingArn"
        }
    }

    public struct FindingTypeAggregation: AWSEncodableShape {
        /// The finding type to aggregate.
        public let findingType: AggregationFindingType?
        /// The resource type to aggregate.
        public let resourceType: AggregationResourceType?
        /// The value to sort results by.
        public let sortBy: FindingTypeSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        @inlinable
        public init(findingType: AggregationFindingType? = nil, resourceType: AggregationResourceType? = nil, sortBy: FindingTypeSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case findingType = "findingType"
            case resourceType = "resourceType"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct FindingTypeAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// The number of findings that have an exploit available.
        public let exploitAvailableCount: Int64?
        ///  Details about the number of fixes.
        public let fixAvailableCount: Int64?
        /// The value to sort results by.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, exploitAvailableCount: Int64? = nil, fixAvailableCount: Int64? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.exploitAvailableCount = exploitAvailableCount
            self.fixAvailableCount = fixAvailableCount
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case exploitAvailableCount = "exploitAvailableCount"
            case fixAvailableCount = "fixAvailableCount"
            case severityCounts = "severityCounts"
        }
    }

    public struct FreeTrialAccountInfo: AWSDecodableShape {
        /// The account associated with the Amazon Inspector free trial information.
        public let accountId: String
        /// Contains information about the Amazon Inspector free trial for an account.
        public let freeTrialInfo: [FreeTrialInfo]

        @inlinable
        public init(accountId: String, freeTrialInfo: [FreeTrialInfo]) {
            self.accountId = accountId
            self.freeTrialInfo = freeTrialInfo
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case freeTrialInfo = "freeTrialInfo"
        }
    }

    public struct FreeTrialInfo: AWSDecodableShape {
        /// The date and time that the Amazon Inspector free trail ends for a given account.
        public let end: Date
        /// The date and time that the Amazon Inspector free trail started for a given account.
        public let start: Date
        /// The order to sort results by.
        public let status: FreeTrialStatus
        /// The type of scan covered by the Amazon Inspector free trail.
        public let type: FreeTrialType

        @inlinable
        public init(end: Date, start: Date, status: FreeTrialStatus, type: FreeTrialType) {
            self.end = end
            self.start = start
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
            case status = "status"
            case type = "type"
        }
    }

    public struct FreeTrialInfoError: AWSDecodableShape {
        /// The account associated with the Amazon Inspector free trial information.
        public let accountId: String
        /// The error code.
        public let code: FreeTrialInfoErrorCode
        /// The error message returned.
        public let message: String

        @inlinable
        public init(accountId: String, code: FreeTrialInfoErrorCode, message: String) {
            self.accountId = accountId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case code = "code"
            case message = "message"
        }
    }

    public struct GetCisScanReportRequest: AWSEncodableShape {
        ///  The format of the report.  Valid values are PDF and CSV.  If no value is specified, the report format defaults to PDF.
        public let reportFormat: CisReportFormat?
        /// The scan ARN.
        public let scanArn: String
        /// The target accounts.
        public let targetAccounts: [String]?

        @inlinable
        public init(reportFormat: CisReportFormat? = nil, scanArn: String, targetAccounts: [String]? = nil) {
            self.reportFormat = reportFormat
            self.scanArn = scanArn
            self.targetAccounts = targetAccounts
        }

        public func validate(name: String) throws {
            try self.validate(self.scanArn, name: "scanArn", parent: name, pattern: "^arn:aws(-us-gov|-cn)?:inspector2:[-.a-z0-9]{0,20}:\\d{12}:owner/(\\d{12}|o-[a-z0-9]{10,32})/cis-scan/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.targetAccounts?.forEach {
                try validate($0, name: "targetAccounts[]", parent: name, max: 12)
                try validate($0, name: "targetAccounts[]", parent: name, min: 12)
                try validate($0, name: "targetAccounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.targetAccounts, name: "targetAccounts", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case reportFormat = "reportFormat"
            case scanArn = "scanArn"
            case targetAccounts = "targetAccounts"
        }
    }

    public struct GetCisScanReportResponse: AWSDecodableShape {
        /// The status.
        public let status: CisReportStatus?
        ///  The URL where a PDF or CSV of the CIS scan report can be downloaded.
        public let url: String?

        @inlinable
        public init(status: CisReportStatus? = nil, url: String? = nil) {
            self.status = status
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case url = "url"
        }
    }

    public struct GetCisScanResultDetailsRequest: AWSEncodableShape {
        /// The account ID.
        public let accountId: String
        /// The filter criteria.
        public let filterCriteria: CisScanResultDetailsFilterCriteria?
        /// The maximum number of CIS scan result details to be returned in a single page of results.
        public let maxResults: Int?
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The scan ARN.
        public let scanArn: String
        /// The sort by order.
        public let sortBy: CisScanResultDetailsSortBy?
        /// The sort order.
        public let sortOrder: CisSortOrder?
        /// The target resource ID.
        public let targetResourceId: String

        @inlinable
        public init(accountId: String, filterCriteria: CisScanResultDetailsFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, scanArn: String, sortBy: CisScanResultDetailsSortBy? = nil, sortOrder: CisSortOrder? = nil, targetResourceId: String) {
            self.accountId = accountId
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.scanArn = scanArn
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.targetResourceId = targetResourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
            try self.validate(self.scanArn, name: "scanArn", parent: name, pattern: "^arn:aws(-us-gov|-cn)?:inspector2:[-.a-z0-9]{0,20}:\\d{12}:owner/(\\d{12}|o-[a-z0-9]{10,32})/cis-scan/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, max: 341)
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, min: 10)
            try self.validate(self.targetResourceId, name: "targetResourceId", parent: name, pattern: "(^arn:.*:ecr:.*:\\d{12}:repository\\/(?:[a-z0-9]+(?:[._-][a-z0-9]+)*\\/)*[a-z0-9]+(?:[._-][a-z0-9]+)*(\\/sha256:[a-z0-9]{64})?$)|(^i-([a-z0-9]{8}|[a-z0-9]{17}|\\\\*)$|(^arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9-_\\.]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?$))")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case scanArn = "scanArn"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
            case targetResourceId = "targetResourceId"
        }
    }

    public struct GetCisScanResultDetailsResponse: AWSDecodableShape {
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The scan result details.
        public let scanResultDetails: [CisScanResultDetails]?

        @inlinable
        public init(nextToken: String? = nil, scanResultDetails: [CisScanResultDetails]? = nil) {
            self.nextToken = nextToken
            self.scanResultDetails = scanResultDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scanResultDetails = "scanResultDetails"
        }
    }

    public struct GetConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetConfigurationResponse: AWSDecodableShape {
        /// Specifies how the Amazon EC2 automated scan mode is currently configured for your environment.
        public let ec2Configuration: Ec2ConfigurationState?
        /// Specifies how the ECR automated re-scan duration is currently configured for your environment.
        public let ecrConfiguration: EcrConfigurationState?

        @inlinable
        public init(ec2Configuration: Ec2ConfigurationState? = nil, ecrConfiguration: EcrConfigurationState? = nil) {
            self.ec2Configuration = ec2Configuration
            self.ecrConfiguration = ecrConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ec2Configuration = "ec2Configuration"
            case ecrConfiguration = "ecrConfiguration"
        }
    }

    public struct GetDelegatedAdminAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDelegatedAdminAccountResponse: AWSDecodableShape {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
        public let delegatedAdmin: DelegatedAdmin?

        @inlinable
        public init(delegatedAdmin: DelegatedAdmin? = nil) {
            self.delegatedAdmin = delegatedAdmin
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdmin = "delegatedAdmin"
        }
    }

    public struct GetEc2DeepInspectionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEc2DeepInspectionConfigurationResponse: AWSDecodableShape {
        /// An error message explaining why Amazon Inspector deep inspection configurations could not be retrieved for your account.
        public let errorMessage: String?
        /// The Amazon Inspector deep inspection custom paths for your organization.
        public let orgPackagePaths: [String]?
        /// The Amazon Inspector deep inspection custom paths for your account.
        public let packagePaths: [String]?
        /// The activation status of Amazon Inspector deep inspection in your account.
        public let status: Ec2DeepInspectionStatus?

        @inlinable
        public init(errorMessage: String? = nil, orgPackagePaths: [String]? = nil, packagePaths: [String]? = nil, status: Ec2DeepInspectionStatus? = nil) {
            self.errorMessage = errorMessage
            self.orgPackagePaths = orgPackagePaths
            self.packagePaths = packagePaths
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case orgPackagePaths = "orgPackagePaths"
            case packagePaths = "packagePaths"
            case status = "status"
        }
    }

    public struct GetEncryptionKeyRequest: AWSEncodableShape {
        /// The resource type the key encrypts.
        public let resourceType: ResourceType
        /// The scan type the key encrypts.
        public let scanType: ScanType

        @inlinable
        public init(resourceType: ResourceType, scanType: ScanType) {
            self.resourceType = resourceType
            self.scanType = scanType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceType, key: "resourceType")
            request.encodeQuery(self.scanType, key: "scanType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEncryptionKeyResponse: AWSDecodableShape {
        /// A kms key ID.
        public let kmsKeyId: String

        @inlinable
        public init(kmsKeyId: String) {
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct GetFindingsReportStatusRequest: AWSEncodableShape {
        /// The ID of the report to retrieve the status of.
        public let reportId: String?

        @inlinable
        public init(reportId: String? = nil) {
            self.reportId = reportId
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "\\b[a-f0-9]{8}\\b-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-\\b[a-f0-9]{12}\\b")
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct GetFindingsReportStatusResponse: AWSDecodableShape {
        /// The destination of the report.
        public let destination: Destination?
        /// The error code of the report.
        public let errorCode: ReportingErrorCode?
        /// The error message of the report.
        public let errorMessage: String?
        /// The filter criteria associated with the report.
        public let filterCriteria: FilterCriteria?
        /// The ID of the report.
        public let reportId: String?
        /// The status of the report.
        public let status: ExternalReportStatus?

        @inlinable
        public init(destination: Destination? = nil, errorCode: ReportingErrorCode? = nil, errorMessage: String? = nil, filterCriteria: FilterCriteria? = nil, reportId: String? = nil, status: ExternalReportStatus? = nil) {
            self.destination = destination
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.filterCriteria = filterCriteria
            self.reportId = reportId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case filterCriteria = "filterCriteria"
            case reportId = "reportId"
            case status = "status"
        }
    }

    public struct GetMemberRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the member account to retrieve information on.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct GetMemberResponse: AWSDecodableShape {
        /// Details of the retrieved member account.
        public let member: Member?

        @inlinable
        public init(member: Member? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct GetSbomExportRequest: AWSEncodableShape {
        /// The report ID of the SBOM export to get details for.
        public let reportId: String

        @inlinable
        public init(reportId: String) {
            self.reportId = reportId
        }

        public func validate(name: String) throws {
            try self.validate(self.reportId, name: "reportId", parent: name, pattern: "\\b[a-f0-9]{8}\\b-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-\\b[a-f0-9]{12}\\b")
        }

        private enum CodingKeys: String, CodingKey {
            case reportId = "reportId"
        }
    }

    public struct GetSbomExportResponse: AWSDecodableShape {
        /// An error code.
        public let errorCode: ReportingErrorCode?
        /// An error message.
        public let errorMessage: String?
        /// Contains details about the resource filter criteria used for the software bill of materials (SBOM) report.
        public let filterCriteria: ResourceFilterCriteria?
        /// The format of the software bill of materials (SBOM) report.
        public let format: SbomReportFormat?
        /// The report ID of the software bill of materials (SBOM) report.
        public let reportId: String?
        /// Contains details of the Amazon S3 bucket and KMS key used to export findings
        public let s3Destination: Destination?
        /// The status of the software bill of materials (SBOM) report.
        public let status: ExternalReportStatus?

        @inlinable
        public init(errorCode: ReportingErrorCode? = nil, errorMessage: String? = nil, filterCriteria: ResourceFilterCriteria? = nil, format: SbomReportFormat? = nil, reportId: String? = nil, s3Destination: Destination? = nil, status: ExternalReportStatus? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.filterCriteria = filterCriteria
            self.format = format
            self.reportId = reportId
            self.s3Destination = s3Destination
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case filterCriteria = "filterCriteria"
            case format = "format"
            case reportId = "reportId"
            case s3Destination = "s3Destination"
            case status = "status"
        }
    }

    public struct ImageLayerAggregation: AWSEncodableShape {
        /// The hashes associated with the layers.
        public let layerHashes: [StringFilter]?
        /// The repository associated with the container image hosting the layers.
        public let repositories: [StringFilter]?
        /// The ID of the container image layer.
        public let resourceIds: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: ImageLayerSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        @inlinable
        public init(layerHashes: [StringFilter]? = nil, repositories: [StringFilter]? = nil, resourceIds: [StringFilter]? = nil, sortBy: ImageLayerSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.layerHashes = layerHashes
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.layerHashes?.forEach {
                try $0.validate(name: "\(name).layerHashes[]")
            }
            try self.validate(self.layerHashes, name: "layerHashes", parent: name, max: 10)
            try self.validate(self.layerHashes, name: "layerHashes", parent: name, min: 1)
            try self.repositories?.forEach {
                try $0.validate(name: "\(name).repositories[]")
            }
            try self.validate(self.repositories, name: "repositories", parent: name, max: 10)
            try self.validate(self.repositories, name: "repositories", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case layerHashes = "layerHashes"
            case repositories = "repositories"
            case resourceIds = "resourceIds"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ImageLayerAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the container image hosting the layer image.
        public let accountId: String
        /// The layer hash.
        public let layerHash: String
        /// The repository the layer resides in.
        public let repository: String
        /// The resource ID of the container image layer.
        public let resourceId: String
        /// An object that represents the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String, layerHash: String, repository: String, resourceId: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.layerHash = layerHash
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case layerHash = "layerHash"
            case repository = "repository"
            case resourceId = "resourceId"
            case severityCounts = "severityCounts"
        }
    }

    public struct InspectorScoreDetails: AWSDecodableShape {
        /// An object that contains details about the CVSS score given to a finding.
        public let adjustedCvss: CvssScoreDetails?

        @inlinable
        public init(adjustedCvss: CvssScoreDetails? = nil) {
            self.adjustedCvss = adjustedCvss
        }

        private enum CodingKeys: String, CodingKey {
            case adjustedCvss = "adjustedCvss"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct LambdaFunctionAggregation: AWSEncodableShape {
        /// The Amazon Web Services Lambda function names to include in the aggregation results.
        public let functionNames: [StringFilter]?
        /// The tags to include in the aggregation results.
        public let functionTags: [MapFilter]?
        /// The resource IDs to include in the aggregation results.
        public let resourceIds: [StringFilter]?
        /// Returns findings aggregated by Amazon Web Services Lambda function runtime environments.
        public let runtimes: [StringFilter]?
        /// The finding severity to use for sorting the results.
        public let sortBy: LambdaFunctionSortBy?
        /// The order to use for sorting the results.
        public let sortOrder: SortOrder?

        @inlinable
        public init(functionNames: [StringFilter]? = nil, functionTags: [MapFilter]? = nil, resourceIds: [StringFilter]? = nil, runtimes: [StringFilter]? = nil, sortBy: LambdaFunctionSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.functionNames = functionNames
            self.functionTags = functionTags
            self.resourceIds = resourceIds
            self.runtimes = runtimes
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.functionNames?.forEach {
                try $0.validate(name: "\(name).functionNames[]")
            }
            try self.validate(self.functionNames, name: "functionNames", parent: name, max: 10)
            try self.validate(self.functionNames, name: "functionNames", parent: name, min: 1)
            try self.functionTags?.forEach {
                try $0.validate(name: "\(name).functionTags[]")
            }
            try self.validate(self.functionTags, name: "functionTags", parent: name, max: 10)
            try self.validate(self.functionTags, name: "functionTags", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
            try self.runtimes?.forEach {
                try $0.validate(name: "\(name).runtimes[]")
            }
            try self.validate(self.runtimes, name: "runtimes", parent: name, max: 10)
            try self.validate(self.runtimes, name: "runtimes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case functionNames = "functionNames"
            case functionTags = "functionTags"
            case resourceIds = "resourceIds"
            case runtimes = "runtimes"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct LambdaFunctionAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the Amazon Web Services Lambda function.
        public let accountId: String?
        /// The Amazon Web Services Lambda function names included in the aggregation results.
        public let functionName: String?
        /// The tags included in the aggregation results.
        public let lambdaTags: [String: String]?
        /// The date that the Amazon Web Services Lambda function included in the aggregation results was last changed.
        public let lastModifiedAt: Date?
        /// The resource IDs included in the aggregation results.
        public let resourceId: String
        /// The runtimes included in the aggregation results.
        public let runtime: String?
        /// An object that contains the counts of aggregated finding per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, functionName: String? = nil, lambdaTags: [String: String]? = nil, lastModifiedAt: Date? = nil, resourceId: String, runtime: String? = nil, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.functionName = functionName
            self.lambdaTags = lambdaTags
            self.lastModifiedAt = lastModifiedAt
            self.resourceId = resourceId
            self.runtime = runtime
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case functionName = "functionName"
            case lambdaTags = "lambdaTags"
            case lastModifiedAt = "lastModifiedAt"
            case resourceId = "resourceId"
            case runtime = "runtime"
            case severityCounts = "severityCounts"
        }
    }

    public struct LambdaFunctionMetadata: AWSDecodableShape {
        /// The name of a function.
        public let functionName: String?
        /// The resource tags on an Amazon Web Services Lambda function.
        public let functionTags: [String: String]?
        /// The layers for an Amazon Web Services Lambda function. A Lambda function can have up to five layers.
        public let layers: [String]?
        /// An Amazon Web Services Lambda function's runtime.
        public let runtime: Runtime?

        @inlinable
        public init(functionName: String? = nil, functionTags: [String: String]? = nil, layers: [String]? = nil, runtime: Runtime? = nil) {
            self.functionName = functionName
            self.functionTags = functionTags
            self.layers = layers
            self.runtime = runtime
        }

        private enum CodingKeys: String, CodingKey {
            case functionName = "functionName"
            case functionTags = "functionTags"
            case layers = "layers"
            case runtime = "runtime"
        }
    }

    public struct LambdaLayerAggregation: AWSEncodableShape {
        /// The names of the Amazon Web Services Lambda functions associated with the layers.
        public let functionNames: [StringFilter]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Lambda function layer.
        public let layerArns: [StringFilter]?
        /// The resource IDs for the Amazon Web Services Lambda function layers.
        public let resourceIds: [StringFilter]?
        /// The finding severity to use for sorting the results.
        public let sortBy: LambdaLayerSortBy?
        /// The order to use for sorting the results.
        public let sortOrder: SortOrder?

        @inlinable
        public init(functionNames: [StringFilter]? = nil, layerArns: [StringFilter]? = nil, resourceIds: [StringFilter]? = nil, sortBy: LambdaLayerSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.functionNames = functionNames
            self.layerArns = layerArns
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.functionNames?.forEach {
                try $0.validate(name: "\(name).functionNames[]")
            }
            try self.validate(self.functionNames, name: "functionNames", parent: name, max: 10)
            try self.validate(self.functionNames, name: "functionNames", parent: name, min: 1)
            try self.layerArns?.forEach {
                try $0.validate(name: "\(name).layerArns[]")
            }
            try self.validate(self.layerArns, name: "layerArns", parent: name, max: 10)
            try self.validate(self.layerArns, name: "layerArns", parent: name, min: 1)
            try self.resourceIds?.forEach {
                try $0.validate(name: "\(name).resourceIds[]")
            }
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 10)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case functionNames = "functionNames"
            case layerArns = "layerArns"
            case resourceIds = "resourceIds"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct LambdaLayerAggregationResponse: AWSDecodableShape {
        /// The account ID of the Amazon Web Services Lambda function layer.
        public let accountId: String
        /// The names of the Amazon Web Services Lambda functions associated with the layers.
        public let functionName: String
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Lambda function layer.
        public let layerArn: String
        /// The Resource ID of the Amazon Web Services Lambda function layer.
        public let resourceId: String
        /// An object that contains the counts of aggregated finding per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String, functionName: String, layerArn: String, resourceId: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.functionName = functionName
            self.layerArn = layerArn
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case functionName = "functionName"
            case layerArn = "layerArn"
            case resourceId = "resourceId"
            case severityCounts = "severityCounts"
        }
    }

    public struct LambdaVpcConfig: AWSDecodableShape {
        /// The VPC security groups and subnets that are attached to an Amazon Web Services Lambda function. For more information, see VPC Settings.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct ListAccountPermissionsRequest: AWSEncodableShape {
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The service scan type to check permissions for.
        public let service: Service?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, service: Service? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.service = service
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1024)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case service = "service"
        }
    }

    public struct ListAccountPermissionsResponse: AWSDecodableShape {
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Contains details on the permissions an account has to configure Amazon Inspector.
        public let permissions: [Permission]

        @inlinable
        public init(nextToken: String? = nil, permissions: [Permission]) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case permissions = "permissions"
        }
    }

    public struct ListCisScanConfigurationsFilterCriteria: AWSEncodableShape {
        /// The list of scan configuration ARN filters.
        public let scanConfigurationArnFilters: [CisStringFilter]?
        /// The list of scan name filters.
        public let scanNameFilters: [CisStringFilter]?
        /// The list of target resource tag filters.
        public let targetResourceTagFilters: [TagFilter]?

        @inlinable
        public init(scanConfigurationArnFilters: [CisStringFilter]? = nil, scanNameFilters: [CisStringFilter]? = nil, targetResourceTagFilters: [TagFilter]? = nil) {
            self.scanConfigurationArnFilters = scanConfigurationArnFilters
            self.scanNameFilters = scanNameFilters
            self.targetResourceTagFilters = targetResourceTagFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.scanConfigurationArnFilters, name: "scanConfigurationArnFilters", parent: name, max: 10)
            try self.validate(self.scanConfigurationArnFilters, name: "scanConfigurationArnFilters", parent: name, min: 1)
            try self.validate(self.scanNameFilters, name: "scanNameFilters", parent: name, max: 10)
            try self.validate(self.scanNameFilters, name: "scanNameFilters", parent: name, min: 1)
            try self.targetResourceTagFilters?.forEach {
                try $0.validate(name: "\(name).targetResourceTagFilters[]")
            }
            try self.validate(self.targetResourceTagFilters, name: "targetResourceTagFilters", parent: name, max: 10)
            try self.validate(self.targetResourceTagFilters, name: "targetResourceTagFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case scanConfigurationArnFilters = "scanConfigurationArnFilters"
            case scanNameFilters = "scanNameFilters"
            case targetResourceTagFilters = "targetResourceTagFilters"
        }
    }

    public struct ListCisScanConfigurationsRequest: AWSEncodableShape {
        /// The CIS scan configuration filter criteria.
        public let filterCriteria: ListCisScanConfigurationsFilterCriteria?
        /// The maximum number of CIS scan configurations to be returned in a single page of results.
        public let maxResults: Int?
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The CIS scan configuration sort by order.
        public let sortBy: CisScanConfigurationsSortBy?
        /// The CIS scan configuration sort order order.
        public let sortOrder: CisSortOrder?

        @inlinable
        public init(filterCriteria: ListCisScanConfigurationsFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: CisScanConfigurationsSortBy? = nil, sortOrder: CisSortOrder? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListCisScanConfigurationsResponse: AWSDecodableShape {
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The CIS scan configuration scan configurations.
        public let scanConfigurations: [CisScanConfiguration]?

        @inlinable
        public init(nextToken: String? = nil, scanConfigurations: [CisScanConfiguration]? = nil) {
            self.nextToken = nextToken
            self.scanConfigurations = scanConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scanConfigurations = "scanConfigurations"
        }
    }

    public struct ListCisScanResultsAggregatedByChecksRequest: AWSEncodableShape {
        /// The filter criteria.
        public let filterCriteria: CisScanResultsAggregatedByChecksFilterCriteria?
        /// The maximum number of scan results aggregated by checks to be returned in a single page of results.
        public let maxResults: Int?
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The scan ARN.
        public let scanArn: String
        /// The sort by order.
        public let sortBy: CisScanResultsAggregatedByChecksSortBy?
        /// The sort order.
        public let sortOrder: CisSortOrder?

        @inlinable
        public init(filterCriteria: CisScanResultsAggregatedByChecksFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, scanArn: String, sortBy: CisScanResultsAggregatedByChecksSortBy? = nil, sortOrder: CisSortOrder? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.scanArn = scanArn
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
            try self.validate(self.scanArn, name: "scanArn", parent: name, pattern: "^arn:aws(-us-gov|-cn)?:inspector2:[-.a-z0-9]{0,20}:\\d{12}:owner/(\\d{12}|o-[a-z0-9]{10,32})/cis-scan/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case scanArn = "scanArn"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListCisScanResultsAggregatedByChecksResponse: AWSDecodableShape {
        /// The check aggregations.
        public let checkAggregations: [CisCheckAggregation]?
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(checkAggregations: [CisCheckAggregation]? = nil, nextToken: String? = nil) {
            self.checkAggregations = checkAggregations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case checkAggregations = "checkAggregations"
            case nextToken = "nextToken"
        }
    }

    public struct ListCisScanResultsAggregatedByTargetResourceRequest: AWSEncodableShape {
        /// The filter criteria.
        public let filterCriteria: CisScanResultsAggregatedByTargetResourceFilterCriteria?
        /// The maximum number of scan results aggregated by a target resource to be returned in a single page of results.
        public let maxResults: Int?
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The scan ARN.
        public let scanArn: String
        /// The sort by order.
        public let sortBy: CisScanResultsAggregatedByTargetResourceSortBy?
        /// The sort order.
        public let sortOrder: CisSortOrder?

        @inlinable
        public init(filterCriteria: CisScanResultsAggregatedByTargetResourceFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, scanArn: String, sortBy: CisScanResultsAggregatedByTargetResourceSortBy? = nil, sortOrder: CisSortOrder? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.scanArn = scanArn
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
            try self.validate(self.scanArn, name: "scanArn", parent: name, pattern: "^arn:aws(-us-gov|-cn)?:inspector2:[-.a-z0-9]{0,20}:\\d{12}:owner/(\\d{12}|o-[a-z0-9]{10,32})/cis-scan/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case scanArn = "scanArn"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListCisScanResultsAggregatedByTargetResourceResponse: AWSDecodableShape {
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The resource aggregations.
        public let targetResourceAggregations: [CisTargetResourceAggregation]?

        @inlinable
        public init(nextToken: String? = nil, targetResourceAggregations: [CisTargetResourceAggregation]? = nil) {
            self.nextToken = nextToken
            self.targetResourceAggregations = targetResourceAggregations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case targetResourceAggregations = "targetResourceAggregations"
        }
    }

    public struct ListCisScansFilterCriteria: AWSEncodableShape {
        /// The list of failed checks filters.
        public let failedChecksFilters: [CisNumberFilter]?
        /// The list of scan ARN filters.
        public let scanArnFilters: [CisStringFilter]?
        /// The list of scan at filters.
        public let scanAtFilters: [CisDateFilter]?
        /// The list of scan configuration ARN filters.
        public let scanConfigurationArnFilters: [CisStringFilter]?
        /// The list of scan name filters.
        public let scanNameFilters: [CisStringFilter]?
        /// The list of scan status filters.
        public let scanStatusFilters: [CisScanStatusFilter]?
        /// The list of scheduled by filters.
        public let scheduledByFilters: [CisStringFilter]?
        /// The list of target account ID filters.
        public let targetAccountIdFilters: [CisStringFilter]?
        /// The list of target resource ID filters.
        public let targetResourceIdFilters: [CisStringFilter]?
        /// The list of target resource tag filters.
        public let targetResourceTagFilters: [TagFilter]?

        @inlinable
        public init(failedChecksFilters: [CisNumberFilter]? = nil, scanArnFilters: [CisStringFilter]? = nil, scanAtFilters: [CisDateFilter]? = nil, scanConfigurationArnFilters: [CisStringFilter]? = nil, scanNameFilters: [CisStringFilter]? = nil, scanStatusFilters: [CisScanStatusFilter]? = nil, scheduledByFilters: [CisStringFilter]? = nil, targetAccountIdFilters: [CisStringFilter]? = nil, targetResourceIdFilters: [CisStringFilter]? = nil, targetResourceTagFilters: [TagFilter]? = nil) {
            self.failedChecksFilters = failedChecksFilters
            self.scanArnFilters = scanArnFilters
            self.scanAtFilters = scanAtFilters
            self.scanConfigurationArnFilters = scanConfigurationArnFilters
            self.scanNameFilters = scanNameFilters
            self.scanStatusFilters = scanStatusFilters
            self.scheduledByFilters = scheduledByFilters
            self.targetAccountIdFilters = targetAccountIdFilters
            self.targetResourceIdFilters = targetResourceIdFilters
            self.targetResourceTagFilters = targetResourceTagFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.failedChecksFilters, name: "failedChecksFilters", parent: name, max: 10)
            try self.validate(self.failedChecksFilters, name: "failedChecksFilters", parent: name, min: 1)
            try self.validate(self.scanArnFilters, name: "scanArnFilters", parent: name, max: 10)
            try self.validate(self.scanArnFilters, name: "scanArnFilters", parent: name, min: 1)
            try self.validate(self.scanAtFilters, name: "scanAtFilters", parent: name, max: 1)
            try self.validate(self.scanAtFilters, name: "scanAtFilters", parent: name, min: 1)
            try self.validate(self.scanConfigurationArnFilters, name: "scanConfigurationArnFilters", parent: name, max: 10)
            try self.validate(self.scanConfigurationArnFilters, name: "scanConfigurationArnFilters", parent: name, min: 1)
            try self.validate(self.scanNameFilters, name: "scanNameFilters", parent: name, max: 10)
            try self.validate(self.scanNameFilters, name: "scanNameFilters", parent: name, min: 1)
            try self.validate(self.scanStatusFilters, name: "scanStatusFilters", parent: name, max: 10)
            try self.validate(self.scanStatusFilters, name: "scanStatusFilters", parent: name, min: 1)
            try self.validate(self.scheduledByFilters, name: "scheduledByFilters", parent: name, max: 10)
            try self.validate(self.scheduledByFilters, name: "scheduledByFilters", parent: name, min: 1)
            try self.validate(self.targetAccountIdFilters, name: "targetAccountIdFilters", parent: name, max: 10)
            try self.validate(self.targetAccountIdFilters, name: "targetAccountIdFilters", parent: name, min: 1)
            try self.validate(self.targetResourceIdFilters, name: "targetResourceIdFilters", parent: name, max: 10)
            try self.validate(self.targetResourceIdFilters, name: "targetResourceIdFilters", parent: name, min: 1)
            try self.targetResourceTagFilters?.forEach {
                try $0.validate(name: "\(name).targetResourceTagFilters[]")
            }
            try self.validate(self.targetResourceTagFilters, name: "targetResourceTagFilters", parent: name, max: 10)
            try self.validate(self.targetResourceTagFilters, name: "targetResourceTagFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case failedChecksFilters = "failedChecksFilters"
            case scanArnFilters = "scanArnFilters"
            case scanAtFilters = "scanAtFilters"
            case scanConfigurationArnFilters = "scanConfigurationArnFilters"
            case scanNameFilters = "scanNameFilters"
            case scanStatusFilters = "scanStatusFilters"
            case scheduledByFilters = "scheduledByFilters"
            case targetAccountIdFilters = "targetAccountIdFilters"
            case targetResourceIdFilters = "targetResourceIdFilters"
            case targetResourceTagFilters = "targetResourceTagFilters"
        }
    }

    public struct ListCisScansRequest: AWSEncodableShape {
        /// The detail applied to the CIS scan.
        public let detailLevel: ListCisScansDetailLevel?
        /// The CIS scan filter criteria.
        public let filterCriteria: ListCisScansFilterCriteria?
        /// The maximum number of results to be returned.
        public let maxResults: Int?
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The CIS scans sort by order.
        public let sortBy: ListCisScansSortBy?
        /// The CIS scans sort order.
        public let sortOrder: CisSortOrder?

        @inlinable
        public init(detailLevel: ListCisScansDetailLevel? = nil, filterCriteria: ListCisScansFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: ListCisScansSortBy? = nil, sortOrder: CisSortOrder? = nil) {
            self.detailLevel = detailLevel
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case detailLevel = "detailLevel"
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListCisScansResponse: AWSDecodableShape {
        /// The pagination token from a previous request that's used to retrieve the next page of results.
        public let nextToken: String?
        /// The CIS scans.
        public let scans: [CisScan]?

        @inlinable
        public init(nextToken: String? = nil, scans: [CisScan]? = nil) {
            self.nextToken = nextToken
            self.scans = scans
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scans = "scans"
        }
    }

    public struct ListCoverageRequest: AWSEncodableShape {
        /// An object that contains details on the filters to apply to the coverage data for your environment.
        public let filterCriteria: CoverageFilterCriteria?
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(filterCriteria: CoverageFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCoverageResponse: AWSDecodableShape {
        /// An object that contains details on the covered resources in your environment.
        public let coveredResources: [CoveredResource]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(coveredResources: [CoveredResource]? = nil, nextToken: String? = nil) {
            self.coveredResources = coveredResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coveredResources = "coveredResources"
            case nextToken = "nextToken"
        }
    }

    public struct ListCoverageStatisticsRequest: AWSEncodableShape {
        /// An object that contains details on the filters to apply to the coverage data for your environment.
        public let filterCriteria: CoverageFilterCriteria?
        /// The value to group the results by.
        public let groupBy: GroupKey?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(filterCriteria: CoverageFilterCriteria? = nil, groupBy: GroupKey? = nil, nextToken: String? = nil) {
            self.filterCriteria = filterCriteria
            self.groupBy = groupBy
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case groupBy = "groupBy"
            case nextToken = "nextToken"
        }
    }

    public struct ListCoverageStatisticsResponse: AWSDecodableShape {
        /// An array with the number for each group.
        public let countsByGroup: [Counts]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// The total number for all groups.
        public let totalCounts: Int64

        @inlinable
        public init(countsByGroup: [Counts]? = nil, nextToken: String? = nil, totalCounts: Int64) {
            self.countsByGroup = countsByGroup
            self.nextToken = nextToken
            self.totalCounts = totalCounts
        }

        private enum CodingKeys: String, CodingKey {
            case countsByGroup = "countsByGroup"
            case nextToken = "nextToken"
            case totalCounts = "totalCounts"
        }
    }

    public struct ListDelegatedAdminAccountsRequest: AWSEncodableShape {
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDelegatedAdminAccountsResponse: AWSDecodableShape {
        /// Details of the Amazon Inspector delegated administrator of your organization.
        public let delegatedAdminAccounts: [DelegatedAdminAccount]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(delegatedAdminAccounts: [DelegatedAdminAccount]? = nil, nextToken: String? = nil) {
            self.delegatedAdminAccounts = delegatedAdminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case delegatedAdminAccounts = "delegatedAdminAccounts"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersRequest: AWSEncodableShape {
        /// The action the filter applies to matched findings.
        public let action: FilterAction?
        /// The Amazon resource number (ARN) of the filter.
        public let arns: [String]?
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(action: FilterAction? = nil, arns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.action = action
            self.arns = arns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.arns?.forEach {
                try validate($0, name: "arns[]", parent: name, max: 128)
                try validate($0, name: "arns[]", parent: name, min: 1)
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arns = "arns"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersResponse: AWSDecodableShape {
        /// Contains details on the filters associated with your account.
        public let filters: [Filter]
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter], nextToken: String? = nil) {
            self.filters = filters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingAggregationsRequest: AWSEncodableShape {
        /// The Amazon Web Services account IDs to retrieve finding aggregation data for.
        public let accountIds: [StringFilter]?
        /// Details of the aggregation request that is used to filter your aggregation results.
        public let aggregationRequest: AggregationRequest?
        /// The type of the aggregation request.
        public let aggregationType: AggregationType
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(accountIds: [StringFilter]? = nil, aggregationRequest: AggregationRequest? = nil, aggregationType: AggregationType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountIds = accountIds
            self.aggregationRequest = aggregationRequest
            self.aggregationType = aggregationType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try $0.validate(name: "\(name).accountIds[]")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 10)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.aggregationRequest?.validate(name: "\(name).aggregationRequest")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case aggregationRequest = "aggregationRequest"
            case aggregationType = "aggregationType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFindingAggregationsResponse: AWSDecodableShape {
        /// The type of aggregation to perform.
        public let aggregationType: AggregationType
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Objects that contain the results of an aggregation operation.
        public let responses: [AggregationResponse]?

        @inlinable
        public init(aggregationType: AggregationType, nextToken: String? = nil, responses: [AggregationResponse]? = nil) {
            self.aggregationType = aggregationType
            self.nextToken = nextToken
            self.responses = responses
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationType = "aggregationType"
            case nextToken = "nextToken"
            case responses = "responses"
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        /// Details on the filters to apply to your finding results.
        public let filterCriteria: FilterCriteria?
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Details on the sort criteria to apply to your finding results.
        public let sortCriteria: SortCriteria?

        @inlinable
        public init(filterCriteria: FilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortCriteria = "sortCriteria"
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        /// Contains details on the findings in your environment.
        public let findings: [Finding]?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(findings: [Finding]? = nil, nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?
        /// Specifies whether to list only currently associated members if True or to list all members within the organization if False.
        public let onlyAssociated: Bool?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: Bool? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case onlyAssociated = "onlyAssociated"
        }
    }

    public struct ListMembersResponse: AWSDecodableShape {
        /// An object that contains details for each member account.
        public let members: [Member]?
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?

        @inlinable
        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon resource number (ARN) of the resource to list tags of.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListUsageTotalsRequest: AWSEncodableShape {
        /// The Amazon Web Services account IDs to retrieve usage totals for.
        public let accountIds: [String]?
        /// The maximum number of results the response can return. If your request would return more than the maximum the response will return a nextToken value, use this value when you call the action again to get the remaining results.
        public let maxResults: Int?
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. If your response returns more than the maxResults maximum value it will also return a nextToken value. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(accountIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountIds = accountIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "[0-9]{12}")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 7000)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListUsageTotalsResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// An object with details on the total usage for the requested account.
        public let totals: [UsageTotal]?

        @inlinable
        public init(nextToken: String? = nil, totals: [UsageTotal]? = nil) {
            self.nextToken = nextToken
            self.totals = totals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case totals = "totals"
        }
    }

    public struct MapFilter: AWSEncodableShape & AWSDecodableShape {
        /// The operator to use when comparing values in the filter.
        public let comparison: MapComparison
        /// The tag key used in the filter.
        public let key: String
        /// The tag value used in the filter.
        public let value: String?

        @inlinable
        public init(comparison: MapComparison, key: String, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case key = "key"
            case value = "value"
        }
    }

    public struct Member: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member account.
        public let accountId: String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for this member account.
        public let delegatedAdminAccountId: String?
        /// The status of the member account.
        public let relationshipStatus: RelationshipStatus?
        /// A timestamp showing when the status of this member was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(accountId: String? = nil, delegatedAdminAccountId: String? = nil, relationshipStatus: RelationshipStatus? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.delegatedAdminAccountId = delegatedAdminAccountId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case delegatedAdminAccountId = "delegatedAdminAccountId"
            case relationshipStatus = "relationshipStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct MemberAccountEc2DeepInspectionStatus: AWSEncodableShape {
        /// The unique identifier for the Amazon Web Services account of the organization member.
        public let accountId: String
        /// Whether Amazon Inspector deep inspection is active in the account.  If TRUE Amazon Inspector deep inspection is active, if FALSE it is not active.
        public let activateDeepInspection: Bool

        @inlinable
        public init(accountId: String, activateDeepInspection: Bool) {
            self.accountId = accountId
            self.activateDeepInspection = activateDeepInspection
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case activateDeepInspection = "activateDeepInspection"
        }
    }

    public struct MemberAccountEc2DeepInspectionStatusState: AWSDecodableShape {
        /// The unique identifier for the Amazon Web Services account of the organization member
        public let accountId: String
        /// The error message explaining why the account failed to activate Amazon Inspector deep inspection.
        public let errorMessage: String?
        /// The state of Amazon Inspector deep inspection in the member account.
        public let status: Ec2DeepInspectionStatus?

        @inlinable
        public init(accountId: String, errorMessage: String? = nil, status: Ec2DeepInspectionStatus? = nil) {
            self.accountId = accountId
            self.errorMessage = errorMessage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case errorMessage = "errorMessage"
            case status = "status"
        }
    }

    public struct MonthlySchedule: AWSEncodableShape & AWSDecodableShape {
        /// The monthly schedule's day.
        public let day: Day
        /// The monthly schedule's start time.
        public let startTime: Time

        @inlinable
        public init(day: Day, startTime: Time) {
            self.day = day
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.startTime.validate(name: "\(name).startTime")
        }

        private enum CodingKeys: String, CodingKey {
            case day = "day"
            case startTime = "startTime"
        }
    }

    public struct NetworkPath: AWSDecodableShape {
        /// The details on the steps in the network path.
        public let steps: [Step]?

        @inlinable
        public init(steps: [Step]? = nil) {
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case steps = "steps"
        }
    }

    public struct NetworkReachabilityDetails: AWSDecodableShape {
        /// An object that contains details about a network path associated with a finding.
        public let networkPath: NetworkPath
        /// An object that contains details about the open port range associated with a finding.
        public let openPortRange: PortRange
        /// The protocol associated with a finding.
        public let `protocol`: NetworkProtocol

        @inlinable
        public init(networkPath: NetworkPath, openPortRange: PortRange, protocol: NetworkProtocol) {
            self.networkPath = networkPath
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case networkPath = "networkPath"
            case openPortRange = "openPortRange"
            case `protocol` = "protocol"
        }
    }

    public struct NumberFilter: AWSEncodableShape & AWSDecodableShape {
        /// The lowest number to be included in the filter.
        public let lowerInclusive: Double?
        /// The highest number to be included in the filter.
        public let upperInclusive: Double?

        @inlinable
        public init(lowerInclusive: Double? = nil, upperInclusive: Double? = nil) {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }

        private enum CodingKeys: String, CodingKey {
            case lowerInclusive = "lowerInclusive"
            case upperInclusive = "upperInclusive"
        }
    }

    public struct OneTimeSchedule: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct PackageAggregation: AWSEncodableShape {
        /// The names of packages to aggregate findings on.
        public let packageNames: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: PackageSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        @inlinable
        public init(packageNames: [StringFilter]? = nil, sortBy: PackageSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.packageNames = packageNames
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.packageNames?.forEach {
                try $0.validate(name: "\(name).packageNames[]")
            }
            try self.validate(self.packageNames, name: "packageNames", parent: name, max: 10)
            try self.validate(self.packageNames, name: "packageNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case packageNames = "packageNames"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct PackageAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// The name of the operating system package.
        public let packageName: String
        /// An object that contains the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, packageName: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.packageName = packageName
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case packageName = "packageName"
            case severityCounts = "severityCounts"
        }
    }

    public struct PackageFilter: AWSEncodableShape & AWSDecodableShape {
        /// An object that contains details on the package architecture type to filter on.
        public let architecture: StringFilter?
        /// An object that contains details on the package epoch to filter on.
        public let epoch: NumberFilter?
        /// An object that contains details on the package file path to filter on.
        public let filePath: StringFilter?
        /// An object that contains details on the name of the package to filter on.
        public let name: StringFilter?
        /// An object that contains details on the package release to filter on.
        public let release: StringFilter?
        /// An object that describes the details of a string filter.
        public let sourceLambdaLayerArn: StringFilter?
        /// An object that contains details on the source layer hash to filter on.
        public let sourceLayerHash: StringFilter?
        /// The package version to filter on.
        public let version: StringFilter?

        @inlinable
        public init(architecture: StringFilter? = nil, epoch: NumberFilter? = nil, filePath: StringFilter? = nil, name: StringFilter? = nil, release: StringFilter? = nil, sourceLambdaLayerArn: StringFilter? = nil, sourceLayerHash: StringFilter? = nil, version: StringFilter? = nil) {
            self.architecture = architecture
            self.epoch = epoch
            self.filePath = filePath
            self.name = name
            self.release = release
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        public func validate(name: String) throws {
            try self.architecture?.validate(name: "\(name).architecture")
            try self.filePath?.validate(name: "\(name).filePath")
            try self.name?.validate(name: "\(name).name")
            try self.release?.validate(name: "\(name).release")
            try self.sourceLambdaLayerArn?.validate(name: "\(name).sourceLambdaLayerArn")
            try self.sourceLayerHash?.validate(name: "\(name).sourceLayerHash")
            try self.version?.validate(name: "\(name).version")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case epoch = "epoch"
            case filePath = "filePath"
            case name = "name"
            case release = "release"
            case sourceLambdaLayerArn = "sourceLambdaLayerArn"
            case sourceLayerHash = "sourceLayerHash"
            case version = "version"
        }
    }

    public struct PackageVulnerabilityDetails: AWSDecodableShape {
        /// An object that contains details about the CVSS score of a finding.
        public let cvss: [CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public let referenceUrls: [String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public let relatedVulnerabilities: [String]?
        /// The source of the vulnerability information.
        public let source: String
        /// A URL to the source of the vulnerability information.
        public let sourceUrl: String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public let vendorCreatedAt: Date?
        /// The severity the vendor has given to this vulnerability type.
        public let vendorSeverity: String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public let vendorUpdatedAt: Date?
        /// The ID given to this vulnerability.
        public let vulnerabilityId: String
        /// The packages impacted by this vulnerability.
        public let vulnerablePackages: [VulnerablePackage]?

        @inlinable
        public init(cvss: [CvssScore]? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, source: String, sourceUrl: String? = nil, vendorCreatedAt: Date? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: Date? = nil, vulnerabilityId: String, vulnerablePackages: [VulnerablePackage]? = nil) {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }

        private enum CodingKeys: String, CodingKey {
            case cvss = "cvss"
            case referenceUrls = "referenceUrls"
            case relatedVulnerabilities = "relatedVulnerabilities"
            case source = "source"
            case sourceUrl = "sourceUrl"
            case vendorCreatedAt = "vendorCreatedAt"
            case vendorSeverity = "vendorSeverity"
            case vendorUpdatedAt = "vendorUpdatedAt"
            case vulnerabilityId = "vulnerabilityId"
            case vulnerablePackages = "vulnerablePackages"
        }
    }

    public struct Permission: AWSDecodableShape {
        /// The operations that can be performed with the given permissions.
        public let operation: Operation
        /// The services that the permissions allow an account to perform the given operations for.
        public let service: Service

        @inlinable
        public init(operation: Operation, service: Service) {
            self.operation = operation
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "operation"
            case service = "service"
        }
    }

    public struct PortRange: AWSDecodableShape {
        /// The beginning port in a port range.
        public let begin: Int
        /// The ending port in a port range.
        public let end: Int

        @inlinable
        public init(begin: Int, end: Int) {
            self.begin = begin
            self.end = end
        }

        private enum CodingKeys: String, CodingKey {
            case begin = "begin"
            case end = "end"
        }
    }

    public struct PortRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The port number the port range begins at.
        public let beginInclusive: Int?
        /// The port number the port range ends at.
        public let endInclusive: Int?

        @inlinable
        public init(beginInclusive: Int? = nil, endInclusive: Int? = nil) {
            self.beginInclusive = beginInclusive
            self.endInclusive = endInclusive
        }

        public func validate(name: String) throws {
            try self.validate(self.beginInclusive, name: "beginInclusive", parent: name, max: 65535)
            try self.validate(self.beginInclusive, name: "beginInclusive", parent: name, min: 0)
            try self.validate(self.endInclusive, name: "endInclusive", parent: name, max: 65535)
            try self.validate(self.endInclusive, name: "endInclusive", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case beginInclusive = "beginInclusive"
            case endInclusive = "endInclusive"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The recommended course of action to remediate the finding.
        public let text: String?
        /// The URL address to the CVE remediation recommendations.
        public let url: String?

        @inlinable
        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case url = "Url"
        }
    }

    public struct Remediation: AWSDecodableShape {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public let recommendation: Recommendation?

        @inlinable
        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "recommendation"
        }
    }

    public struct RepositoryAggregation: AWSEncodableShape {
        /// The names of repositories to aggregate findings on.
        public let repositories: [StringFilter]?
        /// The value to sort results by.
        public let sortBy: RepositorySortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?

        @inlinable
        public init(repositories: [StringFilter]? = nil, sortBy: RepositorySortBy? = nil, sortOrder: SortOrder? = nil) {
            self.repositories = repositories
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.repositories?.forEach {
                try $0.validate(name: "\(name).repositories[]")
            }
            try self.validate(self.repositories, name: "repositories", parent: name, max: 10)
            try self.validate(self.repositories, name: "repositories", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case repositories = "repositories"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct RepositoryAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// The number of container images impacted by the findings.
        public let affectedImages: Int64?
        /// The name of the repository associated with the findings.
        public let repository: String
        /// An object that represent the count of matched findings per severity.
        public let severityCounts: SeverityCounts?

        @inlinable
        public init(accountId: String? = nil, affectedImages: Int64? = nil, repository: String, severityCounts: SeverityCounts? = nil) {
            self.accountId = accountId
            self.affectedImages = affectedImages
            self.repository = repository
            self.severityCounts = severityCounts
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case affectedImages = "affectedImages"
            case repository = "repository"
            case severityCounts = "severityCounts"
        }
    }

    public struct ResetEncryptionKeyRequest: AWSEncodableShape {
        /// The resource type the key encrypts.
        public let resourceType: ResourceType
        /// The scan type the key encrypts.
        public let scanType: ScanType

        @inlinable
        public init(resourceType: ResourceType, scanType: ScanType) {
            self.resourceType = resourceType
            self.scanType = scanType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "resourceType"
            case scanType = "scanType"
        }
    }

    public struct ResetEncryptionKeyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Resource: AWSDecodableShape {
        /// An object that contains details about the resource involved in a finding.
        public let details: ResourceDetails?
        /// The ID of the resource.
        public let id: String
        /// The partition of the resource.
        public let partition: String?
        /// The Amazon Web Services Region the impacted resource is located in.
        public let region: String?
        /// The tags attached to the resource.
        public let tags: [String: String]?
        /// The type of resource.
        public let type: ResourceType

        @inlinable
        public init(details: ResourceDetails? = nil, id: String, partition: String? = nil, region: String? = nil, tags: [String: String]? = nil, type: ResourceType) {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case id = "id"
            case partition = "partition"
            case region = "region"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// An object that contains details about the Amazon EC2 instance involved in the finding.
        public let awsEc2Instance: AwsEc2InstanceDetails?
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public let awsEcrContainerImage: AwsEcrContainerImageDetails?
        /// A summary of the information about an Amazon Web Services Lambda function affected by a finding.
        public let awsLambdaFunction: AwsLambdaFunctionDetails?

        @inlinable
        public init(awsEc2Instance: AwsEc2InstanceDetails? = nil, awsEcrContainerImage: AwsEcrContainerImageDetails? = nil, awsLambdaFunction: AwsLambdaFunctionDetails? = nil) {
            self.awsEc2Instance = awsEc2Instance
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsLambdaFunction = awsLambdaFunction
        }

        private enum CodingKeys: String, CodingKey {
            case awsEc2Instance = "awsEc2Instance"
            case awsEcrContainerImage = "awsEcrContainerImage"
            case awsLambdaFunction = "awsLambdaFunction"
        }
    }

    public struct ResourceFilterCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The account IDs used as resource filter criteria.
        public let accountId: [ResourceStringFilter]?
        /// The EC2 instance tags used as resource filter criteria.
        public let ec2InstanceTags: [ResourceMapFilter]?
        /// The ECR image tags used as resource filter criteria.
        public let ecrImageTags: [ResourceStringFilter]?
        /// The ECR repository names used as resource filter criteria.
        public let ecrRepositoryName: [ResourceStringFilter]?
        /// The Amazon Web Services Lambda function name used as resource filter criteria.
        public let lambdaFunctionName: [ResourceStringFilter]?
        /// The Amazon Web Services Lambda function tags used as resource filter criteria.
        public let lambdaFunctionTags: [ResourceMapFilter]?
        /// The resource IDs used as resource filter criteria.
        public let resourceId: [ResourceStringFilter]?
        /// The resource types used as resource filter criteria.
        public let resourceType: [ResourceStringFilter]?

        @inlinable
        public init(accountId: [ResourceStringFilter]? = nil, ec2InstanceTags: [ResourceMapFilter]? = nil, ecrImageTags: [ResourceStringFilter]? = nil, ecrRepositoryName: [ResourceStringFilter]? = nil, lambdaFunctionName: [ResourceStringFilter]? = nil, lambdaFunctionTags: [ResourceMapFilter]? = nil, resourceId: [ResourceStringFilter]? = nil, resourceType: [ResourceStringFilter]? = nil) {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.lambdaFunctionName = lambdaFunctionName
            self.lambdaFunctionTags = lambdaFunctionTags
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.accountId?.forEach {
                try $0.validate(name: "\(name).accountId[]")
            }
            try self.validate(self.accountId, name: "accountId", parent: name, max: 10)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 1)
            try self.ec2InstanceTags?.forEach {
                try $0.validate(name: "\(name).ec2InstanceTags[]")
            }
            try self.validate(self.ec2InstanceTags, name: "ec2InstanceTags", parent: name, max: 10)
            try self.validate(self.ec2InstanceTags, name: "ec2InstanceTags", parent: name, min: 1)
            try self.ecrImageTags?.forEach {
                try $0.validate(name: "\(name).ecrImageTags[]")
            }
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, max: 10)
            try self.validate(self.ecrImageTags, name: "ecrImageTags", parent: name, min: 1)
            try self.ecrRepositoryName?.forEach {
                try $0.validate(name: "\(name).ecrRepositoryName[]")
            }
            try self.validate(self.ecrRepositoryName, name: "ecrRepositoryName", parent: name, max: 10)
            try self.validate(self.ecrRepositoryName, name: "ecrRepositoryName", parent: name, min: 1)
            try self.lambdaFunctionName?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionName[]")
            }
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, max: 10)
            try self.validate(self.lambdaFunctionName, name: "lambdaFunctionName", parent: name, min: 1)
            try self.lambdaFunctionTags?.forEach {
                try $0.validate(name: "\(name).lambdaFunctionTags[]")
            }
            try self.validate(self.lambdaFunctionTags, name: "lambdaFunctionTags", parent: name, max: 10)
            try self.validate(self.lambdaFunctionTags, name: "lambdaFunctionTags", parent: name, min: 1)
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 10)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 10)
            try self.validate(self.resourceType, name: "resourceType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case ec2InstanceTags = "ec2InstanceTags"
            case ecrImageTags = "ecrImageTags"
            case ecrRepositoryName = "ecrRepositoryName"
            case lambdaFunctionName = "lambdaFunctionName"
            case lambdaFunctionTags = "lambdaFunctionTags"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ResourceMapFilter: AWSEncodableShape & AWSDecodableShape {
        /// The filter's comparison.
        public let comparison: ResourceMapComparison
        /// The filter's key.
        public let key: String
        /// The filter's value.
        public let value: String?

        @inlinable
        public init(comparison: ResourceMapComparison, key: String, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case key = "key"
            case value = "value"
        }
    }

    public struct ResourceScanMetadata: AWSDecodableShape {
        /// An object that contains metadata details for an Amazon EC2 instance.
        public let ec2: Ec2Metadata?
        /// An object that contains details about the container metadata for an Amazon ECR image.
        public let ecrImage: EcrContainerImageMetadata?
        /// An object that contains details about the repository an Amazon ECR image resides in.
        public let ecrRepository: EcrRepositoryMetadata?
        /// An object that contains metadata details for an Amazon Web Services Lambda function.
        public let lambdaFunction: LambdaFunctionMetadata?

        @inlinable
        public init(ec2: Ec2Metadata? = nil, ecrImage: EcrContainerImageMetadata? = nil, ecrRepository: EcrRepositoryMetadata? = nil, lambdaFunction: LambdaFunctionMetadata? = nil) {
            self.ec2 = ec2
            self.ecrImage = ecrImage
            self.ecrRepository = ecrRepository
            self.lambdaFunction = lambdaFunction
        }

        private enum CodingKeys: String, CodingKey {
            case ec2 = "ec2"
            case ecrImage = "ecrImage"
            case ecrRepository = "ecrRepository"
            case lambdaFunction = "lambdaFunction"
        }
    }

    public struct ResourceState: AWSDecodableShape {
        /// An object detailing the state of Amazon Inspector scanning for Amazon EC2 resources.
        public let ec2: State
        /// An object detailing the state of Amazon Inspector scanning for Amazon ECR resources.
        public let ecr: State
        /// An object that described the state of Amazon Inspector scans for an account.
        public let lambda: State?
        /// An object that described the state of Amazon Inspector scans for an account.
        public let lambdaCode: State?

        @inlinable
        public init(ec2: State, ecr: State, lambda: State? = nil, lambdaCode: State? = nil) {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }

        private enum CodingKeys: String, CodingKey {
            case ec2 = "ec2"
            case ecr = "ecr"
            case lambda = "lambda"
            case lambdaCode = "lambdaCode"
        }
    }

    public struct ResourceStatus: AWSDecodableShape {
        /// The status of Amazon Inspector scanning for Amazon EC2 resources.
        public let ec2: Status
        /// The status of Amazon Inspector scanning for Amazon ECR resources.
        public let ecr: Status
        /// The status of Amazon Inspector scanning for Amazon Web Services Lambda function.
        public let lambda: Status?
        /// The status of Amazon Inspector scanning for custom application code for Amazon Web Services Lambda functions.
        public let lambdaCode: Status?

        @inlinable
        public init(ec2: Status, ecr: Status, lambda: Status? = nil, lambdaCode: Status? = nil) {
            self.ec2 = ec2
            self.ecr = ecr
            self.lambda = lambda
            self.lambdaCode = lambdaCode
        }

        private enum CodingKeys: String, CodingKey {
            case ec2 = "ec2"
            case ecr = "ecr"
            case lambda = "lambda"
            case lambdaCode = "lambdaCode"
        }
    }

    public struct ResourceStringFilter: AWSEncodableShape & AWSDecodableShape {
        /// The filter's comparison.
        public let comparison: ResourceStringComparison
        /// The filter's value.
        public let value: String

        @inlinable
        public init(comparison: ResourceStringComparison, value: String) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct ScanStatus: AWSDecodableShape {
        /// The scan status. Possible return values and descriptions are:   PENDING_INITIAL_SCAN - This resource has been identified for scanning, results will be available soon.  ACCESS_DENIED - Resource access policy restricting Amazon Inspector access. Please update the IAM policy.  INTERNAL_ERROR - Amazon Inspector has encountered an internal error for this resource. Amazon Inspector service will automatically resolve the issue and resume the scanning. No action required from the user.  UNMANAGED_EC2_INSTANCE - The EC2 instance is not managed by SSM, please use the following SSM automation to remediate the issue: https://docs.aws.amazon.com/systems-manager-automation-runbooks/latest/userguide/automation-awssupport-troubleshoot-managed-instance.html. Once the instance becomes managed by SSM, Inspector will automatically begin scanning this instance.   UNSUPPORTED_OS - Amazon Inspector does not support this OS, architecture, or image manifest type at this time. To see a complete list of supported operating systems see: https://docs.aws.amazon.com/inspector/latest/user/supported.html.  SCAN_ELIGIBILITY_EXPIRED - The configured scan duration has lapsed for this image.  RESOURCE_TERMINATED - This resource has been terminated. The findings and coverage associated with this resource are in the process of being cleaned up.  SUCCESSFUL - The scan was successful.  NO_RESOURCES_FOUND - Reserved for future use.  IMAGE_SIZE_EXCEEDED - Reserved for future use.  SCAN_FREQUENCY_MANUAL - This image will not be covered by Amazon Inspector due to the repository scan frequency configuration.  SCAN_FREQUENCY_SCAN_ON_PUSH - This image will be scanned one time and will not new findings because of the scan frequency configuration.  EC2_INSTANCE_STOPPED - This EC2 instance is in a stopped state, therefore, Amazon Inspector will pause scanning. The existing findings will continue to exist until the instance is terminated. Once the instance is re-started, Inspector will automatically start scanning the instance again. Please note that you will not be charged for this instance while its in a stopped state.  PENDING_DISABLE - This resource is pending cleanup during disablement. The customer will not be billed while a resource is in the pending disable status.  NO INVENTORY - Amazon Inspector couldnt find software application inventory to scan for vulnerabilities. This might be caused due to required Amazon Inspector associations being deleted or failing to run on your resource. Please verify the status of InspectorInventoryCollection-do-not-delete  association in the SSM console for the resource. Additionally, you can verify the instances inventory in the SSM Fleet Manager console.  STALE_INVENTORY - Amazon Inspector wasnt able to collect an updated software application inventory in the last 7 days. Please confirm the required Amazon Inspector associations still exist and you can still see an updated inventory in the SSM console.  EXCLUDED_BY_TAG - This resource was not scanned because it has been excluded by a tag.  UNSUPPORTED_RUNTIME - The function was not scanned because it has an unsupported runtime. To see a complete list of supported runtimes see: https://docs.aws.amazon.com/inspector/latest/user/supported.html.  UNSUPPORTED_MEDIA_TYPE - The ECR image has an unsupported media type.  UNSUPPORTED_CONFIG_FILE - Reserved for future use.  DEEP_INSPECTION_PACKAGE_COLLECTION_LIMIT_EXCEEDED - The instance has exceeded the 5000 package limit for Amazon Inspector Deep inspection. To resume Deep inspection for this instance you can try to adjust the custom paths associated with the account.  DEEP_INSPECTION_DAILY_SSM_INVENTORY_LIMIT_EXCEEDED - The SSM agent couldn't send inventory to Amazon Inspector because the SSM quota for Inventory data collected per instance per day has already been reached for this instance.  DEEP_INSPECTION_COLLECTION_TIME_LIMIT_EXCEEDED - Amazon Inspector failed to extract the package inventory because the package collection time exceeding the maximum threshold of 15 minutes.  DEEP_INSPECTION_NO_INVENTORY  The Amazon Inspector plugin hasn't yet been able to collect an inventory of packages for this instance. This is usually the result of a pending scan, however, if this status persists after 6 hours, use SSM to ensure that the required Amazon Inspector associations exist and are running for the instance.
        public let reason: ScanStatusReason
        /// The status code of the scan.
        public let statusCode: ScanStatusCode

        @inlinable
        public init(reason: ScanStatusReason, statusCode: ScanStatusCode) {
            self.reason = reason
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case statusCode = "statusCode"
        }
    }

    public struct SearchVulnerabilitiesFilterCriteria: AWSEncodableShape {
        /// The IDs for specific vulnerabilities.
        public let vulnerabilityIds: [String]

        @inlinable
        public init(vulnerabilityIds: [String]) {
            self.vulnerabilityIds = vulnerabilityIds
        }

        public func validate(name: String) throws {
            try self.vulnerabilityIds.forEach {
                try validate($0, name: "vulnerabilityIds[]", parent: name, pattern: "^CVE-[12][0-9]{3}-[0-9]{1,10}$")
            }
            try self.validate(self.vulnerabilityIds, name: "vulnerabilityIds", parent: name, max: 1)
            try self.validate(self.vulnerabilityIds, name: "vulnerabilityIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vulnerabilityIds = "vulnerabilityIds"
        }
    }

    public struct SearchVulnerabilitiesRequest: AWSEncodableShape {
        /// The criteria used to filter the results of a vulnerability search.
        public let filterCriteria: SearchVulnerabilitiesFilterCriteria
        /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
        public let nextToken: String?

        @inlinable
        public init(filterCriteria: SearchVulnerabilitiesFilterCriteria, nextToken: String? = nil) {
            self.filterCriteria = filterCriteria
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filterCriteria.validate(name: "\(name).filterCriteria")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000000)
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria = "filterCriteria"
            case nextToken = "nextToken"
        }
    }

    public struct SearchVulnerabilitiesResponse: AWSDecodableShape {
        /// The pagination parameter to be used on the next list operation to retrieve more items.
        public let nextToken: String?
        /// Details about the listed vulnerability.
        public let vulnerabilities: [Vulnerability]

        @inlinable
        public init(nextToken: String? = nil, vulnerabilities: [Vulnerability]) {
            self.nextToken = nextToken
            self.vulnerabilities = vulnerabilities
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vulnerabilities = "vulnerabilities"
        }
    }

    public struct SendCisSessionHealthRequest: AWSEncodableShape {
        /// A unique identifier for the scan job.
        public let scanJobId: String
        /// The unique token that identifies the CIS session.
        public let sessionToken: String

        @inlinable
        public init(scanJobId: String, sessionToken: String) {
            self.scanJobId = scanJobId
            self.sessionToken = sessionToken
        }

        public func validate(name: String) throws {
            try self.validate(self.scanJobId, name: "scanJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.sessionToken, name: "sessionToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case scanJobId = "scanJobId"
            case sessionToken = "sessionToken"
        }
    }

    public struct SendCisSessionHealthResponse: AWSDecodableShape {
        public init() {}
    }

    public struct SendCisSessionTelemetryRequest: AWSEncodableShape {
        /// The CIS session telemetry messages.
        public let messages: [CisSessionMessage]
        /// A unique identifier for the scan job.
        public let scanJobId: String
        /// The unique token that identifies the CIS session.
        public let sessionToken: String

        @inlinable
        public init(messages: [CisSessionMessage], scanJobId: String, sessionToken: String) {
            self.messages = messages
            self.scanJobId = scanJobId
            self.sessionToken = sessionToken
        }

        public func validate(name: String) throws {
            try self.messages.forEach {
                try $0.validate(name: "\(name).messages[]")
            }
            try self.validate(self.messages, name: "messages", parent: name, max: 150)
            try self.validate(self.messages, name: "messages", parent: name, min: 1)
            try self.validate(self.scanJobId, name: "scanJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.sessionToken, name: "sessionToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case scanJobId = "scanJobId"
            case sessionToken = "sessionToken"
        }
    }

    public struct SendCisSessionTelemetryResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The ID of the resource that exceeds a service quota.
        public let resourceId: String

        @inlinable
        public init(message: String, resourceId: String) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
        }
    }

    public struct SeverityCounts: AWSDecodableShape {
        /// The total count of findings from all severities.
        public let all: Int64?
        /// The total count of critical severity findings.
        public let critical: Int64?
        /// The total count of high severity findings.
        public let high: Int64?
        /// The total count of medium severity findings.
        public let medium: Int64?

        @inlinable
        public init(all: Int64? = nil, critical: Int64? = nil, high: Int64? = nil, medium: Int64? = nil) {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }

        private enum CodingKeys: String, CodingKey {
            case all = "all"
            case critical = "critical"
            case high = "high"
            case medium = "medium"
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        /// The finding detail field by which results are sorted.
        public let field: SortField
        /// The order by which findings are sorted.
        public let sortOrder: SortOrder

        @inlinable
        public init(field: SortField, sortOrder: SortOrder) {
            self.field = field
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case sortOrder = "sortOrder"
        }
    }

    public struct StartCisSessionMessage: AWSEncodableShape {
        /// The unique token that identifies the CIS session.
        public let sessionToken: String

        @inlinable
        public init(sessionToken: String) {
            self.sessionToken = sessionToken
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionToken, name: "sessionToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionToken = "sessionToken"
        }
    }

    public struct StartCisSessionRequest: AWSEncodableShape {
        /// The start CIS session message.
        public let message: StartCisSessionMessage
        /// A unique identifier for the scan job.
        public let scanJobId: String

        @inlinable
        public init(message: StartCisSessionMessage, scanJobId: String) {
            self.message = message
            self.scanJobId = scanJobId
        }

        public func validate(name: String) throws {
            try self.message.validate(name: "\(name).message")
            try self.validate(self.scanJobId, name: "scanJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case scanJobId = "scanJobId"
        }
    }

    public struct StartCisSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct State: AWSDecodableShape {
        /// The error code explaining why the account failed to enable Amazon Inspector.
        public let errorCode: ErrorCode
        /// The error message received when the account failed to enable Amazon Inspector.
        public let errorMessage: String
        /// The status of Amazon Inspector for the account.
        public let status: Status

        @inlinable
        public init(errorCode: ErrorCode, errorMessage: String, status: Status) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case status = "status"
        }
    }

    public struct StatusCounts: AWSDecodableShape {
        /// The number of checks that failed.
        public let failed: Int?
        /// The number of checks that passed.
        public let passed: Int?
        /// The number of checks that were skipped.
        public let skipped: Int?

        @inlinable
        public init(failed: Int? = nil, passed: Int? = nil, skipped: Int? = nil) {
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case passed = "passed"
            case skipped = "skipped"
        }
    }

    public struct Step: AWSDecodableShape {
        /// The component ARN. The ARN can be null and is not displayed in the Amazon Web Services console.
        public let componentArn: String?
        /// The component ID.
        public let componentId: String
        /// The component type.
        public let componentType: String

        @inlinable
        public init(componentArn: String? = nil, componentId: String, componentType: String) {
            self.componentArn = componentArn
            self.componentId = componentId
            self.componentType = componentType
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn = "componentArn"
            case componentId = "componentId"
            case componentType = "componentType"
        }
    }

    public struct StopCisMessageProgress: AWSEncodableShape {
        /// The progress' error checks.
        public let errorChecks: Int?
        /// The progress' failed checks.
        public let failedChecks: Int?
        /// The progress' informational checks.
        public let informationalChecks: Int?
        /// The progress' not applicable checks.
        public let notApplicableChecks: Int?
        /// The progress' not evaluated checks.
        public let notEvaluatedChecks: Int?
        /// The progress' successful checks.
        public let successfulChecks: Int?
        /// The progress' total checks.
        public let totalChecks: Int?
        /// The progress' unknown checks.
        public let unknownChecks: Int?

        @inlinable
        public init(errorChecks: Int? = nil, failedChecks: Int? = nil, informationalChecks: Int? = nil, notApplicableChecks: Int? = nil, notEvaluatedChecks: Int? = nil, successfulChecks: Int? = nil, totalChecks: Int? = nil, unknownChecks: Int? = nil) {
            self.errorChecks = errorChecks
            self.failedChecks = failedChecks
            self.informationalChecks = informationalChecks
            self.notApplicableChecks = notApplicableChecks
            self.notEvaluatedChecks = notEvaluatedChecks
            self.successfulChecks = successfulChecks
            self.totalChecks = totalChecks
            self.unknownChecks = unknownChecks
        }

        public func validate(name: String) throws {
            try self.validate(self.errorChecks, name: "errorChecks", parent: name, max: 65536)
            try self.validate(self.errorChecks, name: "errorChecks", parent: name, min: 0)
            try self.validate(self.failedChecks, name: "failedChecks", parent: name, max: 65536)
            try self.validate(self.failedChecks, name: "failedChecks", parent: name, min: 0)
            try self.validate(self.informationalChecks, name: "informationalChecks", parent: name, max: 65536)
            try self.validate(self.informationalChecks, name: "informationalChecks", parent: name, min: 0)
            try self.validate(self.notApplicableChecks, name: "notApplicableChecks", parent: name, max: 65536)
            try self.validate(self.notApplicableChecks, name: "notApplicableChecks", parent: name, min: 0)
            try self.validate(self.notEvaluatedChecks, name: "notEvaluatedChecks", parent: name, max: 65536)
            try self.validate(self.notEvaluatedChecks, name: "notEvaluatedChecks", parent: name, min: 0)
            try self.validate(self.successfulChecks, name: "successfulChecks", parent: name, max: 65536)
            try self.validate(self.successfulChecks, name: "successfulChecks", parent: name, min: 0)
            try self.validate(self.totalChecks, name: "totalChecks", parent: name, max: 65536)
            try self.validate(self.totalChecks, name: "totalChecks", parent: name, min: 0)
            try self.validate(self.unknownChecks, name: "unknownChecks", parent: name, max: 65536)
            try self.validate(self.unknownChecks, name: "unknownChecks", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case errorChecks = "errorChecks"
            case failedChecks = "failedChecks"
            case informationalChecks = "informationalChecks"
            case notApplicableChecks = "notApplicableChecks"
            case notEvaluatedChecks = "notEvaluatedChecks"
            case successfulChecks = "successfulChecks"
            case totalChecks = "totalChecks"
            case unknownChecks = "unknownChecks"
        }
    }

    public struct StopCisSessionMessage: AWSEncodableShape {
        /// The message benchmark profile.
        public let benchmarkProfile: String?
        /// The message benchmark version.
        public let benchmarkVersion: String?
        /// The message compute platform.
        public let computePlatform: ComputePlatform?
        /// The progress of the message.
        public let progress: StopCisMessageProgress
        /// The reason for the message.
        public let reason: String?
        /// The status of the message.
        public let status: StopCisSessionStatus

        @inlinable
        public init(benchmarkProfile: String? = nil, benchmarkVersion: String? = nil, computePlatform: ComputePlatform? = nil, progress: StopCisMessageProgress, reason: String? = nil, status: StopCisSessionStatus) {
            self.benchmarkProfile = benchmarkProfile
            self.benchmarkVersion = benchmarkVersion
            self.computePlatform = computePlatform
            self.progress = progress
            self.reason = reason
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.benchmarkProfile, name: "benchmarkProfile", parent: name, max: 128)
            try self.validate(self.benchmarkVersion, name: "benchmarkVersion", parent: name, max: 8)
            try self.computePlatform?.validate(name: "\(name).computePlatform")
            try self.progress.validate(name: "\(name).progress")
            try self.validate(self.reason, name: "reason", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case benchmarkProfile = "benchmarkProfile"
            case benchmarkVersion = "benchmarkVersion"
            case computePlatform = "computePlatform"
            case progress = "progress"
            case reason = "reason"
            case status = "status"
        }
    }

    public struct StopCisSessionRequest: AWSEncodableShape {
        /// The stop CIS session message.
        public let message: StopCisSessionMessage
        /// A unique identifier for the scan job.
        public let scanJobId: String
        /// The unique token that identifies the CIS session.
        public let sessionToken: String

        @inlinable
        public init(message: StopCisSessionMessage, scanJobId: String, sessionToken: String) {
            self.message = message
            self.scanJobId = scanJobId
            self.sessionToken = sessionToken
        }

        public func validate(name: String) throws {
            try self.message.validate(name: "\(name).message")
            try self.validate(self.scanJobId, name: "scanJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.sessionToken, name: "sessionToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case scanJobId = "scanJobId"
            case sessionToken = "sessionToken"
        }
    }

    public struct StopCisSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StringFilter: AWSEncodableShape & AWSDecodableShape {
        /// The operator to use when comparing values in the filter.
        public let comparison: StringComparison
        /// The value to filter on.
        public let value: String

        @inlinable
        public init(comparison: StringComparison, value: String) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case value = "value"
        }
    }

    public struct SuggestedFix: AWSDecodableShape {
        /// The fix's code.
        public let code: String?
        /// The fix's description.
        public let description: String?

        @inlinable
        public init(code: String? = nil, description: String? = nil) {
            self.code = code
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case description = "description"
        }
    }

    public struct TagFilter: AWSEncodableShape {
        /// The tag filter comparison value.
        public let comparison: TagComparison
        /// The tag filter key.
        public let key: String
        /// The tag filter value.
        public let value: String

        @inlinable
        public init(comparison: TagComparison, key: String, value: String) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "comparison"
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to apply a tag to.
        public let resourceArn: String
        /// The tags to be added to a resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Time: AWSEncodableShape & AWSDecodableShape {
        /// The time of day in 24-hour format (00:00).
        public let timeOfDay: String
        /// The timezone.
        public let timezone: String

        @inlinable
        public init(timeOfDay: String, timezone: String) {
            self.timeOfDay = timeOfDay
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.timeOfDay, name: "timeOfDay", parent: name, pattern: "^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$")
            try self.validate(self.timezone, name: "timezone", parent: name, max: 50)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case timeOfDay = "timeOfDay"
            case timezone = "timezone"
        }
    }

    public struct TitleAggregation: AWSEncodableShape {
        /// The type of finding to aggregate on.
        public let findingType: AggregationFindingType?
        /// The resource type to aggregate on.
        public let resourceType: AggregationResourceType?
        /// The value to sort results by.
        public let sortBy: TitleSortBy?
        /// The order to sort results by.
        public let sortOrder: SortOrder?
        /// The finding titles to aggregate on.
        public let titles: [StringFilter]?
        /// The vulnerability IDs of the findings.
        public let vulnerabilityIds: [StringFilter]?

        @inlinable
        public init(findingType: AggregationFindingType? = nil, resourceType: AggregationResourceType? = nil, sortBy: TitleSortBy? = nil, sortOrder: SortOrder? = nil, titles: [StringFilter]? = nil, vulnerabilityIds: [StringFilter]? = nil) {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.titles = titles
            self.vulnerabilityIds = vulnerabilityIds
        }

        public func validate(name: String) throws {
            try self.titles?.forEach {
                try $0.validate(name: "\(name).titles[]")
            }
            try self.validate(self.titles, name: "titles", parent: name, max: 10)
            try self.validate(self.titles, name: "titles", parent: name, min: 1)
            try self.vulnerabilityIds?.forEach {
                try $0.validate(name: "\(name).vulnerabilityIds[]")
            }
            try self.validate(self.vulnerabilityIds, name: "vulnerabilityIds", parent: name, max: 10)
            try self.validate(self.vulnerabilityIds, name: "vulnerabilityIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findingType = "findingType"
            case resourceType = "resourceType"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
            case titles = "titles"
            case vulnerabilityIds = "vulnerabilityIds"
        }
    }

    public struct TitleAggregationResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account associated with the findings.
        public let accountId: String?
        /// An object that represent the count of matched findings per severity.
        public let severityCounts: SeverityCounts?
        /// The title that the findings were aggregated on.
        public let title: String
        /// The vulnerability ID of the finding.
        public let vulnerabilityId: String?

        @inlinable
        public init(accountId: String? = nil, severityCounts: SeverityCounts? = nil, title: String, vulnerabilityId: String? = nil) {
            self.accountId = accountId
            self.severityCounts = severityCounts
            self.title = title
            self.vulnerabilityId = vulnerabilityId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case severityCounts = "severityCounts"
            case title = "title"
            case vulnerabilityId = "vulnerabilityId"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource to remove tags from.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCisScanConfigurationRequest: AWSEncodableShape {
        /// The CIS scan configuration ARN.
        public let scanConfigurationArn: String
        /// The scan name for the CIS scan configuration.
        public let scanName: String?
        /// The schedule for the CIS scan configuration.
        public let schedule: Schedule?
        ///  The security level for the CIS scan configuration.  Security level refers to the Benchmark levels that CIS assigns to a profile.
        public let securityLevel: CisSecurityLevel?
        /// The targets for the CIS scan configuration.
        public let targets: UpdateCisTargets?

        @inlinable
        public init(scanConfigurationArn: String, scanName: String? = nil, schedule: Schedule? = nil, securityLevel: CisSecurityLevel? = nil, targets: UpdateCisTargets? = nil) {
            self.scanConfigurationArn = scanConfigurationArn
            self.scanName = scanName
            self.schedule = schedule
            self.securityLevel = securityLevel
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.validate(self.scanConfigurationArn, name: "scanConfigurationArn", parent: name, pattern: "^arn:aws(-us-gov|-cn)?:inspector2:[a-z]{2}(-gov)?-[a-z]+-[0-9]{1}:[0-9]{12}:owner/(o-[a-z0-9]+|[0-9]{12})/cis-configuration/[0-9a-fA-F-]+$")
            try self.validate(self.scanName, name: "scanName", parent: name, max: 128)
            try self.validate(self.scanName, name: "scanName", parent: name, min: 1)
            try self.schedule?.validate(name: "\(name).schedule")
            try self.targets?.validate(name: "\(name).targets")
        }

        private enum CodingKeys: String, CodingKey {
            case scanConfigurationArn = "scanConfigurationArn"
            case scanName = "scanName"
            case schedule = "schedule"
            case securityLevel = "securityLevel"
            case targets = "targets"
        }
    }

    public struct UpdateCisScanConfigurationResponse: AWSDecodableShape {
        /// The CIS scan configuration ARN.
        public let scanConfigurationArn: String

        @inlinable
        public init(scanConfigurationArn: String) {
            self.scanConfigurationArn = scanConfigurationArn
        }

        private enum CodingKeys: String, CodingKey {
            case scanConfigurationArn = "scanConfigurationArn"
        }
    }

    public struct UpdateCisTargets: AWSEncodableShape {
        /// The target account ids.
        public let accountIds: [String]?
        /// The target resource tags.
        public let targetResourceTags: [String: [String]]?

        @inlinable
        public init(accountIds: [String]? = nil, targetResourceTags: [String: [String]]? = nil) {
            self.accountIds = accountIds
            self.targetResourceTags = targetResourceTags
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}|ALL_ACCOUNTS|SELF$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 10000)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
            try self.targetResourceTags?.forEach {
                try validate($0.key, name: "targetResourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "targetResourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "targetResourceTags.key", parent: name, pattern: "^[\\p{L}\\p{Z}\\p{N}_.:/=\\-@]*$")
                try validate($0.value, name: "targetResourceTags[\"\($0.key)\"]", parent: name, max: 5)
                try validate($0.value, name: "targetResourceTags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.targetResourceTags, name: "targetResourceTags", parent: name, max: 5)
            try self.validate(self.targetResourceTags, name: "targetResourceTags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "accountIds"
            case targetResourceTags = "targetResourceTags"
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        /// Specifies how the Amazon EC2 automated scan will be updated for your environment.
        public let ec2Configuration: Ec2Configuration?
        /// Specifies how the ECR automated re-scan will be updated for your environment.
        public let ecrConfiguration: EcrConfiguration?

        @inlinable
        public init(ec2Configuration: Ec2Configuration? = nil, ecrConfiguration: EcrConfiguration? = nil) {
            self.ec2Configuration = ec2Configuration
            self.ecrConfiguration = ecrConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ec2Configuration = "ec2Configuration"
            case ecrConfiguration = "ecrConfiguration"
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEc2DeepInspectionConfigurationRequest: AWSEncodableShape {
        /// Specify TRUE to activate Amazon Inspector deep inspection in your account, or FALSE to deactivate. Member accounts in an organization cannot deactivate deep inspection, instead the delegated administrator for the organization can deactivate a member account using BatchUpdateMemberEc2DeepInspectionStatus.
        public let activateDeepInspection: Bool?
        /// The Amazon Inspector deep inspection custom paths you are adding for your account.
        public let packagePaths: [String]?

        @inlinable
        public init(activateDeepInspection: Bool? = nil, packagePaths: [String]? = nil) {
            self.activateDeepInspection = activateDeepInspection
            self.packagePaths = packagePaths
        }

        public func validate(name: String) throws {
            try self.packagePaths?.forEach {
                try validate($0, name: "packagePaths[]", parent: name, max: 512)
                try validate($0, name: "packagePaths[]", parent: name, min: 1)
                try validate($0, name: "packagePaths[]", parent: name, pattern: "^(?:/(?:\\.[-\\w]+|[-\\w]+(?:\\.[-\\w]+)?))+/?$")
            }
            try self.validate(self.packagePaths, name: "packagePaths", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case activateDeepInspection = "activateDeepInspection"
            case packagePaths = "packagePaths"
        }
    }

    public struct UpdateEc2DeepInspectionConfigurationResponse: AWSDecodableShape {
        /// An error message explaining why new Amazon Inspector deep inspection custom paths could not be added.
        public let errorMessage: String?
        /// The current Amazon Inspector deep inspection custom paths for the organization.
        public let orgPackagePaths: [String]?
        /// The current Amazon Inspector deep inspection custom paths for your account.
        public let packagePaths: [String]?
        /// The status of Amazon Inspector deep inspection in your account.
        public let status: Ec2DeepInspectionStatus?

        @inlinable
        public init(errorMessage: String? = nil, orgPackagePaths: [String]? = nil, packagePaths: [String]? = nil, status: Ec2DeepInspectionStatus? = nil) {
            self.errorMessage = errorMessage
            self.orgPackagePaths = orgPackagePaths
            self.packagePaths = packagePaths
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case orgPackagePaths = "orgPackagePaths"
            case packagePaths = "packagePaths"
            case status = "status"
        }
    }

    public struct UpdateEncryptionKeyRequest: AWSEncodableShape {
        /// A KMS key ID for the encryption key.
        public let kmsKeyId: String
        /// The resource type for the encryption key.
        public let resourceType: ResourceType
        /// The scan type for the encryption key.
        public let scanType: ScanType

        @inlinable
        public init(kmsKeyId: String, resourceType: ResourceType, scanType: ScanType) {
            self.kmsKeyId = kmsKeyId
            self.resourceType = resourceType
            self.scanType = scanType
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^arn:aws(-(us-gov|cn))?:kms:([a-z0-9][-.a-z0-9]{0,62})?:[0-9]{12}?:key/(([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})|(mrk-[0-9a-zA-Z]{32}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
            case resourceType = "resourceType"
            case scanType = "scanType"
        }
    }

    public struct UpdateEncryptionKeyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFilterRequest: AWSEncodableShape {
        /// Specifies the action that is to be applied to the findings that match the filter.
        public let action: FilterAction?
        /// A description of the filter.
        public let description: String?
        /// The Amazon Resource Number (ARN) of the filter to update.
        public let filterArn: String
        /// Defines the criteria to be update in the filter.
        public let filterCriteria: FilterCriteria?
        /// The name of the filter.
        public let name: String?
        /// The reason the filter was updated.
        public let reason: String?

        @inlinable
        public init(action: FilterAction? = nil, description: String? = nil, filterArn: String, filterCriteria: FilterCriteria? = nil, name: String? = nil, reason: String? = nil) {
            self.action = action
            self.description = description
            self.filterArn = filterArn
            self.filterCriteria = filterCriteria
            self.name = name
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.filterArn, name: "filterArn", parent: name, max: 128)
            try self.validate(self.filterArn, name: "filterArn", parent: name, min: 1)
            try self.filterCriteria?.validate(name: "\(name).filterCriteria")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.reason, name: "reason", parent: name, max: 512)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case filterArn = "filterArn"
            case filterCriteria = "filterCriteria"
            case name = "name"
            case reason = "reason"
        }
    }

    public struct UpdateFilterResponse: AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the successfully updated filter.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct UpdateOrgEc2DeepInspectionConfigurationRequest: AWSEncodableShape {
        /// The Amazon Inspector deep inspection custom paths you are adding for your organization.
        public let orgPackagePaths: [String]

        @inlinable
        public init(orgPackagePaths: [String]) {
            self.orgPackagePaths = orgPackagePaths
        }

        public func validate(name: String) throws {
            try self.orgPackagePaths.forEach {
                try validate($0, name: "orgPackagePaths[]", parent: name, max: 512)
                try validate($0, name: "orgPackagePaths[]", parent: name, min: 1)
                try validate($0, name: "orgPackagePaths[]", parent: name, pattern: "^(?:/(?:\\.[-\\w]+|[-\\w]+(?:\\.[-\\w]+)?))+/?$")
            }
            try self.validate(self.orgPackagePaths, name: "orgPackagePaths", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case orgPackagePaths = "orgPackagePaths"
        }
    }

    public struct UpdateOrgEc2DeepInspectionConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        /// Defines which scan types are enabled automatically for new members of your Amazon Inspector organization.
        public let autoEnable: AutoEnable

        @inlinable
        public init(autoEnable: AutoEnable) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        /// The updated status of scan types automatically enabled for new members of your Amazon Inspector organization.
        public let autoEnable: AutoEnable

        @inlinable
        public init(autoEnable: AutoEnable) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "autoEnable"
        }
    }

    public struct Usage: AWSDecodableShape {
        /// The currency type used when calculating usage data.
        public let currency: Currency?
        /// The estimated monthly cost of Amazon Inspector.
        public let estimatedMonthlyCost: Double?
        /// The total of usage.
        public let total: Double?
        /// The type scan.
        public let type: UsageType?

        @inlinable
        public init(currency: Currency? = nil, estimatedMonthlyCost: Double? = nil, total: Double? = nil, type: UsageType? = nil) {
            self.currency = currency
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.total = total
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "currency"
            case estimatedMonthlyCost = "estimatedMonthlyCost"
            case total = "total"
            case type = "type"
        }
    }

    public struct UsageTotal: AWSDecodableShape {
        /// The account ID of the account that usage data was retrieved for.
        public let accountId: String?
        /// An object representing the total usage for an account.
        public let usage: [Usage]?

        @inlinable
        public init(accountId: String? = nil, usage: [Usage]? = nil) {
            self.accountId = accountId
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case usage = "usage"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The fields that failed validation.
        public let fields: [ValidationExceptionField]?
        public let message: String
        /// The reason for the validation failure.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The validation exception message.
        public let message: String
        /// The name of the validation exception.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct Vulnerability: AWSDecodableShape {
        /// An object that contains information about the Amazon Web Services Threat Intel Group (ATIG) details for the vulnerability.
        public let atigData: AtigData?
        /// An object that contains the Cybersecurity and Infrastructure Security Agency (CISA) details for the vulnerability.
        public let cisaData: CisaData?
        /// An object that contains the Common Vulnerability Scoring System (CVSS) Version 2 details for the vulnerability.
        public let cvss2: Cvss2?
        /// An object that contains the Common Vulnerability Scoring System (CVSS) Version 3 details for the vulnerability.
        public let cvss3: Cvss3?
        /// The Common Weakness Enumeration (CWE) associated with the vulnerability.
        public let cwes: [String]?
        /// A description of the vulnerability.
        public let description: String?
        /// Platforms that the vulnerability can be detected on.
        public let detectionPlatforms: [String]?
        /// An object that contains the Exploit Prediction Scoring System (EPSS) score for a vulnerability.
        public let epss: Epss?
        /// An object that contains details on when the exploit was observed.
        public let exploitObserved: ExploitObserved?
        /// The ID for the specific vulnerability.
        public let id: String
        /// Links to various resources with more information on this vulnerability.
        public let referenceUrls: [String]?
        /// A list of related vulnerabilities.
        public let relatedVulnerabilities: [String]?
        /// The source of the vulnerability information.  Possible results are RHEL, AMAZON_CVE, DEBIAN or NVD.
        public let source: VulnerabilitySource?
        /// A link to the official source material for this vulnerability.
        public let sourceUrl: String?
        /// The date and time when the vendor created this vulnerability.
        public let vendorCreatedAt: Date?
        /// The severity assigned by the vendor.
        public let vendorSeverity: String?
        /// The date and time when the vendor last updated this vulnerability.
        public let vendorUpdatedAt: Date?

        @inlinable
        public init(atigData: AtigData? = nil, cisaData: CisaData? = nil, cvss2: Cvss2? = nil, cvss3: Cvss3? = nil, cwes: [String]? = nil, description: String? = nil, detectionPlatforms: [String]? = nil, epss: Epss? = nil, exploitObserved: ExploitObserved? = nil, id: String, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, source: VulnerabilitySource? = nil, sourceUrl: String? = nil, vendorCreatedAt: Date? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: Date? = nil) {
            self.atigData = atigData
            self.cisaData = cisaData
            self.cvss2 = cvss2
            self.cvss3 = cvss3
            self.cwes = cwes
            self.description = description
            self.detectionPlatforms = detectionPlatforms
            self.epss = epss
            self.exploitObserved = exploitObserved
            self.id = id
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case atigData = "atigData"
            case cisaData = "cisaData"
            case cvss2 = "cvss2"
            case cvss3 = "cvss3"
            case cwes = "cwes"
            case description = "description"
            case detectionPlatforms = "detectionPlatforms"
            case epss = "epss"
            case exploitObserved = "exploitObserved"
            case id = "id"
            case referenceUrls = "referenceUrls"
            case relatedVulnerabilities = "relatedVulnerabilities"
            case source = "source"
            case sourceUrl = "sourceUrl"
            case vendorCreatedAt = "vendorCreatedAt"
            case vendorSeverity = "vendorSeverity"
            case vendorUpdatedAt = "vendorUpdatedAt"
        }
    }

    public struct VulnerablePackage: AWSDecodableShape {
        /// The architecture of the vulnerable package.
        public let arch: String?
        /// The epoch of the vulnerable package.
        public let epoch: Int?
        /// The file path of the vulnerable package.
        public let filePath: String?
        /// The version of the package that contains the vulnerability fix.
        public let fixedInVersion: String?
        /// The name of the vulnerable package.
        public let name: String
        /// The package manager of the vulnerable package.
        public let packageManager: PackageManager?
        /// The release of the vulnerable package.
        public let release: String?
        /// The code to run in your environment to update packages with a fix available.
        public let remediation: String?
        /// The Amazon Resource Number (ARN) of the Amazon Web Services Lambda function affected by a finding.
        public let sourceLambdaLayerArn: String?
        /// The source layer hash of the vulnerable package.
        public let sourceLayerHash: String?
        /// The version of the vulnerable package.
        public let version: String

        @inlinable
        public init(arch: String? = nil, epoch: Int? = nil, filePath: String? = nil, fixedInVersion: String? = nil, name: String, packageManager: PackageManager? = nil, release: String? = nil, remediation: String? = nil, sourceLambdaLayerArn: String? = nil, sourceLayerHash: String? = nil, version: String) {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLambdaLayerArn = sourceLambdaLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arch = "arch"
            case epoch = "epoch"
            case filePath = "filePath"
            case fixedInVersion = "fixedInVersion"
            case name = "name"
            case packageManager = "packageManager"
            case release = "release"
            case remediation = "remediation"
            case sourceLambdaLayerArn = "sourceLambdaLayerArn"
            case sourceLayerHash = "sourceLayerHash"
            case version = "version"
        }
    }

    public struct WeeklySchedule: AWSEncodableShape & AWSDecodableShape {
        /// The weekly schedule's days.
        public let days: [Day]
        /// The weekly schedule's start time.
        public let startTime: Time

        @inlinable
        public init(days: [Day], startTime: Time) {
            self.days = days
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.days, name: "days", parent: name, max: 7)
            try self.validate(self.days, name: "days", parent: name, min: 1)
            try self.startTime.validate(name: "\(name).startTime")
        }

        private enum CodingKeys: String, CodingKey {
            case days = "days"
            case startTime = "startTime"
        }
    }
}

// MARK: - Errors

/// Error enum for Inspector2
public struct Inspector2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Inspector2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// One or more tags submitted as part of the request is not valid.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// A conflict occurred.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request has failed due to an internal failure of the Amazon Inspector service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The operation tried to access an invalid resource. Make sure the resource is specified correctly.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The limit on the number of requests per second was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request has failed validation due to missing required fields or having invalid inputs.
    public static var validationException: Self { .init(.validationException) }
}

extension Inspector2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Inspector2.ConflictException.self,
        "InternalServerException": Inspector2.InternalServerException.self,
        "ServiceQuotaExceededException": Inspector2.ServiceQuotaExceededException.self,
        "ThrottlingException": Inspector2.ThrottlingException.self,
        "ValidationException": Inspector2.ValidationException.self
    ]
}

extension Inspector2ErrorType: Equatable {
    public static func == (lhs: Inspector2ErrorType, rhs: Inspector2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension Inspector2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
